<SourceFile>
  <Line number="1">/**</Line>
  <Line number="2"> * Copyright (C) 2015 - 2016 Bosch Sensortec GmbH</Line>
  <Line number="3"> *</Line>
  <Line number="4"> * Redistribution and use in source and binary forms, with or without</Line>
  <Line number="5"> * modification, are permitted provided that the following conditions are met:</Line>
  <Line number="6"> *</Line>
  <Line number="7"> * Redistributions of source code must retain the above copyright</Line>
  <Line number="8"> * notice, this list of conditions and the following disclaimer.</Line>
  <Line number="9"> *</Line>
  <Line number="10"> * Redistributions in binary form must reproduce the above copyright</Line>
  <Line number="11"> * notice, this list of conditions and the following disclaimer in the</Line>
  <Line number="12"> * documentation and/or other materials provided with the distribution.</Line>
  <Line number="13"> *</Line>
  <Line number="14"> * Neither the name of the copyright holder nor the names of the</Line>
  <Line number="15"> * contributors may be used to endorse or promote products derived from</Line>
  <Line number="16"> * this software without specific prior written permission.</Line>
  <Line number="17"> *</Line>
  <Line number="18"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND</Line>
  <Line number="19"> * CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR</Line>
  <Line number="20"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</Line>
  <Line number="21"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</Line>
  <Line number="22"> * DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER</Line>
  <Line number="23"> * OR CONTRIBUTORS BE LIABLE FOR ANY</Line>
  <Line number="24"> * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,</Line>
  <Line number="25"> * OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO,</Line>
  <Line number="26"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</Line>
  <Line number="27"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</Line>
  <Line number="28"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</Line>
  <Line number="29"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</Line>
  <Line number="30"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN</Line>
  <Line number="31"> * ANY WAY OUT OF THE USE OF THIS</Line>
  <Line number="32"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</Line>
  <Line number="33"> *</Line>
  <Line number="34"> * The information provided is believed to be accurate and reliable.</Line>
  <Line number="35"> * The copyright holder assumes no responsibility</Line>
  <Line number="36"> * for the consequences of use</Line>
  <Line number="37"> * of such information nor for any infringement of patents or</Line>
  <Line number="38"> * other rights of third parties which may result from its use.</Line>
  <Line number="39"> * No license is granted by implication or otherwise under any patent or</Line>
  <Line number="40"> * patent rights of the copyright holder.</Line>
  <Line number="41"> *</Line>
  <Line number="42"> * @file    bmi160.c</Line>
  <Line number="43"> * @date    24 Nov 2017</Line>
  <Line number="44"> * @version 3.7.4</Line>
  <Line number="45"> * @brief</Line>
  <Line number="46"> *</Line>
  <Line number="47"> */</Line>
  <Line number="48"></Line>
  <Line number="49">/*!</Line>
  <Line number="50"> * @defgroup bmi160</Line>
  <Line number="51"> * @brief</Line>
  <Line number="52"> * @{*/</Line>
  <Line number="53"></Line>
  <Line number="54">#include &quot;bmi160.h&quot;</Line>
  <Line number="55"></Line>
  <Line number="56">#ifdef LOCAL_ANALYSIS</Line>
  <Line number="57">extern struct bmi160_dev configStub;</Line>
  <Line number="58">extern void initStubs();</Line>
  <Line number="59">#define INIT_STUBS(DEV_PTR) initStubs(); DEV_PTR=&amp;configStub</Line>
  <Line number="60">#else</Line>
  <Line number="61">#define INIT_STUBS(DEV_PTR)</Line>
  <Line number="62">#endif</Line>
  <Line number="63"></Line>
  <Line number="64">/* Below look up table follows the enum bmi160_int_types.</Line>
  <Line number="65"> * Hence any change should match to the enum bmi160_int_types</Line>
  <Line number="66"> */</Line>
  <Line number="67">const uint8_t int_mask_lookup_table[13] = {</Line>
  <Line number="68">		BMI160_INT1_SLOPE_MASK,</Line>
  <Line number="69">		BMI160_INT1_SLOPE_MASK,</Line>
  <Line number="70">		BMI160_INT2_LOW_STEP_DETECT_MASK,</Line>
  <Line number="71">		BMI160_INT1_DOUBLE_TAP_MASK,</Line>
  <Line number="72">		BMI160_INT1_SINGLE_TAP_MASK,</Line>
  <Line number="73">		BMI160_INT1_ORIENT_MASK,</Line>
  <Line number="74">		BMI160_INT1_FLAT_MASK,</Line>
  <Line number="75">		BMI160_INT1_HIGH_G_MASK,</Line>
  <Line number="76">		BMI160_INT1_LOW_G_MASK,</Line>
  <Line number="77">		BMI160_INT1_NO_MOTION_MASK,</Line>
  <Line number="78">		BMI160_INT2_DATA_READY_MASK,</Line>
  <Line number="79">		BMI160_INT2_FIFO_FULL_MASK,</Line>
  <Line number="80">		BMI160_INT2_FIFO_WM_MASK</Line>
  <Line number="81">};</Line>
  <Line number="82"></Line>
  <Line number="83">/*********************************************************************/</Line>
  <Line number="84">/* Static function declarations */</Line>
  <Line number="85"></Line>
  <Line number="86">/*!</Line>
  <Line number="87"> * @brief This API configures the pins to fire the</Line>
  <Line number="88"> * interrupt signal when it occurs</Line>
  <Line number="89"> *</Line>
  <Line number="90"> * @param[in] int_config  : Structure instance of bmi160_int_settg.</Line>
  <Line number="91"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="92"> *</Line>
  <Line number="93"> * @return Result of API execution status</Line>
  <Line number="94"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="95"> */</Line>
  <Line number="96">static int8_t set_intr_pin_config(const struct bmi160_int_settg *int_config,  const struct bmi160_dev *dev);</Line>
  <Line number="97"></Line>
  <Line number="98">/*!</Line>
  <Line number="99"> * @brief This API sets the any-motion interrupt of the sensor.</Line>
  <Line number="100"> * This interrupt occurs when accel values exceeds preset threshold</Line>
  <Line number="101"> * for a certain period of time.</Line>
  <Line number="102"> *</Line>
  <Line number="103"> * @param[in] int_config  : Structure instance of bmi160_int_settg.</Line>
  <Line number="104"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="105"> *</Line>
  <Line number="106"> * @return Result of API execution status</Line>
  <Line number="107"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="108"> */</Line>
  <Line number="109">static int8_t set_accel_any_motion_int(struct bmi160_int_settg *int_config, struct bmi160_dev *dev);</Line>
  <Line number="110"></Line>
  <Line number="111">/*!</Line>
  <Line number="112"> * @brief This API sets tap interrupts.Interrupt is fired when</Line>
  <Line number="113"> * tap movements happen.</Line>
  <Line number="114"> *</Line>
  <Line number="115"> * @param[in] int_config  : Structure instance of bmi160_int_settg.</Line>
  <Line number="116"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="117"> *</Line>
  <Line number="118"> * @return Result of API execution status</Line>
  <Line number="119"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="120"> */</Line>
  <Line number="121">static int8_t set_accel_tap_int(struct bmi160_int_settg *int_config, const struct bmi160_dev *dev);</Line>
  <Line number="122"></Line>
  <Line number="123">/*!</Line>
  <Line number="124"> * @brief This API sets the data ready interrupt for both accel and gyro.</Line>
  <Line number="125"> * This interrupt occurs when new accel and gyro data come.</Line>
  <Line number="126"> *</Line>
  <Line number="127"> * @param[in] int_config  : Structure instance of bmi160_int_settg.</Line>
  <Line number="128"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="129"> *</Line>
  <Line number="130"> * @return Result of API execution status</Line>
  <Line number="131"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="132"> */</Line>
  <Line number="133">static int8_t set_accel_gyro_data_ready_int(const struct bmi160_int_settg *int_config,</Line>
  <Line number="134">						const struct bmi160_dev *dev);</Line>
  <Line number="135"></Line>
  <Line number="136">/*!</Line>
  <Line number="137"> * @brief This API sets the significant motion interrupt of the sensor.This</Line>
  <Line number="138"> * interrupt occurs when there is change in user location.</Line>
  <Line number="139"> *</Line>
  <Line number="140"> * @param[in] int_config  : Structure instance of bmi160_int_settg.</Line>
  <Line number="141"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="142"></Line>
  <Line number="143"> *</Line>
  <Line number="144"> * @return Result of API execution status</Line>
  <Line number="145"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="146"> */</Line>
  <Line number="147">static int8_t set_accel_sig_motion_int(struct bmi160_int_settg *int_config, struct bmi160_dev *dev);</Line>
  <Line number="148"></Line>
  <Line number="149">/*!</Line>
  <Line number="150"> * @brief This API sets the no motion/slow motion interrupt of the sensor.</Line>
  <Line number="151"> * Slow motion is similar to any motion interrupt.No motion interrupt</Line>
  <Line number="152"> * occurs when slope bet. two accel values falls below preset threshold</Line>
  <Line number="153"> * for preset duration.</Line>
  <Line number="154"> *</Line>
  <Line number="155"> * @param[in] int_config  : Structure instance of bmi160_int_settg.</Line>
  <Line number="156"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="157"> *</Line>
  <Line number="158"> * @return Result of API execution status</Line>
  <Line number="159"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="160"> */</Line>
  <Line number="161">static int8_t set_accel_no_motion_int(struct bmi160_int_settg *int_config, const struct bmi160_dev *dev);</Line>
  <Line number="162"></Line>
  <Line number="163">/*!</Line>
  <Line number="164"> * @brief This API sets the step detection interrupt.This interrupt</Line>
  <Line number="165"> * occurs when the single step causes accel values to go above</Line>
  <Line number="166"> * preset threshold.</Line>
  <Line number="167"> *</Line>
  <Line number="168"> * @param[in] int_config  : Structure instance of bmi160_int_settg.</Line>
  <Line number="169"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="170"> *</Line>
  <Line number="171"> * @return Result of API execution status</Line>
  <Line number="172"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="173"> */</Line>
  <Line number="174">static int8_t set_accel_step_detect_int(struct bmi160_int_settg *int_config, const struct bmi160_dev *dev);</Line>
  <Line number="175"></Line>
  <Line number="176">/*!</Line>
  <Line number="177"> * @brief This API sets the orientation interrupt of the sensor.This</Line>
  <Line number="178"> * interrupt occurs when there is orientation change in the sensor</Line>
  <Line number="179"> * with respect to gravitational field vector g.</Line>
  <Line number="180"> *</Line>
  <Line number="181"> * @param[in] int_config  : Structure instance of bmi160_int_settg.</Line>
  <Line number="182"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="183"> *</Line>
  <Line number="184"> * @return Result of API execution status</Line>
  <Line number="185"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="186"> */</Line>
  <Line number="187">static int8_t set_accel_orientation_int(struct bmi160_int_settg *int_config, const struct bmi160_dev *dev);</Line>
  <Line number="188"></Line>
  <Line number="189">/*!</Line>
  <Line number="190"> * @brief This API sets the flat interrupt of the sensor.This interrupt</Line>
  <Line number="191"> * occurs in case of flat orientation</Line>
  <Line number="192"> *</Line>
  <Line number="193"> * @param[in] int_config  : Structure instance of bmi160_int_settg.</Line>
  <Line number="194"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="195"> *</Line>
  <Line number="196"> * @return Result of API execution status</Line>
  <Line number="197"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="198"> */</Line>
  <Line number="199">static int8_t set_accel_flat_detect_int(struct bmi160_int_settg *int_config, const struct bmi160_dev *dev);</Line>
  <Line number="200"></Line>
  <Line number="201">/*!</Line>
  <Line number="202"> * @brief This API sets the low-g interrupt of the sensor.This interrupt</Line>
  <Line number="203"> * occurs during free-fall.</Line>
  <Line number="204"> *</Line>
  <Line number="205"> * @param[in] int_config  : Structure instance of bmi160_int_settg.</Line>
  <Line number="206"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="207"> *</Line>
  <Line number="208"> * @return Result of API execution status</Line>
  <Line number="209"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="210"> */</Line>
  <Line number="211">static int8_t set_accel_low_g_int(struct bmi160_int_settg *int_config, const struct bmi160_dev *dev);</Line>
  <Line number="212"></Line>
  <Line number="213">/*!</Line>
  <Line number="214"> * @brief This API sets the high-g interrupt of the sensor.The interrupt</Line>
  <Line number="215"> * occurs if the absolute value of acceleration data of any enabled axis</Line>
  <Line number="216"> * exceeds the programmed threshold and the sign of the value does not</Line>
  <Line number="217"> * change for a preset duration.</Line>
  <Line number="218"> *</Line>
  <Line number="219"> * @param[in] int_config  : Structure instance of bmi160_int_settg.</Line>
  <Line number="220"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="221"> *</Line>
  <Line number="222"> * @return Result of API execution status</Line>
  <Line number="223"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="224"> */</Line>
  <Line number="225">static int8_t set_accel_high_g_int(struct bmi160_int_settg *int_config, const struct bmi160_dev *dev);</Line>
  <Line number="226"></Line>
  <Line number="227">/*!</Line>
  <Line number="228"> * @brief This API sets the default configuration parameters of accel &amp; gyro.</Line>
  <Line number="229"> * Also maintain the previous state of configurations.</Line>
  <Line number="230"> *</Line>
  <Line number="231"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="232"> *</Line>
  <Line number="233"> * @return Result of API execution status</Line>
  <Line number="234"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="235"> */</Line>
  <Line number="236">static void default_param_settg(struct bmi160_dev *dev);</Line>
  <Line number="237">/*!</Line>
  <Line number="238"> * @brief This API is used to validate the device structure pointer for</Line>
  <Line number="239"> * null conditions.</Line>
  <Line number="240"> *</Line>
  <Line number="241"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="242"> *</Line>
  <Line number="243"> * @return Result of API execution status</Line>
  <Line number="244"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="245"> */</Line>
  <Line number="246">static int8_t null_ptr_check(const struct bmi160_dev *dev);</Line>
  <Line number="247"></Line>
  <Line number="248">/*!</Line>
  <Line number="249"> * @brief This API set the accel configuration.</Line>
  <Line number="250"> *</Line>
  <Line number="251"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="252"> *</Line>
  <Line number="253"> * @return Result of API execution status</Line>
  <Line number="254"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="255"> */</Line>
  <Line number="256">static int8_t set_accel_conf(struct bmi160_dev *dev);</Line>
  <Line number="257"></Line>
  <Line number="258"> /*!</Line>
  <Line number="259"> * @brief This API check the accel configuration.</Line>
  <Line number="260"> *</Line>
  <Line number="261"> * @param[in] data        : Pointer to store the updated accel config.</Line>
  <Line number="262"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="263"> *</Line>
  <Line number="264"> * @return Result of API execution status</Line>
  <Line number="265"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="266"> */</Line>
  <Line number="267">static int8_t check_accel_config(uint8_t *data, const struct bmi160_dev *dev);</Line>
  <Line number="268"></Line>
  <Line number="269"> /*!</Line>
  <Line number="270">  * @brief This API process the accel odr.</Line>
  <Line number="271">  *</Line>
  <Line number="272">  * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="273">  *</Line>
  <Line number="274">  * @return Result of API execution status</Line>
  <Line number="275">  * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="276">  */</Line>
  <Line number="277">static int8_t process_accel_odr(uint8_t *data, const struct bmi160_dev *dev);</Line>
  <Line number="278"></Line>
  <Line number="279"> /*!</Line>
  <Line number="280">  * @brief This API process the accel bandwidth.</Line>
  <Line number="281">  *</Line>
  <Line number="282">  * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="283">  *</Line>
  <Line number="284">  * @return Result of API execution status</Line>
  <Line number="285">  * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="286">  */</Line>
  <Line number="287">static int8_t process_accel_bw(uint8_t *data, const struct bmi160_dev *dev);</Line>
  <Line number="288"></Line>
  <Line number="289"> /*!</Line>
  <Line number="290">  * @brief This API process the accel range.</Line>
  <Line number="291">  *</Line>
  <Line number="292">  * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="293">  *</Line>
  <Line number="294">  * @return Result of API execution status</Line>
  <Line number="295">  * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="296">  */</Line>
  <Line number="297">static int8_t process_accel_range(uint8_t *data, const struct bmi160_dev *dev);</Line>
  <Line number="298"></Line>
  <Line number="299">/*!</Line>
  <Line number="300"> * @brief This API checks the invalid settings for ODR &amp; Bw for Accel and Gyro.</Line>
  <Line number="301"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="302"> *</Line>
  <Line number="303"> * @return Result of API execution status</Line>
  <Line number="304"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="305"> */</Line>
  <Line number="306">static int8_t check_invalid_settg(const struct bmi160_dev *dev);</Line>
  <Line number="307"></Line>
  <Line number="308"> /*!</Line>
  <Line number="309"> * @brief This API set the gyro configuration.</Line>
  <Line number="310"> *</Line>
  <Line number="311"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="312"> *</Line>
  <Line number="313"> * @return Result of API execution status</Line>
  <Line number="314"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="315"> */</Line>
  <Line number="316">static int8_t set_gyro_conf(struct bmi160_dev *dev);</Line>
  <Line number="317"></Line>
  <Line number="318"> /*!</Line>
  <Line number="319"> * @brief This API check the gyro configuration.</Line>
  <Line number="320"> *</Line>
  <Line number="321"> * @param[in] data        : Pointer to store the updated gyro config.</Line>
  <Line number="322"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="323"> *</Line>
  <Line number="324"> * @return Result of API execution status</Line>
  <Line number="325"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="326"> */</Line>
  <Line number="327">static int8_t check_gyro_config(uint8_t *data, const struct bmi160_dev *dev);</Line>
  <Line number="328"></Line>
  <Line number="329"> /*!</Line>
  <Line number="330">  * @brief This API process the gyro odr.</Line>
  <Line number="331">  *</Line>
  <Line number="332">  * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="333">  *</Line>
  <Line number="334">  * @return Result of API execution status</Line>
  <Line number="335">  * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="336">  */</Line>
  <Line number="337">static int8_t process_gyro_odr(uint8_t *data, const struct bmi160_dev *dev);</Line>
  <Line number="338"></Line>
  <Line number="339"> /*!</Line>
  <Line number="340">  * @brief This API process the gyro bandwidth.</Line>
  <Line number="341">  *</Line>
  <Line number="342">  * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="343">  *</Line>
  <Line number="344">  * @return Result of API execution status</Line>
  <Line number="345">  * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="346">  */</Line>
  <Line number="347">static int8_t process_gyro_bw(uint8_t *data, const struct bmi160_dev *dev);</Line>
  <Line number="348"></Line>
  <Line number="349"> /*!</Line>
  <Line number="350">  * @brief This API process the gyro range.</Line>
  <Line number="351">  *</Line>
  <Line number="352">  * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="353">  *</Line>
  <Line number="354">  * @return Result of API execution status</Line>
  <Line number="355">  * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="356">  */</Line>
  <Line number="357">static int8_t process_gyro_range(uint8_t *data, const struct bmi160_dev *dev);</Line>
  <Line number="358"></Line>
  <Line number="359">/*!</Line>
  <Line number="360"> * @brief This API sets the accel power mode.</Line>
  <Line number="361"> *</Line>
  <Line number="362"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="363"> *</Line>
  <Line number="364"> * @return Result of API execution status</Line>
  <Line number="365"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="366"> */</Line>
  <Line number="367">static int8_t set_accel_pwr(struct bmi160_dev *dev);</Line>
  <Line number="368"></Line>
  <Line number="369">/*!</Line>
  <Line number="370"> * @brief This API process the undersampling setting of Accel.</Line>
  <Line number="371"> *</Line>
  <Line number="372"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="373"> *</Line>
  <Line number="374"> * @return Result of API execution status</Line>
  <Line number="375"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="376"> */</Line>
  <Line number="377">static int8_t process_under_sampling(uint8_t *data,</Line>
  <Line number="378">	const struct bmi160_dev *dev);</Line>
  <Line number="379"></Line>
  <Line number="380">/*!</Line>
  <Line number="381"> * @brief This API sets the gyro power mode.</Line>
  <Line number="382"> *</Line>
  <Line number="383"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="384"> *</Line>
  <Line number="385"> * @return Result of API execution status</Line>
  <Line number="386"> * @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="387"> */</Line>
  <Line number="388">static int8_t set_gyro_pwr(struct bmi160_dev *dev);</Line>
  <Line number="389"></Line>
  <Line number="390">/*!</Line>
  <Line number="391"> * @brief This API reads accel data along with sensor time if time is requested</Line>
  <Line number="392"> * by user. Kindly refer the user guide(README.md) for more info.</Line>
  <Line number="393"> *</Line>
  <Line number="394"> * @param[in] len    : len to read no of bytes</Line>
  <Line number="395"> * @param[out] accel    : Structure pointer to store accel data</Line>
  <Line number="396"> * @param[in] dev       : Structure instance of bmi160_dev.</Line>
  <Line number="397"> *</Line>
  <Line number="398"> * @return Result of API execution status</Line>
  <Line number="399"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="400"> */</Line>
  <Line number="401">static int8_t get_accel_data(uint8_t len, struct bmi160_sensor_data *accel, const struct bmi160_dev *dev);</Line>
  <Line number="402"></Line>
  <Line number="403">/*!</Line>
  <Line number="404"> * @brief This API reads accel data along with sensor time if time is requested</Line>
  <Line number="405"> * by user. Kindly refer the user guide(README.md) for more info.</Line>
  <Line number="406"> *</Line>
  <Line number="407"> * @param[in] len    : len to read no of bytes</Line>
  <Line number="408"> * @param[out] gyro    : Structure pointer to store accel data</Line>
  <Line number="409"> * @param[in] dev       : Structure instance of bmi160_dev.</Line>
  <Line number="410"> *</Line>
  <Line number="411"> * @return Result of API execution status</Line>
  <Line number="412"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="413"> */</Line>
  <Line number="414">static int8_t get_gyro_data(uint8_t len, struct bmi160_sensor_data *gyro, const struct bmi160_dev *dev);</Line>
  <Line number="415"></Line>
  <Line number="416">/*!</Line>
  <Line number="417"> * @brief This API reads accel and gyro data along with sensor time</Line>
  <Line number="418"> * if time is requested by user.</Line>
  <Line number="419"> * Kindly refer the user guide(README.md) for more info.</Line>
  <Line number="420"> *</Line>
  <Line number="421"> * @param[in] len    : len to read no of bytes</Line>
  <Line number="422"> * @param[out] accel    : Structure pointer to store accel data</Line>
  <Line number="423"> * @param[out] gyro    : Structure pointer to store accel data</Line>
  <Line number="424"> * @param[in] dev       : Structure instance of bmi160_dev.</Line>
  <Line number="425"> *</Line>
  <Line number="426"> * @return Result of API execution status</Line>
  <Line number="427"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="428"> */</Line>
  <Line number="429">static int8_t get_accel_gyro_data(uint8_t len, struct bmi160_sensor_data *accel, struct bmi160_sensor_data *gyro,</Line>
  <Line number="430">					const struct bmi160_dev *dev);</Line>
  <Line number="431"></Line>
  <Line number="432">/*!</Line>
  <Line number="433"> * @brief This API enables the any-motion interrupt for accel.</Line>
  <Line number="434"> *</Line>
  <Line number="435"> * @param[in] any_motion_int_cfg   : Structure instance of</Line>
  <Line number="436"> *				     bmi160_acc_any_mot_int_cfg.</Line>
  <Line number="437"> * @param[in] dev		   : Structure instance of bmi160_dev.</Line>
  <Line number="438"> *</Line>
  <Line number="439"> * @return Result of API execution status</Line>
  <Line number="440"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="441"> */</Line>
  <Line number="442">static int8_t enable_accel_any_motion_int(const struct bmi160_acc_any_mot_int_cfg *any_motion_int_cfg,</Line>
  <Line number="443">						struct bmi160_dev *dev);</Line>
  <Line number="444"></Line>
  <Line number="445">/*!</Line>
  <Line number="446"> * @brief This API disable the sig-motion interrupt.</Line>
  <Line number="447"> *</Line>
  <Line number="448"> * @param[in] dev	: Structure instance of bmi160_dev.</Line>
  <Line number="449"> *</Line>
  <Line number="450"> * @return Result of API execution status</Line>
  <Line number="451"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="452"> */</Line>
  <Line number="453">static int8_t disable_sig_motion_int(const struct bmi160_dev *dev);</Line>
  <Line number="454"></Line>
  <Line number="455">/*!</Line>
  <Line number="456"> * @brief This API configure the source of data(filter &amp; pre-filter)</Line>
  <Line number="457"> * for any-motion interrupt.</Line>
  <Line number="458"> *</Line>
  <Line number="459"> * @param[in] any_motion_int_cfg  : Structure instance of</Line>
  <Line number="460"> *				    bmi160_acc_any_mot_int_cfg.</Line>
  <Line number="461"> * @param[in] dev		  : Structure instance of bmi160_dev.</Line>
  <Line number="462"> *</Line>
  <Line number="463"> * @return Result of API execution status</Line>
  <Line number="464"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="465"> */</Line>
  <Line number="466">static int8_t config_any_motion_src(const struct bmi160_acc_any_mot_int_cfg *any_motion_int_cfg,</Line>
  <Line number="467">					const struct bmi160_dev *dev);</Line>
  <Line number="468"></Line>
  <Line number="469">/*!</Line>
  <Line number="470"> * @brief This API configure the duration and threshold of</Line>
  <Line number="471"> * any-motion interrupt.</Line>
  <Line number="472"> *</Line>
  <Line number="473"> * @param[in] any_motion_int_cfg  : Structure instance of</Line>
  <Line number="474"> *				    bmi160_acc_any_mot_int_cfg.</Line>
  <Line number="475"> * @param[in] dev		  : Structure instance of bmi160_dev.</Line>
  <Line number="476"> *</Line>
  <Line number="477"> * @return Result of API execution status</Line>
  <Line number="478"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="479"> */</Line>
  <Line number="480">static int8_t config_any_dur_threshold(const struct bmi160_acc_any_mot_int_cfg *any_motion_int_cfg,</Line>
  <Line number="481">					const struct bmi160_dev *dev);</Line>
  <Line number="482"></Line>
  <Line number="483">/*!</Line>
  <Line number="484"> * @brief This API configure necessary setting of any-motion interrupt.</Line>
  <Line number="485"> *</Line>
  <Line number="486"> * @param[in] int_config	   : Structure instance of bmi160_int_settg.</Line>
  <Line number="487"> * @param[in] any_motion_int_cfg   : Structure instance of</Line>
  <Line number="488"> *				     bmi160_acc_any_mot_int_cfg.</Line>
  <Line number="489"> * @param[in] dev		   : Structure instance of bmi160_dev.</Line>
  <Line number="490"> *</Line>
  <Line number="491"> * @return Result of API execution status</Line>
  <Line number="492"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="493"> */</Line>
  <Line number="494">static int8_t config_any_motion_int_settg(const struct bmi160_int_settg *int_config,</Line>
  <Line number="495">					const struct bmi160_acc_any_mot_int_cfg *any_motion_int_cfg,</Line>
  <Line number="496">					const struct bmi160_dev *dev);</Line>
  <Line number="497"></Line>
  <Line number="498">/*!</Line>
  <Line number="499"> * @brief This API enable the data ready interrupt.</Line>
  <Line number="500"> *</Line>
  <Line number="501"> * @param[in] dev		: Structure instance of bmi160_dev.</Line>
  <Line number="502"> *</Line>
  <Line number="503"> * @return Result of API execution status</Line>
  <Line number="504"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="505"> */</Line>
  <Line number="506">static int8_t enable_data_ready_int(const struct bmi160_dev *dev);</Line>
  <Line number="507"></Line>
  <Line number="508">/*!</Line>
  <Line number="509"> * @brief This API enables the no motion/slow motion interrupt.</Line>
  <Line number="510"> *</Line>
  <Line number="511"> * @param[in] no_mot_int_cfg	: Structure instance of</Line>
  <Line number="512"> *				  bmi160_acc_no_motion_int_cfg.</Line>
  <Line number="513"> * @param[in] dev		: Structure instance of bmi160_dev.</Line>
  <Line number="514"> *</Line>
  <Line number="515"> * @return Result of API execution status</Line>
  <Line number="516"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="517"> */</Line>
  <Line number="518">static int8_t enable_no_motion_int(const struct bmi160_acc_no_motion_int_cfg *no_mot_int_cfg,</Line>
  <Line number="519">					const struct bmi160_dev *dev);</Line>
  <Line number="520"></Line>
  <Line number="521">/*!</Line>
  <Line number="522"> * @brief This API configure the interrupt PIN setting for</Line>
  <Line number="523"> * no motion/slow motion interrupt.</Line>
  <Line number="524"> *</Line>
  <Line number="525"> * @param[in] int_config	: structure instance of bmi160_int_settg.</Line>
  <Line number="526"> * @param[in] no_mot_int_cfg	: Structure instance of</Line>
  <Line number="527"> *				  bmi160_acc_no_motion_int_cfg.</Line>
  <Line number="528"> * @param[in] dev		: Structure instance of bmi160_dev.</Line>
  <Line number="529"> *</Line>
  <Line number="530"> * @return Result of API execution status</Line>
  <Line number="531"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="532"> */</Line>
  <Line number="533">static int8_t config_no_motion_int_settg(const struct bmi160_int_settg *int_config,</Line>
  <Line number="534">					const struct bmi160_acc_no_motion_int_cfg *no_mot_int_cfg,</Line>
  <Line number="535">					const struct bmi160_dev *dev);</Line>
  <Line number="536"></Line>
  <Line number="537">/*!</Line>
  <Line number="538"> * @brief This API configure the source of interrupt for no motion.</Line>
  <Line number="539"> *</Line>
  <Line number="540"> * @param[in] no_mot_int_cfg	: Structure instance of</Line>
  <Line number="541"> *				  bmi160_acc_no_motion_int_cfg.</Line>
  <Line number="542"> * @param[in] dev		: Structure instance of bmi160_dev.</Line>
  <Line number="543"> *</Line>
  <Line number="544"> * @return Result of API execution status</Line>
  <Line number="545"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="546"> */</Line>
  <Line number="547">static int8_t config_no_motion_data_src(const struct bmi160_acc_no_motion_int_cfg *no_mot_int_cfg,</Line>
  <Line number="548">					const struct bmi160_dev *dev);</Line>
  <Line number="549"></Line>
  <Line number="550">/*!</Line>
  <Line number="551"> * @brief This API configure the duration and threshold of</Line>
  <Line number="552"> * no motion/slow motion interrupt along with selection of no/slow motion.</Line>
  <Line number="553"> *</Line>
  <Line number="554"> * @param[in] no_mot_int_cfg	: Structure instance of</Line>
  <Line number="555"> *				  bmi160_acc_no_motion_int_cfg.</Line>
  <Line number="556"> * @param[in] dev		: Structure instance of bmi160_dev.</Line>
  <Line number="557"> *</Line>
  <Line number="558"> * @return Result of API execution status</Line>
  <Line number="559"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="560"> */</Line>
  <Line number="561">static int8_t config_no_motion_dur_thr(const struct bmi160_acc_no_motion_int_cfg *no_mot_int_cfg,</Line>
  <Line number="562">					const struct bmi160_dev *dev);</Line>
  <Line number="563"></Line>
  <Line number="564">/*!</Line>
  <Line number="565"> * @brief This API enables the sig-motion motion interrupt.</Line>
  <Line number="566"> *</Line>
  <Line number="567"> * @param[in] sig_mot_int_cfg	: Structure instance of</Line>
  <Line number="568"> *				  bmi160_acc_sig_mot_int_cfg.</Line>
  <Line number="569"> * @param[in] dev		: Structure instance of bmi160_dev.</Line>
  <Line number="570"> *</Line>
  <Line number="571"> * @return Result of API execution status</Line>
  <Line number="572"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="573"> */</Line>
  <Line number="574">static int8_t enable_sig_motion_int(const struct bmi160_acc_sig_mot_int_cfg *sig_mot_int_cfg, struct bmi160_dev *dev);</Line>
  <Line number="575"></Line>
  <Line number="576">/*!</Line>
  <Line number="577"> * @brief This API configure the interrupt PIN setting for</Line>
  <Line number="578"> * significant motion interrupt.</Line>
  <Line number="579"> *</Line>
  <Line number="580"> * @param[in] int_config	: Structure instance of bmi160_int_settg.</Line>
  <Line number="581"> * @param[in] sig_mot_int_cfg	: Structure instance of</Line>
  <Line number="582"> *				  bmi160_acc_sig_mot_int_cfg.</Line>
  <Line number="583"> * @param[in] dev		: Structure instance of bmi160_dev.</Line>
  <Line number="584"> *</Line>
  <Line number="585"> * @return Result of API execution status</Line>
  <Line number="586"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="587"> */</Line>
  <Line number="588">static int8_t config_sig_motion_int_settg(const struct bmi160_int_settg *int_config,</Line>
  <Line number="589">					const struct bmi160_acc_sig_mot_int_cfg *sig_mot_int_cfg,</Line>
  <Line number="590">					const struct bmi160_dev *dev);</Line>
  <Line number="591"></Line>
  <Line number="592">/*!</Line>
  <Line number="593"> * @brief This API configure the source of data(filter &amp; pre-filter)</Line>
  <Line number="594"> * for sig motion interrupt.</Line>
  <Line number="595"> *</Line>
  <Line number="596"> * @param[in] sig_mot_int_cfg	: Structure instance of</Line>
  <Line number="597"> *				  bmi160_acc_sig_mot_int_cfg.</Line>
  <Line number="598"> * @param[in] dev		: Structure instance of bmi160_dev.</Line>
  <Line number="599"> *</Line>
  <Line number="600"> * @return Result of API execution status</Line>
  <Line number="601"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="602"> */</Line>
  <Line number="603">static int8_t config_sig_motion_data_src(const struct bmi160_acc_sig_mot_int_cfg *sig_mot_int_cfg,</Line>
  <Line number="604">					const struct bmi160_dev *dev);</Line>
  <Line number="605"></Line>
  <Line number="606">/*!</Line>
  <Line number="607"> * @brief This API configure the threshold, skip and proof time of</Line>
  <Line number="608"> * sig motion interrupt.</Line>
  <Line number="609"> *</Line>
  <Line number="610"> * @param[in] sig_mot_int_cfg	: Structure instance of</Line>
  <Line number="611"> *				  bmi160_acc_sig_mot_int_cfg.</Line>
  <Line number="612"> * @param[in] dev		: Structure instance of bmi160_dev.</Line>
  <Line number="613"> *</Line>
  <Line number="614"> * @return Result of API execution status</Line>
  <Line number="615"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="616"> */</Line>
  <Line number="617">static int8_t config_sig_dur_threshold(const struct bmi160_acc_sig_mot_int_cfg *sig_mot_int_cfg,</Line>
  <Line number="618">					const struct bmi160_dev *dev);</Line>
  <Line number="619"></Line>
  <Line number="620">/*!</Line>
  <Line number="621"> * @brief This API enables the step detector interrupt.</Line>
  <Line number="622"> *</Line>
  <Line number="623"> * @param[in] step_detect_int_cfg	: Structure instance of</Line>
  <Line number="624"> *					  bmi160_acc_step_detect_int_cfg.</Line>
  <Line number="625"> * @param[in] dev			: Structure instance of bmi160_dev.</Line>
  <Line number="626"> *</Line>
  <Line number="627"> * @return Result of API execution status</Line>
  <Line number="628"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="629"> */</Line>
  <Line number="630">static int8_t enable_step_detect_int(const struct bmi160_acc_step_detect_int_cfg *step_detect_int_cfg,</Line>
  <Line number="631">					const struct bmi160_dev *dev);</Line>
  <Line number="632"></Line>
  <Line number="633">/*!</Line>
  <Line number="634"> * @brief This API configure the step detector parameter.</Line>
  <Line number="635"> *</Line>
  <Line number="636"> * @param[in] step_detect_int_cfg	: Structure instance of</Line>
  <Line number="637"> *					  bmi160_acc_step_detect_int_cfg.</Line>
  <Line number="638"> * @param[in] dev			: Structure instance of bmi160_dev.</Line>
  <Line number="639"> *</Line>
  <Line number="640"> * @return Result of API execution status</Line>
  <Line number="641"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="642"> */</Line>
  <Line number="643">static int8_t config_step_detect(const struct bmi160_acc_step_detect_int_cfg *step_detect_int_cfg,</Line>
  <Line number="644">					const struct bmi160_dev *dev);</Line>
  <Line number="645"></Line>
  <Line number="646">/*!</Line>
  <Line number="647"> * @brief This API enables the single/double tap interrupt.</Line>
  <Line number="648"> *</Line>
  <Line number="649"> * @param[in] int_config	: Structure instance of bmi160_int_settg.</Line>
  <Line number="650"> * @param[in] dev		: Structure instance of bmi160_dev.</Line>
  <Line number="651"> *</Line>
  <Line number="652"> * @return Result of API execution status</Line>
  <Line number="653"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="654"> */</Line>
  <Line number="655">static int8_t enable_tap_int(const struct bmi160_int_settg *int_config,</Line>
  <Line number="656">				const struct bmi160_acc_tap_int_cfg *tap_int_cfg,</Line>
  <Line number="657">				const struct bmi160_dev *dev);</Line>
  <Line number="658"></Line>
  <Line number="659">/*!</Line>
  <Line number="660"> * @brief This API configure the interrupt PIN setting for</Line>
  <Line number="661"> * tap interrupt.</Line>
  <Line number="662"> *</Line>
  <Line number="663"> * @param[in] int_config	: Structure instance of bmi160_int_settg.</Line>
  <Line number="664"> * @param[in] tap_int_cfg	: Structure instance of bmi160_acc_tap_int_cfg.</Line>
  <Line number="665"> * @param[in] dev		: Structure instance of bmi160_dev.</Line>
  <Line number="666"> *</Line>
  <Line number="667"> * @return Result of API execution status</Line>
  <Line number="668"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="669"> */</Line>
  <Line number="670">static int8_t config_tap_int_settg(const struct bmi160_int_settg *int_config,</Line>
  <Line number="671">					const struct bmi160_acc_tap_int_cfg *tap_int_cfg,</Line>
  <Line number="672">					const struct bmi160_dev *dev);</Line>
  <Line number="673"></Line>
  <Line number="674">/*!</Line>
  <Line number="675"> * @brief This API configure the source of data(filter &amp; pre-filter)</Line>
  <Line number="676"> * for tap interrupt.</Line>
  <Line number="677"> *</Line>
  <Line number="678"> * @param[in] tap_int_cfg	: Structure instance of bmi160_acc_tap_int_cfg.</Line>
  <Line number="679"> * @param[in] dev		: Structure instance of bmi160_dev.</Line>
  <Line number="680"> *</Line>
  <Line number="681"> * @return Result of API execution status</Line>
  <Line number="682"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="683"> */</Line>
  <Line number="684">static int8_t config_tap_data_src(const struct bmi160_acc_tap_int_cfg *tap_int_cfg, const struct bmi160_dev *dev);</Line>
  <Line number="685"></Line>
  <Line number="686">/*!</Line>
  <Line number="687"> * @brief This API configure the  parameters of tap interrupt.</Line>
  <Line number="688"> * Threshold, quite, shock, and duration.</Line>
  <Line number="689"> *</Line>
  <Line number="690"> * @param[in] int_config	: Structure instance of bmi160_int_settg.</Line>
  <Line number="691"> * @param[in] tap_int_cfg	: Structure instance of bmi160_acc_tap_int_cfg.</Line>
  <Line number="692"> * @param[in] dev		: structure instance of bmi160_dev.</Line>
  <Line number="693"> *</Line>
  <Line number="694"> * @return Result of API execution status</Line>
  <Line number="695"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="696"> */</Line>
  <Line number="697">static int8_t config_tap_param(const struct bmi160_int_settg *int_config,</Line>
  <Line number="698">				const struct bmi160_acc_tap_int_cfg *tap_int_cfg,</Line>
  <Line number="699">				const struct bmi160_dev *dev);</Line>
  <Line number="700"></Line>
  <Line number="701">/*!</Line>
  <Line number="702"> * @brief This API enable the external mode configuration.</Line>
  <Line number="703"> *</Line>
  <Line number="704"> * @param[in] dev	: Structure instance of bmi160_dev.</Line>
  <Line number="705"> *</Line>
  <Line number="706"> * @return Result of API execution status</Line>
  <Line number="707"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="708"> */</Line>
  <Line number="709">static int8_t config_sec_if(const struct bmi160_dev *dev);</Line>
  <Line number="710"></Line>
  <Line number="711">/*!</Line>
  <Line number="712"> * @brief This API configure the ODR of the auxiliary sensor.</Line>
  <Line number="713"> *</Line>
  <Line number="714"> * @param[in] dev	: Structure instance of bmi160_dev.</Line>
  <Line number="715"> *</Line>
  <Line number="716"> * @return Result of API execution status</Line>
  <Line number="717"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="718"> */</Line>
  <Line number="719">static int8_t config_aux_odr(const struct bmi160_dev *dev);</Line>
  <Line number="720"></Line>
  <Line number="721">/*!</Line>
  <Line number="722"> * @brief This API maps the actual burst read length set by user.</Line>
  <Line number="723"> *</Line>
  <Line number="724"> * @param[in] len	: Pointer to store the read length.</Line>
  <Line number="725"> * @param[in] dev	: Structure instance of bmi160_dev.</Line>
  <Line number="726"> *</Line>
  <Line number="727"> * @return Result of API execution status</Line>
  <Line number="728"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="729"> */</Line>
  <Line number="730">static int8_t map_read_len(uint16_t *len, const struct bmi160_dev *dev);</Line>
  <Line number="731"></Line>
  <Line number="732">/*!</Line>
  <Line number="733"> * @brief This API configure the settings of auxiliary sensor.</Line>
  <Line number="734"> *</Line>
  <Line number="735"> * @param[in] dev	: Structure instance of bmi160_dev.</Line>
  <Line number="736"> *</Line>
  <Line number="737"> * @return Result of API execution status</Line>
  <Line number="738"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="739"> */</Line>
  <Line number="740">static int8_t config_aux_settg(const struct bmi160_dev *dev);</Line>
  <Line number="741"></Line>
  <Line number="742">/*!</Line>
  <Line number="743"> * @brief This API extract the read data from auxiliary sensor.</Line>
  <Line number="744"> *</Line>
  <Line number="745"> * @param[in] map_len	  : burst read value.</Line>
  <Line number="746"> * @param[in] reg_addr	  : Address of register to read.</Line>
  <Line number="747"> * @param[in] aux_data	  : Pointer to store the read data.</Line>
  <Line number="748"> * @param[in] len	  : length to read the data.</Line>
  <Line number="749"> * @param[in] dev         : Structure instance of bmi160_dev.</Line>
  <Line number="750"> * @note : Refer user guide for detailed info.</Line>
  <Line number="751"> *</Line>
  <Line number="752"> * @return Result of API execution status</Line>
  <Line number="753"> * @retval zero -&gt; Success / -ve value -&gt; Error</Line>
  <Line number="754"> */</Line>
  <Line number="755">static int8_t extract_aux_read(uint16_t map_len, uint8_t reg_addr, uint8_t *aux_data, uint16_t len,</Line>
  <Line number="756">				const struct bmi160_dev *dev);</Line>
  <Line number="757"></Line>
  <Line number="758">/*!</Line>
  <Line number="759"> * @brief This API enables the orient interrupt.</Line>
  <Line number="760"> *</Line>
  <Line number="761"> * @param[in] orient_int_cfg : Structure instance of bmi160_acc_orient_int_cfg.</Line>
  <Line number="762"> * @param[in] dev	     : Structure instance of bmi160_dev.</Line>
  <Line number="763"> *</Line>
  <Line number="764"> * @return Result of API execution status</Line>
  <Line number="765"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="766"> */</Line>
  <Line number="767">static int8_t enable_orient_int(const struct bmi160_acc_orient_int_cfg *orient_int_cfg, const struct bmi160_dev *dev);</Line>
  <Line number="768"></Line>
  <Line number="769">/*!</Line>
  <Line number="770"> * @brief This API configure the necessary setting of orientation interrupt.</Line>
  <Line number="771"> *</Line>
  <Line number="772"> * @param[in] orient_int_cfg : Structure instance of bmi160_acc_orient_int_cfg.</Line>
  <Line number="773"> * @param[in] dev	     : structure instance of bmi160_dev.</Line>
  <Line number="774"> *</Line>
  <Line number="775"> * @return Result of API execution status</Line>
  <Line number="776"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="777"> */</Line>
  <Line number="778">static int8_t config_orient_int_settg(const struct bmi160_acc_orient_int_cfg *orient_int_cfg,</Line>
  <Line number="779">					const struct bmi160_dev *dev);</Line>
  <Line number="780"></Line>
  <Line number="781">/*!</Line>
  <Line number="782"> * @brief This API enables the flat interrupt.</Line>
  <Line number="783"> *</Line>
  <Line number="784"> * @param[in] flat_int	: Structure instance of bmi160_acc_flat_detect_int_cfg.</Line>
  <Line number="785"> * @param[in] dev		: structure instance of bmi160_dev.</Line>
  <Line number="786"> *</Line>
  <Line number="787"> * @return Result of API execution status</Line>
  <Line number="788"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="789"> */</Line>
  <Line number="790">static int8_t enable_flat_int(const struct bmi160_acc_flat_detect_int_cfg *flat_int, const struct bmi160_dev *dev);</Line>
  <Line number="791"></Line>
  <Line number="792">/*!</Line>
  <Line number="793"> * @brief This API configure the necessary setting of flat interrupt.</Line>
  <Line number="794"> *</Line>
  <Line number="795"> * @param[in] flat_int	: Structure instance of bmi160_acc_flat_detect_int_cfg.</Line>
  <Line number="796"> * @param[in] dev	: structure instance of bmi160_dev.</Line>
  <Line number="797"> *</Line>
  <Line number="798"> * @return Result of API execution status</Line>
  <Line number="799"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="800"> */</Line>
  <Line number="801">static int8_t config_flat_int_settg(const struct bmi160_acc_flat_detect_int_cfg *flat_int,</Line>
  <Line number="802">					const struct bmi160_dev *dev);</Line>
  <Line number="803"></Line>
  <Line number="804">/*!</Line>
  <Line number="805"> * @brief This API enables the Low-g interrupt.</Line>
  <Line number="806"> *</Line>
  <Line number="807"> * @param[in] low_g_int	: Structure instance of bmi160_acc_low_g_int_cfg.</Line>
  <Line number="808"> * @param[in] dev	: structure instance of bmi160_dev.</Line>
  <Line number="809"> *</Line>
  <Line number="810"> * @return Result of API execution status</Line>
  <Line number="811"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="812"> */</Line>
  <Line number="813">static int8_t enable_low_g_int(const struct bmi160_acc_low_g_int_cfg *low_g_int, const struct bmi160_dev *dev);</Line>
  <Line number="814"></Line>
  <Line number="815">/*!</Line>
  <Line number="816"> * @brief This API configure the source of data(filter &amp; pre-filter) for low-g interrupt.</Line>
  <Line number="817"> *</Line>
  <Line number="818"> * @param[in] low_g_int	: Structure instance of bmi160_acc_low_g_int_cfg.</Line>
  <Line number="819"> * @param[in] dev	: structure instance of bmi160_dev.</Line>
  <Line number="820"> *</Line>
  <Line number="821"> * @return Result of API execution status</Line>
  <Line number="822"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="823"> */</Line>
  <Line number="824">static int8_t config_low_g_data_src(const struct bmi160_acc_low_g_int_cfg *low_g_int, const struct bmi160_dev *dev);</Line>
  <Line number="825"></Line>
  <Line number="826">/*!</Line>
  <Line number="827"> * @brief This API configure the necessary setting of low-g interrupt.</Line>
  <Line number="828"> *</Line>
  <Line number="829"> * @param[in] low_g_int	: Structure instance of bmi160_acc_low_g_int_cfg.</Line>
  <Line number="830"> * @param[in] dev	: structure instance of bmi160_dev.</Line>
  <Line number="831"> *</Line>
  <Line number="832"> * @return Result of API execution status</Line>
  <Line number="833"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="834"> */</Line>
  <Line number="835">static int8_t config_low_g_int_settg(const struct bmi160_acc_low_g_int_cfg *low_g_int,  const struct bmi160_dev *dev);</Line>
  <Line number="836"></Line>
  <Line number="837">/*!</Line>
  <Line number="838"> * @brief This API enables the high-g interrupt.</Line>
  <Line number="839"> *</Line>
  <Line number="840"> * @param[in] high_g_int_cfg : Structure instance of bmi160_acc_high_g_int_cfg.</Line>
  <Line number="841"> * @param[in] dev	     : structure instance of bmi160_dev.</Line>
  <Line number="842"> *</Line>
  <Line number="843"> * @return Result of API execution status</Line>
  <Line number="844"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="845"> */</Line>
  <Line number="846">static int8_t enable_high_g_int(const struct bmi160_acc_high_g_int_cfg *high_g_int_cfg, const struct bmi160_dev *dev);</Line>
  <Line number="847"></Line>
  <Line number="848">/*!</Line>
  <Line number="849"> * @brief This API configure the source of data(filter &amp; pre-filter)</Line>
  <Line number="850"> * for high-g interrupt.</Line>
  <Line number="851"> *</Line>
  <Line number="852"> * @param[in] high_g_int_cfg : Structure instance of bmi160_acc_high_g_int_cfg.</Line>
  <Line number="853"> * @param[in] dev	     : structure instance of bmi160_dev.</Line>
  <Line number="854"> *</Line>
  <Line number="855"> * @return Result of API execution status</Line>
  <Line number="856"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="857"> */</Line>
  <Line number="858">static int8_t config_high_g_data_src(const struct bmi160_acc_high_g_int_cfg *high_g_int_cfg,</Line>
  <Line number="859">					const struct bmi160_dev *dev);</Line>
  <Line number="860"></Line>
  <Line number="861">/*!</Line>
  <Line number="862"> * @brief This API configure the necessary setting of high-g interrupt.</Line>
  <Line number="863"> *</Line>
  <Line number="864"> * @param[in] high_g_int_cfg : Structure instance of bmi160_acc_high_g_int_cfg.</Line>
  <Line number="865"> * @param[in] dev	     : structure instance of bmi160_dev.</Line>
  <Line number="866"> *</Line>
  <Line number="867"> * @return Result of API execution status</Line>
  <Line number="868"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="869"> */</Line>
  <Line number="870">static int8_t config_high_g_int_settg(const struct bmi160_acc_high_g_int_cfg *high_g_int_cfg,</Line>
  <Line number="871">					const struct bmi160_dev *dev);</Line>
  <Line number="872"></Line>
  <Line number="873">/*!</Line>
  <Line number="874"> * @brief This API configure the behavioural setting of interrupt pin.</Line>
  <Line number="875"> *</Line>
  <Line number="876"> * @param[in] int_config	: Structure instance of bmi160_int_settg.</Line>
  <Line number="877"> * @param[in] dev		: structure instance of bmi160_dev.</Line>
  <Line number="878"> *</Line>
  <Line number="879"> * @return Result of API execution status</Line>
  <Line number="880"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="881"> */</Line>
  <Line number="882">static int8_t config_int_out_ctrl(const struct bmi160_int_settg *int_config,  const struct bmi160_dev *dev);</Line>
  <Line number="883"></Line>
  <Line number="884">/*!</Line>
  <Line number="885"> * @brief This API configure the mode(input enable, latch or non-latch) of interrupt pin.</Line>
  <Line number="886"> *</Line>
  <Line number="887"> * @param[in] int_config	: Structure instance of bmi160_int_settg.</Line>
  <Line number="888"> * @param[in] dev		: structure instance of bmi160_dev.</Line>
  <Line number="889"> *</Line>
  <Line number="890"> * @return Result of API execution status</Line>
  <Line number="891"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="892"> */</Line>
  <Line number="893">static int8_t config_int_latch(const struct bmi160_int_settg *int_config,  const struct bmi160_dev *dev);</Line>
  <Line number="894"></Line>
  <Line number="895">/*!</Line>
  <Line number="896"> * @brief This API performs the self test for accelerometer of BMI160</Line>
  <Line number="897"> *</Line>
  <Line number="898"> * @param[in] dev	: structure instance of bmi160_dev.</Line>
  <Line number="899"> *</Line>
  <Line number="900"> * @return Result of API execution status</Line>
  <Line number="901"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="902"> */</Line>
  <Line number="903">static int8_t perform_accel_self_test(struct bmi160_dev *dev);</Line>
  <Line number="904"></Line>
  <Line number="905">/*!</Line>
  <Line number="906"> * @brief This API enables to perform the accel self test by setting proper</Line>
  <Line number="907"> * configurations to facilitate accel self test</Line>
  <Line number="908"> *</Line>
  <Line number="909"> * @param[in] dev	: structure instance of bmi160_dev.</Line>
  <Line number="910"> *</Line>
  <Line number="911"> * @return Result of API execution status</Line>
  <Line number="912"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="913"> */</Line>
  <Line number="914">static int8_t enable_accel_self_test(struct bmi160_dev *dev);</Line>
  <Line number="915"></Line>
  <Line number="916">/*!</Line>
  <Line number="917"> * @brief This API performs accel self test with positive excitation</Line>
  <Line number="918"> *</Line>
  <Line number="919"> * @param[in] accel_pos	: Structure pointer to store accel data</Line>
  <Line number="920"> *                        for positive excitation</Line>
  <Line number="921"> * @param[in] dev	: structure instance of bmi160_dev</Line>
  <Line number="922"> *</Line>
  <Line number="923"> * @return Result of API execution status</Line>
  <Line number="924"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="925"> */</Line>
  <Line number="926">static int8_t accel_self_test_positive_excitation(struct bmi160_sensor_data *accel_pos, const struct bmi160_dev *dev);</Line>
  <Line number="927"></Line>
  <Line number="928">/*!</Line>
  <Line number="929"> * @brief This API performs accel self test with negative excitation</Line>
  <Line number="930"> *</Line>
  <Line number="931"> * @param[in] accel_neg	: Structure pointer to store accel data</Line>
  <Line number="932"> *                        for negative excitation</Line>
  <Line number="933"> * @param[in] dev	: structure instance of bmi160_dev</Line>
  <Line number="934"> *</Line>
  <Line number="935"> * @return Result of API execution status</Line>
  <Line number="936"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="937"> */</Line>
  <Line number="938">static int8_t accel_self_test_negative_excitation(struct bmi160_sensor_data *accel_neg, const struct bmi160_dev *dev);</Line>
  <Line number="939"></Line>
  <Line number="940">/*!</Line>
  <Line number="941"> * @brief This API validates the accel self test results</Line>
  <Line number="942"> *</Line>
  <Line number="943"> * @param[in] accel_pos	: Structure pointer to store accel data</Line>
  <Line number="944"> *                        for positive excitation</Line>
  <Line number="945"> * @param[in] accel_neg	: Structure pointer to store accel data</Line>
  <Line number="946"> *                        for negative excitation</Line>
  <Line number="947"> *</Line>
  <Line number="948"> * @return Result of API execution status</Line>
  <Line number="949"> * @retval zero -&gt; Success  / -ve value -&gt; Error / +ve value -&gt; Self test fail</Line>
  <Line number="950"> */</Line>
  <Line number="951">static int8_t validate_accel_self_test(const struct bmi160_sensor_data *accel_pos,</Line>
  <Line number="952">					const struct bmi160_sensor_data *accel_neg);</Line>
  <Line number="953"></Line>
  <Line number="954">/*!</Line>
  <Line number="955"> * @brief This API performs the self test for gyroscope of BMI160</Line>
  <Line number="956"> *</Line>
  <Line number="957"> * @param[in] dev	: structure instance of bmi160_dev.</Line>
  <Line number="958"> *</Line>
  <Line number="959"> * @return Result of API execution status</Line>
  <Line number="960"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="961"> */</Line>
  <Line number="962">static int8_t perform_gyro_self_test(const struct bmi160_dev *dev);</Line>
  <Line number="963"></Line>
  <Line number="964">/*!</Line>
  <Line number="965"> * @brief This API enables the self test bit to trigger self test for gyro</Line>
  <Line number="966"> *</Line>
  <Line number="967"> * @param[in] dev	: structure instance of bmi160_dev.</Line>
  <Line number="968"> *</Line>
  <Line number="969"> * @return Result of API execution status</Line>
  <Line number="970"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="971"> */</Line>
  <Line number="972">static int8_t enable_gyro_self_test(const struct bmi160_dev *dev);</Line>
  <Line number="973"></Line>
  <Line number="974">/*!</Line>
  <Line number="975"> * @brief This API validates the self test results of gyro</Line>
  <Line number="976"> *</Line>
  <Line number="977"> * @param[in] dev	: structure instance of bmi160_dev.</Line>
  <Line number="978"> *</Line>
  <Line number="979"> * @return Result of API execution status</Line>
  <Line number="980"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="981"> */</Line>
  <Line number="982">static int8_t validate_gyro_self_test(const struct bmi160_dev *dev);</Line>
  <Line number="983"></Line>
  <Line number="984">/*!</Line>
  <Line number="985"> *  @brief This API sets FIFO full interrupt of the sensor.This interrupt</Line>
  <Line number="986"> *  occurs when the FIFO is full and the next full data sample would cause</Line>
  <Line number="987"> *  a FIFO overflow, which may delete the old samples.</Line>
  <Line number="988"> *</Line>
  <Line number="989"> * @param[in] int_config	: Structure instance of bmi160_int_settg.</Line>
  <Line number="990"> * @param[in] dev		: structure instance of bmi160_dev.</Line>
  <Line number="991"> *</Line>
  <Line number="992"> * @return Result of API execution status</Line>
  <Line number="993"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="994"> */</Line>
  <Line number="995">static int8_t set_fifo_full_int(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev);</Line>
  <Line number="996"></Line>
  <Line number="997">/*!</Line>
  <Line number="998"> * @brief This enable the FIFO full interrupt engine.</Line>
  <Line number="999"> *</Line>
  <Line number="1000"> * @param[in] int_config	: Structure instance of bmi160_int_settg.</Line>
  <Line number="1001"> * @param[in] dev		: structure instance of bmi160_dev.</Line>
  <Line number="1002"> *</Line>
  <Line number="1003"> * @return Result of API execution status</Line>
  <Line number="1004"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1005"> */</Line>
  <Line number="1006">static int8_t enable_fifo_full_int(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev);</Line>
  <Line number="1007"></Line>
  <Line number="1008">/*!</Line>
  <Line number="1009"> *  @brief This API sets FIFO watermark interrupt of the sensor.The FIFO</Line>
  <Line number="1010"> *  watermark interrupt is fired, when the FIFO fill level is above a fifo</Line>
  <Line number="1011"> *  watermark.</Line>
  <Line number="1012"> *</Line>
  <Line number="1013"> * @param[in] int_config	: Structure instance of bmi160_int_settg.</Line>
  <Line number="1014"> * @param[in] dev		: structure instance of bmi160_dev.</Line>
  <Line number="1015"> *</Line>
  <Line number="1016"> * @return Result of API execution status</Line>
  <Line number="1017"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1018"> */</Line>
  <Line number="1019">static int8_t set_fifo_watermark_int(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev);</Line>
  <Line number="1020"></Line>
  <Line number="1021">/*!</Line>
  <Line number="1022"> * @brief This enable the FIFO watermark interrupt engine.</Line>
  <Line number="1023"> *</Line>
  <Line number="1024"> * @param[in] int_config	: Structure instance of bmi160_int_settg.</Line>
  <Line number="1025"> * @param[in] dev		: structure instance of bmi160_dev.</Line>
  <Line number="1026"> *</Line>
  <Line number="1027"> * @return Result of API execution status</Line>
  <Line number="1028"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1029"> */</Line>
  <Line number="1030">static int8_t enable_fifo_wtm_int(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev);</Line>
  <Line number="1031"></Line>
  <Line number="1032">/*!</Line>
  <Line number="1033"> * @brief This API is used to reset the FIFO related configurations</Line>
  <Line number="1034"> *  in the fifo_frame structure.</Line>
  <Line number="1035"> *</Line>
  <Line number="1036"> * @param[in] dev		: structure instance of bmi160_dev.</Line>
  <Line number="1037"> *</Line>
  <Line number="1038"> * @return Result of API execution status</Line>
  <Line number="1039"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1040"> */</Line>
  <Line number="1041">static void reset_fifo_data_structure(const struct bmi160_dev *dev);</Line>
  <Line number="1042"></Line>
  <Line number="1043">/*!</Line>
  <Line number="1044"> *  @brief This API is used to read number of bytes filled</Line>
  <Line number="1045"> *  currently in FIFO buffer.</Line>
  <Line number="1046"> *</Line>
  <Line number="1047"> *  @param[in] bytes_to_read  : Number of bytes available in FIFO at the</Line>
  <Line number="1048"> *                              instant which is obtained from FIFO counter.</Line>
  <Line number="1049"> *  @param[in] dev            : Structure instance of bmi160_dev.</Line>
  <Line number="1050"> *</Line>
  <Line number="1051"> *  @return Result of API execution status</Line>
  <Line number="1052"> *  @retval zero -&gt; Success / -ve value -&gt; Error.</Line>
  <Line number="1053"> *  @retval Any non zero value -&gt; Fail</Line>
  <Line number="1054"> *</Line>
  <Line number="1055"> */</Line>
  <Line number="1056">static int8_t get_fifo_byte_counter(uint16_t *bytes_to_read, struct bmi160_dev const *dev);</Line>
  <Line number="1057"></Line>
  <Line number="1058">/*!</Line>
  <Line number="1059"> *  @brief This API is used to compute the number of bytes of accel FIFO data</Line>
  <Line number="1060"> *  which is to be parsed in header-less mode</Line>
  <Line number="1061"> *</Line>
  <Line number="1062"> *  @param[out] data_index        : The start index for parsing data</Line>
  <Line number="1063"> *  @param[out] data_read_length  : Number of bytes to be parsed</Line>
  <Line number="1064"> *  @param[in]  acc_frame_count   : Number of accelerometer frames to be read</Line>
  <Line number="1065"> *  @param[in]  dev               : Structure instance of bmi160_dev.</Line>
  <Line number="1066"> *</Line>
  <Line number="1067"> */</Line>
  <Line number="1068">static void get_accel_len_to_parse(uint16_t *data_index, uint16_t *data_read_length, const uint8_t *acc_frame_count,</Line>
  <Line number="1069">					const struct bmi160_dev *dev);</Line>
  <Line number="1070"></Line>
  <Line number="1071">/*!</Line>
  <Line number="1072"> *  @brief This API is used to parse the accelerometer data from the</Line>
  <Line number="1073"> *  FIFO data in both header mode and header-less mode.</Line>
  <Line number="1074"> *  It updates the idx value which is used to store the index of</Line>
  <Line number="1075"> *  the current data byte which is parsed.</Line>
  <Line number="1076"> *</Line>
  <Line number="1077"> *  @param[in,out] acc		: structure instance of sensor data</Line>
  <Line number="1078"> *  @param[in,out] idx		: Index value of number of bytes parsed</Line>
  <Line number="1079"> *  @param[in,out] acc_idx	: Index value of accelerometer data</Line>
  <Line number="1080"> *                                (x,y,z axes) frames parsed</Line>
  <Line number="1081"> *  @param[in] frame_info       : It consists of either fifo_data_enable</Line>
  <Line number="1082"> *                                parameter in header-less mode or</Line>
  <Line number="1083"> *                                frame header data in header mode</Line>
  <Line number="1084"> *  @param[in] dev		: structure instance of bmi160_dev.</Line>
  <Line number="1085"> *</Line>
  <Line number="1086"> *  @return Result of API execution status</Line>
  <Line number="1087"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1088"> */</Line>
  <Line number="1089">static void unpack_accel_frame(struct bmi160_sensor_data *acc, uint16_t *idx, uint8_t *acc_idx, uint8_t frame_info,</Line>
  <Line number="1090">				const struct bmi160_dev *dev);</Line>
  <Line number="1091"></Line>
  <Line number="1092">/*!</Line>
  <Line number="1093"> *  @brief This API is used to parse the accelerometer data from the</Line>
  <Line number="1094"> *  FIFO data and store it in the instance of the structure bmi160_sensor_data.</Line>
  <Line number="1095"> *</Line>
  <Line number="1096"> * @param[in,out] accel_data	    : structure instance of sensor data</Line>
  <Line number="1097"> * @param[in,out] data_start_index  : Index value of number of bytes parsed</Line>
  <Line number="1098"> * @param[in] dev		    : structure instance of bmi160_dev.</Line>
  <Line number="1099"> *</Line>
  <Line number="1100"> * @return Result of API execution status</Line>
  <Line number="1101"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1102"> */</Line>
  <Line number="1103">static void unpack_accel_data(struct bmi160_sensor_data *accel_data, uint16_t data_start_index,</Line>
  <Line number="1104">				const struct bmi160_dev *dev);</Line>
  <Line number="1105"></Line>
  <Line number="1106">/*!</Line>
  <Line number="1107"> *  @brief This API is used to parse the accelerometer data from the</Line>
  <Line number="1108"> *  FIFO data in header mode.</Line>
  <Line number="1109"> *</Line>
  <Line number="1110"> *  @param[in,out] accel_data	 : Structure instance of sensor data</Line>
  <Line number="1111"> *  @param[in,out] accel_length  : Number of accelerometer frames</Line>
  <Line number="1112"> *  @param[in] dev               : Structure instance of bmi160_dev.</Line>
  <Line number="1113"> *</Line>
  <Line number="1114"> *  @return Result of API execution status</Line>
  <Line number="1115"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1116"> */</Line>
  <Line number="1117">static void extract_accel_header_mode(struct bmi160_sensor_data *accel_data, uint8_t *accel_length,</Line>
  <Line number="1118">					const struct bmi160_dev *dev);</Line>
  <Line number="1119"></Line>
  <Line number="1120">/*!</Line>
  <Line number="1121"> *  @brief This API computes the number of bytes of gyro FIFO data</Line>
  <Line number="1122"> *  which is to be parsed in header-less mode</Line>
  <Line number="1123"> *</Line>
  <Line number="1124"> *  @param[out] data_index       : The start index for parsing data</Line>
  <Line number="1125"> *  @param[out] data_read_length : No of bytes to be parsed from FIFO buffer</Line>
  <Line number="1126"> *  @param[in] gyro_frame_count  : Number of Gyro data frames to be read</Line>
  <Line number="1127"> *  @param[in] dev               : Structure instance of bmi160_dev.</Line>
  <Line number="1128"> */</Line>
  <Line number="1129">static void get_gyro_len_to_parse(uint16_t *data_index, uint16_t *data_read_length, const uint8_t *gyro_frame_count,</Line>
  <Line number="1130">					const struct bmi160_dev *dev);</Line>
  <Line number="1131"></Line>
  <Line number="1132">/*!</Line>
  <Line number="1133"> *  @brief This API is used to parse the gyroscope&apos;s data from the</Line>
  <Line number="1134"> *  FIFO data in both header mode and header-less mode.</Line>
  <Line number="1135"> *  It updates the idx value which is used to store the index of</Line>
  <Line number="1136"> *  the current data byte which is parsed.</Line>
  <Line number="1137"> *</Line>
  <Line number="1138"> *  @param[in,out] gyro		: structure instance of sensor data</Line>
  <Line number="1139"> *  @param[in,out] idx		: Index value of number of bytes parsed</Line>
  <Line number="1140"> *  @param[in,out] gyro_idx	: Index value of gyro data</Line>
  <Line number="1141"> *                                (x,y,z axes) frames parsed</Line>
  <Line number="1142"> *  @param[in] frame_info       : It consists of either fifo_data_enable</Line>
  <Line number="1143"> *                                parameter in header-less mode or</Line>
  <Line number="1144"> *                                frame header data in header mode</Line>
  <Line number="1145"> *  @param[in] dev		: structure instance of bmi160_dev.</Line>
  <Line number="1146"> *</Line>
  <Line number="1147"> *  @return Result of API execution status</Line>
  <Line number="1148"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1149"> */</Line>
  <Line number="1150">static void unpack_gyro_frame(struct bmi160_sensor_data *gyro, uint16_t *idx, uint8_t *gyro_idx, uint8_t frame_info,</Line>
  <Line number="1151">				const struct bmi160_dev *dev);</Line>
  <Line number="1152"></Line>
  <Line number="1153"></Line>
  <Line number="1154">/*!</Line>
  <Line number="1155"> *  @brief This API is used to parse the gyro data from the</Line>
  <Line number="1156"> *  FIFO data and store it in the instance of the structure bmi160_sensor_data.</Line>
  <Line number="1157"> *</Line>
  <Line number="1158"> *  @param[in,out] gyro_data         : structure instance of sensor data</Line>
  <Line number="1159"> *  @param[in,out] data_start_index  : Index value of number of bytes parsed</Line>
  <Line number="1160"> *  @param[in] dev		     : structure instance of bmi160_dev.</Line>
  <Line number="1161"> *</Line>
  <Line number="1162"> *  @return Result of API execution status</Line>
  <Line number="1163"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1164"> */</Line>
  <Line number="1165">static void unpack_gyro_data(struct bmi160_sensor_data *gyro_data, uint16_t data_start_index,</Line>
  <Line number="1166">				const struct bmi160_dev *dev);</Line>
  <Line number="1167"></Line>
  <Line number="1168">/*!</Line>
  <Line number="1169"> *  @brief This API is used to parse the gyro data from the</Line>
  <Line number="1170"> *  FIFO data in header mode.</Line>
  <Line number="1171"> *</Line>
  <Line number="1172"> *  @param[in,out] gyro_data	 : Structure instance of sensor data</Line>
  <Line number="1173"> *  @param[in,out] gyro_length   : Number of gyro frames</Line>
  <Line number="1174"> *  @param[in] dev               : Structure instance of bmi160_dev.</Line>
  <Line number="1175"> *</Line>
  <Line number="1176"> *  @return Result of API execution status</Line>
  <Line number="1177"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1178"> */</Line>
  <Line number="1179">static void extract_gyro_header_mode(struct bmi160_sensor_data *gyro_data, uint8_t *gyro_length,</Line>
  <Line number="1180">					const struct bmi160_dev *dev);</Line>
  <Line number="1181"></Line>
  <Line number="1182">/*!</Line>
  <Line number="1183"> *  @brief This API computes the number of bytes of aux FIFO data</Line>
  <Line number="1184"> *  which is to be parsed in header-less mode</Line>
  <Line number="1185"> *</Line>
  <Line number="1186"> *  @param[out] data_index       : The start index for parsing data</Line>
  <Line number="1187"> *  @param[out] data_read_length : No of bytes to be parsed from FIFO buffer</Line>
  <Line number="1188"> *  @param[in] aux_frame_count   : Number of Aux data frames to be read</Line>
  <Line number="1189"> *  @param[in] dev               : Structure instance of bmi160_dev.</Line>
  <Line number="1190"> */</Line>
  <Line number="1191">static void get_aux_len_to_parse(uint16_t *data_index, uint16_t *data_read_length, const uint8_t *aux_frame_count,</Line>
  <Line number="1192">					const struct bmi160_dev *dev);</Line>
  <Line number="1193"></Line>
  <Line number="1194">/*!</Line>
  <Line number="1195"> *  @brief This API is used to parse the aux&apos;s data from the</Line>
  <Line number="1196"> *  FIFO data in both header mode and header-less mode.</Line>
  <Line number="1197"> *  It updates the idx value which is used to store the index of</Line>
  <Line number="1198"> *  the current data byte which is parsed</Line>
  <Line number="1199"> *</Line>
  <Line number="1200"> *  @param[in,out] aux_data	: structure instance of sensor data</Line>
  <Line number="1201"> *  @param[in,out] idx		: Index value of number of bytes parsed</Line>
  <Line number="1202"> *  @param[in,out] aux_index	: Index value of gyro data</Line>
  <Line number="1203"> *                                (x,y,z axes) frames parsed</Line>
  <Line number="1204"> *  @param[in] frame_info       : It consists of either fifo_data_enable</Line>
  <Line number="1205"> *                                parameter in header-less mode or</Line>
  <Line number="1206"> *                                frame header data in header mode</Line>
  <Line number="1207"> *  @param[in] dev		: structure instance of bmi160_dev.</Line>
  <Line number="1208"> *</Line>
  <Line number="1209"> *  @return Result of API execution status</Line>
  <Line number="1210"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1211"> */</Line>
  <Line number="1212">static void unpack_aux_frame(struct bmi160_aux_data *aux_data, uint16_t *idx, uint8_t *aux_index, uint8_t frame_info,</Line>
  <Line number="1213">				const struct bmi160_dev *dev);</Line>
  <Line number="1214"></Line>
  <Line number="1215">/*!</Line>
  <Line number="1216"> *  @brief This API is used to parse the aux data from the</Line>
  <Line number="1217"> *  FIFO data and store it in the instance of the structure bmi160_aux_data.</Line>
  <Line number="1218"> *</Line>
  <Line number="1219"> * @param[in,out] aux_data	    : structure instance of sensor data</Line>
  <Line number="1220"> * @param[in,out] data_start_index  : Index value of number of bytes parsed</Line>
  <Line number="1221"> * @param[in] dev		    : structure instance of bmi160_dev.</Line>
  <Line number="1222"> *</Line>
  <Line number="1223"> * @return Result of API execution status</Line>
  <Line number="1224"> * @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1225"> */</Line>
  <Line number="1226">static void unpack_aux_data(struct bmi160_aux_data *aux_data, uint16_t data_start_index,</Line>
  <Line number="1227">				const struct bmi160_dev *dev);</Line>
  <Line number="1228"></Line>
  <Line number="1229">/*!</Line>
  <Line number="1230"> *  @brief This API is used to parse the aux data from the</Line>
  <Line number="1231"> *  FIFO data in header mode.</Line>
  <Line number="1232"> *</Line>
  <Line number="1233"> *  @param[in,out] aux_data     : Structure instance of sensor data</Line>
  <Line number="1234"> *  @param[in,out] aux_length   : Number of aux frames</Line>
  <Line number="1235"> *  @param[in] dev              : Structure instance of bmi160_dev.</Line>
  <Line number="1236"> *</Line>
  <Line number="1237"> *  @return Result of API execution status</Line>
  <Line number="1238"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1239"> */</Line>
  <Line number="1240">static void extract_aux_header_mode(struct bmi160_aux_data *aux_data, uint8_t *aux_length,</Line>
  <Line number="1241">					const struct bmi160_dev *dev);</Line>
  <Line number="1242"></Line>
  <Line number="1243">/*!</Line>
  <Line number="1244"> *  @brief This API checks the presence of non-valid frames in the read fifo data.</Line>
  <Line number="1245"> *</Line>
  <Line number="1246"> *  @param[in,out] data_index	 : The index of the current data to</Line>
  <Line number="1247"> *                                be parsed from fifo data</Line>
  <Line number="1248"> *  @param[in] dev               : Structure instance of bmi160_dev.</Line>
  <Line number="1249"> *</Line>
  <Line number="1250"> *  @return Result of API execution status</Line>
  <Line number="1251"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1252"> */</Line>
  <Line number="1253">static void check_frame_validity(uint16_t *data_index, const struct bmi160_dev *dev);</Line>
  <Line number="1254"></Line>
  <Line number="1255">/*!</Line>
  <Line number="1256"> *  @brief This API is used to move the data index ahead of the</Line>
  <Line number="1257"> *  current_frame_length parameter when unnecessary FIFO data appears while</Line>
  <Line number="1258"> *  extracting the user specified data.</Line>
  <Line number="1259"> *</Line>
  <Line number="1260"> *  @param[in,out] data_index       : Index of the FIFO data which</Line>
  <Line number="1261"> *                                  is to be moved ahead of the</Line>
  <Line number="1262"> *                                  current_frame_length</Line>
  <Line number="1263"> *  @param[in] current_frame_length : Number of bytes in a particular frame</Line>
  <Line number="1264"> *  @param[in] dev                  : Structure instance of bmi160_dev.</Line>
  <Line number="1265"> *</Line>
  <Line number="1266"> *  @return Result of API execution status</Line>
  <Line number="1267"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1268"> */</Line>
  <Line number="1269">static void move_next_frame(uint16_t *data_index, uint8_t current_frame_length, const struct bmi160_dev *dev);</Line>
  <Line number="1270"></Line>
  <Line number="1271">/*!</Line>
  <Line number="1272"> *  @brief This API is used to parse and store the sensor time from the</Line>
  <Line number="1273"> *  FIFO data in the structure instance dev.</Line>
  <Line number="1274"> *</Line>
  <Line number="1275"> *  @param[in,out] data_index : Index of the FIFO data which</Line>
  <Line number="1276"> *                              has the sensor time.</Line>
  <Line number="1277"> *  @param[in] dev            : Structure instance of bmi160_dev.</Line>
  <Line number="1278"> *</Line>
  <Line number="1279"> *  @return Result of API execution status</Line>
  <Line number="1280"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1281"> */</Line>
  <Line number="1282">static void unpack_sensortime_frame(uint16_t *data_index, const struct bmi160_dev *dev);</Line>
  <Line number="1283"></Line>
  <Line number="1284">/*!</Line>
  <Line number="1285"> *  @brief This API is used to parse and store the skipped_frame_count from</Line>
  <Line number="1286"> *  the FIFO data in the structure instance dev.</Line>
  <Line number="1287"> *</Line>
  <Line number="1288"> *  @param[in,out] data_index   : Index of the FIFO data which</Line>
  <Line number="1289"> *                                    has the skipped frame count.</Line>
  <Line number="1290"> *  @param[in] dev              : Structure instance of bmi160_dev.</Line>
  <Line number="1291"> *</Line>
  <Line number="1292"> *  @return Result of API execution status</Line>
  <Line number="1293"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1294"> */</Line>
  <Line number="1295">static void unpack_skipped_frame(uint16_t *data_index, const struct bmi160_dev *dev);</Line>
  <Line number="1296"></Line>
  <Line number="1297">/*!</Line>
  <Line number="1298"> *  @brief This API is used to get the FOC status from the sensor</Line>
  <Line number="1299"> *</Line>
  <Line number="1300"> *  @param[in,out] foc_status   : Result of FOC status.</Line>
  <Line number="1301"> *  @param[in] dev              : Structure instance of bmi160_dev.</Line>
  <Line number="1302"> *</Line>
  <Line number="1303"> *  @return Result of API execution status</Line>
  <Line number="1304"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1305"> */</Line>
  <Line number="1306">static int8_t get_foc_status(uint8_t *foc_status, struct bmi160_dev const *dev);</Line>
  <Line number="1307"></Line>
  <Line number="1308">/*!</Line>
  <Line number="1309"> *  @brief This API is used to configure the offset enable bits in the sensor</Line>
  <Line number="1310"> *</Line>
  <Line number="1311"> *  @param[in,out] foc_conf   : Structure instance of bmi160_foc_conf which</Line>
  <Line number="1312"> *                                   has the FOC and offset configurations</Line>
  <Line number="1313"> *  @param[in] dev            : Structure instance of bmi160_dev.</Line>
  <Line number="1314"> *</Line>
  <Line number="1315"> *  @return Result of API execution status</Line>
  <Line number="1316"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1317"> */</Line>
  <Line number="1318">static int8_t configure_offset_enable(const struct bmi160_foc_conf *foc_conf, struct bmi160_dev const *dev);</Line>
  <Line number="1319"></Line>
  <Line number="1320">/*!</Line>
  <Line number="1321"> *  @brief This API is used to trigger the FOC in the sensor</Line>
  <Line number="1322"> *</Line>
  <Line number="1323"> *  @param[in,out] offset     : Structure instance of bmi160_offsets which</Line>
  <Line number="1324"> *                              reads and stores the offset values after FOC</Line>
  <Line number="1325"> *  @param[in] dev            : Structure instance of bmi160_dev.</Line>
  <Line number="1326"> *</Line>
  <Line number="1327"> *  @return Result of API execution status</Line>
  <Line number="1328"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1329"> */</Line>
  <Line number="1330">static int8_t trigger_foc(struct bmi160_offsets *offset, struct bmi160_dev const *dev);</Line>
  <Line number="1331"></Line>
  <Line number="1332">/*!</Line>
  <Line number="1333"> *  @brief This API is used to map/unmap the Dataready(Accel &amp; Gyro), FIFO full</Line>
  <Line number="1334"> *  and FIFO watermark interrupt</Line>
  <Line number="1335"> *</Line>
  <Line number="1336"> *  @param[in] int_config     : Structure instance of bmi160_int_settg which</Line>
  <Line number="1337"> *                              stores the interrupt type and interrupt channel</Line>
  <Line number="1338"> *				configurations to map/unmap the interrupt pins</Line>
  <Line number="1339"> *  @param[in] dev            : Structure instance of bmi160_dev.</Line>
  <Line number="1340"> *</Line>
  <Line number="1341"> *  @return Result of API execution status</Line>
  <Line number="1342"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1343"> */</Line>
  <Line number="1344">static int8_t map_hardware_interrupt(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev);</Line>
  <Line number="1345"></Line>
  <Line number="1346">/*!</Line>
  <Line number="1347"> *  @brief This API is used to map/unmap the Any/Sig motion, Step det/Low-g,</Line>
  <Line number="1348"> *  Double tap, Single tap, Orientation, Flat, High-G, Nomotion interrupt pins.</Line>
  <Line number="1349"> *</Line>
  <Line number="1350"> *  @param[in] int_config     : Structure instance of bmi160_int_settg which</Line>
  <Line number="1351"> *                              stores the interrupt type and interrupt channel</Line>
  <Line number="1352"> *				configurations to map/unmap the interrupt pins</Line>
  <Line number="1353"> *  @param[in] dev            : Structure instance of bmi160_dev.</Line>
  <Line number="1354"> *</Line>
  <Line number="1355"> *  @return Result of API execution status</Line>
  <Line number="1356"> *  @retval zero -&gt; Success  / -ve value -&gt; Error</Line>
  <Line number="1357"> */</Line>
  <Line number="1358">static int8_t map_feature_interrupt(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev);</Line>
  <Line number="1359">/*********************** User function definitions ****************************/</Line>
  <Line number="1360">/*!</Line>
  <Line number="1361"> * @brief This API reads the data from the given register address</Line>
  <Line number="1362"> * of sensor.</Line>
  <Line number="1363"> */</Line>
  <Line number="1364"> //Poosible DRS: len must be in range of data</Line>
  <Line number="1365">int8_t bmi160_get_regs(uint8_t reg_addr, uint8_t *data, uint16_t len, const struct bmi160_dev *dev)</Line>
  <Line number="1366">{ INIT_STUBS(dev);</Line>
  <Line number="1367">	int8_t rslt = <CheckRefs ids="9">BMI160_OK</CheckRefs>;</Line>
  <Line number="1368">	/* Null-pointer check */</Line>
  <Line number="1369">	if ((dev == NULL) || (dev-&gt;read == NULL)) {</Line>
  <Line number="1370">		rslt = <CheckRefs ids="10,11">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1371">	} else {</Line>
  <Line number="1372">		/* Configuring reg_addr for SPI Interface */</Line>
  <Line number="1373">		if (<CheckRefs ids="12">dev</CheckRefs>-&gt;interface == BMI160_SPI_INTF)</Line>
  <Line number="1374">			reg_addr = <CheckRefs ids="13">(</CheckRefs><CheckRefs ids="14">reg_addr</CheckRefs> | BMI160_SPI_RD_MASK);</Line>
  <Line number="1375"></Line>
  <Line number="1376">		rslt = dev-&gt;read(dev-&gt;id, reg_addr, data, len);</Line>
  <Line number="1377">		/* Kindly refer section 3.2.4 of data-sheet*/</Line>
  <Line number="1378">		dev-&gt;delay_ms(<CheckRefs ids="15">1</CheckRefs>);</Line>
  <Line number="1379">		if (<CheckRefs ids="16">rslt</CheckRefs> != BMI160_OK)</Line>
  <Line number="1380">			rslt = <CheckRefs ids="18,17">BMI160_E_COM_FAIL</CheckRefs>;</Line>
  <Line number="1381">	}</Line>
  <Line number="1382"></Line>
  <Line number="1383">	return rslt;</Line>
  <Line number="1384">}</Line>
  <Line number="1385"></Line>
  <Line number="1386">/*!</Line>
  <Line number="1387"> * @brief This API writes the given data to the register address</Line>
  <Line number="1388"> * of sensor.</Line>
  <Line number="1389"> */</Line>
  <Line number="1390"> //Poosible DRS: len must be in range of data</Line>
  <Line number="1391">int8_t bmi160_set_regs(uint8_t reg_addr, uint8_t *data, uint16_t len, const struct bmi160_dev *dev)</Line>
  <Line number="1392">{ INIT_STUBS(dev);</Line>
  <Line number="1393">	int8_t rslt = <CheckRefs ids="19">BMI160_OK</CheckRefs>;</Line>
  <Line number="1394">	uint8_t count = <CheckRefs ids="20">0</CheckRefs>;</Line>
  <Line number="1395">	/* Null-pointer check */</Line>
  <Line number="1396">	//if ((dev == NULL) || (dev-&gt;write == NULL)) {</Line>
  <Line number="1397">	//	rslt = BMI160_E_NULL_PTR;</Line>
  <Line number="1398">	//} else {</Line>
  <Line number="1399">		/* Configuring reg_addr for SPI Interface */</Line>
  <Line number="1400">		//if (dev-&gt;interface == BMI160_SPI_INTF)</Line>
  <Line number="1401">		//	reg_addr = (reg_addr &amp; BMI160_SPI_WR_MASK);</Line>
  <Line number="1402"></Line>
  <Line number="1403">		//if ((dev-&gt;prev_accel_cfg.power == BMI160_ACCEL_NORMAL_MODE) ||</Line>
  <Line number="1404">		//	(dev-&gt;prev_gyro_cfg.power == BMI160_GYRO_NORMAL_MODE)) {</Line>
  <Line number="1405"></Line>
  <Line number="1406">			//rslt = dev-&gt;write(dev-&gt;id, reg_addr, data, len);</Line>
  <Line number="1407">			/* Kindly refer section 3.2.4 of data-sheet*/</Line>
  <Line number="1408">			//dev-&gt;delay_ms(1);</Line>
  <Line number="1409">		//} //else {</Line>
  <Line number="1410">			/*Burst write is not allowed in</Line>
  <Line number="1411">			suspend &amp; low power mode */</Line>
  <Line number="1412">			for (; <CheckRefs ids="21">count</CheckRefs> &lt; <CheckRefs ids="22">len</CheckRefs>; count<CheckRefs ids="23">++</CheckRefs>) {//check 44</Line>
  <Line number="1413">				rslt = dev-&gt;write(dev-&gt;id, reg_addr, &amp;data[count], <CheckRefs ids="24">1</CheckRefs>);</Line>
  <Line number="1414">				reg_addr<CheckRefs ids="25">++</CheckRefs>; //check 51</Line>
  <Line number="1415">				/* Kindly refer section 3.2.4 of data-sheet*/</Line>
  <Line number="1416">				//dev-&gt;delay_ms(1);</Line>
  <Line number="1417">			}</Line>
  <Line number="1418">		//}</Line>
  <Line number="1419"></Line>
  <Line number="1420">		//if (rslt != BMI160_OK)</Line>
  <Line number="1421">		//	rslt = BMI160_E_COM_FAIL;</Line>
  <Line number="1422">	//}</Line>
  <Line number="1423"></Line>
  <Line number="1424">	return rslt;</Line>
  <Line number="1425">}</Line>
  <Line number="1426"></Line>
  <Line number="1427">/*!</Line>
  <Line number="1428"> *  @brief This API is the entry point for sensor.It performs</Line>
  <Line number="1429"> *  the selection of I2C/SPI read mechanism according to the</Line>
  <Line number="1430"> *  selected interface and reads the chip-id of bmi160 sensor.</Line>
  <Line number="1431"> */</Line>
  <Line number="1432">int8_t bmi160_init(struct bmi160_dev *dev)</Line>
  <Line number="1433">{ INIT_STUBS(dev);</Line>
  <Line number="1434">	int8_t rslt;</Line>
  <Line number="1435">	uint8_t data;</Line>
  <Line number="1436">	uint8_t try = <CheckRefs ids="26">3</CheckRefs>;</Line>
  <Line number="1437"></Line>
  <Line number="1438">	/* Assign chip id as zero */</Line>
  <Line number="1439">	dev-&gt;chip_id = <CheckRefs ids="27">0</CheckRefs>;</Line>
  <Line number="1440"></Line>
  <Line number="1441">	/* Null-pointer check */</Line>
  <Line number="1442">	rslt = null_ptr_check(dev);</Line>
  <Line number="1443"></Line>
  <Line number="1444">	/* Dummy read of 0x7F register to enable SPI Interface</Line>
  <Line number="1445">	 if SPI is used */</Line>
  <Line number="1446">	if ((<CheckRefs ids="28">rslt</CheckRefs> == BMI160_OK) &amp;&amp; (<CheckRefs ids="29">dev</CheckRefs>-&gt;interface == BMI160_SPI_INTF))</Line>
  <Line number="1447">		rslt = bmi160_get_regs(<CheckRefs ids="30">BMI160_SPI_COMM_TEST_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="31">1</CheckRefs>, dev);</Line>
  <Line number="1448"></Line>
  <Line number="1449">	if (<CheckRefs ids="32">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="1450"></Line>
  <Line number="1451">		while (<CheckRefs ids="33">(</CheckRefs>try<CheckRefs ids="34">--</CheckRefs>) &amp;&amp; (<CheckRefs ids="35">dev</CheckRefs>-&gt;chip_id != BMI160_CHIP_ID)) {</Line>
  <Line number="1452">			/* Read chip_id */</Line>
  <Line number="1453">			rslt = bmi160_get_regs(<CheckRefs ids="36">BMI160_CHIP_ID_ADDR</CheckRefs>, &amp;dev-&gt;chip_id, <CheckRefs ids="37">1</CheckRefs>, dev);</Line>
  <Line number="1454">		}</Line>
  <Line number="1455"></Line>
  <Line number="1456">		if ((<CheckRefs ids="38">rslt</CheckRefs> == BMI160_OK) &amp;&amp; (<CheckRefs ids="39">dev</CheckRefs>-&gt;chip_id == BMI160_CHIP_ID)) {</Line>
  <Line number="1457">			dev-&gt;any_sig_sel = <CheckRefs ids="40">BMI160_BOTH_ANY_SIG_MOTION_DISABLED</CheckRefs>;</Line>
  <Line number="1458">			/* Soft reset */</Line>
  <Line number="1459">			rslt = bmi160_soft_reset(dev);</Line>
  <Line number="1460">		} else {</Line>
  <Line number="1461">			rslt = <CheckRefs ids="41,42">BMI160_E_DEV_NOT_FOUND</CheckRefs>;</Line>
  <Line number="1462">		}</Line>
  <Line number="1463">	}</Line>
  <Line number="1464"></Line>
  <Line number="1465">	return rslt;</Line>
  <Line number="1466">}</Line>
  <Line number="1467"></Line>
  <Line number="1468">/*!</Line>
  <Line number="1469"> * @brief This API resets and restarts the device.</Line>
  <Line number="1470"> * All register values are overwritten with default parameters.</Line>
  <Line number="1471"> */</Line>
  <Line number="1472">int8_t bmi160_soft_reset(struct bmi160_dev *dev)</Line>
  <Line number="1473">{ INIT_STUBS(dev);</Line>
  <Line number="1474">	int8_t rslt;</Line>
  <Line number="1475">	uint8_t data = <CheckRefs ids="43">BMI160_SOFT_RESET_CMD</CheckRefs>;</Line>
  <Line number="1476"></Line>
  <Line number="1477">	/* Null-pointer check */</Line>
  <Line number="1478">	if ((dev == NULL) || (dev-&gt;delay_ms == NULL)) {</Line>
  <Line number="1479">		rslt = <CheckRefs ids="44,45">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1480">	} else {</Line>
  <Line number="1481">		 /* Reset the device */</Line>
  <Line number="1482">		rslt = bmi160_set_regs(<CheckRefs ids="46">BMI160_COMMAND_REG_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="47">1</CheckRefs>, dev);</Line>
  <Line number="1483">		dev-&gt;delay_ms(BMI160_SOFT_RESET_DELAY_MS);</Line>
  <Line number="1484">		if ((<CheckRefs ids="48">rslt</CheckRefs> == BMI160_OK) &amp;&amp; (<CheckRefs ids="49">dev</CheckRefs>-&gt;interface == BMI160_SPI_INTF)) {</Line>
  <Line number="1485">			/* Dummy read of 0x7F register to enable SPI Interface</Line>
  <Line number="1486">			if SPI is used */</Line>
  <Line number="1487">			rslt = bmi160_get_regs(<CheckRefs ids="50">BMI160_SPI_COMM_TEST_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="51">1</CheckRefs>, dev);</Line>
  <Line number="1488">		}</Line>
  <Line number="1489">		if (<CheckRefs ids="52">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="1490">			/* Update the default parameters */</Line>
  <Line number="1491">			default_param_settg(dev);</Line>
  <Line number="1492">		}</Line>
  <Line number="1493">	}</Line>
  <Line number="1494"></Line>
  <Line number="1495">	return rslt;</Line>
  <Line number="1496">}</Line>
  <Line number="1497"></Line>
  <Line number="1498">/*!</Line>
  <Line number="1499"> * @brief This API configures the power mode, range and bandwidth</Line>
  <Line number="1500"> * of sensor.</Line>
  <Line number="1501"> */</Line>
  <Line number="1502">int8_t bmi160_set_sens_conf(struct bmi160_dev *dev)</Line>
  <Line number="1503">{ INIT_STUBS(dev);</Line>
  <Line number="1504">	int8_t rslt = <CheckRefs ids="53">BMI160_OK</CheckRefs>;</Line>
  <Line number="1505"></Line>
  <Line number="1506">	/* Null-pointer check */</Line>
  <Line number="1507">	if ((dev == NULL) || (dev-&gt;delay_ms == NULL)) {</Line>
  <Line number="1508">		rslt = <CheckRefs ids="54,55">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1509">	} else {</Line>
  <Line number="1510">		rslt = set_accel_conf(dev);</Line>
  <Line number="1511">		if (<CheckRefs ids="56">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="1512">			rslt = set_gyro_conf(dev);</Line>
  <Line number="1513">			if (<CheckRefs ids="57">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="1514">				/* write power mode for accel and gyro */</Line>
  <Line number="1515">				rslt = bmi160_set_power_mode(dev);</Line>
  <Line number="1516">				if (<CheckRefs ids="58">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="1517">					rslt = check_invalid_settg(dev);</Line>
  <Line number="1518">			}</Line>
  <Line number="1519">		}</Line>
  <Line number="1520">	}</Line>
  <Line number="1521"></Line>
  <Line number="1522">	return rslt;</Line>
  <Line number="1523">}</Line>
  <Line number="1524"></Line>
  <Line number="1525">/*!</Line>
  <Line number="1526"> * @brief This API sets the power mode of the sensor.</Line>
  <Line number="1527"> */</Line>
  <Line number="1528">int8_t bmi160_set_power_mode(struct bmi160_dev *dev)</Line>
  <Line number="1529">{ INIT_STUBS(dev);</Line>
  <Line number="1530">	int8_t rslt = <CheckRefs ids="59">0</CheckRefs>;</Line>
  <Line number="1531"></Line>
  <Line number="1532">	/* Null-pointer check */</Line>
  <Line number="1533">	if ((dev == NULL) || (dev-&gt;delay_ms == NULL)) {</Line>
  <Line number="1534">		rslt = <CheckRefs ids="60,61">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1535">	} else {</Line>
  <Line number="1536">		rslt = set_accel_pwr(dev);</Line>
  <Line number="1537">		if (<CheckRefs ids="62">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="1538">			rslt = set_gyro_pwr(dev);</Line>
  <Line number="1539">	}</Line>
  <Line number="1540"></Line>
  <Line number="1541">	return rslt;</Line>
  <Line number="1542"></Line>
  <Line number="1543">}</Line>
  <Line number="1544"></Line>
  <Line number="1545">/*!</Line>
  <Line number="1546"> * @brief This API reads sensor data, stores it in</Line>
  <Line number="1547"> * the bmi160_sensor_data structure pointer passed by the user.</Line>
  <Line number="1548"> */</Line>
  <Line number="1549">int8_t bmi160_get_sensor_data(uint8_t select_sensor, struct bmi160_sensor_data *accel, struct bmi160_sensor_data *gyro,</Line>
  <Line number="1550">				const struct bmi160_dev *dev)</Line>
  <Line number="1551">{ INIT_STUBS(dev);</Line>
  <Line number="1552">	int8_t rslt = <CheckRefs ids="63">BMI160_OK</CheckRefs>;</Line>
  <Line number="1553">	uint8_t time_sel;</Line>
  <Line number="1554">	uint8_t sen_sel;</Line>
  <Line number="1555">	uint8_t len = <CheckRefs ids="64">0</CheckRefs>;</Line>
  <Line number="1556"></Line>
  <Line number="1557">	/*Extract the sensor  and time select information*/</Line>
  <Line number="1558">	sen_sel = <CheckRefs ids="66">select_sensor</CheckRefs> <CheckRefs ids="65">&amp;</CheckRefs> BMI160_SEN_SEL_MASK;</Line>
  <Line number="1559">	time_sel = <CheckRefs ids="67">(</CheckRefs>(<CheckRefs ids="69">sen_sel</CheckRefs> &amp; BMI160_TIME_SEL) <CheckRefs ids="68">&gt;&gt;</CheckRefs> 2);</Line>
  <Line number="1560">	sen_sel = <CheckRefs ids="71">sen_sel</CheckRefs> <CheckRefs ids="70">&amp;</CheckRefs> (BMI160_ACCEL_SEL | BMI160_GYRO_SEL);</Line>
  <Line number="1561">	if (<CheckRefs ids="72">time_sel</CheckRefs> == 1)</Line>
  <Line number="1562">		len = <CheckRefs ids="73">3</CheckRefs>;</Line>
  <Line number="1563"></Line>
  <Line number="1564">	/* Null-pointer check */</Line>
  <Line number="1565">	if (dev != NULL) {</Line>
  <Line number="1566">		switch (<CheckRefs ids="74">sen_sel</CheckRefs>) {</Line>
  <Line number="1567">		case BMI160_ACCEL_ONLY:</Line>
  <Line number="1568">			/* Null-pointer check */</Line>
  <Line number="1569">			if (accel == NULL)</Line>
  <Line number="1570">				rslt = <CheckRefs ids="76,75">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1571">			else</Line>
  <Line number="1572">				rslt = get_accel_data(len, accel, dev);</Line>
  <Line number="1573">			break;</Line>
  <Line number="1574">		case BMI160_GYRO_ONLY:</Line>
  <Line number="1575">			/* Null-pointer check */</Line>
  <Line number="1576">			if (gyro == NULL)</Line>
  <Line number="1577">				rslt = <CheckRefs ids="77,78">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1578">			else</Line>
  <Line number="1579">				rslt = get_gyro_data(len, gyro, dev);</Line>
  <Line number="1580">			break;</Line>
  <Line number="1581">		case BMI160_BOTH_ACCEL_AND_GYRO:</Line>
  <Line number="1582">			/* Null-pointer check */</Line>
  <Line number="1583">			if ((gyro == NULL) || (accel == NULL))</Line>
  <Line number="1584">				rslt = <CheckRefs ids="79,80">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1585">			else</Line>
  <Line number="1586">				rslt = get_accel_gyro_data(len, accel, gyro, dev);</Line>
  <Line number="1587">			break;</Line>
  <Line number="1588">		default:</Line>
  <Line number="1589">			rslt = <CheckRefs ids="81,82">BMI160_E_INVALID_INPUT</CheckRefs>;</Line>
  <Line number="1590">			break;</Line>
  <Line number="1591">		}</Line>
  <Line number="1592">	} else {</Line>
  <Line number="1593">		rslt = <CheckRefs ids="83,84">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1594">	}</Line>
  <Line number="1595"></Line>
  <Line number="1596">	return rslt;</Line>
  <Line number="1597"></Line>
  <Line number="1598">}</Line>
  <Line number="1599"></Line>
  <Line number="1600">/*!</Line>
  <Line number="1601"> * @brief This API configures the necessary interrupt based on</Line>
  <Line number="1602"> *  the user settings in the bmi160_int_settg structure instance.</Line>
  <Line number="1603"> */</Line>
  <Line number="1604"> //DRS int_config -&gt; int_type : it can be cheched that it is in range of the switch and default with result bmi160_OK is not given</Line>
  <Line number="1605">int8_t bmi160_set_int_config(struct bmi160_int_settg *int_config, struct bmi160_dev *dev)</Line>
  <Line number="1606">{ INIT_STUBS(dev);</Line>
  <Line number="1607">	int8_t rslt = <CheckRefs ids="85">BMI160_OK</CheckRefs>;</Line>
  <Line number="1608"></Line>
  <Line number="1609">	switch (<CheckRefs ids="86">int_config</CheckRefs>-&gt;int_type) {</Line>
  <Line number="1610">	case <CheckRefs ids="87">BMI160_ACC_ANY_MOTION_INT</CheckRefs>:</Line>
  <Line number="1611">		/*Any-motion  interrupt*/</Line>
  <Line number="1612">		rslt = set_accel_any_motion_int(int_config, dev);</Line>
  <Line number="1613">		break;</Line>
  <Line number="1614">	case <CheckRefs ids="88">BMI160_ACC_SIG_MOTION_INT</CheckRefs>:</Line>
  <Line number="1615">		/* Significant motion interrupt */</Line>
  <Line number="1616">		rslt = set_accel_sig_motion_int(int_config, dev);</Line>
  <Line number="1617">		break;</Line>
  <Line number="1618">	case <CheckRefs ids="89">BMI160_ACC_SLOW_NO_MOTION_INT</CheckRefs>:</Line>
  <Line number="1619">		/* Slow or no motion interrupt */</Line>
  <Line number="1620">		rslt = set_accel_no_motion_int(int_config, dev);</Line>
  <Line number="1621">		break;</Line>
  <Line number="1622">	case <CheckRefs ids="90">BMI160_ACC_DOUBLE_TAP_INT</CheckRefs>:</Line>
  <Line number="1623">	case <CheckRefs ids="91">BMI160_ACC_SINGLE_TAP_INT</CheckRefs>:</Line>
  <Line number="1624">		 /* Double tap and single tap Interrupt */</Line>
  <Line number="1625">		rslt = set_accel_tap_int(int_config, dev);</Line>
  <Line number="1626">		break;</Line>
  <Line number="1627">	case <CheckRefs ids="92">BMI160_STEP_DETECT_INT</CheckRefs>:</Line>
  <Line number="1628">		/* Step detector interrupt */</Line>
  <Line number="1629">		rslt = set_accel_step_detect_int(int_config, dev);</Line>
  <Line number="1630">		break;</Line>
  <Line number="1631">	case <CheckRefs ids="93">BMI160_ACC_ORIENT_INT</CheckRefs>:</Line>
  <Line number="1632">		/* Orientation interrupt */</Line>
  <Line number="1633">		rslt = set_accel_orientation_int(int_config, dev);</Line>
  <Line number="1634">		break;</Line>
  <Line number="1635">	case <CheckRefs ids="94">BMI160_ACC_FLAT_INT</CheckRefs>:</Line>
  <Line number="1636">		/* Flat detection interrupt */</Line>
  <Line number="1637">		rslt = set_accel_flat_detect_int(int_config, dev);</Line>
  <Line number="1638">		break;</Line>
  <Line number="1639">	case <CheckRefs ids="95">BMI160_ACC_LOW_G_INT</CheckRefs>:</Line>
  <Line number="1640">		 /* Low-g interrupt */</Line>
  <Line number="1641">		rslt = set_accel_low_g_int(int_config, dev);</Line>
  <Line number="1642">		break;</Line>
  <Line number="1643">	case <CheckRefs ids="96">BMI160_ACC_HIGH_G_INT</CheckRefs>:</Line>
  <Line number="1644">		/* High-g interrupt */</Line>
  <Line number="1645">		rslt = set_accel_high_g_int(int_config, dev);</Line>
  <Line number="1646">		break;</Line>
  <Line number="1647">	case <CheckRefs ids="97">BMI160_ACC_GYRO_DATA_RDY_INT</CheckRefs>:</Line>
  <Line number="1648">		/* Data ready interrupt */</Line>
  <Line number="1649">		rslt = set_accel_gyro_data_ready_int(int_config, dev);</Line>
  <Line number="1650">		break;</Line>
  <Line number="1651">	case <CheckRefs ids="98">BMI160_ACC_GYRO_FIFO_FULL_INT</CheckRefs>:</Line>
  <Line number="1652">		 /* Fifo full interrupt */</Line>
  <Line number="1653">		rslt = set_fifo_full_int(int_config, dev);</Line>
  <Line number="1654">		break;</Line>
  <Line number="1655">	case <CheckRefs ids="99">BMI160_ACC_GYRO_FIFO_WATERMARK_INT</CheckRefs>:</Line>
  <Line number="1656">		 /* Fifo water-mark interrupt */</Line>
  <Line number="1657">		rslt = set_fifo_watermark_int(int_config, dev);</Line>
  <Line number="1658">		break;</Line>
  <Line number="1659">	case <CheckRefs ids="100">BMI160_FIFO_TAG_INT_PIN</CheckRefs>:</Line>
  <Line number="1660">		/* Fifo tagging feature support */</Line>
  <Line number="1661">		/* Configure Interrupt pins */</Line>
  <Line number="1662">		rslt = set_intr_pin_config(int_config, dev);</Line>
  <Line number="1663">		break;</Line>
  <Line number="1664">	default:</Line>
  <Line number="1665">		break;</Line>
  <Line number="1666">	}</Line>
  <Line number="1667">	return rslt;</Line>
  <Line number="1668">}</Line>
  <Line number="1669"></Line>
  <Line number="1670">/*!</Line>
  <Line number="1671"> * @brief This API enables or disable the step counter feature.</Line>
  <Line number="1672"> * 1 - enable step counter (0 - disable)</Line>
  <Line number="1673"> */</Line>
  <Line number="1674">int8_t bmi160_set_step_counter(uint8_t step_cnt_enable, const struct bmi160_dev *dev)</Line>
  <Line number="1675">{ INIT_STUBS(dev);</Line>
  <Line number="1676">	int8_t rslt;</Line>
  <Line number="1677">	uint8_t data = <CheckRefs ids="101">0</CheckRefs>;</Line>
  <Line number="1678"></Line>
  <Line number="1679">	/* Null-pointer check */</Line>
  <Line number="1680">	rslt = null_ptr_check(dev);</Line>
  <Line number="1681"></Line>
  <Line number="1682">	if (<CheckRefs ids="102">rslt</CheckRefs> != BMI160_OK) {</Line>
  <Line number="1683">		rslt = <CheckRefs ids="103,104">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1684">	} else {</Line>
  <Line number="1685"></Line>
  <Line number="1686">		rslt = bmi160_get_regs(<CheckRefs ids="105">BMI160_INT_STEP_CONFIG_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="106">1</CheckRefs>, dev);</Line>
  <Line number="1687">		if (<CheckRefs ids="107">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="1688">			if (<CheckRefs ids="108">step_cnt_enable</CheckRefs> == BMI160_ENABLE)</Line>
  <Line number="1689">				data |= <CheckRefs ids="109,110">(</CheckRefs>uint8_t)(<CheckRefs ids="114">step_cnt_enable</CheckRefs> <CheckRefs ids="111,112,113">&lt;&lt;</CheckRefs> 3);</Line>
  <Line number="1690">			else</Line>
  <Line number="1691">				data &amp;= ~BMI160_STEP_COUNT_EN_BIT_MASK;</Line>
  <Line number="1692">			rslt = bmi160_set_regs(<CheckRefs ids="115">BMI160_INT_STEP_CONFIG_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="116">1</CheckRefs>, dev);</Line>
  <Line number="1693">		}</Line>
  <Line number="1694">	}</Line>
  <Line number="1695"></Line>
  <Line number="1696">	return rslt;</Line>
  <Line number="1697">}</Line>
  <Line number="1698"></Line>
  <Line number="1699">/*!</Line>
  <Line number="1700"> * @brief This API reads the step counter value.</Line>
  <Line number="1701"> */</Line>
  <Line number="1702">int8_t bmi160_read_step_counter(uint16_t *step_val, const struct bmi160_dev *dev)</Line>
  <Line number="1703">{ INIT_STUBS(dev);</Line>
  <Line number="1704">	int8_t rslt;</Line>
  <Line number="1705">	uint8_t data[2] = {<CheckRefs ids="117">0</CheckRefs>, <CheckRefs ids="118">0</CheckRefs>};</Line>
  <Line number="1706">	uint16_t msb = <CheckRefs ids="119">0</CheckRefs>;</Line>
  <Line number="1707">	uint8_t lsb = <CheckRefs ids="120">0</CheckRefs>;</Line>
  <Line number="1708"></Line>
  <Line number="1709">	/* Null-pointer check */</Line>
  <Line number="1710">	rslt = null_ptr_check(dev);</Line>
  <Line number="1711"></Line>
  <Line number="1712">	if (<CheckRefs ids="121">rslt</CheckRefs> != BMI160_OK) {</Line>
  <Line number="1713">		rslt = <CheckRefs ids="122,123">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1714">	} else {</Line>
  <Line number="1715">		rslt = bmi160_get_regs(<CheckRefs ids="124">BMI160_INT_STEP_CNT_0_ADDR</CheckRefs>, data, <CheckRefs ids="125">2</CheckRefs>, dev);</Line>
  <Line number="1716">		if (<CheckRefs ids="126">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="1717">			lsb = data[0<CheckRefs ids="127">]</CheckRefs>;</Line>
  <Line number="1718">			msb = <CheckRefs ids="132">data</CheckRefs>[1<CheckRefs ids="133">]</CheckRefs> <CheckRefs ids="129,130,128,131">&lt;&lt;</CheckRefs> 8;</Line>
  <Line number="1719">			*step_val = <CheckRefs ids="135">msb</CheckRefs> <CheckRefs ids="134">|</CheckRefs> <CheckRefs ids="136">lsb</CheckRefs>;</Line>
  <Line number="1720">		}</Line>
  <Line number="1721">	}</Line>
  <Line number="1722"></Line>
  <Line number="1723">	return rslt;</Line>
  <Line number="1724">}</Line>
  <Line number="1725"></Line>
  <Line number="1726">/*!</Line>
  <Line number="1727"> * @brief This API reads the mention no of byte of data from the given</Line>
  <Line number="1728"> * register address of auxiliary sensor.</Line>
  <Line number="1729"> */</Line>
  <Line number="1730">int8_t bmi160_aux_read(uint8_t reg_addr, uint8_t *aux_data, uint16_t len, const struct bmi160_dev *dev)</Line>
  <Line number="1731">{ INIT_STUBS(dev);</Line>
  <Line number="1732">	int8_t rslt = <CheckRefs ids="137">BMI160_OK</CheckRefs>;</Line>
  <Line number="1733">	uint16_t map_len = <CheckRefs ids="138">0</CheckRefs>;</Line>
  <Line number="1734"></Line>
  <Line number="1735">	/* Null-pointer check */</Line>
  <Line number="1736">	if ((dev == NULL) || (dev-&gt;read == NULL)) {</Line>
  <Line number="1737">		rslt = <CheckRefs ids="139,140">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1738">	} else {</Line>
  <Line number="1739">		if (<CheckRefs ids="141">dev</CheckRefs>-&gt;aux_cfg.aux_sensor_enable == BMI160_ENABLE) {</Line>
  <Line number="1740">			rslt = map_read_len(&amp;map_len, dev);</Line>
  <Line number="1741">			if (<CheckRefs ids="142">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="1742">				rslt = extract_aux_read(map_len, reg_addr, aux_data, len, dev);</Line>
  <Line number="1743">		} else {</Line>
  <Line number="1744">			rslt = <CheckRefs ids="143,144">BMI160_E_INVALID_INPUT</CheckRefs>;</Line>
  <Line number="1745">		}</Line>
  <Line number="1746">	}</Line>
  <Line number="1747"></Line>
  <Line number="1748">	return rslt;</Line>
  <Line number="1749">}</Line>
  <Line number="1750"></Line>
  <Line number="1751">/*!</Line>
  <Line number="1752"> * @brief This API writes the mention no of byte of data to the given</Line>
  <Line number="1753"> * register address of auxiliary sensor.</Line>
  <Line number="1754"> */</Line>
  <Line number="1755">int8_t bmi160_aux_write(uint8_t reg_addr, uint8_t *aux_data, uint16_t len, const struct bmi160_dev *dev)</Line>
  <Line number="1756">{ INIT_STUBS(dev);</Line>
  <Line number="1757">	int8_t rslt = <CheckRefs ids="145">BMI160_OK</CheckRefs>;</Line>
  <Line number="1758">	uint8_t count = <CheckRefs ids="146">0</CheckRefs>;</Line>
  <Line number="1759"></Line>
  <Line number="1760">	/* Null-pointer check */</Line>
  <Line number="1761">	if ((dev == NULL) || (dev-&gt;write == NULL)) {</Line>
  <Line number="1762">		rslt = <CheckRefs ids="147,148">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1763">	} else {</Line>
  <Line number="1764">		for (; <CheckRefs ids="149">count</CheckRefs> &lt; <CheckRefs ids="150">len</CheckRefs>; count<CheckRefs ids="151">++</CheckRefs>) {</Line>
  <Line number="1765">			/* set data to write */</Line>
  <Line number="1766">			rslt = bmi160_set_regs(<CheckRefs ids="152">BMI160_AUX_IF_4_ADDR</CheckRefs>, aux_data, <CheckRefs ids="153">1</CheckRefs>, dev);</Line>
  <Line number="1767">			dev-&gt;delay_ms(BMI160_AUX_COM_DELAY);</Line>
  <Line number="1768">			if (<CheckRefs ids="154">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="1769">				/* set address to write */</Line>
  <Line number="1770">				rslt = bmi160_set_regs(<CheckRefs ids="155">BMI160_AUX_IF_3_ADDR</CheckRefs>, &amp;reg_addr, <CheckRefs ids="156">1</CheckRefs>, dev);</Line>
  <Line number="1771">				dev-&gt;delay_ms(BMI160_AUX_COM_DELAY);</Line>
  <Line number="1772">				if (<CheckRefs ids="157">rslt</CheckRefs> == BMI160_OK &amp;&amp; (<CheckRefs ids="158">count</CheckRefs> &lt; <CheckRefs ids="160">len</CheckRefs> <CheckRefs ids="159">-</CheckRefs> 1)) {</Line>
  <Line number="1773">					aux_data++;</Line>
  <Line number="1774">					reg_addr<CheckRefs ids="161">++</CheckRefs>;</Line>
  <Line number="1775">				}</Line>
  <Line number="1776">			}</Line>
  <Line number="1777">		}</Line>
  <Line number="1778">	}</Line>
  <Line number="1779"></Line>
  <Line number="1780">	return rslt;</Line>
  <Line number="1781">}</Line>
  <Line number="1782"></Line>
  <Line number="1783">/*!</Line>
  <Line number="1784"> * @brief This API initialize the auxiliary sensor</Line>
  <Line number="1785"> * in order to access it.</Line>
  <Line number="1786"> */</Line>
  <Line number="1787">int8_t bmi160_aux_init(const struct bmi160_dev *dev)</Line>
  <Line number="1788">{ INIT_STUBS(dev);</Line>
  <Line number="1789">	int8_t rslt;</Line>
  <Line number="1790"></Line>
  <Line number="1791">	/* Null-pointer check */</Line>
  <Line number="1792">	rslt = null_ptr_check(dev);</Line>
  <Line number="1793"></Line>
  <Line number="1794">	if (<CheckRefs ids="162">rslt</CheckRefs> != BMI160_OK) {</Line>
  <Line number="1795">		rslt = <CheckRefs ids="164,163">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1796">	} else {</Line>
  <Line number="1797">		if (<CheckRefs ids="165">dev</CheckRefs>-&gt;aux_cfg.aux_sensor_enable == BMI160_ENABLE) {</Line>
  <Line number="1798">			/* Configures the auxiliary sensor interface settings */</Line>
  <Line number="1799">			rslt = config_aux_settg(dev);</Line>
  <Line number="1800">		} else {</Line>
  <Line number="1801">			rslt = <CheckRefs ids="166,167">BMI160_E_INVALID_INPUT</CheckRefs>;</Line>
  <Line number="1802">		}</Line>
  <Line number="1803">	}</Line>
  <Line number="1804"></Line>
  <Line number="1805">	return rslt;</Line>
  <Line number="1806">}</Line>
  <Line number="1807"></Line>
  <Line number="1808">/*!</Line>
  <Line number="1809"> * @brief This API is used to setup the auxiliary sensor of bmi160 in auto mode</Line>
  <Line number="1810"> * Thus enabling the auto update of 8 bytes of data from auxiliary sensor</Line>
  <Line number="1811"> * to BMI160 register address 0x04 to 0x0B</Line>
  <Line number="1812"> */</Line>
  <Line number="1813">int8_t bmi160_set_aux_auto_mode(uint8_t *data_addr, struct bmi160_dev *dev)</Line>
  <Line number="1814">{ INIT_STUBS(dev);</Line>
  <Line number="1815">	int8_t rslt;</Line>
  <Line number="1816">	/* Null-pointer check */</Line>
  <Line number="1817">	rslt = null_ptr_check(dev);</Line>
  <Line number="1818"></Line>
  <Line number="1819">	if (<CheckRefs ids="168">rslt</CheckRefs> != BMI160_OK) {</Line>
  <Line number="1820">		rslt = <CheckRefs ids="169,170">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1821">	} else {</Line>
  <Line number="1822">		if (<CheckRefs ids="171">dev</CheckRefs>-&gt;aux_cfg.aux_sensor_enable == BMI160_ENABLE) {</Line>
  <Line number="1823">			/* Write the aux. address to read in 0x4D of BMI160*/</Line>
  <Line number="1824">			rslt = bmi160_set_regs(<CheckRefs ids="172">BMI160_AUX_IF_2_ADDR</CheckRefs>, data_addr, <CheckRefs ids="173">1</CheckRefs>, dev);</Line>
  <Line number="1825">			dev-&gt;delay_ms(BMI160_AUX_COM_DELAY);</Line>
  <Line number="1826">			if (<CheckRefs ids="174">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="1827">				/* Configure the polling ODR for</Line>
  <Line number="1828">				auxiliary sensor */</Line>
  <Line number="1829">					rslt = config_aux_odr(dev);</Line>
  <Line number="1830"></Line>
  <Line number="1831">				if (<CheckRefs ids="175">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="1832">					/* Disable the aux. manual mode, i.e aux.</Line>
  <Line number="1833">					 * sensor is in auto-mode (data-mode) */</Line>
  <Line number="1834">					dev-&gt;aux_cfg.manual_enable = <CheckRefs ids="176">BMI160_DISABLE</CheckRefs>;</Line>
  <Line number="1835">					rslt = bmi160_config_aux_mode(dev);</Line>
  <Line number="1836"></Line>
  <Line number="1837">					/*  Auxiliary sensor data is obtained</Line>
  <Line number="1838">					 * in auto mode from this point */</Line>
  <Line number="1839">				}</Line>
  <Line number="1840">			}</Line>
  <Line number="1841">		} else {</Line>
  <Line number="1842">			rslt = <CheckRefs ids="177,178">BMI160_E_INVALID_INPUT</CheckRefs>;</Line>
  <Line number="1843">		}</Line>
  <Line number="1844">	}</Line>
  <Line number="1845"></Line>
  <Line number="1846">	return rslt;</Line>
  <Line number="1847">}</Line>
  <Line number="1848"></Line>
  <Line number="1849">/*!</Line>
  <Line number="1850"> * @brief This API configures the 0x4C register and settings like</Line>
  <Line number="1851"> * Auxiliary sensor manual enable/ disable and aux burst read length.</Line>
  <Line number="1852"> */</Line>
  <Line number="1853"> //Possible DRS: dev-&gt;aux_cfg mehrmaler nutzen, BMI160_SET_BITS is defined in bmi160_defs.h</Line>
  <Line number="1854">int8_t bmi160_config_aux_mode(const struct bmi160_dev *dev)</Line>
  <Line number="1855">{ INIT_STUBS(dev);</Line>
  <Line number="1856">	int8_t rslt;</Line>
  <Line number="1857">	uint8_t aux_if[2] = {<CheckRefs ids="179">(</CheckRefs>uint8_t)(<CheckRefs ids="181">dev</CheckRefs>-&gt;aux_cfg.aux_i2c_addr <CheckRefs ids="180">*</CheckRefs> 2), <CheckRefs ids="182">0</CheckRefs>};</Line>
  <Line number="1858"></Line>
  <Line number="1859">	rslt = bmi160_get_regs(<CheckRefs ids="183">BMI160_AUX_IF_1_ADDR</CheckRefs>, &amp;aux_if[1<CheckRefs ids="184">]</CheckRefs>, <CheckRefs ids="185">1</CheckRefs>, dev);</Line>
  <Line number="1860">	if (<CheckRefs ids="186">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="1861">		/* update the Auxiliary interface to manual/auto mode */</Line>
  <Line number="1862">		aux_if[1<CheckRefs ids="187">]</CheckRefs> = <CheckRefs ids="195,189,190,192,193,194,188,191">BMI160_SET_BITS</CheckRefs>(aux_if[1], BMI160_MANUAL_MODE_EN, dev-&gt;aux_cfg.manual_enable);</Line>
  <Line number="1863">		/* update the burst read length defined by user */</Line>
  <Line number="1864">		aux_if[1<CheckRefs ids="196">]</CheckRefs> = <CheckRefs ids="198,199,200,197">BMI160_SET_BITS_POS_0</CheckRefs>(aux_if[1], BMI160_AUX_READ_BURST, dev-&gt;aux_cfg.aux_rd_burst_len);</Line>
  <Line number="1865">		/* Set the secondary interface address and manual mode</Line>
  <Line number="1866">		 * along with burst read length */</Line>
  <Line number="1867">		rslt = bmi160_set_regs(<CheckRefs ids="201">BMI160_AUX_IF_0_ADDR</CheckRefs>, &amp;aux_if[0<CheckRefs ids="202">]</CheckRefs>, <CheckRefs ids="203">2</CheckRefs>, dev);</Line>
  <Line number="1868">		dev-&gt;delay_ms(BMI160_AUX_COM_DELAY);</Line>
  <Line number="1869">	}</Line>
  <Line number="1870"></Line>
  <Line number="1871">	return rslt;</Line>
  <Line number="1872">}</Line>
  <Line number="1873"></Line>
  <Line number="1874">/*!</Line>
  <Line number="1875"> * @brief This API is used to read the raw uncompensated auxiliary sensor</Line>
  <Line number="1876"> * data of 8 bytes from BMI160 register address 0x04 to 0x0B</Line>
  <Line number="1877"> */</Line>
  <Line number="1878">int8_t bmi160_read_aux_data_auto_mode(uint8_t *aux_data, const struct bmi160_dev *dev)</Line>
  <Line number="1879">{ INIT_STUBS(dev);</Line>
  <Line number="1880">	int8_t rslt;</Line>
  <Line number="1881"></Line>
  <Line number="1882">	/* Null-pointer check */</Line>
  <Line number="1883">	rslt = null_ptr_check(dev);</Line>
  <Line number="1884"></Line>
  <Line number="1885">	if (<CheckRefs ids="204">rslt</CheckRefs> != BMI160_OK) {</Line>
  <Line number="1886">		rslt = <CheckRefs ids="205,206">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1887">	} else {</Line>
  <Line number="1888">		if ((<CheckRefs ids="207">dev</CheckRefs>-&gt;aux_cfg.aux_sensor_enable == BMI160_ENABLE) &amp;&amp;</Line>
  <Line number="1889">			(<CheckRefs ids="208">dev</CheckRefs>-&gt;aux_cfg.manual_enable == BMI160_DISABLE)) {</Line>
  <Line number="1890">			/* Read the aux. sensor&apos;s raw data */</Line>
  <Line number="1891">			rslt = bmi160_get_regs(<CheckRefs ids="209">BMI160_AUX_DATA_ADDR</CheckRefs>, aux_data, <CheckRefs ids="210">8</CheckRefs>, dev);</Line>
  <Line number="1892">		} else {</Line>
  <Line number="1893">			rslt = <CheckRefs ids="211,212">BMI160_E_INVALID_INPUT</CheckRefs>;</Line>
  <Line number="1894">		}</Line>
  <Line number="1895">	}</Line>
  <Line number="1896"></Line>
  <Line number="1897">	return rslt;</Line>
  <Line number="1898">}</Line>
  <Line number="1899"></Line>
  <Line number="1900">/*!</Line>
  <Line number="1901"> * @brief This is used to perform self test of accel/gyro of the BMI160 sensor</Line>
  <Line number="1902"> */</Line>
  <Line number="1903">int8_t bmi160_perform_self_test(uint8_t select_sensor, struct bmi160_dev *dev)</Line>
  <Line number="1904">{ INIT_STUBS(dev);</Line>
  <Line number="1905">	int8_t rslt;</Line>
  <Line number="1906">	int8_t self_test_rslt = <CheckRefs ids="213">0</CheckRefs>;</Line>
  <Line number="1907"></Line>
  <Line number="1908">	/* Null-pointer check */</Line>
  <Line number="1909">	rslt = null_ptr_check(dev);</Line>
  <Line number="1910"></Line>
  <Line number="1911">	if (<CheckRefs ids="214">rslt</CheckRefs> != BMI160_OK) {</Line>
  <Line number="1912">		rslt = <CheckRefs ids="215,216">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1913">	} else {</Line>
  <Line number="1914">		/* Proceed if null check is fine */</Line>
  <Line number="1915">		switch (<CheckRefs ids="217">select_sensor</CheckRefs>) {</Line>
  <Line number="1916">		case BMI160_ACCEL_ONLY:</Line>
  <Line number="1917">			rslt = perform_accel_self_test(dev);</Line>
  <Line number="1918">			break;</Line>
  <Line number="1919"></Line>
  <Line number="1920">		case BMI160_GYRO_ONLY:</Line>
  <Line number="1921">			/* Set the power mode as normal mode */</Line>
  <Line number="1922">			dev-&gt;gyro_cfg.power = <CheckRefs ids="218">BMI160_GYRO_NORMAL_MODE</CheckRefs>;</Line>
  <Line number="1923">			rslt = bmi160_set_power_mode(dev);</Line>
  <Line number="1924">			/* Perform gyro self test */</Line>
  <Line number="1925">			if (<CheckRefs ids="219">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="1926">				/* Perform gyro self test */</Line>
  <Line number="1927">				rslt = perform_gyro_self_test(dev);</Line>
  <Line number="1928">			}</Line>
  <Line number="1929">			break;</Line>
  <Line number="1930"></Line>
  <Line number="1931">		default:</Line>
  <Line number="1932">			rslt = <CheckRefs ids="220,221">BMI160_E_INVALID_INPUT</CheckRefs>;</Line>
  <Line number="1933">			break;</Line>
  <Line number="1934">		}</Line>
  <Line number="1935"></Line>
  <Line number="1936">		/* Check to ensure bus error does not occur */</Line>
  <Line number="1937">		if (<CheckRefs ids="222">rslt</CheckRefs> &gt;= BMI160_OK) {</Line>
  <Line number="1938">			/* Store the status of self test result */</Line>
  <Line number="1939">			self_test_rslt = rslt;</Line>
  <Line number="1940">			/* Perform soft reset */</Line>
  <Line number="1941">			rslt = bmi160_soft_reset(dev);</Line>
  <Line number="1942">		}</Line>
  <Line number="1943">		/* Check to ensure bus operations are success */</Line>
  <Line number="1944">		if (<CheckRefs ids="223">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="1945">			/* Restore self_test_rslt as return value */</Line>
  <Line number="1946">			rslt = self_test_rslt;</Line>
  <Line number="1947">		}</Line>
  <Line number="1948"></Line>
  <Line number="1949">	}</Line>
  <Line number="1950"></Line>
  <Line number="1951">	return rslt;</Line>
  <Line number="1952">}</Line>
  <Line number="1953"></Line>
  <Line number="1954"></Line>
  <Line number="1955"></Line>
  <Line number="1956">/*!</Line>
  <Line number="1957"> * @brief This API reads the data from fifo buffer.</Line>
  <Line number="1958"> */</Line>
  <Line number="1959">int8_t bmi160_get_fifo_data(struct bmi160_dev const *dev)</Line>
  <Line number="1960">{ INIT_STUBS(dev);</Line>
  <Line number="1961">	int8_t rslt = <CheckRefs ids="224">0</CheckRefs>;</Line>
  <Line number="1962">	uint16_t bytes_to_read = <CheckRefs ids="225">0</CheckRefs>;</Line>
  <Line number="1963">	uint16_t user_fifo_len = <CheckRefs ids="226">0</CheckRefs>;</Line>
  <Line number="1964">	uint8_t addr = <CheckRefs ids="227">BMI160_FIFO_DATA_ADDR</CheckRefs>;</Line>
  <Line number="1965"></Line>
  <Line number="1966">	/* check the bmi160 structure as NULL*/</Line>
  <Line number="1967">	if ((dev == NULL) || (dev-&gt;fifo-&gt;data == NULL)) {</Line>
  <Line number="1968">		rslt = <CheckRefs ids="228,229">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="1969">	} else {</Line>
  <Line number="1970">		reset_fifo_data_structure(dev);</Line>
  <Line number="1971">		/* get current FIFO fill-level*/</Line>
  <Line number="1972">		rslt = get_fifo_byte_counter(&amp;bytes_to_read, dev);</Line>
  <Line number="1973">		if (<CheckRefs ids="230">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="1974">			user_fifo_len = dev-&gt;fifo-&gt;length;</Line>
  <Line number="1975"></Line>
  <Line number="1976">			if (<CheckRefs ids="231">dev</CheckRefs>-&gt;fifo-&gt;length &gt; <CheckRefs ids="232">bytes_to_read</CheckRefs>) {</Line>
  <Line number="1977">				/* Handling the case where user requests</Line>
  <Line number="1978">				more data than available in FIFO */</Line>
  <Line number="1979">				dev-&gt;fifo-&gt;length = bytes_to_read;</Line>
  <Line number="1980">			}</Line>
  <Line number="1981"></Line>
  <Line number="1982">			if ((<CheckRefs ids="233">dev</CheckRefs>-&gt;fifo-&gt;fifo_time_enable == BMI160_FIFO_TIME_ENABLE)</Line>
  <Line number="1983">				&amp;&amp; (<CheckRefs ids="235">bytes_to_read</CheckRefs> <CheckRefs ids="234">+</CheckRefs> BMI160_FIFO_BYTES_OVERREAD &lt;= <CheckRefs ids="236">user_fifo_len</CheckRefs>)) {</Line>
  <Line number="1984">				/* Handling case of sensor time availability*/</Line>
  <Line number="1985">				dev-&gt;fifo-&gt;length = <CheckRefs ids="239">dev</CheckRefs>-&gt;fifo-&gt;length <CheckRefs ids="238,237">+</CheckRefs> BMI160_FIFO_BYTES_OVERREAD;</Line>
  <Line number="1986">			}</Line>
  <Line number="1987"></Line>
  <Line number="1988">			if (<CheckRefs ids="240">dev</CheckRefs>-&gt;interface == BMI160_SPI_INTF) {</Line>
  <Line number="1989">				/* SPI read mask */</Line>
  <Line number="1990">				addr = <CheckRefs ids="242">addr</CheckRefs> <CheckRefs ids="241">|</CheckRefs> BMI160_SPI_RD_MASK;</Line>
  <Line number="1991">			}</Line>
  <Line number="1992"></Line>
  <Line number="1993">			/* read only the filled bytes in the FIFO Buffer */</Line>
  <Line number="1994">			rslt = dev-&gt;read(dev-&gt;id, addr, dev-&gt;fifo-&gt;data, dev-&gt;fifo-&gt;length);</Line>
  <Line number="1995">		}</Line>
  <Line number="1996">	}</Line>
  <Line number="1997"></Line>
  <Line number="1998">	return rslt;</Line>
  <Line number="1999">}</Line>
  <Line number="2000"></Line>
  <Line number="2001">/*!</Line>
  <Line number="2002"> *  @brief This API writes fifo_flush command to command register.This</Line>
  <Line number="2003"> *  action clears all data in the Fifo without changing fifo configuration</Line>
  <Line number="2004"> *  settings</Line>
  <Line number="2005"> */</Line>
  <Line number="2006">int8_t bmi160_set_fifo_flush(const struct bmi160_dev *dev)</Line>
  <Line number="2007">{ INIT_STUBS(dev);</Line>
  <Line number="2008">	int8_t rslt = <CheckRefs ids="243">0</CheckRefs>;</Line>
  <Line number="2009">	uint8_t data =  <CheckRefs ids="244">BMI160_FIFO_FLUSH_VALUE</CheckRefs>;</Line>
  <Line number="2010">	uint8_t reg_addr = <CheckRefs ids="245">BMI160_COMMAND_REG_ADDR</CheckRefs>;</Line>
  <Line number="2011"></Line>
  <Line number="2012">	/* Check the bmi160_dev structure for NULL address*/</Line>
  <Line number="2013">	if (dev == NULL)</Line>
  <Line number="2014">		rslt = <CheckRefs ids="246,247">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2015">	else</Line>
  <Line number="2016">		rslt = bmi160_set_regs(reg_addr, &amp;data, <CheckRefs ids="248">BMI160_ONE</CheckRefs>, dev);</Line>
  <Line number="2017"></Line>
  <Line number="2018">	return rslt;</Line>
  <Line number="2019">}</Line>
  <Line number="2020"></Line>
  <Line number="2021">/*!</Line>
  <Line number="2022"> * @brief This API sets the FIFO configuration in the sensor.</Line>
  <Line number="2023"> */</Line>
  <Line number="2024">int8_t bmi160_set_fifo_config(uint8_t config, uint8_t enable, struct bmi160_dev const *dev)</Line>
  <Line number="2025">{ INIT_STUBS(dev);</Line>
  <Line number="2026">	int8_t rslt = <CheckRefs ids="249">0</CheckRefs>;</Line>
  <Line number="2027">	uint8_t data =  <CheckRefs ids="250">0</CheckRefs>;</Line>
  <Line number="2028">	uint8_t reg_addr = <CheckRefs ids="251">BMI160_FIFO_CONFIG_1_ADDR</CheckRefs>;</Line>
  <Line number="2029">	uint8_t fifo_config = <CheckRefs ids="253">config</CheckRefs> <CheckRefs ids="252">&amp;</CheckRefs> BMI160_FIFO_CONFIG_1_MASK;</Line>
  <Line number="2030"></Line>
  <Line number="2031">	/* Check the bmi160_dev structure for NULL address*/</Line>
  <Line number="2032">	if (dev == NULL) {</Line>
  <Line number="2033">		rslt = <CheckRefs ids="255,254">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2034">	} else {</Line>
  <Line number="2035">		rslt = bmi160_get_regs(reg_addr, &amp;data, <CheckRefs ids="256">BMI160_ONE</CheckRefs>, dev);</Line>
  <Line number="2036"></Line>
  <Line number="2037">		if (<CheckRefs ids="257">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2038"></Line>
  <Line number="2039">			if (<CheckRefs ids="258">fifo_config</CheckRefs> &gt; 0) {</Line>
  <Line number="2040"></Line>
  <Line number="2041">				if (<CheckRefs ids="259">enable</CheckRefs> == BMI160_ENABLE)</Line>
  <Line number="2042">					data = <CheckRefs ids="261">data</CheckRefs> <CheckRefs ids="260">|</CheckRefs> <CheckRefs ids="262">fifo_config</CheckRefs>;</Line>
  <Line number="2043">				else</Line>
  <Line number="2044">					data = <CheckRefs ids="264">data</CheckRefs> <CheckRefs ids="263">&amp;</CheckRefs> (~<CheckRefs ids="265">fifo_config</CheckRefs>);</Line>
  <Line number="2045">			}</Line>
  <Line number="2046">			/* write fifo frame content configuration*/</Line>
  <Line number="2047">			rslt = bmi160_set_regs(reg_addr, &amp;data, <CheckRefs ids="266">BMI160_ONE</CheckRefs>, dev);</Line>
  <Line number="2048">			if (<CheckRefs ids="267">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2049">				/* read fifo frame content configuration*/</Line>
  <Line number="2050">				rslt = bmi160_get_regs(reg_addr, &amp;data, <CheckRefs ids="268">BMI160_ONE</CheckRefs>, dev);</Line>
  <Line number="2051">				if (<CheckRefs ids="269">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2052">					/* extract fifo header enabled status */</Line>
  <Line number="2053">					dev-&gt;fifo-&gt;fifo_header_enable = <CheckRefs ids="271">data</CheckRefs> <CheckRefs ids="270">&amp;</CheckRefs> BMI160_FIFO_HEAD_ENABLE;</Line>
  <Line number="2054">					/* extract accel/gyr/aux. data enabled status */</Line>
  <Line number="2055">					dev-&gt;fifo-&gt;fifo_data_enable = <CheckRefs ids="273">data</CheckRefs> <CheckRefs ids="272">&amp;</CheckRefs> BMI160_FIFO_M_G_A_ENABLE;</Line>
  <Line number="2056">					/* extract fifo sensor time enabled status */</Line>
  <Line number="2057">					dev-&gt;fifo-&gt;fifo_time_enable = <CheckRefs ids="275">data</CheckRefs> <CheckRefs ids="274">&amp;</CheckRefs> BMI160_FIFO_TIME_ENABLE;</Line>
  <Line number="2058">				}</Line>
  <Line number="2059">			}</Line>
  <Line number="2060">		}</Line>
  <Line number="2061">	}</Line>
  <Line number="2062"></Line>
  <Line number="2063">	return rslt;</Line>
  <Line number="2064">}</Line>
  <Line number="2065"></Line>
  <Line number="2066">/*! @brief This API is used to configure the down sampling ratios of</Line>
  <Line number="2067"> *  the accel and gyro data for FIFO.Also, it configures filtered or</Line>
  <Line number="2068"> *  pre-filtered data for accel and gyro.</Line>
  <Line number="2069"> *</Line>
  <Line number="2070"> */</Line>
  <Line number="2071">int8_t bmi160_set_fifo_down(uint8_t fifo_down, const struct bmi160_dev *dev)</Line>
  <Line number="2072">{ INIT_STUBS(dev);</Line>
  <Line number="2073">	int8_t rslt = <CheckRefs ids="276">0</CheckRefs>;</Line>
  <Line number="2074">	uint8_t data =  <CheckRefs ids="277">0</CheckRefs>;</Line>
  <Line number="2075">	uint8_t reg_addr = <CheckRefs ids="278">BMI160_FIFO_DOWN_ADDR</CheckRefs>;</Line>
  <Line number="2076"></Line>
  <Line number="2077">	/* Check the bmi160_dev structure for NULL address*/</Line>
  <Line number="2078">	if (dev == NULL) {</Line>
  <Line number="2079">		rslt = <CheckRefs ids="279,280">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2080">	} else {</Line>
  <Line number="2081">		rslt = bmi160_get_regs(reg_addr, &amp;data, <CheckRefs ids="281">BMI160_ONE</CheckRefs>, dev);</Line>
  <Line number="2082"></Line>
  <Line number="2083">		 if (<CheckRefs ids="282">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2084">			data = <CheckRefs ids="284">data</CheckRefs> <CheckRefs ids="283">|</CheckRefs> <CheckRefs ids="285">fifo_down</CheckRefs>;</Line>
  <Line number="2085">			rslt = bmi160_set_regs(reg_addr, &amp;data, <CheckRefs ids="286">BMI160_ONE</CheckRefs>, dev);</Line>
  <Line number="2086">		 }</Line>
  <Line number="2087">	}</Line>
  <Line number="2088"></Line>
  <Line number="2089">	return rslt;</Line>
  <Line number="2090"></Line>
  <Line number="2091">}</Line>
  <Line number="2092"></Line>
  <Line number="2093">/*!</Line>
  <Line number="2094"> *  @brief This API sets the FIFO watermark level in the sensor.</Line>
  <Line number="2095"> *</Line>
  <Line number="2096"> */</Line>
  <Line number="2097">int8_t bmi160_set_fifo_wm(uint8_t fifo_wm, const struct bmi160_dev *dev)</Line>
  <Line number="2098">{ INIT_STUBS(dev);</Line>
  <Line number="2099">	int8_t rslt = <CheckRefs ids="287">0</CheckRefs>;</Line>
  <Line number="2100">	uint8_t data =  fifo_wm;</Line>
  <Line number="2101">	uint8_t reg_addr = <CheckRefs ids="288">BMI160_FIFO_CONFIG_0_ADDR</CheckRefs>;</Line>
  <Line number="2102"></Line>
  <Line number="2103">	/* Check the bmi160_dev structure for NULL address*/</Line>
  <Line number="2104">	if (dev == NULL)</Line>
  <Line number="2105">		rslt = <CheckRefs ids="289,290">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2106">	else</Line>
  <Line number="2107">		rslt = bmi160_set_regs(reg_addr, &amp;data, <CheckRefs ids="291">BMI160_ONE</CheckRefs>, dev);</Line>
  <Line number="2108"></Line>
  <Line number="2109">	return rslt;</Line>
  <Line number="2110"></Line>
  <Line number="2111">}</Line>
  <Line number="2112"></Line>
  <Line number="2113">/*!</Line>
  <Line number="2114"> *  @brief This API parses and extracts the accelerometer frames from</Line>
  <Line number="2115"> *  FIFO data read by the &quot;bmi160_get_fifo_data&quot; API and stores it in</Line>
  <Line number="2116"> *  the &quot;accel_data&quot; structure instance.</Line>
  <Line number="2117"> */</Line>
  <Line number="2118">int8_t bmi160_extract_accel(struct bmi160_sensor_data *accel_data, uint8_t *accel_length, struct bmi160_dev const *dev)</Line>
  <Line number="2119">{ INIT_STUBS(dev);</Line>
  <Line number="2120">	int8_t rslt = <CheckRefs ids="292">0</CheckRefs>;</Line>
  <Line number="2121">	uint16_t data_index = <CheckRefs ids="293">0</CheckRefs>;</Line>
  <Line number="2122">	uint16_t data_read_length = <CheckRefs ids="294">0</CheckRefs>;</Line>
  <Line number="2123">	uint8_t accel_index = <CheckRefs ids="295">0</CheckRefs>;</Line>
  <Line number="2124">	uint8_t fifo_data_enable = <CheckRefs ids="296">0</CheckRefs>;</Line>
  <Line number="2125"></Line>
  <Line number="2126">	if (dev == NULL || dev-&gt;fifo == NULL || dev-&gt;fifo-&gt;data == NULL) {</Line>
  <Line number="2127">		rslt = <CheckRefs ids="297,298">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2128">	} else {</Line>
  <Line number="2129">		/* Parsing the FIFO data in header-less mode */</Line>
  <Line number="2130">		if (<CheckRefs ids="299">dev</CheckRefs>-&gt;fifo-&gt;fifo_header_enable == 0) {</Line>
  <Line number="2131">			/* Number of bytes to be parsed from FIFO */</Line>
  <Line number="2132">			get_accel_len_to_parse(&amp;data_index, &amp;data_read_length, accel_length, dev);</Line>
  <Line number="2133">			for (; <CheckRefs ids="300">data_index</CheckRefs> &lt; <CheckRefs ids="301">data_read_length</CheckRefs>; ) {</Line>
  <Line number="2134">				/*Check for the availability of next two bytes of FIFO data */</Line>
  <Line number="2135">				check_frame_validity(&amp;data_index, dev);</Line>
  <Line number="2136">				fifo_data_enable = dev-&gt;fifo-&gt;fifo_data_enable;</Line>
  <Line number="2137">				unpack_accel_frame(accel_data, &amp;data_index, &amp;accel_index, fifo_data_enable, dev);</Line>
  <Line number="2138">			}</Line>
  <Line number="2139">			/* update number of accel data read*/</Line>
  <Line number="2140">			*accel_length = accel_index;</Line>
  <Line number="2141">			/*update the accel byte index*/</Line>
  <Line number="2142">			dev-&gt;fifo-&gt;accel_byte_start_idx = data_index;</Line>
  <Line number="2143">		} else {</Line>
  <Line number="2144">			/* Parsing the FIFO data in header mode */</Line>
  <Line number="2145">			extract_accel_header_mode(accel_data, accel_length, dev);</Line>
  <Line number="2146">		}</Line>
  <Line number="2147">	}</Line>
  <Line number="2148"></Line>
  <Line number="2149">	return rslt;</Line>
  <Line number="2150">}</Line>
  <Line number="2151"></Line>
  <Line number="2152">/*!</Line>
  <Line number="2153"> *  @brief This API parses and extracts the gyro frames from</Line>
  <Line number="2154"> *  FIFO data read by the &quot;bmi160_get_fifo_data&quot; API and stores it in</Line>
  <Line number="2155"> *  the &quot;gyro_data&quot; structure instance.</Line>
  <Line number="2156"> */</Line>
  <Line number="2157">int8_t bmi160_extract_gyro(struct bmi160_sensor_data *gyro_data, uint8_t *gyro_length, struct bmi160_dev const *dev)</Line>
  <Line number="2158">{ INIT_STUBS(dev);</Line>
  <Line number="2159">	int8_t rslt = <CheckRefs ids="302">0</CheckRefs>;</Line>
  <Line number="2160">	uint16_t data_index = <CheckRefs ids="303">0</CheckRefs>;</Line>
  <Line number="2161">	uint16_t data_read_length = <CheckRefs ids="304">0</CheckRefs>;</Line>
  <Line number="2162">	uint8_t gyro_index = <CheckRefs ids="305">0</CheckRefs>;</Line>
  <Line number="2163">	uint8_t fifo_data_enable = <CheckRefs ids="306">0</CheckRefs>;</Line>
  <Line number="2164"></Line>
  <Line number="2165">	if (dev == NULL || dev-&gt;fifo-&gt;data == NULL) {</Line>
  <Line number="2166">		rslt = <CheckRefs ids="307,308">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2167">	} else {</Line>
  <Line number="2168">		/* Parsing the FIFO data in header-less mode */</Line>
  <Line number="2169">		if (<CheckRefs ids="309">dev</CheckRefs>-&gt;fifo-&gt;fifo_header_enable == 0) {</Line>
  <Line number="2170">			/* Number of bytes to be parsed from FIFO */</Line>
  <Line number="2171">			get_gyro_len_to_parse(&amp;data_index, &amp;data_read_length, gyro_length, dev);</Line>
  <Line number="2172">			for (; <CheckRefs ids="310">data_index</CheckRefs> &lt; <CheckRefs ids="311">data_read_length</CheckRefs> ;) {</Line>
  <Line number="2173">				/*Check for the availability of next two bytes of FIFO data */</Line>
  <Line number="2174">				check_frame_validity(&amp;data_index, dev);</Line>
  <Line number="2175">				fifo_data_enable = dev-&gt;fifo-&gt;fifo_data_enable;</Line>
  <Line number="2176">				unpack_gyro_frame(gyro_data, &amp;data_index, &amp;gyro_index, fifo_data_enable, dev);</Line>
  <Line number="2177">			}</Line>
  <Line number="2178">			/* update number of gyro data read */</Line>
  <Line number="2179">			*gyro_length = gyro_index;</Line>
  <Line number="2180">			/* update the gyro byte index */</Line>
  <Line number="2181">			dev-&gt;fifo-&gt;gyro_byte_start_idx = data_index;</Line>
  <Line number="2182">		} else {</Line>
  <Line number="2183">			/* Parsing the FIFO data in header mode */</Line>
  <Line number="2184">			extract_gyro_header_mode(gyro_data, gyro_length, dev);</Line>
  <Line number="2185">		}</Line>
  <Line number="2186">	}</Line>
  <Line number="2187"></Line>
  <Line number="2188">	return rslt;</Line>
  <Line number="2189">}</Line>
  <Line number="2190"></Line>
  <Line number="2191">/*!</Line>
  <Line number="2192"> *  @brief This API parses and extracts the aux frames from</Line>
  <Line number="2193"> *  FIFO data read by the &quot;bmi160_get_fifo_data&quot; API and stores it in</Line>
  <Line number="2194"> *  the &quot;aux_data&quot; structure instance.</Line>
  <Line number="2195"> */</Line>
  <Line number="2196">int8_t bmi160_extract_aux(struct bmi160_aux_data *aux_data, uint8_t *aux_len, struct bmi160_dev const *dev)</Line>
  <Line number="2197">{ INIT_STUBS(dev);</Line>
  <Line number="2198">	int8_t rslt = <CheckRefs ids="312">0</CheckRefs>;</Line>
  <Line number="2199">	uint16_t data_index = <CheckRefs ids="313">0</CheckRefs>;</Line>
  <Line number="2200">	uint16_t data_read_length = <CheckRefs ids="314">0</CheckRefs>;</Line>
  <Line number="2201">	uint8_t aux_index = <CheckRefs ids="315">0</CheckRefs>;</Line>
  <Line number="2202">	uint8_t fifo_data_enable = <CheckRefs ids="316">0</CheckRefs>;</Line>
  <Line number="2203"></Line>
  <Line number="2204">	if ((dev == NULL) || (dev-&gt;fifo-&gt;data == NULL) || (aux_data == NULL)) {</Line>
  <Line number="2205">		rslt = <CheckRefs ids="317,318">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2206">	} else {</Line>
  <Line number="2207">		/* Parsing the FIFO data in header-less mode */</Line>
  <Line number="2208">		if (<CheckRefs ids="319">dev</CheckRefs>-&gt;fifo-&gt;fifo_header_enable == 0) {</Line>
  <Line number="2209">			/* Number of bytes to be parsed from FIFO */</Line>
  <Line number="2210">			get_aux_len_to_parse(&amp;data_index, &amp;data_read_length, aux_len, dev);</Line>
  <Line number="2211">			for (; <CheckRefs ids="320">data_index</CheckRefs> &lt; <CheckRefs ids="321">data_read_length</CheckRefs> ;) {</Line>
  <Line number="2212">				/* Check for the availability of next two</Line>
  <Line number="2213">				 * bytes of FIFO data */</Line>
  <Line number="2214">				check_frame_validity(&amp;data_index, dev);</Line>
  <Line number="2215">				fifo_data_enable = dev-&gt;fifo-&gt;fifo_data_enable;</Line>
  <Line number="2216">				unpack_aux_frame(aux_data, &amp;data_index, &amp;aux_index, fifo_data_enable, dev);</Line>
  <Line number="2217">			}</Line>
  <Line number="2218">			/* update number of aux data read */</Line>
  <Line number="2219">			*aux_len = aux_index;</Line>
  <Line number="2220">			/* update the aux byte index */</Line>
  <Line number="2221">			dev-&gt;fifo-&gt;aux_byte_start_idx = data_index;</Line>
  <Line number="2222">		} else {</Line>
  <Line number="2223">			/* Parsing the FIFO data in header mode */</Line>
  <Line number="2224">			extract_aux_header_mode(aux_data, aux_len, dev);</Line>
  <Line number="2225">		}</Line>
  <Line number="2226">	}</Line>
  <Line number="2227"></Line>
  <Line number="2228">	return rslt;</Line>
  <Line number="2229">}</Line>
  <Line number="2230"></Line>
  <Line number="2231">/*!</Line>
  <Line number="2232"> *  @brief This API starts the FOC of accel and gyro</Line>
  <Line number="2233"> *</Line>
  <Line number="2234"> *  @note FOC should not be used in low-power mode of sensor</Line>
  <Line number="2235"> *</Line>
  <Line number="2236"> *  @note Accel FOC targets values of +1g , 0g , -1g</Line>
  <Line number="2237"> *  Gyro FOC always targets value of 0 dps</Line>
  <Line number="2238"> */</Line>
  <Line number="2239">int8_t bmi160_start_foc(const struct bmi160_foc_conf *foc_conf, struct bmi160_offsets *offset,</Line>
  <Line number="2240">				struct bmi160_dev const *dev)</Line>
  <Line number="2241">{ INIT_STUBS(dev);</Line>
  <Line number="2242">	int8_t rslt;</Line>
  <Line number="2243">	uint8_t data;</Line>
  <Line number="2244"></Line>
  <Line number="2245">	/* Null-pointer check */</Line>
  <Line number="2246">	rslt = null_ptr_check(dev);</Line>
  <Line number="2247"></Line>
  <Line number="2248">	if (<CheckRefs ids="322">rslt</CheckRefs> != BMI160_OK) {</Line>
  <Line number="2249">		rslt = <CheckRefs ids="323,324">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2250">	} else {</Line>
  <Line number="2251">		/* Set the offset enable bits */</Line>
  <Line number="2252">		rslt = configure_offset_enable(foc_conf, dev);</Line>
  <Line number="2253">		if (<CheckRefs ids="325">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2254">			/* Read the FOC config from the sensor */</Line>
  <Line number="2255">			rslt = bmi160_get_regs(<CheckRefs ids="326">BMI160_FOC_CONF_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="327">1</CheckRefs>, dev);</Line>
  <Line number="2256"></Line>
  <Line number="2257">			/* Set the FOC config for gyro */</Line>
  <Line number="2258">			data = <CheckRefs ids="334,332,331,329,330,328,333">BMI160_SET_BITS</CheckRefs>(data, BMI160_GYRO_FOC_EN, foc_conf-&gt;foc_gyr_en);</Line>
  <Line number="2259"></Line>
  <Line number="2260">			/* Set the FOC config for accel xyz axes */</Line>
  <Line number="2261">			data = <CheckRefs ids="336,341,338,339,335,340,337">BMI160_SET_BITS</CheckRefs>(data, BMI160_ACCEL_FOC_X_CONF, foc_conf-&gt;foc_acc_x);</Line>
  <Line number="2262">			data = <CheckRefs ids="343,345,346,348,342,344,347">BMI160_SET_BITS</CheckRefs>(data, BMI160_ACCEL_FOC_Y_CONF, foc_conf-&gt;foc_acc_y);</Line>
  <Line number="2263">			data = <CheckRefs ids="350,351,349">BMI160_SET_BITS_POS_0</CheckRefs>(data, BMI160_ACCEL_FOC_Z_CONF, foc_conf-&gt;foc_acc_z);</Line>
  <Line number="2264"></Line>
  <Line number="2265">			if (<CheckRefs ids="352">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2266">				/* Set the FOC config in the sensor */</Line>
  <Line number="2267">				rslt = bmi160_set_regs(<CheckRefs ids="353">BMI160_FOC_CONF_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="354">1</CheckRefs>, dev);</Line>
  <Line number="2268">				if (<CheckRefs ids="355">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2269">					/* Procedure to trigger</Line>
  <Line number="2270">					 * FOC and check status */</Line>
  <Line number="2271">					rslt = trigger_foc(offset, dev);</Line>
  <Line number="2272">				}</Line>
  <Line number="2273">			}</Line>
  <Line number="2274">		}</Line>
  <Line number="2275">	}</Line>
  <Line number="2276"></Line>
  <Line number="2277">	return rslt;</Line>
  <Line number="2278">}</Line>
  <Line number="2279"></Line>
  <Line number="2280">/*!</Line>
  <Line number="2281"> *  @brief This API reads and stores the offset values of accel and gyro</Line>
  <Line number="2282"> */</Line>
  <Line number="2283">int8_t bmi160_get_offsets(struct bmi160_offsets *offset, const struct bmi160_dev *dev)</Line>
  <Line number="2284">{ INIT_STUBS(dev);</Line>
  <Line number="2285">	int8_t rslt;</Line>
  <Line number="2286">	uint8_t data[7];</Line>
  <Line number="2287">	uint8_t lsb, msb;</Line>
  <Line number="2288">	int16_t offset_msb, offset_lsb;</Line>
  <Line number="2289">	int16_t offset_data;</Line>
  <Line number="2290"></Line>
  <Line number="2291"></Line>
  <Line number="2292">	/* Null-pointer check */</Line>
  <Line number="2293">	rslt = null_ptr_check(dev);</Line>
  <Line number="2294"></Line>
  <Line number="2295">	if (<CheckRefs ids="356">rslt</CheckRefs> != BMI160_OK) {</Line>
  <Line number="2296">		rslt = <CheckRefs ids="357,358">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2297">	} else {</Line>
  <Line number="2298">		/* Read the FOC config from the sensor */</Line>
  <Line number="2299">		rslt = bmi160_get_regs(<CheckRefs ids="359">BMI160_OFFSET_ADDR</CheckRefs>, data, <CheckRefs ids="360">7</CheckRefs>, dev);</Line>
  <Line number="2300"></Line>
  <Line number="2301">		/* Accel offsets */</Line>
  <Line number="2302">		offset-&gt;off_acc_x = <CheckRefs ids="361">(</CheckRefs>int8_t)data[0<CheckRefs ids="362">]</CheckRefs>;</Line>
  <Line number="2303">		offset-&gt;off_acc_y = <CheckRefs ids="363">(</CheckRefs>int8_t)data[1<CheckRefs ids="364">]</CheckRefs>;</Line>
  <Line number="2304">		offset-&gt;off_acc_z = <CheckRefs ids="365">(</CheckRefs>int8_t)data[2<CheckRefs ids="366">]</CheckRefs>;</Line>
  <Line number="2305"></Line>
  <Line number="2306">		/* Gyro x-axis offset */</Line>
  <Line number="2307">		lsb = data[3<CheckRefs ids="367">]</CheckRefs>;</Line>
  <Line number="2308">		msb = <CheckRefs ids="369,370,368">BMI160_GET_BITS_POS_0</CheckRefs>(data[6], BMI160_GYRO_OFFSET_X);</Line>
  <Line number="2309">		offset_msb = <CheckRefs ids="371">(</CheckRefs>int16_t)(<CheckRefs ids="375">msb</CheckRefs> <CheckRefs ids="373,372,374">&lt;&lt;</CheckRefs> 14);</Line>
  <Line number="2310">		offset_lsb = <CheckRefs ids="380">lsb</CheckRefs> <CheckRefs ids="377,378,379,376">&lt;&lt;</CheckRefs> 6;</Line>
  <Line number="2311">		offset_data = <CheckRefs ids="382">offset_msb</CheckRefs> <CheckRefs ids="381">|</CheckRefs> <CheckRefs ids="383">offset_lsb</CheckRefs>;</Line>
  <Line number="2312">		/* Divide by 64 to get the Right shift by 6 value */</Line>
  <Line number="2313">		offset-&gt;off_gyro_x = <CheckRefs ids="384">(</CheckRefs>int16_t)(<CheckRefs ids="387">offset_data</CheckRefs> <CheckRefs ids="386,385">/</CheckRefs> 64);</Line>
  <Line number="2314"></Line>
  <Line number="2315">		/* Gyro y-axis offset */</Line>
  <Line number="2316">		lsb = data[4<CheckRefs ids="388">]</CheckRefs>;</Line>
  <Line number="2317">		msb = <CheckRefs ids="390,391,392,389">BMI160_GET_BITS</CheckRefs>(data[6], BMI160_GYRO_OFFSET_Y);</Line>
  <Line number="2318">		offset_msb = <CheckRefs ids="393">(</CheckRefs>int16_t)(<CheckRefs ids="397">msb</CheckRefs> <CheckRefs ids="394,395,396">&lt;&lt;</CheckRefs> 14);</Line>
  <Line number="2319">		offset_lsb = <CheckRefs ids="402">lsb</CheckRefs> <CheckRefs ids="399,400,398,401">&lt;&lt;</CheckRefs> 6;</Line>
  <Line number="2320">		offset_data = <CheckRefs ids="404">offset_msb</CheckRefs> <CheckRefs ids="403">|</CheckRefs> <CheckRefs ids="405">offset_lsb</CheckRefs>;</Line>
  <Line number="2321">		/* Divide by 64 to get the Right shift by 6 value */</Line>
  <Line number="2322">		offset-&gt;off_gyro_y = <CheckRefs ids="406">(</CheckRefs>int16_t)(<CheckRefs ids="409">offset_data</CheckRefs> <CheckRefs ids="407,408">/</CheckRefs> 64);</Line>
  <Line number="2323"></Line>
  <Line number="2324">		/* Gyro z-axis offset */</Line>
  <Line number="2325">		lsb = data[5<CheckRefs ids="410">]</CheckRefs>;</Line>
  <Line number="2326">		msb = <CheckRefs ids="413,414,412,411">BMI160_GET_BITS</CheckRefs>(data[6], BMI160_GYRO_OFFSET_Z);</Line>
  <Line number="2327">		offset_msb = <CheckRefs ids="415">(</CheckRefs>int16_t)(<CheckRefs ids="419">msb</CheckRefs> <CheckRefs ids="416,417,418">&lt;&lt;</CheckRefs> 14);</Line>
  <Line number="2328">		offset_lsb = <CheckRefs ids="424">lsb</CheckRefs> <CheckRefs ids="421,422,423,420">&lt;&lt;</CheckRefs> 6;</Line>
  <Line number="2329">		offset_data = <CheckRefs ids="426">offset_msb</CheckRefs> <CheckRefs ids="425">|</CheckRefs> <CheckRefs ids="427">offset_lsb</CheckRefs>;</Line>
  <Line number="2330">		/* Divide by 64 to get the Right shift by 6 value */</Line>
  <Line number="2331">		offset-&gt;off_gyro_z = <CheckRefs ids="428">(</CheckRefs>int16_t)(<CheckRefs ids="431">offset_data</CheckRefs> <CheckRefs ids="429,430">/</CheckRefs> 64);</Line>
  <Line number="2332">	}</Line>
  <Line number="2333"></Line>
  <Line number="2334">	return rslt;</Line>
  <Line number="2335">}</Line>
  <Line number="2336"></Line>
  <Line number="2337">/*!</Line>
  <Line number="2338"> *  @brief This API writes the offset values of accel and gyro to</Line>
  <Line number="2339"> *  the sensor but these values will be reset on POR or soft reset.</Line>
  <Line number="2340"> */</Line>
  <Line number="2341">int8_t bmi160_set_offsets(const struct bmi160_foc_conf *foc_conf, const struct bmi160_offsets *offset,</Line>
  <Line number="2342">				struct bmi160_dev const *dev)</Line>
  <Line number="2343">{ INIT_STUBS(dev);</Line>
  <Line number="2344">	int8_t rslt;</Line>
  <Line number="2345">	uint8_t data[7];</Line>
  <Line number="2346">	uint8_t x_msb, y_msb, z_msb;</Line>
  <Line number="2347"></Line>
  <Line number="2348"></Line>
  <Line number="2349">	/* Null-pointer check */</Line>
  <Line number="2350">	rslt = null_ptr_check(dev);</Line>
  <Line number="2351"></Line>
  <Line number="2352">	if (<CheckRefs ids="432">rslt</CheckRefs> != BMI160_OK) {</Line>
  <Line number="2353">		rslt = <CheckRefs ids="434,433">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2354">	} else {</Line>
  <Line number="2355">		/* Update the accel offset */</Line>
  <Line number="2356">		data[0<CheckRefs ids="435">]</CheckRefs> = <CheckRefs ids="436">(</CheckRefs>uint8_t)offset-&gt;off_acc_x;</Line>
  <Line number="2357">		data[1<CheckRefs ids="437">]</CheckRefs> = <CheckRefs ids="438">(</CheckRefs>uint8_t)offset-&gt;off_acc_y;</Line>
  <Line number="2358">		data[2<CheckRefs ids="439">]</CheckRefs> = <CheckRefs ids="440">(</CheckRefs>uint8_t)offset-&gt;off_acc_z;</Line>
  <Line number="2359"></Line>
  <Line number="2360">		/* Update the LSB of gyro offset */</Line>
  <Line number="2361">		data[3<CheckRefs ids="441">]</CheckRefs> = <CheckRefs ids="443,442">BMI160_GET_LSB</CheckRefs>(offset-&gt;off_gyro_x);</Line>
  <Line number="2362">		data[4<CheckRefs ids="444">]</CheckRefs> = <CheckRefs ids="446,445">BMI160_GET_LSB</CheckRefs>(offset-&gt;off_gyro_y);</Line>
  <Line number="2363">		data[5<CheckRefs ids="447">]</CheckRefs> = <CheckRefs ids="449,448">BMI160_GET_LSB</CheckRefs>(offset-&gt;off_gyro_z);</Line>
  <Line number="2364"></Line>
  <Line number="2365">		/* Update the MSB of gyro offset */</Line>
  <Line number="2366">		x_msb = <CheckRefs ids="451,452,450">BMI160_GET_BITS</CheckRefs>(offset-&gt;off_gyro_x, BMI160_GYRO_OFFSET);</Line>
  <Line number="2367">		y_msb = <CheckRefs ids="454,455,453">BMI160_GET_BITS</CheckRefs>(offset-&gt;off_gyro_y, BMI160_GYRO_OFFSET);</Line>
  <Line number="2368">		z_msb = <CheckRefs ids="457,458,456">BMI160_GET_BITS</CheckRefs>(offset-&gt;off_gyro_z, BMI160_GYRO_OFFSET);</Line>
  <Line number="2369">		data[6<CheckRefs ids="459">]</CheckRefs> = <CheckRefs ids="460">(</CheckRefs>uint8_t)(<CheckRefs ids="464">z_msb</CheckRefs> <CheckRefs ids="461,462,463">&lt;&lt;</CheckRefs> 4 | <CheckRefs ids="468">y_msb</CheckRefs> <CheckRefs ids="465,466,467">&lt;&lt;</CheckRefs> 2 | <CheckRefs ids="469">x_msb</CheckRefs>);</Line>
  <Line number="2370"></Line>
  <Line number="2371">		/* Set the offset enable/disable for gyro and accel */</Line>
  <Line number="2372">		data[6<CheckRefs ids="470">]</CheckRefs> = <CheckRefs ids="478,476,475,473,472,477,471,474">BMI160_SET_BITS</CheckRefs>(data[6], BMI160_GYRO_OFFSET_EN, foc_conf-&gt;gyro_off_en);</Line>
  <Line number="2373">		data[6<CheckRefs ids="479">]</CheckRefs> = <CheckRefs ids="484,487,485,482,481,483,486,480">BMI160_SET_BITS</CheckRefs>(data[6], BMI160_ACCEL_OFFSET_EN, foc_conf-&gt;acc_off_en);</Line>
  <Line number="2374"></Line>
  <Line number="2375">		/* Set the offset config and values in the sensor */</Line>
  <Line number="2376">		rslt = bmi160_set_regs(<CheckRefs ids="488">BMI160_OFFSET_ADDR</CheckRefs>, data, <CheckRefs ids="489">7</CheckRefs>, dev);</Line>
  <Line number="2377">	}</Line>
  <Line number="2378"></Line>
  <Line number="2379">	return rslt;</Line>
  <Line number="2380">}</Line>
  <Line number="2381"></Line>
  <Line number="2382">/*!</Line>
  <Line number="2383"> *  @brief This API writes the image registers values to NVM which is</Line>
  <Line number="2384"> *  stored even after POR or soft reset</Line>
  <Line number="2385"> */</Line>
  <Line number="2386">int8_t bmi160_update_nvm(struct bmi160_dev const *dev)</Line>
  <Line number="2387">{ INIT_STUBS(dev);</Line>
  <Line number="2388">	int8_t rslt;</Line>
  <Line number="2389">	uint8_t data;</Line>
  <Line number="2390">	uint8_t cmd = <CheckRefs ids="490">BMI160_NVM_BACKUP_EN</CheckRefs>;</Line>
  <Line number="2391"></Line>
  <Line number="2392">	/* Read the nvm_prog_en configuration */</Line>
  <Line number="2393">	rslt = bmi160_get_regs(<CheckRefs ids="491">BMI160_CONF_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="492">1</CheckRefs>, dev);</Line>
  <Line number="2394">	if (<CheckRefs ids="493">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2395">		data = <CheckRefs ids="495,496,497,498,499,494">BMI160_SET_BITS</CheckRefs>(data, BMI160_NVM_UPDATE, 1);</Line>
  <Line number="2396">		/* Set the nvm_prog_en bit in the sensor */</Line>
  <Line number="2397">		rslt = bmi160_set_regs(<CheckRefs ids="500">BMI160_CONF_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="501">1</CheckRefs>, dev);</Line>
  <Line number="2398">		if (<CheckRefs ids="502">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2399">			/* Update NVM */</Line>
  <Line number="2400">			rslt = bmi160_set_regs(<CheckRefs ids="503">BMI160_COMMAND_REG_ADDR</CheckRefs>, &amp;cmd, <CheckRefs ids="504">1</CheckRefs>, dev);</Line>
  <Line number="2401">			if (<CheckRefs ids="505">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2402">				/* Check for NVM ready status */</Line>
  <Line number="2403">				rslt = bmi160_get_regs(<CheckRefs ids="506">BMI160_STATUS_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="507">1</CheckRefs>, dev);</Line>
  <Line number="2404">				if (<CheckRefs ids="508">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2405">					data = <CheckRefs ids="510,511,509">BMI160_GET_BITS</CheckRefs>(data, BMI160_NVM_STATUS);</Line>
  <Line number="2406">					if (<CheckRefs ids="512">data</CheckRefs> != BMI160_ENABLE) {</Line>
  <Line number="2407">						/* Delay to update NVM */</Line>
  <Line number="2408">						dev-&gt;delay_ms(<CheckRefs ids="513">25</CheckRefs>);</Line>
  <Line number="2409">					}</Line>
  <Line number="2410">				}</Line>
  <Line number="2411">			}</Line>
  <Line number="2412">		}</Line>
  <Line number="2413">	}</Line>
  <Line number="2414"></Line>
  <Line number="2415">	return rslt;</Line>
  <Line number="2416">}</Line>
  <Line number="2417"></Line>
  <Line number="2418">/*!</Line>
  <Line number="2419"> *  @brief This API gets the interrupt status from the sensor.</Line>
  <Line number="2420"> */</Line>
  <Line number="2421">int8_t bmi160_get_int_status(enum bmi160_int_status_sel int_status_sel,</Line>
  <Line number="2422">				union bmi160_int_status *int_status, struct bmi160_dev const *dev)</Line>
  <Line number="2423">{ INIT_STUBS(dev);</Line>
  <Line number="2424">	int8_t rslt = <CheckRefs ids="514">0</CheckRefs>;</Line>
  <Line number="2425"></Line>
  <Line number="2426">	/* To get the status of all interrupts */</Line>
  <Line number="2427">	if (<CheckRefs ids="515">int_status_sel</CheckRefs> == <CheckRefs ids="516">BMI160_INT_STATUS_ALL</CheckRefs>) {</Line>
  <Line number="2428">		rslt = bmi160_get_regs(<CheckRefs ids="517">BMI160_INT_STATUS_ADDR</CheckRefs>, &amp;int_status-&gt;data[0<CheckRefs ids="518">]</CheckRefs>, <CheckRefs ids="519">4</CheckRefs>, dev);</Line>
  <Line number="2429">	} else {</Line>
  <Line number="2430">		if (<CheckRefs ids="520">int_status_sel</CheckRefs> &amp; <CheckRefs ids="521">BMI160_INT_STATUS_0</CheckRefs>)</Line>
  <Line number="2431">			rslt = bmi160_get_regs(<CheckRefs ids="522">BMI160_INT_STATUS_ADDR</CheckRefs>, &amp;int_status-&gt;data[0<CheckRefs ids="523">]</CheckRefs>, <CheckRefs ids="524">1</CheckRefs>, dev);</Line>
  <Line number="2432">		if (<CheckRefs ids="525">int_status_sel</CheckRefs> &amp; <CheckRefs ids="526">BMI160_INT_STATUS_1</CheckRefs>)</Line>
  <Line number="2433">			rslt = bmi160_get_regs(BMI160_INT_STATUS_ADDR <CheckRefs ids="527,528">+</CheckRefs> <CheckRefs ids="529">1</CheckRefs>, &amp;int_status-&gt;data[1<CheckRefs ids="530">]</CheckRefs>, <CheckRefs ids="531">1</CheckRefs>, dev);</Line>
  <Line number="2434">		if (<CheckRefs ids="532">int_status_sel</CheckRefs> &amp; <CheckRefs ids="533">BMI160_INT_STATUS_2</CheckRefs>)</Line>
  <Line number="2435">			rslt = bmi160_get_regs(BMI160_INT_STATUS_ADDR <CheckRefs ids="534,535">+</CheckRefs> <CheckRefs ids="536">2</CheckRefs>, &amp;int_status-&gt;data[2<CheckRefs ids="537">]</CheckRefs>, <CheckRefs ids="538">1</CheckRefs>, dev);</Line>
  <Line number="2436">		if (<CheckRefs ids="539">int_status_sel</CheckRefs> &amp; <CheckRefs ids="540">BMI160_INT_STATUS_3</CheckRefs>)</Line>
  <Line number="2437">			rslt = bmi160_get_regs(BMI160_INT_STATUS_ADDR <CheckRefs ids="541,542">+</CheckRefs> <CheckRefs ids="543">3</CheckRefs>, &amp;int_status-&gt;data[3<CheckRefs ids="544">]</CheckRefs>, <CheckRefs ids="545">1</CheckRefs>, dev);</Line>
  <Line number="2438">	}</Line>
  <Line number="2439"></Line>
  <Line number="2440">	return rslt;</Line>
  <Line number="2441">}</Line>
  <Line number="2442"></Line>
  <Line number="2443">/*********************** Local function definitions ***************************/</Line>
  <Line number="2444"></Line>
  <Line number="2445">/*!</Line>
  <Line number="2446"> * @brief This API sets the any-motion interrupt of the sensor.</Line>
  <Line number="2447"> * This interrupt occurs when accel values exceeds preset threshold</Line>
  <Line number="2448"> * for a certain period of time.</Line>
  <Line number="2449"> */</Line>
  <Line number="2450"> //DRS: int_config-&gt;int_type</Line>
  <Line number="2451">static int8_t set_accel_any_motion_int(struct bmi160_int_settg *int_config, struct bmi160_dev *dev)</Line>
  <Line number="2452">{ INIT_STUBS(dev);</Line>
  <Line number="2453">	int8_t rslt;</Line>
  <Line number="2454"></Line>
  <Line number="2455">	/* Null-pointer check */</Line>
  <Line number="2456">	rslt = null_ptr_check(dev);</Line>
  <Line number="2457"></Line>
  <Line number="2458">	if ((<CheckRefs ids="546">rslt</CheckRefs> != BMI160_OK) || (int_config == NULL)) {</Line>
  <Line number="2459">		rslt = <CheckRefs ids="547,548">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2460">	} else {</Line>
  <Line number="2461">		/* updating the interrupt structure to local structure */</Line>
  <Line number="2462">		struct bmi160_acc_any_mot_int_cfg *any_motion_int_cfg = &amp;(int_config-&gt;int_type_cfg.acc_any_motion_int);</Line>
  <Line number="2463"></Line>
  <Line number="2464">		rslt = enable_accel_any_motion_int(any_motion_int_cfg, dev);</Line>
  <Line number="2465">		if (<CheckRefs ids="549">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="2466">			rslt = config_any_motion_int_settg(int_config, any_motion_int_cfg, dev);</Line>
  <Line number="2467">	}</Line>
  <Line number="2468"></Line>
  <Line number="2469">	return rslt;</Line>
  <Line number="2470">}</Line>
  <Line number="2471"></Line>
  <Line number="2472">/*!</Line>
  <Line number="2473"> * @brief This API sets tap interrupts.Interrupt is fired when</Line>
  <Line number="2474"> * tap movements happen.</Line>
  <Line number="2475"> */</Line>
  <Line number="2476">static int8_t set_accel_tap_int(struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="2477">{ INIT_STUBS(dev);</Line>
  <Line number="2478">	int8_t rslt;</Line>
  <Line number="2479"></Line>
  <Line number="2480">	/* Null-pointer check */</Line>
  <Line number="2481">	rslt = null_ptr_check(dev);</Line>
  <Line number="2482"></Line>
  <Line number="2483">	if ((<CheckRefs ids="550">rslt</CheckRefs> != BMI160_OK) || (int_config == NULL)) {</Line>
  <Line number="2484">		rslt = <CheckRefs ids="551,552">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2485">	} else {</Line>
  <Line number="2486"></Line>
  <Line number="2487">		/* updating the interrupt structure to local structure */</Line>
  <Line number="2488">		struct bmi160_acc_tap_int_cfg *tap_int_cfg = &amp;(int_config-&gt;int_type_cfg.acc_tap_int);</Line>
  <Line number="2489"></Line>
  <Line number="2490">		rslt = enable_tap_int(int_config, tap_int_cfg, dev);</Line>
  <Line number="2491">		if (<CheckRefs ids="553">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2492">			/* Configure Interrupt pins */</Line>
  <Line number="2493">			rslt = set_intr_pin_config(int_config, dev);</Line>
  <Line number="2494">			if (<CheckRefs ids="554">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="2495">				rslt = config_tap_int_settg(int_config, tap_int_cfg, dev);</Line>
  <Line number="2496">		}</Line>
  <Line number="2497">	}</Line>
  <Line number="2498">	return rslt;</Line>
  <Line number="2499">}</Line>
  <Line number="2500"></Line>
  <Line number="2501">/*!</Line>
  <Line number="2502"> * @brief This API sets the data ready interrupt for both accel and gyro.</Line>
  <Line number="2503"> * This interrupt occurs when new accel and gyro data comes.</Line>
  <Line number="2504"> */</Line>
  <Line number="2505">static int8_t set_accel_gyro_data_ready_int(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="2506">{ INIT_STUBS(dev);</Line>
  <Line number="2507">	int8_t rslt;</Line>
  <Line number="2508"></Line>
  <Line number="2509">	/* Null-pointer check */</Line>
  <Line number="2510">	rslt = null_ptr_check(dev);</Line>
  <Line number="2511"></Line>
  <Line number="2512">	if ((<CheckRefs ids="555">rslt</CheckRefs> != BMI160_OK) || (int_config == NULL)) {</Line>
  <Line number="2513">		rslt = <CheckRefs ids="557,556">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2514">	} else {</Line>
  <Line number="2515">		rslt = enable_data_ready_int(dev);</Line>
  <Line number="2516"></Line>
  <Line number="2517">		if (<CheckRefs ids="558">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2518">			/* Configure Interrupt pins */</Line>
  <Line number="2519">			rslt = set_intr_pin_config(int_config, dev);</Line>
  <Line number="2520"></Line>
  <Line number="2521">			if (<CheckRefs ids="559">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="2522">				rslt = map_hardware_interrupt(int_config, dev);</Line>
  <Line number="2523">		}</Line>
  <Line number="2524">	}</Line>
  <Line number="2525"></Line>
  <Line number="2526">	return rslt;</Line>
  <Line number="2527">}</Line>
  <Line number="2528"></Line>
  <Line number="2529">/*!</Line>
  <Line number="2530"> * @brief This API sets the significant motion interrupt of the sensor.This</Line>
  <Line number="2531"> * interrupt occurs when there is change in user location.</Line>
  <Line number="2532"> */</Line>
  <Line number="2533">static int8_t set_accel_sig_motion_int(struct bmi160_int_settg *int_config, struct bmi160_dev *dev)</Line>
  <Line number="2534">{ INIT_STUBS(dev);</Line>
  <Line number="2535">	int8_t rslt;</Line>
  <Line number="2536"></Line>
  <Line number="2537">	/* Null-pointer check */</Line>
  <Line number="2538">	rslt = null_ptr_check(dev);</Line>
  <Line number="2539"></Line>
  <Line number="2540">	if ((<CheckRefs ids="560">rslt</CheckRefs> != BMI160_OK) || (int_config == NULL)) {</Line>
  <Line number="2541">		rslt = <CheckRefs ids="561,562">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2542">	} else {</Line>
  <Line number="2543">		/* updating the interrupt structure to local structure */</Line>
  <Line number="2544">		struct bmi160_acc_sig_mot_int_cfg *sig_mot_int_cfg = &amp;(int_config-&gt;int_type_cfg.acc_sig_motion_int);</Line>
  <Line number="2545"></Line>
  <Line number="2546">		rslt = enable_sig_motion_int(sig_mot_int_cfg, dev);</Line>
  <Line number="2547">		if (<CheckRefs ids="563">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="2548">			rslt = config_sig_motion_int_settg(int_config, sig_mot_int_cfg, dev);</Line>
  <Line number="2549">	}</Line>
  <Line number="2550"></Line>
  <Line number="2551">	return rslt;</Line>
  <Line number="2552">}</Line>
  <Line number="2553"></Line>
  <Line number="2554">/*!</Line>
  <Line number="2555"> * @brief This API sets the no motion/slow motion interrupt of the sensor.</Line>
  <Line number="2556"> * Slow motion is similar to any motion interrupt.No motion interrupt</Line>
  <Line number="2557"> * occurs when slope bet. two accel values falls below preset threshold</Line>
  <Line number="2558"> * for preset duration.</Line>
  <Line number="2559"> */</Line>
  <Line number="2560">static int8_t set_accel_no_motion_int(struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="2561">{ INIT_STUBS(dev);</Line>
  <Line number="2562">	int8_t rslt;</Line>
  <Line number="2563"></Line>
  <Line number="2564">	/* Null-pointer check */</Line>
  <Line number="2565">	rslt = null_ptr_check(dev);</Line>
  <Line number="2566"></Line>
  <Line number="2567">	if ((<CheckRefs ids="564">rslt</CheckRefs> != BMI160_OK) || (int_config == NULL)) {</Line>
  <Line number="2568">		rslt = <CheckRefs ids="566,565">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2569">	} else {</Line>
  <Line number="2570">		/* updating the interrupt structure to local structure */</Line>
  <Line number="2571">		struct bmi160_acc_no_motion_int_cfg *no_mot_int_cfg = &amp;(int_config-&gt;int_type_cfg.acc_no_motion_int);</Line>
  <Line number="2572"></Line>
  <Line number="2573">		rslt = enable_no_motion_int(no_mot_int_cfg, dev);</Line>
  <Line number="2574">		if (<CheckRefs ids="567">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="2575">			/* Configure the INT PIN settings*/</Line>
  <Line number="2576">			rslt = config_no_motion_int_settg(int_config, no_mot_int_cfg, dev);</Line>
  <Line number="2577">	}</Line>
  <Line number="2578"></Line>
  <Line number="2579">	return rslt;</Line>
  <Line number="2580">}</Line>
  <Line number="2581"></Line>
  <Line number="2582">/*!</Line>
  <Line number="2583"> * @brief This API sets the step detection interrupt.This interrupt</Line>
  <Line number="2584"> * occurs when the single step causes accel values to go above</Line>
  <Line number="2585"> * preset threshold.</Line>
  <Line number="2586"> */</Line>
  <Line number="2587">static int8_t set_accel_step_detect_int(struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="2588">{ INIT_STUBS(dev);</Line>
  <Line number="2589">	int8_t rslt;</Line>
  <Line number="2590"></Line>
  <Line number="2591">	/* Null-pointer check */</Line>
  <Line number="2592">	rslt = null_ptr_check(dev);</Line>
  <Line number="2593"></Line>
  <Line number="2594">	if ((<CheckRefs ids="568">rslt</CheckRefs> != BMI160_OK) || (int_config == NULL)) {</Line>
  <Line number="2595">		rslt = <CheckRefs ids="569,570">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2596">	} else {</Line>
  <Line number="2597">		/* updating the interrupt structure to local structure */</Line>
  <Line number="2598">		struct bmi160_acc_step_detect_int_cfg *step_detect_int_cfg =</Line>
  <Line number="2599">								&amp;(int_config-&gt;int_type_cfg.acc_step_detect_int);</Line>
  <Line number="2600"></Line>
  <Line number="2601">		rslt = enable_step_detect_int(step_detect_int_cfg, dev);</Line>
  <Line number="2602">		if (<CheckRefs ids="571">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2603">			/* Configure Interrupt pins */</Line>
  <Line number="2604">			rslt = set_intr_pin_config(int_config, dev);</Line>
  <Line number="2605">			if (<CheckRefs ids="572">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2606">				rslt = map_feature_interrupt(int_config, dev);</Line>
  <Line number="2607">				if (<CheckRefs ids="573">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="2608">					rslt = config_step_detect(step_detect_int_cfg, dev);</Line>
  <Line number="2609">			}</Line>
  <Line number="2610">		}</Line>
  <Line number="2611">	}</Line>
  <Line number="2612">	return rslt;</Line>
  <Line number="2613">}</Line>
  <Line number="2614"></Line>
  <Line number="2615">/*!</Line>
  <Line number="2616"> * @brief This API sets the orientation interrupt of the sensor.This</Line>
  <Line number="2617"> * interrupt occurs when there is orientation change in the sensor</Line>
  <Line number="2618"> * with respect to gravitational field vector g.</Line>
  <Line number="2619"> */</Line>
  <Line number="2620">static int8_t set_accel_orientation_int(struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="2621">{ INIT_STUBS(dev);</Line>
  <Line number="2622">	int8_t rslt;</Line>
  <Line number="2623"></Line>
  <Line number="2624">	/* Null-pointer check */</Line>
  <Line number="2625">	rslt = null_ptr_check(dev);</Line>
  <Line number="2626"></Line>
  <Line number="2627">	if ((<CheckRefs ids="574">rslt</CheckRefs> != BMI160_OK) || (int_config == NULL)) {</Line>
  <Line number="2628">		rslt = <CheckRefs ids="575,576">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2629">	} else {</Line>
  <Line number="2630">		/* updating the interrupt structure to local structure */</Line>
  <Line number="2631">		struct bmi160_acc_orient_int_cfg *orient_int_cfg = &amp;(int_config-&gt;int_type_cfg.acc_orient_int);</Line>
  <Line number="2632"></Line>
  <Line number="2633">		rslt = enable_orient_int(orient_int_cfg, dev);</Line>
  <Line number="2634">		if (<CheckRefs ids="577">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2635">			/* Configure Interrupt pins */</Line>
  <Line number="2636">			rslt = set_intr_pin_config(int_config, dev);</Line>
  <Line number="2637">			if (<CheckRefs ids="578">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2638">				/* map INT pin to orient interrupt */</Line>
  <Line number="2639">				rslt = map_feature_interrupt(int_config, dev);</Line>
  <Line number="2640">				if (<CheckRefs ids="579">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="2641">					/* configure the</Line>
  <Line number="2642">					 * orientation setting*/</Line>
  <Line number="2643">					rslt = config_orient_int_settg(orient_int_cfg, dev);</Line>
  <Line number="2644">			}</Line>
  <Line number="2645">		}</Line>
  <Line number="2646">	}</Line>
  <Line number="2647"></Line>
  <Line number="2648">	return rslt;</Line>
  <Line number="2649">}</Line>
  <Line number="2650"></Line>
  <Line number="2651">/*!</Line>
  <Line number="2652"> * @brief This API sets the flat interrupt of the sensor.This interrupt</Line>
  <Line number="2653"> * occurs in case of flat orientation</Line>
  <Line number="2654"> */</Line>
  <Line number="2655">static int8_t set_accel_flat_detect_int(struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="2656">{ INIT_STUBS(dev);</Line>
  <Line number="2657">	int8_t rslt;</Line>
  <Line number="2658"></Line>
  <Line number="2659">	/* Null-pointer check */</Line>
  <Line number="2660">	rslt = null_ptr_check(dev);</Line>
  <Line number="2661"></Line>
  <Line number="2662">	if ((<CheckRefs ids="580">rslt</CheckRefs> != BMI160_OK) || (int_config == NULL)) {</Line>
  <Line number="2663">		rslt = <CheckRefs ids="581,582">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2664">	} else {</Line>
  <Line number="2665">		/* updating the interrupt structure to local structure */</Line>
  <Line number="2666">		struct bmi160_acc_flat_detect_int_cfg *flat_detect_int = &amp;(int_config-&gt;int_type_cfg.acc_flat_int);</Line>
  <Line number="2667"></Line>
  <Line number="2668">		/* enable the flat interrupt */</Line>
  <Line number="2669">		rslt = enable_flat_int(flat_detect_int, dev);</Line>
  <Line number="2670">		if (<CheckRefs ids="583">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2671">			/* Configure Interrupt pins */</Line>
  <Line number="2672">			rslt = set_intr_pin_config(int_config, dev);</Line>
  <Line number="2673">			if (<CheckRefs ids="584">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2674">				/* map INT pin to flat interrupt */</Line>
  <Line number="2675">				rslt = map_feature_interrupt(int_config, dev);</Line>
  <Line number="2676">				if (<CheckRefs ids="585">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="2677">					/* configure the flat setting*/</Line>
  <Line number="2678">					rslt = config_flat_int_settg(flat_detect_int, dev);</Line>
  <Line number="2679">			}</Line>
  <Line number="2680">		}</Line>
  <Line number="2681">	}</Line>
  <Line number="2682"></Line>
  <Line number="2683">	return rslt;</Line>
  <Line number="2684">}</Line>
  <Line number="2685"></Line>
  <Line number="2686">/*!</Line>
  <Line number="2687"> * @brief This API sets the low-g interrupt of the sensor.This interrupt</Line>
  <Line number="2688"> * occurs during free-fall.</Line>
  <Line number="2689"> */</Line>
  <Line number="2690">static int8_t set_accel_low_g_int(struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="2691">{ INIT_STUBS(dev);</Line>
  <Line number="2692">	int8_t rslt;</Line>
  <Line number="2693"></Line>
  <Line number="2694">	/* Null-pointer check */</Line>
  <Line number="2695">	rslt = null_ptr_check(dev);</Line>
  <Line number="2696"></Line>
  <Line number="2697">	if ((<CheckRefs ids="586">rslt</CheckRefs> != BMI160_OK) || (int_config == NULL)) {</Line>
  <Line number="2698">		rslt = <CheckRefs ids="587,588">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2699">	} else {</Line>
  <Line number="2700">		/* updating the interrupt structure to local structure */</Line>
  <Line number="2701">		struct bmi160_acc_low_g_int_cfg *low_g_int = &amp;(int_config-&gt;int_type_cfg.acc_low_g_int);</Line>
  <Line number="2702"></Line>
  <Line number="2703">		/* Enable the low-g interrupt*/</Line>
  <Line number="2704">		rslt = enable_low_g_int (low_g_int, dev);</Line>
  <Line number="2705">		if (<CheckRefs ids="589">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2706">			/* Configure Interrupt pins */</Line>
  <Line number="2707">			rslt = set_intr_pin_config(int_config, dev);</Line>
  <Line number="2708">			if (<CheckRefs ids="590">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2709">				/* Map INT pin to low-g interrupt */</Line>
  <Line number="2710">				rslt = map_feature_interrupt(int_config, dev);</Line>
  <Line number="2711">				if (<CheckRefs ids="591">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2712">					/* configure the data source</Line>
  <Line number="2713">					 * for low-g interrupt*/</Line>
  <Line number="2714">					rslt = config_low_g_data_src(low_g_int, dev);</Line>
  <Line number="2715">					if (<CheckRefs ids="592">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="2716">						rslt = config_low_g_int_settg(low_g_int, dev);</Line>
  <Line number="2717">				}</Line>
  <Line number="2718">			}</Line>
  <Line number="2719">		}</Line>
  <Line number="2720">	}</Line>
  <Line number="2721"></Line>
  <Line number="2722">	return rslt;</Line>
  <Line number="2723">}</Line>
  <Line number="2724"></Line>
  <Line number="2725">/*!</Line>
  <Line number="2726"> * @brief This API sets the high-g interrupt of the sensor.The interrupt</Line>
  <Line number="2727"> * occurs if the absolute value of acceleration data of any enabled axis</Line>
  <Line number="2728"> * exceeds the programmed threshold and the sign of the value does not</Line>
  <Line number="2729"> * change for a preset duration.</Line>
  <Line number="2730"> */</Line>
  <Line number="2731">static int8_t set_accel_high_g_int(struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="2732">{ INIT_STUBS(dev);</Line>
  <Line number="2733">	int8_t rslt;</Line>
  <Line number="2734"></Line>
  <Line number="2735">	/* Null-pointer check */</Line>
  <Line number="2736">	rslt = null_ptr_check(dev);</Line>
  <Line number="2737"></Line>
  <Line number="2738">	if ((<CheckRefs ids="593">rslt</CheckRefs> != BMI160_OK) || (int_config == NULL)) {</Line>
  <Line number="2739">		rslt = <CheckRefs ids="594,595">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2740">	} else {</Line>
  <Line number="2741">		/* updating the interrupt structure to local structure */</Line>
  <Line number="2742">		struct bmi160_acc_high_g_int_cfg *high_g_int_cfg = &amp;(int_config-&gt;int_type_cfg.acc_high_g_int);</Line>
  <Line number="2743"></Line>
  <Line number="2744">		/* Enable the high-g interrupt */</Line>
  <Line number="2745">		rslt = enable_high_g_int(high_g_int_cfg, dev);</Line>
  <Line number="2746">		if (<CheckRefs ids="596">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2747">			/* Configure Interrupt pins */</Line>
  <Line number="2748">			rslt = set_intr_pin_config(int_config, dev);</Line>
  <Line number="2749">			if (<CheckRefs ids="597">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2750">				/* Map INT pin to high-g interrupt */</Line>
  <Line number="2751">				rslt = map_feature_interrupt(int_config, dev);</Line>
  <Line number="2752">				if (<CheckRefs ids="598">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2753">					/* configure the data source</Line>
  <Line number="2754">					* for high-g interrupt*/</Line>
  <Line number="2755">					rslt = config_high_g_data_src(high_g_int_cfg, dev);</Line>
  <Line number="2756">					if (<CheckRefs ids="599">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="2757">						rslt = config_high_g_int_settg(high_g_int_cfg, dev);</Line>
  <Line number="2758">				}</Line>
  <Line number="2759">			}</Line>
  <Line number="2760">		}</Line>
  <Line number="2761">	}</Line>
  <Line number="2762"></Line>
  <Line number="2763">	return rslt;</Line>
  <Line number="2764">}</Line>
  <Line number="2765"></Line>
  <Line number="2766">/*!</Line>
  <Line number="2767"> * @brief This API configures the pins to fire the</Line>
  <Line number="2768"> * interrupt signal when it occurs.</Line>
  <Line number="2769"> */</Line>
  <Line number="2770">static int8_t set_intr_pin_config(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="2771">{ INIT_STUBS(dev);</Line>
  <Line number="2772">	int8_t rslt;</Line>
  <Line number="2773"></Line>
  <Line number="2774">	/* configure the behavioural settings of interrupt pin */</Line>
  <Line number="2775">	rslt = config_int_out_ctrl(int_config, dev);</Line>
  <Line number="2776">	if (<CheckRefs ids="600">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="2777">		rslt = config_int_latch(int_config, dev);</Line>
  <Line number="2778"></Line>
  <Line number="2779">	return rslt;</Line>
  <Line number="2780">}</Line>
  <Line number="2781"></Line>
  <Line number="2782">/*!</Line>
  <Line number="2783"> * @brief This internal API is used to validate the device structure pointer for</Line>
  <Line number="2784"> * null conditions.</Line>
  <Line number="2785"> */</Line>
  <Line number="2786">static int8_t null_ptr_check(const struct bmi160_dev *dev)</Line>
  <Line number="2787">{ INIT_STUBS(dev);</Line>
  <Line number="2788">	int8_t rslt;</Line>
  <Line number="2789"></Line>
  <Line number="2790">	if ((dev == NULL) || (dev-&gt;read == NULL) || (dev-&gt;write == NULL) || (dev-&gt;delay_ms == NULL)) {</Line>
  <Line number="2791">		rslt = <CheckRefs ids="601,602">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="2792">	} else {</Line>
  <Line number="2793">		/* Device structure is fine */</Line>
  <Line number="2794">		rslt = <CheckRefs ids="603">BMI160_OK</CheckRefs>;</Line>
  <Line number="2795">	}</Line>
  <Line number="2796"></Line>
  <Line number="2797">	return rslt;</Line>
  <Line number="2798">}</Line>
  <Line number="2799"></Line>
  <Line number="2800">/*!</Line>
  <Line number="2801"> * @brief This API sets the default configuration parameters of accel &amp; gyro.</Line>
  <Line number="2802"> * Also maintain the previous state of configurations.</Line>
  <Line number="2803"> */</Line>
  <Line number="2804">static void default_param_settg(struct bmi160_dev *dev)</Line>
  <Line number="2805">{ INIT_STUBS(dev);</Line>
  <Line number="2806">	/* Initializing accel and gyro params with</Line>
  <Line number="2807">	* default values */</Line>
  <Line number="2808">	dev-&gt;accel_cfg.bw = <CheckRefs ids="604">BMI160_ACCEL_BW_NORMAL_AVG4</CheckRefs>;</Line>
  <Line number="2809">	dev-&gt;accel_cfg.odr = <CheckRefs ids="605">BMI160_ACCEL_ODR_100HZ</CheckRefs>;</Line>
  <Line number="2810">	dev-&gt;accel_cfg.power = <CheckRefs ids="606">BMI160_ACCEL_SUSPEND_MODE</CheckRefs>;</Line>
  <Line number="2811">	dev-&gt;accel_cfg.range = <CheckRefs ids="607">BMI160_ACCEL_RANGE_2G</CheckRefs>;</Line>
  <Line number="2812">	dev-&gt;gyro_cfg.bw = <CheckRefs ids="608">BMI160_GYRO_BW_NORMAL_MODE</CheckRefs>;</Line>
  <Line number="2813">	dev-&gt;gyro_cfg.odr = <CheckRefs ids="609">BMI160_GYRO_ODR_100HZ</CheckRefs>;</Line>
  <Line number="2814">	dev-&gt;gyro_cfg.power = <CheckRefs ids="610">BMI160_GYRO_SUSPEND_MODE</CheckRefs>;</Line>
  <Line number="2815">	dev-&gt;gyro_cfg.range = <CheckRefs ids="611">BMI160_GYRO_RANGE_2000_DPS</CheckRefs>;</Line>
  <Line number="2816"></Line>
  <Line number="2817">	/* To maintain the previous state of accel configuration */</Line>
  <Line number="2818">	dev-&gt;prev_accel_cfg = dev-&gt;accel_cfg;</Line>
  <Line number="2819">	/* To maintain the previous state of gyro configuration */</Line>
  <Line number="2820">	dev-&gt;prev_gyro_cfg = dev-&gt;gyro_cfg;</Line>
  <Line number="2821">}</Line>
  <Line number="2822"></Line>
  <Line number="2823">/*!</Line>
  <Line number="2824"> * @brief This API set the accel configuration.</Line>
  <Line number="2825"> */</Line>
  <Line number="2826">static int8_t set_accel_conf(struct bmi160_dev *dev)</Line>
  <Line number="2827">{ INIT_STUBS(dev);</Line>
  <Line number="2828">	int8_t rslt;</Line>
  <Line number="2829">	uint8_t data[2]  = {<CheckRefs ids="612">0</CheckRefs>};</Line>
  <Line number="2830"></Line>
  <Line number="2831">	rslt = check_accel_config(data, dev);</Line>
  <Line number="2832">	if (<CheckRefs ids="613">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2833">		/* Write output data rate and bandwidth */</Line>
  <Line number="2834">		rslt = bmi160_set_regs(<CheckRefs ids="614">BMI160_ACCEL_CONFIG_ADDR</CheckRefs>, &amp;data[0<CheckRefs ids="615">]</CheckRefs>, <CheckRefs ids="616">1</CheckRefs>, dev);</Line>
  <Line number="2835">		if (<CheckRefs ids="617">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2836">			dev-&gt;prev_accel_cfg.odr = dev-&gt;accel_cfg.odr;</Line>
  <Line number="2837">			dev-&gt;prev_accel_cfg.bw = dev-&gt;accel_cfg.bw;</Line>
  <Line number="2838">			dev-&gt;delay_ms(BMI160_ONE_MS_DELAY);</Line>
  <Line number="2839">			/* write accel range */</Line>
  <Line number="2840">			rslt = bmi160_set_regs(<CheckRefs ids="618">BMI160_ACCEL_RANGE_ADDR</CheckRefs>, &amp;data[1<CheckRefs ids="619">]</CheckRefs>, <CheckRefs ids="620">1</CheckRefs>, dev);</Line>
  <Line number="2841">			if (<CheckRefs ids="621">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="2842">				dev-&gt;prev_accel_cfg.range = dev-&gt;accel_cfg.range;</Line>
  <Line number="2843">		}</Line>
  <Line number="2844">	}</Line>
  <Line number="2845"></Line>
  <Line number="2846">	return rslt;</Line>
  <Line number="2847">}</Line>
  <Line number="2848"></Line>
  <Line number="2849">/*!</Line>
  <Line number="2850">* @brief This API check the accel configuration.</Line>
  <Line number="2851">*/</Line>
  <Line number="2852">static int8_t check_accel_config(uint8_t *data, const struct bmi160_dev *dev)</Line>
  <Line number="2853">{ INIT_STUBS(dev);</Line>
  <Line number="2854">	int8_t rslt;</Line>
  <Line number="2855"></Line>
  <Line number="2856">	/* read accel Output data rate and bandwidth */</Line>
  <Line number="2857">	rslt = bmi160_get_regs(<CheckRefs ids="622">BMI160_ACCEL_CONFIG_ADDR</CheckRefs>, data, <CheckRefs ids="623">2</CheckRefs>, dev);</Line>
  <Line number="2858">	if (<CheckRefs ids="624">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2859">		rslt = process_accel_odr(&amp;data[0], dev);</Line>
  <Line number="2860">		if (<CheckRefs ids="625">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2861">			rslt = process_accel_bw(&amp;data[0], dev);</Line>
  <Line number="2862">			if (<CheckRefs ids="626">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="2863">				rslt = process_accel_range(&amp;data[1], dev);</Line>
  <Line number="2864">		}</Line>
  <Line number="2865">	}</Line>
  <Line number="2866"></Line>
  <Line number="2867">	return rslt;</Line>
  <Line number="2868">}</Line>
  <Line number="2869"></Line>
  <Line number="2870">/*!</Line>
  <Line number="2871"> * @brief This API process the accel odr.</Line>
  <Line number="2872"> */</Line>
  <Line number="2873">static int8_t process_accel_odr(uint8_t *data, const struct bmi160_dev *dev)</Line>
  <Line number="2874">{ INIT_STUBS(dev);</Line>
  <Line number="2875">	int8_t rslt = <CheckRefs ids="627">0</CheckRefs>;</Line>
  <Line number="2876">	uint8_t temp = <CheckRefs ids="628">0</CheckRefs>;</Line>
  <Line number="2877">	uint8_t odr = <CheckRefs ids="629">0</CheckRefs>;</Line>
  <Line number="2878"></Line>
  <Line number="2879">	if (<CheckRefs ids="630">dev</CheckRefs>-&gt;accel_cfg.odr &lt;= BMI160_ACCEL_ODR_MAX) {</Line>
  <Line number="2880">		if (<CheckRefs ids="631">dev</CheckRefs>-&gt;accel_cfg.odr != <CheckRefs ids="632">dev</CheckRefs>-&gt;prev_accel_cfg.odr) {</Line>
  <Line number="2881">			odr = (uint8_t)dev-&gt;accel_cfg.odr;</Line>
  <Line number="2882">			temp = <CheckRefs ids="634">*</CheckRefs>data <CheckRefs ids="633">&amp;</CheckRefs> ~BMI160_ACCEL_ODR_MASK;</Line>
  <Line number="2883">			/* Adding output data rate */</Line>
  <Line number="2884">			*data = <CheckRefs ids="636">temp</CheckRefs> <CheckRefs ids="635">|</CheckRefs> (<CheckRefs ids="637">odr</CheckRefs> &amp; BMI160_ACCEL_ODR_MASK);</Line>
  <Line number="2885">		}</Line>
  <Line number="2886">	} else {</Line>
  <Line number="2887">		rslt = <CheckRefs ids="638,639">BMI160_E_OUT_OF_RANGE</CheckRefs>;</Line>
  <Line number="2888">	}</Line>
  <Line number="2889"></Line>
  <Line number="2890">	return rslt;</Line>
  <Line number="2891">}</Line>
  <Line number="2892"></Line>
  <Line number="2893">/*!</Line>
  <Line number="2894"> * @brief This API process the accel bandwidth.</Line>
  <Line number="2895"> */</Line>
  <Line number="2896">static int8_t process_accel_bw(uint8_t *data, const struct bmi160_dev *dev)</Line>
  <Line number="2897">{ INIT_STUBS(dev);</Line>
  <Line number="2898">	int8_t rslt = <CheckRefs ids="640">0</CheckRefs>;</Line>
  <Line number="2899">	uint8_t temp = <CheckRefs ids="641">0</CheckRefs>;</Line>
  <Line number="2900">	uint8_t bw = <CheckRefs ids="642">0</CheckRefs>;</Line>
  <Line number="2901"></Line>
  <Line number="2902">	if (<CheckRefs ids="643">dev</CheckRefs>-&gt;accel_cfg.bw &lt;= BMI160_ACCEL_BW_MAX) {</Line>
  <Line number="2903">		if (<CheckRefs ids="644">dev</CheckRefs>-&gt;accel_cfg.bw != <CheckRefs ids="645">dev</CheckRefs>-&gt;prev_accel_cfg.bw) {</Line>
  <Line number="2904">			bw = (uint8_t)dev-&gt;accel_cfg.bw;</Line>
  <Line number="2905">			temp = <CheckRefs ids="647">*</CheckRefs>data <CheckRefs ids="646">&amp;</CheckRefs> ~BMI160_ACCEL_BW_MASK;</Line>
  <Line number="2906">			/* Adding bandwidth */</Line>
  <Line number="2907">			*data = <CheckRefs ids="649">temp</CheckRefs> <CheckRefs ids="648">|</CheckRefs> (<CheckRefs ids="650">(</CheckRefs><CheckRefs ids="654">bw</CheckRefs> <CheckRefs ids="651,652,653">&lt;&lt;</CheckRefs> 4) &amp; BMI160_ACCEL_ODR_MASK);</Line>
  <Line number="2908">		}</Line>
  <Line number="2909">	} else {</Line>
  <Line number="2910">		rslt = <CheckRefs ids="656,655">BMI160_E_OUT_OF_RANGE</CheckRefs>;</Line>
  <Line number="2911">	}</Line>
  <Line number="2912"></Line>
  <Line number="2913">	return rslt;</Line>
  <Line number="2914">}</Line>
  <Line number="2915"></Line>
  <Line number="2916">/*!</Line>
  <Line number="2917"> * @brief This API process the accel range.</Line>
  <Line number="2918"> */</Line>
  <Line number="2919">static int8_t process_accel_range(uint8_t *data, const struct bmi160_dev *dev)</Line>
  <Line number="2920">{ INIT_STUBS(dev);</Line>
  <Line number="2921">	int8_t rslt = <CheckRefs ids="657">0</CheckRefs>;</Line>
  <Line number="2922">	uint8_t temp = <CheckRefs ids="658">0</CheckRefs>;</Line>
  <Line number="2923">	uint8_t range = <CheckRefs ids="659">0</CheckRefs>;</Line>
  <Line number="2924"></Line>
  <Line number="2925">	if (<CheckRefs ids="660">dev</CheckRefs>-&gt;accel_cfg.range &lt;= BMI160_ACCEL_RANGE_MAX) {</Line>
  <Line number="2926">		if (<CheckRefs ids="661">dev</CheckRefs>-&gt;accel_cfg.range != <CheckRefs ids="662">dev</CheckRefs>-&gt;prev_accel_cfg.range) {</Line>
  <Line number="2927">			range = (uint8_t)dev-&gt;accel_cfg.range;</Line>
  <Line number="2928">			temp = <CheckRefs ids="664">*</CheckRefs>data <CheckRefs ids="663">&amp;</CheckRefs> ~BMI160_ACCEL_RANGE_MASK;</Line>
  <Line number="2929">			/* Adding range */</Line>
  <Line number="2930">			*data = <CheckRefs ids="666">temp</CheckRefs> <CheckRefs ids="665">|</CheckRefs> (<CheckRefs ids="667">range</CheckRefs> &amp; BMI160_ACCEL_RANGE_MASK);</Line>
  <Line number="2931">		}</Line>
  <Line number="2932">	} else {</Line>
  <Line number="2933">		rslt = <CheckRefs ids="668,669">BMI160_E_OUT_OF_RANGE</CheckRefs>;</Line>
  <Line number="2934">	}</Line>
  <Line number="2935"></Line>
  <Line number="2936">	return rslt;</Line>
  <Line number="2937">}</Line>
  <Line number="2938"></Line>
  <Line number="2939">/*!</Line>
  <Line number="2940"> * @brief This API checks the invalid settings for ODR &amp; Bw for</Line>
  <Line number="2941"> * Accel and Gyro.</Line>
  <Line number="2942"> */</Line>
  <Line number="2943">static int8_t check_invalid_settg(const struct bmi160_dev *dev)</Line>
  <Line number="2944">{ INIT_STUBS(dev);</Line>
  <Line number="2945">	int8_t rslt;</Line>
  <Line number="2946">	uint8_t data = <CheckRefs ids="670">0</CheckRefs>;</Line>
  <Line number="2947"></Line>
  <Line number="2948">	/* read the error reg */</Line>
  <Line number="2949">	rslt = bmi160_get_regs(<CheckRefs ids="671">BMI160_ERROR_REG_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="672">1</CheckRefs>, dev);</Line>
  <Line number="2950"></Line>
  <Line number="2951">	data = <CheckRefs ids="677">data</CheckRefs> <CheckRefs ids="675,674,676,673">&gt;&gt;</CheckRefs> 1;</Line>
  <Line number="2952">	data = <CheckRefs ids="679">data</CheckRefs> <CheckRefs ids="678">&amp;</CheckRefs> BMI160_ERR_REG_MASK;</Line>
  <Line number="2953">	if (<CheckRefs ids="680">data</CheckRefs> == 1)</Line>
  <Line number="2954">		rslt = <CheckRefs ids="681,682">BMI160_E_ACCEL_ODR_BW_INVALID</CheckRefs>;</Line>
  <Line number="2955">	else if (<CheckRefs ids="683">data</CheckRefs> == 2)</Line>
  <Line number="2956">		rslt = <CheckRefs ids="685,684">BMI160_E_GYRO_ODR_BW_INVALID</CheckRefs>;</Line>
  <Line number="2957">	else if (<CheckRefs ids="686">data</CheckRefs> == 3)</Line>
  <Line number="2958">		rslt = <CheckRefs ids="687,688">BMI160_E_LWP_PRE_FLTR_INT_INVALID</CheckRefs>;</Line>
  <Line number="2959">	else if (<CheckRefs ids="689">data</CheckRefs> == 7)</Line>
  <Line number="2960">		rslt = <CheckRefs ids="690,691">BMI160_E_LWP_PRE_FLTR_INVALID</CheckRefs>;</Line>
  <Line number="2961"></Line>
  <Line number="2962">	return rslt;</Line>
  <Line number="2963">}</Line>
  <Line number="2964"></Line>
  <Line number="2965">static int8_t set_gyro_conf(struct bmi160_dev *dev)</Line>
  <Line number="2966">{ INIT_STUBS(dev);</Line>
  <Line number="2967">	int8_t rslt;</Line>
  <Line number="2968">	uint8_t data[2] = {<CheckRefs ids="692">0</CheckRefs>};</Line>
  <Line number="2969"></Line>
  <Line number="2970">	rslt = check_gyro_config(data, dev);</Line>
  <Line number="2971">	if (<CheckRefs ids="693">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2972">		/* Write output data rate and bandwidth */</Line>
  <Line number="2973">		rslt = bmi160_set_regs(<CheckRefs ids="694">BMI160_GYRO_CONFIG_ADDR</CheckRefs>, &amp;data[0<CheckRefs ids="695">]</CheckRefs>, <CheckRefs ids="696">1</CheckRefs>, dev);</Line>
  <Line number="2974">		if (<CheckRefs ids="697">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2975">			dev-&gt;prev_gyro_cfg.odr = dev-&gt;gyro_cfg.odr;</Line>
  <Line number="2976">			dev-&gt;prev_gyro_cfg.bw = dev-&gt;gyro_cfg.bw;</Line>
  <Line number="2977">			dev-&gt;delay_ms(BMI160_ONE_MS_DELAY);</Line>
  <Line number="2978">			/* Write gyro range */</Line>
  <Line number="2979">			rslt = bmi160_set_regs(<CheckRefs ids="698">BMI160_GYRO_RANGE_ADDR</CheckRefs>, &amp;data[1<CheckRefs ids="699">]</CheckRefs>, <CheckRefs ids="700">1</CheckRefs>, dev);</Line>
  <Line number="2980">			if (<CheckRefs ids="701">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="2981">				dev-&gt;prev_gyro_cfg.range = dev-&gt;gyro_cfg.range;</Line>
  <Line number="2982">		}</Line>
  <Line number="2983">	}</Line>
  <Line number="2984"></Line>
  <Line number="2985">	return rslt;</Line>
  <Line number="2986">}</Line>
  <Line number="2987"></Line>
  <Line number="2988">/*!</Line>
  <Line number="2989">* @brief This API check the gyro configuration.</Line>
  <Line number="2990">*/</Line>
  <Line number="2991">static int8_t check_gyro_config(uint8_t *data, const struct bmi160_dev *dev)</Line>
  <Line number="2992">{ INIT_STUBS(dev);</Line>
  <Line number="2993">	int8_t rslt;</Line>
  <Line number="2994"></Line>
  <Line number="2995">	/* read gyro Output data rate and bandwidth */</Line>
  <Line number="2996">	rslt = bmi160_get_regs(<CheckRefs ids="702">BMI160_GYRO_CONFIG_ADDR</CheckRefs>, data, <CheckRefs ids="703">2</CheckRefs>, dev);</Line>
  <Line number="2997">	if (<CheckRefs ids="704">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="2998">		rslt = process_gyro_odr(&amp;data[0], dev);</Line>
  <Line number="2999">		if (<CheckRefs ids="705">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3000">			rslt = process_gyro_bw(&amp;data[0], dev);</Line>
  <Line number="3001">			if (<CheckRefs ids="706">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="3002">				rslt = process_gyro_range(&amp;data[1], dev);</Line>
  <Line number="3003">		}</Line>
  <Line number="3004">	}</Line>
  <Line number="3005"></Line>
  <Line number="3006">	return rslt;</Line>
  <Line number="3007"></Line>
  <Line number="3008">}</Line>
  <Line number="3009"></Line>
  <Line number="3010">/*!</Line>
  <Line number="3011"> * @brief This API process the gyro odr.</Line>
  <Line number="3012"> */</Line>
  <Line number="3013">static int8_t process_gyro_odr(uint8_t *data, const struct bmi160_dev *dev)</Line>
  <Line number="3014">{ INIT_STUBS(dev);</Line>
  <Line number="3015">	int8_t rslt = <CheckRefs ids="707">0</CheckRefs>;</Line>
  <Line number="3016">	uint8_t temp = <CheckRefs ids="708">0</CheckRefs>;</Line>
  <Line number="3017">	uint8_t odr = <CheckRefs ids="709">0</CheckRefs>;</Line>
  <Line number="3018"></Line>
  <Line number="3019">	if (<CheckRefs ids="710">dev</CheckRefs>-&gt;gyro_cfg.odr &lt;= BMI160_GYRO_ODR_MAX) {</Line>
  <Line number="3020">		if (<CheckRefs ids="711">dev</CheckRefs>-&gt;gyro_cfg.odr != <CheckRefs ids="712">dev</CheckRefs>-&gt;prev_gyro_cfg.odr) {</Line>
  <Line number="3021">			odr = (uint8_t)dev-&gt;gyro_cfg.odr;</Line>
  <Line number="3022">			temp = <CheckRefs ids="713">(</CheckRefs><CheckRefs ids="714">*</CheckRefs>data &amp; ~BMI160_GYRO_ODR_MASK);</Line>
  <Line number="3023">			/* Adding output data rate */</Line>
  <Line number="3024">			*data = <CheckRefs ids="716">temp</CheckRefs> <CheckRefs ids="715">|</CheckRefs> (<CheckRefs ids="717">odr</CheckRefs> &amp; BMI160_GYRO_ODR_MASK);</Line>
  <Line number="3025">		}</Line>
  <Line number="3026">	} else {</Line>
  <Line number="3027">		rslt = <CheckRefs ids="718,719">BMI160_E_OUT_OF_RANGE</CheckRefs>;</Line>
  <Line number="3028">	}</Line>
  <Line number="3029"></Line>
  <Line number="3030">	return rslt;</Line>
  <Line number="3031">}</Line>
  <Line number="3032"></Line>
  <Line number="3033">/*!</Line>
  <Line number="3034"> * @brief This API process the gyro bandwidth.</Line>
  <Line number="3035"> */</Line>
  <Line number="3036">static int8_t process_gyro_bw(uint8_t *data, const struct bmi160_dev *dev)</Line>
  <Line number="3037">{ INIT_STUBS(dev);</Line>
  <Line number="3038">	int8_t rslt = <CheckRefs ids="720">0</CheckRefs>;</Line>
  <Line number="3039">	uint8_t temp = <CheckRefs ids="721">0</CheckRefs>;</Line>
  <Line number="3040">	uint8_t bw = <CheckRefs ids="722">0</CheckRefs>;</Line>
  <Line number="3041"></Line>
  <Line number="3042">	if (<CheckRefs ids="723">dev</CheckRefs>-&gt;gyro_cfg.bw &lt;= BMI160_GYRO_BW_MAX) {</Line>
  <Line number="3043">		bw = (uint8_t)dev-&gt;gyro_cfg.bw;</Line>
  <Line number="3044">		temp = <CheckRefs ids="725">*</CheckRefs>data <CheckRefs ids="724">&amp;</CheckRefs> ~BMI160_GYRO_BW_MASK;</Line>
  <Line number="3045">		/* Adding bandwidth */</Line>
  <Line number="3046">		*data = <CheckRefs ids="727">temp</CheckRefs> <CheckRefs ids="726">|</CheckRefs> (<CheckRefs ids="728">(</CheckRefs><CheckRefs ids="732">bw</CheckRefs> <CheckRefs ids="729,730,731">&lt;&lt;</CheckRefs> 4) &amp; BMI160_GYRO_BW_MASK);</Line>
  <Line number="3047">	} else {</Line>
  <Line number="3048">		rslt = <CheckRefs ids="733,734">BMI160_E_OUT_OF_RANGE</CheckRefs>;</Line>
  <Line number="3049">	}</Line>
  <Line number="3050"></Line>
  <Line number="3051">	return rslt;</Line>
  <Line number="3052">}</Line>
  <Line number="3053"></Line>
  <Line number="3054">/*!</Line>
  <Line number="3055"> * @brief This API process the gyro range.</Line>
  <Line number="3056"> */</Line>
  <Line number="3057">static int8_t process_gyro_range(uint8_t *data, const struct bmi160_dev *dev)</Line>
  <Line number="3058">{ INIT_STUBS(dev);</Line>
  <Line number="3059">	int8_t rslt = <CheckRefs ids="735">0</CheckRefs>;</Line>
  <Line number="3060">	uint8_t temp = <CheckRefs ids="736">0</CheckRefs>;</Line>
  <Line number="3061">	uint8_t range = <CheckRefs ids="737">0</CheckRefs>;</Line>
  <Line number="3062"></Line>
  <Line number="3063">	if (<CheckRefs ids="738">dev</CheckRefs>-&gt;gyro_cfg.range &lt;= BMI160_GYRO_RANGE_MAX) {</Line>
  <Line number="3064">		if (<CheckRefs ids="739">dev</CheckRefs>-&gt;gyro_cfg.range != <CheckRefs ids="740">dev</CheckRefs>-&gt;prev_gyro_cfg.range) {</Line>
  <Line number="3065">			range = (uint8_t)dev-&gt;gyro_cfg.range;</Line>
  <Line number="3066">			temp = <CheckRefs ids="742">*</CheckRefs>data <CheckRefs ids="741">&amp;</CheckRefs> ~BMI160_GYRO_RANGE_MSK;</Line>
  <Line number="3067">			/* Adding range */</Line>
  <Line number="3068">			*data = <CheckRefs ids="744">temp</CheckRefs> <CheckRefs ids="743">|</CheckRefs> (<CheckRefs ids="745">range</CheckRefs> &amp; BMI160_GYRO_RANGE_MSK);</Line>
  <Line number="3069">		}</Line>
  <Line number="3070">	} else {</Line>
  <Line number="3071">		rslt = <CheckRefs ids="746,747">BMI160_E_OUT_OF_RANGE</CheckRefs>;</Line>
  <Line number="3072">	}</Line>
  <Line number="3073"></Line>
  <Line number="3074">	return rslt;</Line>
  <Line number="3075">}</Line>
  <Line number="3076"></Line>
  <Line number="3077">/*!</Line>
  <Line number="3078"> * @brief This API sets the accel power.</Line>
  <Line number="3079"> */</Line>
  <Line number="3080">static int8_t set_accel_pwr(struct bmi160_dev *dev)</Line>
  <Line number="3081">{ INIT_STUBS(dev);</Line>
  <Line number="3082">	int8_t rslt = <CheckRefs ids="748">0</CheckRefs>;</Line>
  <Line number="3083">	uint8_t data = <CheckRefs ids="749">0</CheckRefs>;</Line>
  <Line number="3084"></Line>
  <Line number="3085">	if ((<CheckRefs ids="750">dev</CheckRefs>-&gt;accel_cfg.power &gt;= BMI160_ACCEL_SUSPEND_MODE) &amp;&amp;</Line>
  <Line number="3086">		(<CheckRefs ids="751">dev</CheckRefs>-&gt;accel_cfg.power &lt;= BMI160_ACCEL_LOWPOWER_MODE)) {</Line>
  <Line number="3087">		if (<CheckRefs ids="752">dev</CheckRefs>-&gt;accel_cfg.power != <CheckRefs ids="753">dev</CheckRefs>-&gt;prev_accel_cfg.power) {</Line>
  <Line number="3088">			rslt = process_under_sampling(&amp;data, dev);</Line>
  <Line number="3089">			if (<CheckRefs ids="754">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3090">				/* Write accel power */</Line>
  <Line number="3091">				rslt = bmi160_set_regs(<CheckRefs ids="755">BMI160_COMMAND_REG_ADDR</CheckRefs>, &amp;dev-&gt;accel_cfg.power, <CheckRefs ids="756">1</CheckRefs>, dev);</Line>
  <Line number="3092">				/* Add delay of 5 ms */</Line>
  <Line number="3093">				if (<CheckRefs ids="757">dev</CheckRefs>-&gt;prev_accel_cfg.power == BMI160_ACCEL_SUSPEND_MODE)</Line>
  <Line number="3094">					dev-&gt;delay_ms(BMI160_ACCEL_DELAY_MS);</Line>
  <Line number="3095">				dev-&gt;prev_accel_cfg.power = dev-&gt;accel_cfg.power;</Line>
  <Line number="3096">			}</Line>
  <Line number="3097">		}</Line>
  <Line number="3098">	} else {</Line>
  <Line number="3099">		rslt = <CheckRefs ids="758,759">BMI160_E_OUT_OF_RANGE</CheckRefs>;</Line>
  <Line number="3100">	}</Line>
  <Line number="3101"></Line>
  <Line number="3102">	return rslt;</Line>
  <Line number="3103">}</Line>
  <Line number="3104"></Line>
  <Line number="3105">/*!</Line>
  <Line number="3106"> * @brief This API process the undersampling setting of Accel.</Line>
  <Line number="3107"> */</Line>
  <Line number="3108">static int8_t process_under_sampling(uint8_t *data, const struct bmi160_dev *dev)</Line>
  <Line number="3109">{ INIT_STUBS(dev);</Line>
  <Line number="3110">	int8_t rslt;</Line>
  <Line number="3111">	uint8_t temp = <CheckRefs ids="760">0</CheckRefs>;</Line>
  <Line number="3112">	uint8_t pre_filter = <CheckRefs ids="761">0</CheckRefs>;</Line>
  <Line number="3113"></Line>
  <Line number="3114">	rslt = bmi160_get_regs(<CheckRefs ids="762">BMI160_ACCEL_CONFIG_ADDR</CheckRefs>, data, <CheckRefs ids="763">1</CheckRefs>, dev);</Line>
  <Line number="3115">	if (<CheckRefs ids="764">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3116">		if (<CheckRefs ids="765">dev</CheckRefs>-&gt;accel_cfg.power == BMI160_ACCEL_LOWPOWER_MODE) {</Line>
  <Line number="3117">			temp = <CheckRefs ids="767">*</CheckRefs>data <CheckRefs ids="766">&amp;</CheckRefs> ~BMI160_ACCEL_UNDERSAMPLING_MASK;</Line>
  <Line number="3118">			/* Set under-sampling parameter */</Line>
  <Line number="3119">			*data = <CheckRefs ids="769">temp</CheckRefs> <CheckRefs ids="768">|</CheckRefs> (<CheckRefs ids="770">(</CheckRefs>1 <CheckRefs ids="771,773,772">&lt;&lt;</CheckRefs> 7) &amp; BMI160_ACCEL_UNDERSAMPLING_MASK);</Line>
  <Line number="3120">			/* Write data */</Line>
  <Line number="3121">			rslt = bmi160_set_regs(<CheckRefs ids="774">BMI160_ACCEL_CONFIG_ADDR</CheckRefs>, data, <CheckRefs ids="775">1</CheckRefs>, dev);</Line>
  <Line number="3122">			/* disable the pre-filter data in</Line>
  <Line number="3123">			 * low power mode */</Line>
  <Line number="3124">			if (<CheckRefs ids="776">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="3125">				/* Disable the Pre-filter data*/</Line>
  <Line number="3126">				rslt = bmi160_set_regs(<CheckRefs ids="777">BMI160_INT_DATA_0_ADDR</CheckRefs>, &amp;pre_filter, <CheckRefs ids="778">2</CheckRefs>, dev);</Line>
  <Line number="3127">		} else {</Line>
  <Line number="3128">			if (<CheckRefs ids="779">*</CheckRefs>data &amp; BMI160_ACCEL_UNDERSAMPLING_MASK) {</Line>
  <Line number="3129"></Line>
  <Line number="3130">				temp = <CheckRefs ids="781">*</CheckRefs>data <CheckRefs ids="780">&amp;</CheckRefs> ~BMI160_ACCEL_UNDERSAMPLING_MASK;</Line>
  <Line number="3131">				/* disable under-sampling parameter</Line>
  <Line number="3132">				if already enabled */</Line>
  <Line number="3133">				*data = temp;</Line>
  <Line number="3134">				/* Write data */</Line>
  <Line number="3135">				rslt = bmi160_set_regs(<CheckRefs ids="782">BMI160_ACCEL_CONFIG_ADDR</CheckRefs>, data, <CheckRefs ids="783">1</CheckRefs>, dev);</Line>
  <Line number="3136">			}</Line>
  <Line number="3137">		}</Line>
  <Line number="3138">	}</Line>
  <Line number="3139"></Line>
  <Line number="3140">	return rslt;</Line>
  <Line number="3141">}</Line>
  <Line number="3142"></Line>
  <Line number="3143">/*!</Line>
  <Line number="3144"> * @brief This API sets the gyro power mode.</Line>
  <Line number="3145"> */</Line>
  <Line number="3146">static int8_t set_gyro_pwr(struct bmi160_dev *dev)</Line>
  <Line number="3147">{ INIT_STUBS(dev);</Line>
  <Line number="3148">	int8_t rslt = <CheckRefs ids="784">0</CheckRefs>;</Line>
  <Line number="3149"></Line>
  <Line number="3150">	if ((<CheckRefs ids="785">dev</CheckRefs>-&gt;gyro_cfg.power == BMI160_GYRO_SUSPEND_MODE) || (<CheckRefs ids="786">dev</CheckRefs>-&gt;gyro_cfg.power == BMI160_GYRO_NORMAL_MODE)</Line>
  <Line number="3151">		|| (<CheckRefs ids="787">dev</CheckRefs>-&gt;gyro_cfg.power == BMI160_GYRO_FASTSTARTUP_MODE)) {</Line>
  <Line number="3152"></Line>
  <Line number="3153">		if (<CheckRefs ids="788">dev</CheckRefs>-&gt;gyro_cfg.power != <CheckRefs ids="789">dev</CheckRefs>-&gt;prev_gyro_cfg.power) {</Line>
  <Line number="3154"></Line>
  <Line number="3155">			/* Write gyro power */</Line>
  <Line number="3156">			rslt = bmi160_set_regs(<CheckRefs ids="790">BMI160_COMMAND_REG_ADDR</CheckRefs>, &amp;dev-&gt;gyro_cfg.power, <CheckRefs ids="791">1</CheckRefs>, dev);</Line>
  <Line number="3157">			if (<CheckRefs ids="792">dev</CheckRefs>-&gt;prev_gyro_cfg.power ==</Line>
  <Line number="3158">				BMI160_GYRO_SUSPEND_MODE) {</Line>
  <Line number="3159">				/* Delay of 81 ms */</Line>
  <Line number="3160">				dev-&gt;delay_ms(BMI160_GYRO_DELAY_MS);</Line>
  <Line number="3161">			} else if ((<CheckRefs ids="793">dev</CheckRefs>-&gt;prev_gyro_cfg.power == BMI160_GYRO_FASTSTARTUP_MODE)</Line>
  <Line number="3162">				&amp;&amp; (<CheckRefs ids="794">dev</CheckRefs>-&gt;gyro_cfg.power == BMI160_GYRO_NORMAL_MODE)) {</Line>
  <Line number="3163">				/* This delay is required for transition from</Line>
  <Line number="3164">				fast-startup mode to normal mode */</Line>
  <Line number="3165">				dev-&gt;delay_ms(<CheckRefs ids="795">10</CheckRefs>);</Line>
  <Line number="3166">			} else {</Line>
  <Line number="3167">				/* do nothing */</Line>
  <Line number="3168">			}</Line>
  <Line number="3169">			dev-&gt;prev_gyro_cfg.power = dev-&gt;gyro_cfg.power;</Line>
  <Line number="3170">		}</Line>
  <Line number="3171">	} else {</Line>
  <Line number="3172">		rslt = <CheckRefs ids="796,797">BMI160_E_OUT_OF_RANGE</CheckRefs>;</Line>
  <Line number="3173">	}</Line>
  <Line number="3174"></Line>
  <Line number="3175">	return rslt;</Line>
  <Line number="3176">}</Line>
  <Line number="3177"></Line>
  <Line number="3178">/*!</Line>
  <Line number="3179"> * @brief This API reads accel data along with sensor time if time is requested</Line>
  <Line number="3180"> * by user. Kindly refer the user guide(README.md) for more info.</Line>
  <Line number="3181"> */</Line>
  <Line number="3182"> //Possible DRS: len again</Line>
  <Line number="3183">static int8_t get_accel_data(uint8_t len, struct bmi160_sensor_data *accel, const struct bmi160_dev *dev)</Line>
  <Line number="3184">{ INIT_STUBS(dev);</Line>
  <Line number="3185">	int8_t rslt;</Line>
  <Line number="3186">	uint8_t idx = <CheckRefs ids="798">0</CheckRefs>;</Line>
  <Line number="3187">	uint8_t data_array[9] = {<CheckRefs ids="799">0</CheckRefs>};</Line>
  <Line number="3188">	uint8_t time_0 = <CheckRefs ids="800">0</CheckRefs>;</Line>
  <Line number="3189">	uint16_t time_1 = <CheckRefs ids="801">0</CheckRefs>;</Line>
  <Line number="3190">	uint32_t time_2 = <CheckRefs ids="802">0</CheckRefs>;</Line>
  <Line number="3191">	uint8_t lsb;</Line>
  <Line number="3192">	uint8_t msb;</Line>
  <Line number="3193">	int16_t msblsb;</Line>
  <Line number="3194"></Line>
  <Line number="3195">	/* read accel sensor data along with time if requested */</Line>
  <Line number="3196">	rslt = bmi160_get_regs(<CheckRefs ids="803">BMI160_ACCEL_DATA_ADDR</CheckRefs>, data_array, 6 <CheckRefs ids="804,805">+</CheckRefs> <CheckRefs ids="806">len</CheckRefs>, dev);</Line>
  <Line number="3197">	if (<CheckRefs ids="807">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3198"></Line>
  <Line number="3199">		/* Accel Data */</Line>
  <Line number="3200">		lsb = data_array[idx<CheckRefs ids="809">++</CheckRefs><CheckRefs ids="808">]</CheckRefs>;</Line>
  <Line number="3201">		msb = data_array[idx<CheckRefs ids="811">++</CheckRefs><CheckRefs ids="810">]</CheckRefs>;</Line>
  <Line number="3202">		msblsb = <CheckRefs ids="812">(</CheckRefs>int16_t)((<CheckRefs ids="816">msb</CheckRefs> <CheckRefs ids="813,814,815">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="817">lsb</CheckRefs>);</Line>
  <Line number="3203">		accel-&gt;x = msblsb; /* Data in X axis */</Line>
  <Line number="3204"></Line>
  <Line number="3205">		lsb = data_array[idx<CheckRefs ids="819">++</CheckRefs><CheckRefs ids="818">]</CheckRefs>;</Line>
  <Line number="3206">		msb = data_array[idx<CheckRefs ids="821">++</CheckRefs><CheckRefs ids="820">]</CheckRefs>;</Line>
  <Line number="3207">		msblsb = <CheckRefs ids="822">(</CheckRefs>int16_t)((<CheckRefs ids="826">msb</CheckRefs> <CheckRefs ids="823,824,825">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="827">lsb</CheckRefs>);</Line>
  <Line number="3208">		accel-&gt;y = msblsb; /* Data in Y axis */</Line>
  <Line number="3209"></Line>
  <Line number="3210">		lsb = data_array[idx<CheckRefs ids="829">++</CheckRefs><CheckRefs ids="828">]</CheckRefs>;</Line>
  <Line number="3211">		msb = data_array[idx<CheckRefs ids="831">++</CheckRefs><CheckRefs ids="830">]</CheckRefs>;</Line>
  <Line number="3212">		msblsb = <CheckRefs ids="832">(</CheckRefs>int16_t)((<CheckRefs ids="836">msb</CheckRefs> <CheckRefs ids="833,834,835">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="837">lsb</CheckRefs>);</Line>
  <Line number="3213">		accel-&gt;z = msblsb; /* Data in Z axis */</Line>
  <Line number="3214"></Line>
  <Line number="3215">		if (<CheckRefs ids="838">len</CheckRefs> == 3) {</Line>
  <Line number="3216">			time_0 = data_array[idx<CheckRefs ids="840">++</CheckRefs><CheckRefs ids="839">]</CheckRefs>;</Line>
  <Line number="3217">			time_1 = <CheckRefs ids="841">(</CheckRefs>uint16_t)(<CheckRefs ids="845">data_array</CheckRefs>[idx<CheckRefs ids="847">++</CheckRefs><CheckRefs ids="846">]</CheckRefs> <CheckRefs ids="843,842,844">&lt;&lt;</CheckRefs> 8);</Line>
  <Line number="3218">			time_2 = <CheckRefs ids="848">(</CheckRefs>uint32_t)(<CheckRefs ids="852">data_array</CheckRefs>[idx<CheckRefs ids="854">++</CheckRefs><CheckRefs ids="853">]</CheckRefs> <CheckRefs ids="849,850,851">&lt;&lt;</CheckRefs> 16);</Line>
  <Line number="3219">			accel-&gt;sensortime = (uint32_t)(time_2 | <CheckRefs ids="855">time_1</CheckRefs> | <CheckRefs ids="856">time_0</CheckRefs>);</Line>
  <Line number="3220">		} else {</Line>
  <Line number="3221">			accel-&gt;sensortime = <CheckRefs ids="857">0</CheckRefs>;</Line>
  <Line number="3222">		}</Line>
  <Line number="3223">	} else {</Line>
  <Line number="3224">		rslt = <CheckRefs ids="858,859">BMI160_E_COM_FAIL</CheckRefs>;</Line>
  <Line number="3225">	}</Line>
  <Line number="3226"></Line>
  <Line number="3227">	return rslt;</Line>
  <Line number="3228">}</Line>
  <Line number="3229"></Line>
  <Line number="3230">/*!</Line>
  <Line number="3231"> * @brief This API reads accel data along with sensor time if time is requested</Line>
  <Line number="3232"> * by user. Kindly refer the user guide(README.md) for more info.</Line>
  <Line number="3233"> */</Line>
  <Line number="3234">static int8_t get_gyro_data(uint8_t len, struct bmi160_sensor_data *gyro, const struct bmi160_dev *dev)</Line>
  <Line number="3235">{ INIT_STUBS(dev);</Line>
  <Line number="3236">	int8_t rslt;</Line>
  <Line number="3237">	uint8_t idx = <CheckRefs ids="860">0</CheckRefs>;</Line>
  <Line number="3238">	uint8_t data_array[15] = {<CheckRefs ids="861">0</CheckRefs>};</Line>
  <Line number="3239">	uint8_t time_0 = <CheckRefs ids="862">0</CheckRefs>;</Line>
  <Line number="3240">	uint16_t time_1 = <CheckRefs ids="863">0</CheckRefs>;</Line>
  <Line number="3241">	uint32_t time_2 = <CheckRefs ids="864">0</CheckRefs>;</Line>
  <Line number="3242">	uint8_t lsb;</Line>
  <Line number="3243">	uint8_t msb;</Line>
  <Line number="3244">	int16_t msblsb;</Line>
  <Line number="3245"></Line>
  <Line number="3246">	if (<CheckRefs ids="865">len</CheckRefs> == 0) {</Line>
  <Line number="3247">		/* read gyro data only */</Line>
  <Line number="3248">		rslt = bmi160_get_regs(<CheckRefs ids="866">BMI160_GYRO_DATA_ADDR</CheckRefs>, data_array, <CheckRefs ids="867">6</CheckRefs>, dev);</Line>
  <Line number="3249">		if (<CheckRefs ids="868">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3250">			/* Gyro Data */</Line>
  <Line number="3251">			lsb = data_array[idx<CheckRefs ids="870">++</CheckRefs><CheckRefs ids="869">]</CheckRefs>;</Line>
  <Line number="3252">			msb = data_array[idx<CheckRefs ids="872">++</CheckRefs><CheckRefs ids="871">]</CheckRefs>;</Line>
  <Line number="3253">			msblsb = <CheckRefs ids="873">(</CheckRefs>int16_t)((<CheckRefs ids="877">msb</CheckRefs> <CheckRefs ids="874,875,876">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="878">lsb</CheckRefs>);</Line>
  <Line number="3254">			gyro-&gt;x = msblsb; /* Data in X axis */</Line>
  <Line number="3255"></Line>
  <Line number="3256">			lsb = data_array[idx<CheckRefs ids="880">++</CheckRefs><CheckRefs ids="879">]</CheckRefs>;</Line>
  <Line number="3257">			msb = data_array[idx<CheckRefs ids="882">++</CheckRefs><CheckRefs ids="881">]</CheckRefs>;</Line>
  <Line number="3258">			msblsb = <CheckRefs ids="883">(</CheckRefs>int16_t)((<CheckRefs ids="887">msb</CheckRefs> <CheckRefs ids="884,885,886">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="888">lsb</CheckRefs>);</Line>
  <Line number="3259">			gyro-&gt;y = msblsb; /* Data in Y axis */</Line>
  <Line number="3260"></Line>
  <Line number="3261">			lsb = data_array[idx<CheckRefs ids="890">++</CheckRefs><CheckRefs ids="889">]</CheckRefs>;</Line>
  <Line number="3262">			msb = data_array[idx<CheckRefs ids="892">++</CheckRefs><CheckRefs ids="891">]</CheckRefs>;</Line>
  <Line number="3263">			msblsb = <CheckRefs ids="893">(</CheckRefs>int16_t)((<CheckRefs ids="897">msb</CheckRefs> <CheckRefs ids="894,895,896">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="898">lsb</CheckRefs>);</Line>
  <Line number="3264">			gyro-&gt;z = msblsb; /* Data in Z axis */</Line>
  <Line number="3265">			gyro-&gt;sensortime = <CheckRefs ids="899">0</CheckRefs>;</Line>
  <Line number="3266"></Line>
  <Line number="3267">		} else {</Line>
  <Line number="3268">			rslt = <CheckRefs ids="901,900">BMI160_E_COM_FAIL</CheckRefs>;</Line>
  <Line number="3269">		}</Line>
  <Line number="3270">	} else {</Line>
  <Line number="3271">		/* read gyro sensor data along with time */</Line>
  <Line number="3272">		rslt = bmi160_get_regs(<CheckRefs ids="902">BMI160_GYRO_DATA_ADDR</CheckRefs>, data_array, 12 <CheckRefs ids="903,904">+</CheckRefs> <CheckRefs ids="905">len</CheckRefs>, dev);</Line>
  <Line number="3273">		if (<CheckRefs ids="906">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3274">			/* Gyro Data */</Line>
  <Line number="3275">			lsb = data_array[idx<CheckRefs ids="908">++</CheckRefs><CheckRefs ids="907">]</CheckRefs>;</Line>
  <Line number="3276">			msb = data_array[idx<CheckRefs ids="910">++</CheckRefs><CheckRefs ids="909">]</CheckRefs>;</Line>
  <Line number="3277">			msblsb = <CheckRefs ids="911">(</CheckRefs>int16_t)((<CheckRefs ids="915">msb</CheckRefs> <CheckRefs ids="912,913,914">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="916">lsb</CheckRefs>);</Line>
  <Line number="3278">			gyro-&gt;x = msblsb; /* gyro X axis data */</Line>
  <Line number="3279"></Line>
  <Line number="3280">			lsb = data_array[idx<CheckRefs ids="918">++</CheckRefs><CheckRefs ids="917">]</CheckRefs>;</Line>
  <Line number="3281">			msb = data_array[idx<CheckRefs ids="920">++</CheckRefs><CheckRefs ids="919">]</CheckRefs>;</Line>
  <Line number="3282">			msblsb = <CheckRefs ids="921">(</CheckRefs>int16_t)((<CheckRefs ids="925">msb</CheckRefs> <CheckRefs ids="923,922,924">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="926">lsb</CheckRefs>);</Line>
  <Line number="3283">			gyro-&gt;y = msblsb; /* gyro Y axis data */</Line>
  <Line number="3284"></Line>
  <Line number="3285">			lsb = data_array[idx<CheckRefs ids="928">++</CheckRefs><CheckRefs ids="927">]</CheckRefs>;</Line>
  <Line number="3286">			msb = data_array[idx<CheckRefs ids="930">++</CheckRefs><CheckRefs ids="929">]</CheckRefs>;</Line>
  <Line number="3287">			msblsb = <CheckRefs ids="931">(</CheckRefs>int16_t)((<CheckRefs ids="935">msb</CheckRefs> <CheckRefs ids="932,933,934">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="936">lsb</CheckRefs>);</Line>
  <Line number="3288">			gyro-&gt;z = msblsb; /* gyro Z axis data */</Line>
  <Line number="3289"></Line>
  <Line number="3290">			idx = <CheckRefs ids="939">idx</CheckRefs> <CheckRefs ids="938,937">+</CheckRefs> 6;</Line>
  <Line number="3291">			time_0 = data_array[idx<CheckRefs ids="941">++</CheckRefs><CheckRefs ids="940">]</CheckRefs>;</Line>
  <Line number="3292">			time_1 = <CheckRefs ids="942">(</CheckRefs>uint16_t)(<CheckRefs ids="946">data_array</CheckRefs>[idx<CheckRefs ids="948">++</CheckRefs><CheckRefs ids="947">]</CheckRefs> <CheckRefs ids="943,944,945">&lt;&lt;</CheckRefs> 8);</Line>
  <Line number="3293">			time_2 = <CheckRefs ids="949">(</CheckRefs>uint32_t)(<CheckRefs ids="953">data_array</CheckRefs>[idx<CheckRefs ids="955">++</CheckRefs><CheckRefs ids="954">]</CheckRefs> <CheckRefs ids="950,951,952">&lt;&lt;</CheckRefs> 16);</Line>
  <Line number="3294">			gyro-&gt;sensortime = (uint32_t)(time_2 | <CheckRefs ids="956">time_1</CheckRefs> | <CheckRefs ids="957">time_0</CheckRefs>);</Line>
  <Line number="3295"></Line>
  <Line number="3296">		} else {</Line>
  <Line number="3297">			rslt = <CheckRefs ids="958,959">BMI160_E_COM_FAIL</CheckRefs>;</Line>
  <Line number="3298">		}</Line>
  <Line number="3299">	}</Line>
  <Line number="3300"></Line>
  <Line number="3301">	return rslt;</Line>
  <Line number="3302">}</Line>
  <Line number="3303"></Line>
  <Line number="3304">/*!</Line>
  <Line number="3305"> * @brief This API reads accel and gyro data along with sensor time</Line>
  <Line number="3306"> * if time is requested by user.</Line>
  <Line number="3307"> *  Kindly refer the user guide(README.md) for more info.</Line>
  <Line number="3308"> */</Line>
  <Line number="3309">static int8_t get_accel_gyro_data(uint8_t len, struct bmi160_sensor_data *accel, struct bmi160_sensor_data *gyro,</Line>
  <Line number="3310">					const struct bmi160_dev *dev)</Line>
  <Line number="3311">{ INIT_STUBS(dev);</Line>
  <Line number="3312">	int8_t rslt;</Line>
  <Line number="3313">	uint8_t idx = <CheckRefs ids="960">0</CheckRefs>;</Line>
  <Line number="3314">	uint8_t data_array[15] = {<CheckRefs ids="961">0</CheckRefs>};</Line>
  <Line number="3315">	uint8_t time_0 = <CheckRefs ids="962">0</CheckRefs>;</Line>
  <Line number="3316">	uint16_t time_1 = <CheckRefs ids="963">0</CheckRefs>;</Line>
  <Line number="3317">	uint32_t time_2 = <CheckRefs ids="964">0</CheckRefs>;</Line>
  <Line number="3318">	uint8_t lsb;</Line>
  <Line number="3319">	uint8_t msb;</Line>
  <Line number="3320">	int16_t msblsb;</Line>
  <Line number="3321"></Line>
  <Line number="3322">	/* read both accel and gyro sensor data</Line>
  <Line number="3323">	 * along with time if requested */</Line>
  <Line number="3324">	rslt = bmi160_get_regs(<CheckRefs ids="965">BMI160_GYRO_DATA_ADDR</CheckRefs>, data_array, 12 <CheckRefs ids="966,967">+</CheckRefs> <CheckRefs ids="968">len</CheckRefs>, dev);</Line>
  <Line number="3325">	if (<CheckRefs ids="969">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3326">		/* Gyro Data */</Line>
  <Line number="3327">		lsb = data_array[idx<CheckRefs ids="971">++</CheckRefs><CheckRefs ids="970">]</CheckRefs>;</Line>
  <Line number="3328">		msb = data_array[idx<CheckRefs ids="973">++</CheckRefs><CheckRefs ids="972">]</CheckRefs>;</Line>
  <Line number="3329">		msblsb = <CheckRefs ids="974">(</CheckRefs>int16_t)((<CheckRefs ids="978">msb</CheckRefs> <CheckRefs ids="975,976,977">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="979">lsb</CheckRefs>);</Line>
  <Line number="3330">		gyro-&gt;x = msblsb; /* gyro X axis data */</Line>
  <Line number="3331"></Line>
  <Line number="3332">		lsb = data_array[idx<CheckRefs ids="981">++</CheckRefs><CheckRefs ids="980">]</CheckRefs>;</Line>
  <Line number="3333">		msb = data_array[idx<CheckRefs ids="983">++</CheckRefs><CheckRefs ids="982">]</CheckRefs>;</Line>
  <Line number="3334">		msblsb = <CheckRefs ids="984">(</CheckRefs>int16_t)((<CheckRefs ids="988">msb</CheckRefs> <CheckRefs ids="985,986,987">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="989">lsb</CheckRefs>);</Line>
  <Line number="3335">		gyro-&gt;y = msblsb; /* gyro Y axis data */</Line>
  <Line number="3336"></Line>
  <Line number="3337">		lsb = data_array[idx<CheckRefs ids="991">++</CheckRefs><CheckRefs ids="990">]</CheckRefs>;</Line>
  <Line number="3338">		msb = data_array[idx<CheckRefs ids="993">++</CheckRefs><CheckRefs ids="992">]</CheckRefs>;</Line>
  <Line number="3339">		msblsb = <CheckRefs ids="994">(</CheckRefs>int16_t)((<CheckRefs ids="998">msb</CheckRefs> <CheckRefs ids="995,996,997">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="999">lsb</CheckRefs>);</Line>
  <Line number="3340">		gyro-&gt;z = msblsb; /* gyro Z axis data */</Line>
  <Line number="3341"></Line>
  <Line number="3342">		/* Accel Data */</Line>
  <Line number="3343">		lsb = data_array[idx<CheckRefs ids="1001">++</CheckRefs><CheckRefs ids="1000">]</CheckRefs>;</Line>
  <Line number="3344">		msb = data_array[idx<CheckRefs ids="1003">++</CheckRefs><CheckRefs ids="1002">]</CheckRefs>;</Line>
  <Line number="3345">		msblsb = <CheckRefs ids="1004">(</CheckRefs>int16_t)((<CheckRefs ids="1008">msb</CheckRefs> <CheckRefs ids="1005,1006,1007">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="1009">lsb</CheckRefs>);</Line>
  <Line number="3346">		accel-&gt;x = (int16_t)msblsb; /* accel X axis data */</Line>
  <Line number="3347"></Line>
  <Line number="3348">		lsb = data_array[idx<CheckRefs ids="1011">++</CheckRefs><CheckRefs ids="1010">]</CheckRefs>;</Line>
  <Line number="3349">		msb = data_array[idx<CheckRefs ids="1013">++</CheckRefs><CheckRefs ids="1012">]</CheckRefs>;</Line>
  <Line number="3350">		msblsb = <CheckRefs ids="1014">(</CheckRefs>int16_t)((<CheckRefs ids="1018">msb</CheckRefs> <CheckRefs ids="1015,1016,1017">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="1019">lsb</CheckRefs>);</Line>
  <Line number="3351">		accel-&gt;y = (int16_t)msblsb; /* accel Y axis data */</Line>
  <Line number="3352"></Line>
  <Line number="3353">		lsb = data_array[idx<CheckRefs ids="1021">++</CheckRefs><CheckRefs ids="1020">]</CheckRefs>;</Line>
  <Line number="3354">		msb = data_array[idx<CheckRefs ids="1023">++</CheckRefs><CheckRefs ids="1022">]</CheckRefs>;</Line>
  <Line number="3355">		msblsb = <CheckRefs ids="1024">(</CheckRefs>int16_t)((<CheckRefs ids="1028">msb</CheckRefs> <CheckRefs ids="1025,1026,1027">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="1029">lsb</CheckRefs>);</Line>
  <Line number="3356">		accel-&gt;z = (int16_t)msblsb; /* accel Z axis data */</Line>
  <Line number="3357"></Line>
  <Line number="3358">		if (<CheckRefs ids="1030">len</CheckRefs> == 3) {</Line>
  <Line number="3359">			time_0 = data_array[idx<CheckRefs ids="1032">++</CheckRefs><CheckRefs ids="1031">]</CheckRefs>;</Line>
  <Line number="3360">			time_1 = <CheckRefs ids="1033">(</CheckRefs>uint16_t)(<CheckRefs ids="1037">data_array</CheckRefs>[idx<CheckRefs ids="1039">++</CheckRefs><CheckRefs ids="1038">]</CheckRefs> <CheckRefs ids="1034,1035,1036">&lt;&lt;</CheckRefs> 8);</Line>
  <Line number="3361">			time_2 = <CheckRefs ids="1040">(</CheckRefs>uint32_t)(<CheckRefs ids="1044">data_array</CheckRefs>[idx<CheckRefs ids="1046">++</CheckRefs><CheckRefs ids="1045">]</CheckRefs> <CheckRefs ids="1041,1042,1043">&lt;&lt;</CheckRefs> 16);</Line>
  <Line number="3362">			accel-&gt;sensortime = (uint32_t)(time_2 | <CheckRefs ids="1047">time_1</CheckRefs> | <CheckRefs ids="1048">time_0</CheckRefs>);</Line>
  <Line number="3363">			gyro-&gt;sensortime = (uint32_t)(time_2 | <CheckRefs ids="1049">time_1</CheckRefs> | <CheckRefs ids="1050">time_0</CheckRefs>);</Line>
  <Line number="3364">		} else {</Line>
  <Line number="3365">			accel-&gt;sensortime = <CheckRefs ids="1051">0</CheckRefs>;</Line>
  <Line number="3366">			gyro-&gt;sensortime = <CheckRefs ids="1052">0</CheckRefs>;</Line>
  <Line number="3367">		}</Line>
  <Line number="3368">	} else {</Line>
  <Line number="3369">		rslt = <CheckRefs ids="1053,1054">BMI160_E_COM_FAIL</CheckRefs>;</Line>
  <Line number="3370">	}</Line>
  <Line number="3371"></Line>
  <Line number="3372">	return rslt;</Line>
  <Line number="3373">}</Line>
  <Line number="3374"></Line>
  <Line number="3375">/*!</Line>
  <Line number="3376"> * @brief This API enables the any-motion interrupt for accel.</Line>
  <Line number="3377"> */</Line>
  <Line number="3378">static int8_t enable_accel_any_motion_int(const struct bmi160_acc_any_mot_int_cfg *any_motion_int_cfg,</Line>
  <Line number="3379">						struct bmi160_dev *dev)</Line>
  <Line number="3380">{ INIT_STUBS(dev);</Line>
  <Line number="3381">	int8_t rslt;</Line>
  <Line number="3382">	uint8_t data = <CheckRefs ids="1055">0</CheckRefs>;</Line>
  <Line number="3383">	uint8_t temp = <CheckRefs ids="1056">0</CheckRefs>;</Line>
  <Line number="3384"></Line>
  <Line number="3385">	/* Enable any motion x, any motion y, any motion z</Line>
  <Line number="3386">	in Int Enable 0 register */</Line>
  <Line number="3387">	rslt = bmi160_get_regs(<CheckRefs ids="1057">BMI160_INT_ENABLE_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1058">1</CheckRefs>, dev);</Line>
  <Line number="3388">	if (<CheckRefs ids="1059">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3389"></Line>
  <Line number="3390">		if (<CheckRefs ids="1060">any_motion_int_cfg</CheckRefs>-&gt;anymotion_en == BMI160_ENABLE) {</Line>
  <Line number="3391">			temp = <CheckRefs ids="1062">data</CheckRefs> <CheckRefs ids="1061">&amp;</CheckRefs> ~BMI160_ANY_MOTION_X_INT_EN_MASK;</Line>
  <Line number="3392">			/* Adding Any_motion x axis */</Line>
  <Line number="3393">			data = <CheckRefs ids="1064">temp</CheckRefs> <CheckRefs ids="1063">|</CheckRefs> (<CheckRefs ids="1065">any_motion_int_cfg</CheckRefs>-&gt;anymotion_x &amp; BMI160_ANY_MOTION_X_INT_EN_MASK);</Line>
  <Line number="3394"></Line>
  <Line number="3395"></Line>
  <Line number="3396">			temp = <CheckRefs ids="1067">data</CheckRefs> <CheckRefs ids="1066">&amp;</CheckRefs> ~BMI160_ANY_MOTION_Y_INT_EN_MASK;</Line>
  <Line number="3397">			/* Adding Any_motion y axis */</Line>
  <Line number="3398">			data = <CheckRefs ids="1069">temp</CheckRefs> <CheckRefs ids="1068">|</CheckRefs> (<CheckRefs ids="1070">(</CheckRefs><CheckRefs ids="1074">any_motion_int_cfg</CheckRefs>-&gt;anymotion_y <CheckRefs ids="1071,1072,1073">&lt;&lt;</CheckRefs> 1) &amp; BMI160_ANY_MOTION_Y_INT_EN_MASK);</Line>
  <Line number="3399"></Line>
  <Line number="3400"></Line>
  <Line number="3401">			temp = <CheckRefs ids="1076">data</CheckRefs> <CheckRefs ids="1075">&amp;</CheckRefs> ~BMI160_ANY_MOTION_Z_INT_EN_MASK;</Line>
  <Line number="3402">			/* Adding Any_motion z axis */</Line>
  <Line number="3403">			data = <CheckRefs ids="1078">temp</CheckRefs> <CheckRefs ids="1077">|</CheckRefs> (<CheckRefs ids="1079">(</CheckRefs><CheckRefs ids="1083">any_motion_int_cfg</CheckRefs>-&gt;anymotion_z <CheckRefs ids="1080,1081,1082">&lt;&lt;</CheckRefs> 2) &amp; BMI160_ANY_MOTION_Z_INT_EN_MASK);</Line>
  <Line number="3404"></Line>
  <Line number="3405">			/* any-motion feature selected*/</Line>
  <Line number="3406">			dev-&gt;any_sig_sel = <CheckRefs ids="1084">BMI160_ANY_MOTION_ENABLED</CheckRefs>;</Line>
  <Line number="3407">		} else {</Line>
  <Line number="3408">			data = <CheckRefs ids="1086">data</CheckRefs> <CheckRefs ids="1085">&amp;</CheckRefs> ~BMI160_ANY_MOTION_ALL_INT_EN_MASK;</Line>
  <Line number="3409">			/* neither any-motion feature nor sig-motion selected */</Line>
  <Line number="3410">			dev-&gt;any_sig_sel = <CheckRefs ids="1087">BMI160_BOTH_ANY_SIG_MOTION_DISABLED</CheckRefs>;</Line>
  <Line number="3411">		}</Line>
  <Line number="3412"></Line>
  <Line number="3413">		/* write data to Int Enable 0 register */</Line>
  <Line number="3414">		rslt = bmi160_set_regs(<CheckRefs ids="1088">BMI160_INT_ENABLE_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1089">1</CheckRefs>, dev);</Line>
  <Line number="3415">	}</Line>
  <Line number="3416"></Line>
  <Line number="3417">	return rslt;</Line>
  <Line number="3418">}</Line>
  <Line number="3419"></Line>
  <Line number="3420">/*!</Line>
  <Line number="3421"> * @brief This API disable the sig-motion interrupt.</Line>
  <Line number="3422"> */</Line>
  <Line number="3423">static int8_t disable_sig_motion_int(const struct bmi160_dev *dev)</Line>
  <Line number="3424">{ INIT_STUBS(dev);</Line>
  <Line number="3425">	int8_t rslt;</Line>
  <Line number="3426">	uint8_t data = <CheckRefs ids="1090">0</CheckRefs>;</Line>
  <Line number="3427">	uint8_t temp = <CheckRefs ids="1091">0</CheckRefs>;</Line>
  <Line number="3428"></Line>
  <Line number="3429">	/* Disabling Significant motion interrupt if enabled */</Line>
  <Line number="3430">	rslt = bmi160_get_regs(<CheckRefs ids="1092">BMI160_INT_MOTION_3_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1093">1</CheckRefs>, dev);</Line>
  <Line number="3431">	if (<CheckRefs ids="1094">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3432">		temp = <CheckRefs ids="1095">(</CheckRefs><CheckRefs ids="1096">data</CheckRefs> &amp; BMI160_SIG_MOTION_SEL_MASK);</Line>
  <Line number="3433">		if (temp) {</Line>
  <Line number="3434">			temp = <CheckRefs ids="1098">data</CheckRefs> <CheckRefs ids="1097">&amp;</CheckRefs> ~BMI160_SIG_MOTION_SEL_MASK;</Line>
  <Line number="3435">			data = temp;</Line>
  <Line number="3436">			/* Write data to register */</Line>
  <Line number="3437">			rslt = bmi160_set_regs(<CheckRefs ids="1099">BMI160_INT_MOTION_3_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1100">1</CheckRefs>, dev);</Line>
  <Line number="3438">		}</Line>
  <Line number="3439">	}</Line>
  <Line number="3440">	return rslt;</Line>
  <Line number="3441">}</Line>
  <Line number="3442"></Line>
  <Line number="3443">/*!</Line>
  <Line number="3444"> *  @brief This API is used to map/unmap the Any/Sig motion, Step det/Low-g,</Line>
  <Line number="3445"> *  Double tap, Single tap, Orientation, Flat, High-G, Nomotion interrupt pins.</Line>
  <Line number="3446"> */</Line>
  <Line number="3447">static int8_t map_feature_interrupt(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="3448">{ INIT_STUBS(dev);</Line>
  <Line number="3449">	int8_t rslt;</Line>
  <Line number="3450">	uint8_t data[3] = {<CheckRefs ids="1101">0</CheckRefs>, <CheckRefs ids="1102">0</CheckRefs>, <CheckRefs ids="1103">0</CheckRefs>};</Line>
  <Line number="3451">	uint8_t temp[3] = {<CheckRefs ids="1104">0</CheckRefs>, <CheckRefs ids="1105">0</CheckRefs>, <CheckRefs ids="1106">0</CheckRefs>};</Line>
  <Line number="3452"></Line>
  <Line number="3453">	rslt = bmi160_get_regs(<CheckRefs ids="1107">BMI160_INT_MAP_0_ADDR</CheckRefs>, data, <CheckRefs ids="1108">3</CheckRefs>, dev);</Line>
  <Line number="3454"></Line>
  <Line number="3455">	if (<CheckRefs ids="1109">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3456">		temp[0<CheckRefs ids="1110">]</CheckRefs> = <CheckRefs ids="1112">data</CheckRefs>[0<CheckRefs ids="1113">]</CheckRefs> <CheckRefs ids="1111">&amp;</CheckRefs> ~<CheckRefs ids="1114">int_mask_lookup_table</CheckRefs>[int_config-&gt;int_type<CheckRefs ids="1115">]</CheckRefs>;</Line>
  <Line number="3457">		temp[2<CheckRefs ids="1116">]</CheckRefs> = <CheckRefs ids="1118">data</CheckRefs>[2<CheckRefs ids="1119">]</CheckRefs> <CheckRefs ids="1117">&amp;</CheckRefs> ~<CheckRefs ids="1120">int_mask_lookup_table</CheckRefs>[int_config-&gt;int_type<CheckRefs ids="1121">]</CheckRefs>;</Line>
  <Line number="3458"></Line>
  <Line number="3459">		switch (<CheckRefs ids="1122">int_config</CheckRefs>-&gt;int_channel) {</Line>
  <Line number="3460">		case <CheckRefs ids="1123">BMI160_INT_CHANNEL_NONE</CheckRefs>:</Line>
  <Line number="3461">			data[0<CheckRefs ids="1124">]</CheckRefs> = temp[0<CheckRefs ids="1125">]</CheckRefs>;</Line>
  <Line number="3462">			data[2<CheckRefs ids="1126">]</CheckRefs> = temp[2<CheckRefs ids="1127">]</CheckRefs>;</Line>
  <Line number="3463">			break;</Line>
  <Line number="3464">		case <CheckRefs ids="1128">BMI160_INT_CHANNEL_1</CheckRefs>:</Line>
  <Line number="3465">			data[0<CheckRefs ids="1129">]</CheckRefs> = <CheckRefs ids="1131">temp</CheckRefs>[0<CheckRefs ids="1132">]</CheckRefs> <CheckRefs ids="1130">|</CheckRefs> <CheckRefs ids="1133">int_mask_lookup_table</CheckRefs>[int_config-&gt;int_type<CheckRefs ids="1134">]</CheckRefs>;</Line>
  <Line number="3466">			data[2<CheckRefs ids="1135">]</CheckRefs> = temp[2<CheckRefs ids="1136">]</CheckRefs>;</Line>
  <Line number="3467">			break;</Line>
  <Line number="3468">		case <CheckRefs ids="1137">BMI160_INT_CHANNEL_2</CheckRefs>:</Line>
  <Line number="3469">			data[2<CheckRefs ids="1138">]</CheckRefs> = <CheckRefs ids="1140">temp</CheckRefs>[2<CheckRefs ids="1141">]</CheckRefs> <CheckRefs ids="1139">|</CheckRefs> <CheckRefs ids="1142">int_mask_lookup_table</CheckRefs>[int_config-&gt;int_type<CheckRefs ids="1143">]</CheckRefs>;</Line>
  <Line number="3470">			data[0<CheckRefs ids="1144">]</CheckRefs> = temp[0<CheckRefs ids="1145">]</CheckRefs>;</Line>
  <Line number="3471">			break;</Line>
  <Line number="3472">		case <CheckRefs ids="1146">BMI160_INT_CHANNEL_BOTH</CheckRefs>:</Line>
  <Line number="3473">			data[0<CheckRefs ids="1147">]</CheckRefs> = <CheckRefs ids="1149">temp</CheckRefs>[0<CheckRefs ids="1150">]</CheckRefs> <CheckRefs ids="1148">|</CheckRefs> <CheckRefs ids="1151">int_mask_lookup_table</CheckRefs>[int_config-&gt;int_type<CheckRefs ids="1152">]</CheckRefs>;</Line>
  <Line number="3474">			data[2<CheckRefs ids="1153">]</CheckRefs> = <CheckRefs ids="1155">temp</CheckRefs>[2<CheckRefs ids="1156">]</CheckRefs> <CheckRefs ids="1154">|</CheckRefs> <CheckRefs ids="1157">int_mask_lookup_table</CheckRefs>[int_config-&gt;int_type<CheckRefs ids="1158">]</CheckRefs>;</Line>
  <Line number="3475">			break;</Line>
  <Line number="3476">		default:</Line>
  <Line number="3477">			rslt = <CheckRefs ids="1159,1160">BMI160_E_OUT_OF_RANGE</CheckRefs>;</Line>
  <Line number="3478">		}</Line>
  <Line number="3479">		if (<CheckRefs ids="1161">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="3480">			rslt = bmi160_set_regs(<CheckRefs ids="1162">BMI160_INT_MAP_0_ADDR</CheckRefs>, data, <CheckRefs ids="1163">3</CheckRefs>, dev);</Line>
  <Line number="3481">	}</Line>
  <Line number="3482"></Line>
  <Line number="3483">	return rslt;</Line>
  <Line number="3484">}</Line>
  <Line number="3485"></Line>
  <Line number="3486">/*!</Line>
  <Line number="3487"> *  @brief This API is used to map/unmap the Dataready(Accel &amp; Gyro), FIFO full</Line>
  <Line number="3488"> *  and FIFO watermark interrupt.</Line>
  <Line number="3489"> */</Line>
  <Line number="3490">static int8_t map_hardware_interrupt(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="3491">{ INIT_STUBS(dev);</Line>
  <Line number="3492">	int8_t rslt;</Line>
  <Line number="3493">	uint8_t data = <CheckRefs ids="1164">0</CheckRefs>;</Line>
  <Line number="3494">	uint8_t temp = <CheckRefs ids="1165">0</CheckRefs>;</Line>
  <Line number="3495"></Line>
  <Line number="3496">	rslt = bmi160_get_regs(<CheckRefs ids="1166">BMI160_INT_MAP_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1167">1</CheckRefs>, dev);</Line>
  <Line number="3497"></Line>
  <Line number="3498">	if (<CheckRefs ids="1168">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3499">		temp = <CheckRefs ids="1170">data</CheckRefs> <CheckRefs ids="1169">&amp;</CheckRefs> ~<CheckRefs ids="1171">int_mask_lookup_table</CheckRefs>[int_config-&gt;int_type<CheckRefs ids="1172">]</CheckRefs>;</Line>
  <Line number="3500">		temp = <CheckRefs ids="1174">temp</CheckRefs> <CheckRefs ids="1173">&amp;</CheckRefs> ~<CheckRefs ids="1175">(</CheckRefs><CheckRefs ids="1176">(</CheckRefs>uint8_t)(<CheckRefs ids="1180">int_mask_lookup_table</CheckRefs>[int_config-&gt;int_type<CheckRefs ids="1181">]</CheckRefs> <CheckRefs ids="1177,1178,1179">&lt;&lt;</CheckRefs> 4));</Line>
  <Line number="3501">		switch (<CheckRefs ids="1182">int_config</CheckRefs>-&gt;int_channel) {</Line>
  <Line number="3502">		case <CheckRefs ids="1183">BMI160_INT_CHANNEL_NONE</CheckRefs>:</Line>
  <Line number="3503">			data = temp;</Line>
  <Line number="3504">			break;</Line>
  <Line number="3505">		case <CheckRefs ids="1184">BMI160_INT_CHANNEL_1</CheckRefs>:</Line>
  <Line number="3506">			data = <CheckRefs ids="1186">temp</CheckRefs> <CheckRefs ids="1185">|</CheckRefs> <CheckRefs ids="1187,1188">(</CheckRefs>uint8_t)(<CheckRefs ids="1192">(</CheckRefs>int_mask_lookup_table[int_config-&gt;int_type<CheckRefs ids="1193">]</CheckRefs>) <CheckRefs ids="1189,1190,1191">&lt;&lt;</CheckRefs> 4);</Line>
  <Line number="3507">			break;</Line>
  <Line number="3508">		case <CheckRefs ids="1194">BMI160_INT_CHANNEL_2</CheckRefs>:</Line>
  <Line number="3509">			data = <CheckRefs ids="1196">temp</CheckRefs> <CheckRefs ids="1195">|</CheckRefs> <CheckRefs ids="1197">int_mask_lookup_table</CheckRefs>[int_config-&gt;int_type<CheckRefs ids="1198">]</CheckRefs>;</Line>
  <Line number="3510">			break;</Line>
  <Line number="3511">		case <CheckRefs ids="1199">BMI160_INT_CHANNEL_BOTH</CheckRefs>:</Line>
  <Line number="3512">			data = <CheckRefs ids="1201">temp</CheckRefs> <CheckRefs ids="1200">|</CheckRefs> <CheckRefs ids="1202">int_mask_lookup_table</CheckRefs>[int_config-&gt;int_type<CheckRefs ids="1203">]</CheckRefs>;</Line>
  <Line number="3513">			data = <CheckRefs ids="1205">data</CheckRefs> <CheckRefs ids="1204">|</CheckRefs> <CheckRefs ids="1206,1207">(</CheckRefs>uint8_t)(<CheckRefs ids="1211">(</CheckRefs>int_mask_lookup_table[int_config-&gt;int_type<CheckRefs ids="1212">]</CheckRefs>) <CheckRefs ids="1209,1208,1210">&lt;&lt;</CheckRefs> 4);</Line>
  <Line number="3514">			break;</Line>
  <Line number="3515">		default:</Line>
  <Line number="3516">			rslt = <CheckRefs ids="1213,1214">BMI160_E_OUT_OF_RANGE</CheckRefs>;</Line>
  <Line number="3517">		}</Line>
  <Line number="3518">		if (<CheckRefs ids="1215">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="3519">			rslt = bmi160_set_regs(<CheckRefs ids="1216">BMI160_INT_MAP_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1217">1</CheckRefs>, dev);</Line>
  <Line number="3520">	}</Line>
  <Line number="3521"></Line>
  <Line number="3522">	return rslt;</Line>
  <Line number="3523">}</Line>
  <Line number="3524"></Line>
  <Line number="3525">/*!</Line>
  <Line number="3526"> * @brief This API configure the source of data(filter &amp; pre-filter)</Line>
  <Line number="3527"> * for any-motion interrupt.</Line>
  <Line number="3528"> */</Line>
  <Line number="3529">static int8_t config_any_motion_src(const struct bmi160_acc_any_mot_int_cfg *any_motion_int_cfg,</Line>
  <Line number="3530">					const struct bmi160_dev *dev)</Line>
  <Line number="3531">{ INIT_STUBS(dev);</Line>
  <Line number="3532">	int8_t rslt;</Line>
  <Line number="3533">	uint8_t data = <CheckRefs ids="1218">0</CheckRefs>;</Line>
  <Line number="3534">	uint8_t temp = <CheckRefs ids="1219">0</CheckRefs>;</Line>
  <Line number="3535"></Line>
  <Line number="3536">	/* Configure Int data 1 register to add source of interrupt */</Line>
  <Line number="3537">	rslt = bmi160_get_regs(<CheckRefs ids="1220">BMI160_INT_DATA_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1221">1</CheckRefs>, dev);</Line>
  <Line number="3538">	if (<CheckRefs ids="1222">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3539">		temp = <CheckRefs ids="1224">data</CheckRefs> <CheckRefs ids="1223">&amp;</CheckRefs> ~BMI160_MOTION_SRC_INT_MASK;</Line>
  <Line number="3540">		data = <CheckRefs ids="1226">temp</CheckRefs> <CheckRefs ids="1225">|</CheckRefs> (<CheckRefs ids="1227">(</CheckRefs><CheckRefs ids="1231">any_motion_int_cfg</CheckRefs>-&gt;anymotion_data_src <CheckRefs ids="1228,1229,1230">&lt;&lt;</CheckRefs> 7) &amp; BMI160_MOTION_SRC_INT_MASK);</Line>
  <Line number="3541">		/* Write data to DATA 1 address */</Line>
  <Line number="3542">		rslt = bmi160_set_regs(<CheckRefs ids="1232">BMI160_INT_DATA_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1233">1</CheckRefs>, dev);</Line>
  <Line number="3543">	}</Line>
  <Line number="3544"></Line>
  <Line number="3545">	return rslt;</Line>
  <Line number="3546">}</Line>
  <Line number="3547"></Line>
  <Line number="3548">/*!</Line>
  <Line number="3549"> * @brief This API configure the duration and threshold of</Line>
  <Line number="3550"> * any-motion interrupt.</Line>
  <Line number="3551"> */</Line>
  <Line number="3552">static int8_t config_any_dur_threshold(const struct bmi160_acc_any_mot_int_cfg *any_motion_int_cfg,</Line>
  <Line number="3553">					const struct bmi160_dev *dev)</Line>
  <Line number="3554">{ INIT_STUBS(dev);</Line>
  <Line number="3555">	int8_t rslt;</Line>
  <Line number="3556">	uint8_t data = <CheckRefs ids="1234">0</CheckRefs>;</Line>
  <Line number="3557">	uint8_t temp = <CheckRefs ids="1235">0</CheckRefs>;</Line>
  <Line number="3558">	uint8_t data_array[2] = {<CheckRefs ids="1236">0</CheckRefs>};</Line>
  <Line number="3559">	uint8_t dur;</Line>
  <Line number="3560"></Line>
  <Line number="3561">	/* Configure Int Motion 0 register */</Line>
  <Line number="3562">	rslt = bmi160_get_regs(<CheckRefs ids="1237">BMI160_INT_MOTION_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1238">1</CheckRefs>, dev);</Line>
  <Line number="3563">	if (<CheckRefs ids="1239">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3564">		/* slope duration */</Line>
  <Line number="3565">		dur = (uint8_t)any_motion_int_cfg-&gt;anymotion_dur;</Line>
  <Line number="3566">		temp = <CheckRefs ids="1241">data</CheckRefs> <CheckRefs ids="1240">&amp;</CheckRefs> ~BMI160_SLOPE_INT_DUR_MASK;</Line>
  <Line number="3567">		data = <CheckRefs ids="1243">temp</CheckRefs> <CheckRefs ids="1242">|</CheckRefs> (<CheckRefs ids="1244">dur</CheckRefs> &amp; BMI160_MOTION_SRC_INT_MASK);</Line>
  <Line number="3568">		data_array[0<CheckRefs ids="1245">]</CheckRefs> = data;</Line>
  <Line number="3569">		/* add slope threshold */</Line>
  <Line number="3570">		data_array[1<CheckRefs ids="1246">]</CheckRefs> = any_motion_int_cfg-&gt;anymotion_thr;</Line>
  <Line number="3571"></Line>
  <Line number="3572">		/* INT MOTION 0 and INT MOTION 1 address lie consecutively,</Line>
  <Line number="3573">		hence writing data to respective registers at one go */</Line>
  <Line number="3574">		/* Writing to Int_motion 0 and</Line>
  <Line number="3575">		Int_motion 1 Address simultaneously */</Line>
  <Line number="3576">		rslt = bmi160_set_regs(<CheckRefs ids="1247">BMI160_INT_MOTION_0_ADDR</CheckRefs>, data_array, <CheckRefs ids="1248">2</CheckRefs>, dev);</Line>
  <Line number="3577">	}</Line>
  <Line number="3578"></Line>
  <Line number="3579">	return rslt;</Line>
  <Line number="3580">}</Line>
  <Line number="3581"></Line>
  <Line number="3582">/*!</Line>
  <Line number="3583"> * @brief This API configure necessary setting of any-motion interrupt.</Line>
  <Line number="3584"> */</Line>
  <Line number="3585">static int8_t config_any_motion_int_settg(const struct bmi160_int_settg *int_config,</Line>
  <Line number="3586">					const struct bmi160_acc_any_mot_int_cfg *any_motion_int_cfg,</Line>
  <Line number="3587">					const struct bmi160_dev *dev)</Line>
  <Line number="3588">{ INIT_STUBS(dev);</Line>
  <Line number="3589">	int8_t rslt;</Line>
  <Line number="3590">	/* Configure Interrupt pins */</Line>
  <Line number="3591">	rslt = set_intr_pin_config(int_config, dev);</Line>
  <Line number="3592">	if (<CheckRefs ids="1249">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3593">		rslt = disable_sig_motion_int(dev);</Line>
  <Line number="3594">		if (<CheckRefs ids="1250">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3595">			rslt = map_feature_interrupt(int_config, dev);</Line>
  <Line number="3596">			if (<CheckRefs ids="1251">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3597">				rslt = config_any_motion_src(any_motion_int_cfg, dev);</Line>
  <Line number="3598">				if (<CheckRefs ids="1252">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="3599">					rslt = config_any_dur_threshold(any_motion_int_cfg, dev);</Line>
  <Line number="3600">			}</Line>
  <Line number="3601">		}</Line>
  <Line number="3602">	}</Line>
  <Line number="3603"></Line>
  <Line number="3604">	return rslt;</Line>
  <Line number="3605">}</Line>
  <Line number="3606"></Line>
  <Line number="3607">/*!</Line>
  <Line number="3608"> * @brief This API enable the data ready interrupt.</Line>
  <Line number="3609"> */</Line>
  <Line number="3610">static int8_t enable_data_ready_int(const struct bmi160_dev *dev)</Line>
  <Line number="3611">{ INIT_STUBS(dev);</Line>
  <Line number="3612">	int8_t rslt;</Line>
  <Line number="3613">	uint8_t data = <CheckRefs ids="1253">0</CheckRefs>;</Line>
  <Line number="3614">	uint8_t temp = <CheckRefs ids="1254">0</CheckRefs>;</Line>
  <Line number="3615"></Line>
  <Line number="3616">	/* Enable data ready interrupt in Int Enable 1 register */</Line>
  <Line number="3617">	rslt = bmi160_get_regs(<CheckRefs ids="1255">BMI160_INT_ENABLE_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1256">1</CheckRefs>, dev);</Line>
  <Line number="3618">	if (<CheckRefs ids="1257">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3619">		temp = <CheckRefs ids="1259">data</CheckRefs> <CheckRefs ids="1258">&amp;</CheckRefs> ~BMI160_DATA_RDY_INT_EN_MASK;</Line>
  <Line number="3620">		data = <CheckRefs ids="1261">temp</CheckRefs> <CheckRefs ids="1260">|</CheckRefs> (<CheckRefs ids="1262">(</CheckRefs>1 <CheckRefs ids="1264,1265,1263">&lt;&lt;</CheckRefs> 4) &amp; BMI160_DATA_RDY_INT_EN_MASK);</Line>
  <Line number="3621">		/* Writing data to INT ENABLE 1 Address */</Line>
  <Line number="3622">		rslt = bmi160_set_regs(<CheckRefs ids="1266">BMI160_INT_ENABLE_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1267">1</CheckRefs>, dev);</Line>
  <Line number="3623">	}</Line>
  <Line number="3624"></Line>
  <Line number="3625">	return rslt;</Line>
  <Line number="3626">}</Line>
  <Line number="3627"></Line>
  <Line number="3628">/*!</Line>
  <Line number="3629"> * @brief This API enables the no motion/slow motion interrupt.</Line>
  <Line number="3630"> */</Line>
  <Line number="3631">static int8_t enable_no_motion_int(const struct bmi160_acc_no_motion_int_cfg *no_mot_int_cfg,</Line>
  <Line number="3632">					const struct bmi160_dev *dev)</Line>
  <Line number="3633">{ INIT_STUBS(dev);</Line>
  <Line number="3634">	int8_t rslt;</Line>
  <Line number="3635">	uint8_t data = <CheckRefs ids="1268">0</CheckRefs>;</Line>
  <Line number="3636">	uint8_t temp = <CheckRefs ids="1269">0</CheckRefs>;</Line>
  <Line number="3637">	/* Enable no motion x, no motion y, no motion z</Line>
  <Line number="3638">	in Int Enable 2 register */</Line>
  <Line number="3639">	rslt = bmi160_get_regs(<CheckRefs ids="1270">BMI160_INT_ENABLE_2_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1271">1</CheckRefs>, dev);</Line>
  <Line number="3640">	if (<CheckRefs ids="1272">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3641">		if (<CheckRefs ids="1273">no_mot_int_cfg</CheckRefs>-&gt;no_motion_x == 1) {</Line>
  <Line number="3642">			temp = <CheckRefs ids="1275">data</CheckRefs> <CheckRefs ids="1274">&amp;</CheckRefs> ~BMI160_NO_MOTION_X_INT_EN_MASK;</Line>
  <Line number="3643">			/* Adding No_motion x axis */</Line>
  <Line number="3644">			data = <CheckRefs ids="1277">temp</CheckRefs> <CheckRefs ids="1276">|</CheckRefs> (<CheckRefs ids="1278">1</CheckRefs> &amp; BMI160_NO_MOTION_X_INT_EN_MASK);</Line>
  <Line number="3645">		}</Line>
  <Line number="3646">		if (<CheckRefs ids="1279">no_mot_int_cfg</CheckRefs>-&gt;no_motion_y == 1) {</Line>
  <Line number="3647">			temp = <CheckRefs ids="1281">data</CheckRefs> <CheckRefs ids="1280">&amp;</CheckRefs> ~BMI160_NO_MOTION_Y_INT_EN_MASK;</Line>
  <Line number="3648">			/* Adding No_motion x axis */</Line>
  <Line number="3649">			data = <CheckRefs ids="1283">temp</CheckRefs> <CheckRefs ids="1282">|</CheckRefs> (<CheckRefs ids="1284">(</CheckRefs>1 <CheckRefs ids="1285,1286,1287">&lt;&lt;</CheckRefs> 1) &amp; BMI160_NO_MOTION_Y_INT_EN_MASK);</Line>
  <Line number="3650">		}</Line>
  <Line number="3651">		if (<CheckRefs ids="1288">no_mot_int_cfg</CheckRefs>-&gt;no_motion_z == 1) {</Line>
  <Line number="3652">			temp = <CheckRefs ids="1290">data</CheckRefs> <CheckRefs ids="1289">&amp;</CheckRefs> ~BMI160_NO_MOTION_Z_INT_EN_MASK;</Line>
  <Line number="3653">			/* Adding No_motion x axis */</Line>
  <Line number="3654">			data = <CheckRefs ids="1292">temp</CheckRefs> <CheckRefs ids="1291">|</CheckRefs> (<CheckRefs ids="1293">(</CheckRefs>1 <CheckRefs ids="1294,1295,1296">&lt;&lt;</CheckRefs> 2) &amp; BMI160_NO_MOTION_Z_INT_EN_MASK);</Line>
  <Line number="3655">		}</Line>
  <Line number="3656">		/* write data to Int Enable 2 register */</Line>
  <Line number="3657">		rslt = bmi160_set_regs(<CheckRefs ids="1297">BMI160_INT_ENABLE_2_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1298">1</CheckRefs>, dev);</Line>
  <Line number="3658">	}</Line>
  <Line number="3659"></Line>
  <Line number="3660">	return rslt;</Line>
  <Line number="3661">}</Line>
  <Line number="3662"></Line>
  <Line number="3663">/*!</Line>
  <Line number="3664"> * @brief This API configure the interrupt PIN setting for</Line>
  <Line number="3665"> * no motion/slow motion interrupt.</Line>
  <Line number="3666"> */</Line>
  <Line number="3667">static int8_t config_no_motion_int_settg(const struct bmi160_int_settg *int_config,</Line>
  <Line number="3668">					const struct bmi160_acc_no_motion_int_cfg *no_mot_int_cfg,</Line>
  <Line number="3669">					const struct bmi160_dev *dev)</Line>
  <Line number="3670">{ INIT_STUBS(dev);</Line>
  <Line number="3671">	int8_t rslt;</Line>
  <Line number="3672"></Line>
  <Line number="3673">	/* Configure Interrupt pins */</Line>
  <Line number="3674">	rslt = set_intr_pin_config(int_config, dev);</Line>
  <Line number="3675">	if (<CheckRefs ids="1299">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3676">		rslt = map_feature_interrupt(int_config, dev);</Line>
  <Line number="3677">		if (<CheckRefs ids="1300">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3678">			rslt = config_no_motion_data_src(no_mot_int_cfg, dev);</Line>
  <Line number="3679">			if (<CheckRefs ids="1301">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="3680">				rslt = config_no_motion_dur_thr(no_mot_int_cfg, dev);</Line>
  <Line number="3681">		}</Line>
  <Line number="3682">	}</Line>
  <Line number="3683"></Line>
  <Line number="3684">	return rslt;</Line>
  <Line number="3685">}</Line>
  <Line number="3686"></Line>
  <Line number="3687"></Line>
  <Line number="3688">/*!</Line>
  <Line number="3689"> * @brief This API configure the source of interrupt for no motion.</Line>
  <Line number="3690"> */</Line>
  <Line number="3691">static int8_t config_no_motion_data_src(const struct bmi160_acc_no_motion_int_cfg *no_mot_int_cfg,</Line>
  <Line number="3692">					const struct bmi160_dev *dev)</Line>
  <Line number="3693">{ INIT_STUBS(dev);</Line>
  <Line number="3694">	int8_t rslt;</Line>
  <Line number="3695">	uint8_t data = <CheckRefs ids="1302">0</CheckRefs>;</Line>
  <Line number="3696">	uint8_t temp = <CheckRefs ids="1303">0</CheckRefs>;</Line>
  <Line number="3697"></Line>
  <Line number="3698">	/* Configure Int data 1 register to add source of interrupt */</Line>
  <Line number="3699">	rslt = bmi160_get_regs(<CheckRefs ids="1304">BMI160_INT_DATA_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1305">1</CheckRefs>, dev);</Line>
  <Line number="3700">	if (<CheckRefs ids="1306">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3701">		temp = <CheckRefs ids="1308">data</CheckRefs> <CheckRefs ids="1307">&amp;</CheckRefs> ~BMI160_MOTION_SRC_INT_MASK;</Line>
  <Line number="3702">		data = <CheckRefs ids="1310">temp</CheckRefs> <CheckRefs ids="1309">|</CheckRefs> (<CheckRefs ids="1311">(</CheckRefs><CheckRefs ids="1315">no_mot_int_cfg</CheckRefs>-&gt;no_motion_src <CheckRefs ids="1312,1313,1314">&lt;&lt;</CheckRefs> 7) &amp; BMI160_MOTION_SRC_INT_MASK);</Line>
  <Line number="3703">		/* Write data to DATA 1 address */</Line>
  <Line number="3704">		rslt = bmi160_set_regs(<CheckRefs ids="1316">BMI160_INT_DATA_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1317">1</CheckRefs>, dev);</Line>
  <Line number="3705">	}</Line>
  <Line number="3706"></Line>
  <Line number="3707">	return rslt;</Line>
  <Line number="3708">}</Line>
  <Line number="3709"></Line>
  <Line number="3710">/*!</Line>
  <Line number="3711"> * @brief This API configure the duration and threshold of</Line>
  <Line number="3712"> * no motion/slow motion interrupt along with selection of no/slow motion.</Line>
  <Line number="3713"> */</Line>
  <Line number="3714">static int8_t config_no_motion_dur_thr(const struct bmi160_acc_no_motion_int_cfg *no_mot_int_cfg,</Line>
  <Line number="3715">					const struct bmi160_dev *dev)</Line>
  <Line number="3716">{ INIT_STUBS(dev);</Line>
  <Line number="3717">	int8_t rslt;</Line>
  <Line number="3718">	uint8_t data = <CheckRefs ids="1318">0</CheckRefs>;</Line>
  <Line number="3719">	uint8_t temp = <CheckRefs ids="1319">0</CheckRefs>;</Line>
  <Line number="3720">	uint8_t temp_1 = <CheckRefs ids="1320">0</CheckRefs>;</Line>
  <Line number="3721">	uint8_t reg_addr;</Line>
  <Line number="3722">	uint8_t data_array[2] = {<CheckRefs ids="1321">0</CheckRefs>};</Line>
  <Line number="3723"></Line>
  <Line number="3724">	/* Configuring INT_MOTION register */</Line>
  <Line number="3725">	reg_addr = <CheckRefs ids="1322">BMI160_INT_MOTION_0_ADDR</CheckRefs>;</Line>
  <Line number="3726">	rslt = bmi160_get_regs(reg_addr, &amp;data, <CheckRefs ids="1323">1</CheckRefs>, dev);</Line>
  <Line number="3727">	if (<CheckRefs ids="1324">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3728">		temp = <CheckRefs ids="1326">data</CheckRefs> <CheckRefs ids="1325">&amp;</CheckRefs> ~BMI160_NO_MOTION_INT_DUR_MASK;</Line>
  <Line number="3729">		/* Adding no_motion duration */</Line>
  <Line number="3730">		data = <CheckRefs ids="1328">temp</CheckRefs> <CheckRefs ids="1327">|</CheckRefs> (<CheckRefs ids="1329">(</CheckRefs><CheckRefs ids="1333">no_mot_int_cfg</CheckRefs>-&gt;no_motion_dur <CheckRefs ids="1331,1330,1332">&lt;&lt;</CheckRefs> 2) &amp; BMI160_NO_MOTION_INT_DUR_MASK);</Line>
  <Line number="3731">		/* Write data to NO_MOTION 0 address */</Line>
  <Line number="3732">		rslt = bmi160_set_regs(reg_addr, &amp;data, <CheckRefs ids="1334">1</CheckRefs>, dev);</Line>
  <Line number="3733">		if (<CheckRefs ids="1335">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3734">			reg_addr = <CheckRefs ids="1336">BMI160_INT_MOTION_3_ADDR</CheckRefs>;</Line>
  <Line number="3735">			rslt = bmi160_get_regs(reg_addr, &amp;data, <CheckRefs ids="1337">1</CheckRefs>, dev);</Line>
  <Line number="3736">			if (<CheckRefs ids="1338">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3737">				temp = <CheckRefs ids="1340">data</CheckRefs> <CheckRefs ids="1339">&amp;</CheckRefs> ~BMI160_NO_MOTION_SEL_BIT_MASK;</Line>
  <Line number="3738">				/* Adding no_motion_sel bit */</Line>
  <Line number="3739">				temp_1 = <CheckRefs ids="1341">(</CheckRefs><CheckRefs ids="1342">no_mot_int_cfg</CheckRefs>-&gt;no_motion_sel &amp; BMI160_NO_MOTION_SEL_BIT_MASK);</Line>
  <Line number="3740">				data = <CheckRefs ids="1343">(</CheckRefs><CheckRefs ids="1344">temp</CheckRefs> | <CheckRefs ids="1345">temp_1</CheckRefs>);</Line>
  <Line number="3741">				data_array[1<CheckRefs ids="1346">]</CheckRefs> = data;</Line>
  <Line number="3742">				/* Adding no motion threshold */</Line>
  <Line number="3743">				data_array[0<CheckRefs ids="1347">]</CheckRefs> = no_mot_int_cfg-&gt;no_motion_thres;</Line>
  <Line number="3744">				reg_addr = <CheckRefs ids="1348">BMI160_INT_MOTION_2_ADDR</CheckRefs>;</Line>
  <Line number="3745">				/* writing data to INT_MOTION 2 and INT_MOTION 3</Line>
  <Line number="3746">				 * address simultaneously */</Line>
  <Line number="3747">				rslt = bmi160_set_regs(reg_addr, data_array, <CheckRefs ids="1349">2</CheckRefs>, dev);</Line>
  <Line number="3748">			}</Line>
  <Line number="3749">		}</Line>
  <Line number="3750">	}</Line>
  <Line number="3751"></Line>
  <Line number="3752">	return rslt;</Line>
  <Line number="3753">}</Line>
  <Line number="3754"></Line>
  <Line number="3755">/*!</Line>
  <Line number="3756"> * @brief This API enables the sig-motion motion interrupt.</Line>
  <Line number="3757"> */</Line>
  <Line number="3758">static int8_t enable_sig_motion_int(const struct bmi160_acc_sig_mot_int_cfg *sig_mot_int_cfg, struct bmi160_dev *dev)</Line>
  <Line number="3759">{ INIT_STUBS(dev);</Line>
  <Line number="3760">	int8_t rslt;</Line>
  <Line number="3761">	uint8_t data = <CheckRefs ids="1350">0</CheckRefs>;</Line>
  <Line number="3762">	uint8_t temp = <CheckRefs ids="1351">0</CheckRefs>;</Line>
  <Line number="3763"></Line>
  <Line number="3764">	/* For significant motion,enable any motion x,any motion y,</Line>
  <Line number="3765">	 * any motion z in Int Enable 0 register */</Line>
  <Line number="3766">	rslt = bmi160_get_regs(<CheckRefs ids="1352">BMI160_INT_ENABLE_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1353">1</CheckRefs>, dev);</Line>
  <Line number="3767">	if (<CheckRefs ids="1354">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3768">		if (<CheckRefs ids="1355">sig_mot_int_cfg</CheckRefs>-&gt;sig_en == BMI160_ENABLE) {</Line>
  <Line number="3769">			temp = <CheckRefs ids="1357">data</CheckRefs> <CheckRefs ids="1356">&amp;</CheckRefs> ~BMI160_SIG_MOTION_INT_EN_MASK;</Line>
  <Line number="3770">			data = <CheckRefs ids="1359">temp</CheckRefs> <CheckRefs ids="1358">|</CheckRefs> (<CheckRefs ids="1360">7</CheckRefs> &amp; BMI160_SIG_MOTION_INT_EN_MASK);</Line>
  <Line number="3771">			/* sig-motion feature selected*/</Line>
  <Line number="3772">			dev-&gt;any_sig_sel = <CheckRefs ids="1361">BMI160_SIG_MOTION_ENABLED</CheckRefs>;</Line>
  <Line number="3773">		} else {</Line>
  <Line number="3774">			data = <CheckRefs ids="1363">data</CheckRefs> <CheckRefs ids="1362">&amp;</CheckRefs> ~BMI160_SIG_MOTION_INT_EN_MASK;</Line>
  <Line number="3775">			/* neither any-motion feature nor sig-motion selected */</Line>
  <Line number="3776">			dev-&gt;any_sig_sel = <CheckRefs ids="1364">BMI160_BOTH_ANY_SIG_MOTION_DISABLED</CheckRefs>;</Line>
  <Line number="3777">		}</Line>
  <Line number="3778">		/* write data to Int Enable 0 register */</Line>
  <Line number="3779">		rslt = bmi160_set_regs(<CheckRefs ids="1365">BMI160_INT_ENABLE_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1366">1</CheckRefs>, dev);</Line>
  <Line number="3780">	}</Line>
  <Line number="3781">	return rslt;</Line>
  <Line number="3782">}</Line>
  <Line number="3783"></Line>
  <Line number="3784">/*!</Line>
  <Line number="3785"> * @brief This API configure the interrupt PIN setting for</Line>
  <Line number="3786"> * significant motion interrupt.</Line>
  <Line number="3787"> */</Line>
  <Line number="3788">static int8_t config_sig_motion_int_settg(const struct bmi160_int_settg *int_config,</Line>
  <Line number="3789">					const struct bmi160_acc_sig_mot_int_cfg *sig_mot_int_cfg,</Line>
  <Line number="3790">					const struct bmi160_dev *dev)</Line>
  <Line number="3791">{ INIT_STUBS(dev);</Line>
  <Line number="3792">	int8_t rslt;</Line>
  <Line number="3793"></Line>
  <Line number="3794">	/* Configure Interrupt pins */</Line>
  <Line number="3795">	rslt = set_intr_pin_config(int_config, dev);</Line>
  <Line number="3796">	if (<CheckRefs ids="1367">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3797">		rslt = map_feature_interrupt(int_config, dev);</Line>
  <Line number="3798">		if (<CheckRefs ids="1368">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3799">			rslt = config_sig_motion_data_src(sig_mot_int_cfg, dev);</Line>
  <Line number="3800">			if (<CheckRefs ids="1369">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="3801">				rslt = config_sig_dur_threshold(sig_mot_int_cfg, dev);</Line>
  <Line number="3802">		}</Line>
  <Line number="3803">	}</Line>
  <Line number="3804"></Line>
  <Line number="3805">	return rslt;</Line>
  <Line number="3806">}</Line>
  <Line number="3807"></Line>
  <Line number="3808">/*!</Line>
  <Line number="3809"> * @brief This API configure the source of data(filter &amp; pre-filter)</Line>
  <Line number="3810"> * for sig motion interrupt.</Line>
  <Line number="3811"> */</Line>
  <Line number="3812">static int8_t config_sig_motion_data_src(const struct bmi160_acc_sig_mot_int_cfg *sig_mot_int_cfg,</Line>
  <Line number="3813">					const struct bmi160_dev *dev)</Line>
  <Line number="3814">{ INIT_STUBS(dev);</Line>
  <Line number="3815">	int8_t rslt;</Line>
  <Line number="3816">	uint8_t data = <CheckRefs ids="1370">0</CheckRefs>;</Line>
  <Line number="3817">	uint8_t temp = <CheckRefs ids="1371">0</CheckRefs>;</Line>
  <Line number="3818"></Line>
  <Line number="3819">	/* Configure Int data 1 register to add source of interrupt */</Line>
  <Line number="3820">	rslt = bmi160_get_regs(<CheckRefs ids="1372">BMI160_INT_DATA_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1373">1</CheckRefs>, dev);</Line>
  <Line number="3821">	if (<CheckRefs ids="1374">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3822">		temp = <CheckRefs ids="1376">data</CheckRefs> <CheckRefs ids="1375">&amp;</CheckRefs> ~BMI160_MOTION_SRC_INT_MASK;</Line>
  <Line number="3823">		data = <CheckRefs ids="1378">temp</CheckRefs> <CheckRefs ids="1377">|</CheckRefs> (<CheckRefs ids="1379">(</CheckRefs><CheckRefs ids="1383">sig_mot_int_cfg</CheckRefs>-&gt;sig_data_src <CheckRefs ids="1380,1381,1382">&lt;&lt;</CheckRefs> 7) &amp; BMI160_MOTION_SRC_INT_MASK);</Line>
  <Line number="3824">		/* Write data to DATA 1 address */</Line>
  <Line number="3825">		rslt = bmi160_set_regs(<CheckRefs ids="1384">BMI160_INT_DATA_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1385">1</CheckRefs>, dev);</Line>
  <Line number="3826">	}</Line>
  <Line number="3827"></Line>
  <Line number="3828">	return rslt;</Line>
  <Line number="3829">}</Line>
  <Line number="3830"></Line>
  <Line number="3831">/*!</Line>
  <Line number="3832"> * @brief This API configure the threshold, skip and proof time of</Line>
  <Line number="3833"> * sig motion interrupt.</Line>
  <Line number="3834"> */</Line>
  <Line number="3835">static int8_t config_sig_dur_threshold(const struct bmi160_acc_sig_mot_int_cfg *sig_mot_int_cfg,</Line>
  <Line number="3836">					const struct bmi160_dev *dev)</Line>
  <Line number="3837">{ INIT_STUBS(dev);</Line>
  <Line number="3838">	int8_t rslt;</Line>
  <Line number="3839">	uint8_t data;</Line>
  <Line number="3840">	uint8_t temp = <CheckRefs ids="1386">0</CheckRefs>;</Line>
  <Line number="3841"></Line>
  <Line number="3842">	/* Configuring INT_MOTION registers */</Line>
  <Line number="3843">	/* Write significant motion threshold.</Line>
  <Line number="3844">	 * This threshold is same as any motion threshold */</Line>
  <Line number="3845">	data = sig_mot_int_cfg-&gt;sig_mot_thres;</Line>
  <Line number="3846">	/* Write data to INT_MOTION 1 address */</Line>
  <Line number="3847">	rslt = bmi160_set_regs(<CheckRefs ids="1387">BMI160_INT_MOTION_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1388">1</CheckRefs>, dev);</Line>
  <Line number="3848">	if (<CheckRefs ids="1389">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3849">		rslt = bmi160_get_regs(<CheckRefs ids="1390">BMI160_INT_MOTION_3_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1391">1</CheckRefs>, dev);</Line>
  <Line number="3850">		if (<CheckRefs ids="1392">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3851">			temp = <CheckRefs ids="1394">data</CheckRefs> <CheckRefs ids="1393">&amp;</CheckRefs> ~BMI160_SIG_MOTION_SKIP_MASK;</Line>
  <Line number="3852">			/* adding skip time of sig_motion interrupt*/</Line>
  <Line number="3853">			data = <CheckRefs ids="1396">temp</CheckRefs> <CheckRefs ids="1395">|</CheckRefs> (<CheckRefs ids="1397">(</CheckRefs><CheckRefs ids="1401">sig_mot_int_cfg</CheckRefs>-&gt;sig_mot_skip <CheckRefs ids="1398,1399,1400">&lt;&lt;</CheckRefs> 2) &amp; BMI160_SIG_MOTION_SKIP_MASK);</Line>
  <Line number="3854">			temp = <CheckRefs ids="1403">data</CheckRefs> <CheckRefs ids="1402">&amp;</CheckRefs> ~BMI160_SIG_MOTION_PROOF_MASK;</Line>
  <Line number="3855">			 /* adding proof time of sig_motion interrupt */</Line>
  <Line number="3856">			data = <CheckRefs ids="1405">temp</CheckRefs> <CheckRefs ids="1404">|</CheckRefs> (<CheckRefs ids="1406">(</CheckRefs><CheckRefs ids="1410">sig_mot_int_cfg</CheckRefs>-&gt;sig_mot_proof <CheckRefs ids="1407,1408,1409">&lt;&lt;</CheckRefs> 4) &amp; BMI160_SIG_MOTION_PROOF_MASK);</Line>
  <Line number="3857">			/* configure the int_sig_mot_sel bit to select</Line>
  <Line number="3858">			 * significant motion interrupt */</Line>
  <Line number="3859">			temp = <CheckRefs ids="1412">data</CheckRefs> <CheckRefs ids="1411">&amp;</CheckRefs> ~BMI160_SIG_MOTION_SEL_MASK;</Line>
  <Line number="3860">			data = <CheckRefs ids="1414">temp</CheckRefs> <CheckRefs ids="1413">|</CheckRefs> (<CheckRefs ids="1415">(</CheckRefs><CheckRefs ids="1419">sig_mot_int_cfg</CheckRefs>-&gt;sig_en <CheckRefs ids="1417,1416,1418">&lt;&lt;</CheckRefs> 1) &amp; BMI160_SIG_MOTION_SEL_MASK);</Line>
  <Line number="3861"></Line>
  <Line number="3862">			rslt = bmi160_set_regs(<CheckRefs ids="1420">BMI160_INT_MOTION_3_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1421">1</CheckRefs>, dev);</Line>
  <Line number="3863">		}</Line>
  <Line number="3864">	}</Line>
  <Line number="3865">	return rslt;</Line>
  <Line number="3866">}</Line>
  <Line number="3867"></Line>
  <Line number="3868">/*!</Line>
  <Line number="3869"> * @brief This API enables the step detector interrupt.</Line>
  <Line number="3870"> */</Line>
  <Line number="3871">static int8_t enable_step_detect_int(const struct bmi160_acc_step_detect_int_cfg *step_detect_int_cfg,</Line>
  <Line number="3872">					const struct bmi160_dev *dev)</Line>
  <Line number="3873">{ INIT_STUBS(dev);</Line>
  <Line number="3874">	int8_t rslt;</Line>
  <Line number="3875">	uint8_t data = <CheckRefs ids="1422">0</CheckRefs>;</Line>
  <Line number="3876">	uint8_t temp = <CheckRefs ids="1423">0</CheckRefs>;</Line>
  <Line number="3877"></Line>
  <Line number="3878">	/* Enable data ready interrupt in Int Enable 2 register */</Line>
  <Line number="3879">	rslt = bmi160_get_regs(<CheckRefs ids="1424">BMI160_INT_ENABLE_2_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1425">1</CheckRefs>, dev);</Line>
  <Line number="3880">	if (<CheckRefs ids="1426">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3881">		temp = <CheckRefs ids="1428">data</CheckRefs> <CheckRefs ids="1427">&amp;</CheckRefs> ~BMI160_STEP_DETECT_INT_EN_MASK;</Line>
  <Line number="3882">		data = <CheckRefs ids="1430">temp</CheckRefs> <CheckRefs ids="1429">|</CheckRefs> (<CheckRefs ids="1431">(</CheckRefs><CheckRefs ids="1435">step_detect_int_cfg</CheckRefs>-&gt;step_detector_en <CheckRefs ids="1432,1433,1434">&lt;&lt;</CheckRefs> 3) &amp; BMI160_STEP_DETECT_INT_EN_MASK);</Line>
  <Line number="3883">		/* Writing data to INT ENABLE 2 Address */</Line>
  <Line number="3884">		rslt = bmi160_set_regs(<CheckRefs ids="1436">BMI160_INT_ENABLE_2_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1437">1</CheckRefs>, dev);</Line>
  <Line number="3885">	}</Line>
  <Line number="3886">	return rslt;</Line>
  <Line number="3887">}</Line>
  <Line number="3888"></Line>
  <Line number="3889">/*!</Line>
  <Line number="3890"> * @brief This API configure the step detector parameter.</Line>
  <Line number="3891"> */</Line>
  <Line number="3892">static int8_t config_step_detect(const struct bmi160_acc_step_detect_int_cfg *step_detect_int_cfg,</Line>
  <Line number="3893">				const struct bmi160_dev *dev)</Line>
  <Line number="3894">{ INIT_STUBS(dev);</Line>
  <Line number="3895">	int8_t rslt;</Line>
  <Line number="3896">	uint8_t temp = <CheckRefs ids="1438">0</CheckRefs>;</Line>
  <Line number="3897">	uint8_t data_array[2] = {<CheckRefs ids="1439">0</CheckRefs>};</Line>
  <Line number="3898"></Line>
  <Line number="3899"></Line>
  <Line number="3900">	if (<CheckRefs ids="1440">step_detect_int_cfg</CheckRefs>-&gt;step_detector_mode == BMI160_STEP_DETECT_NORMAL) {</Line>
  <Line number="3901">		/* Normal mode setting */</Line>
  <Line number="3902">		data_array[0<CheckRefs ids="1441">]</CheckRefs> = <CheckRefs ids="1442">0x15</CheckRefs>;</Line>
  <Line number="3903">		data_array[1<CheckRefs ids="1443">]</CheckRefs> = <CheckRefs ids="1444">0x03</CheckRefs>;</Line>
  <Line number="3904">	} else if (<CheckRefs ids="1445">step_detect_int_cfg</CheckRefs>-&gt;step_detector_mode == BMI160_STEP_DETECT_SENSITIVE) {</Line>
  <Line number="3905">		/* Sensitive mode setting */</Line>
  <Line number="3906">		data_array[0<CheckRefs ids="1446">]</CheckRefs> = <CheckRefs ids="1447">0x2D</CheckRefs>;</Line>
  <Line number="3907">		data_array[1<CheckRefs ids="1448">]</CheckRefs> = <CheckRefs ids="1449">0x00</CheckRefs>;</Line>
  <Line number="3908">	} else if (<CheckRefs ids="1450">step_detect_int_cfg</CheckRefs>-&gt;step_detector_mode == BMI160_STEP_DETECT_ROBUST) {</Line>
  <Line number="3909">		/* Robust mode setting */</Line>
  <Line number="3910">		data_array[0<CheckRefs ids="1451">]</CheckRefs> = <CheckRefs ids="1452">0x1D</CheckRefs>;</Line>
  <Line number="3911">		data_array[1<CheckRefs ids="1453">]</CheckRefs> = <CheckRefs ids="1454">0x07</CheckRefs>;</Line>
  <Line number="3912">	} else if (<CheckRefs ids="1455">step_detect_int_cfg</CheckRefs>-&gt;step_detector_mode == BMI160_STEP_DETECT_USER_DEFINE) {</Line>
  <Line number="3913">		/* Non recommended User defined setting */</Line>
  <Line number="3914">		/* Configuring STEP_CONFIG register */</Line>
  <Line number="3915">		rslt = bmi160_get_regs(<CheckRefs ids="1456">BMI160_INT_STEP_CONFIG_0_ADDR</CheckRefs>, &amp;data_array[0<CheckRefs ids="1457">]</CheckRefs>, <CheckRefs ids="1458">2</CheckRefs>, dev);</Line>
  <Line number="3916"></Line>
  <Line number="3917">		if (<CheckRefs ids="1459">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3918">			temp = <CheckRefs ids="1461">data_array</CheckRefs>[0<CheckRefs ids="1462">]</CheckRefs> <CheckRefs ids="1460">&amp;</CheckRefs> ~BMI160_STEP_DETECT_MIN_THRES_MASK;</Line>
  <Line number="3919">			/* Adding min_threshold */</Line>
  <Line number="3920">			data_array[0<CheckRefs ids="1463">]</CheckRefs> = <CheckRefs ids="1465">temp</CheckRefs> <CheckRefs ids="1464">|</CheckRefs> (<CheckRefs ids="1466">(</CheckRefs><CheckRefs ids="1470">step_detect_int_cfg</CheckRefs>-&gt;min_threshold <CheckRefs ids="1468,1467,1469">&lt;&lt;</CheckRefs> 3)</Line>
  <Line number="3921">					&amp; BMI160_STEP_DETECT_MIN_THRES_MASK);</Line>
  <Line number="3922"></Line>
  <Line number="3923">			temp = <CheckRefs ids="1472">data_array</CheckRefs>[0<CheckRefs ids="1473">]</CheckRefs> <CheckRefs ids="1471">&amp;</CheckRefs> ~BMI160_STEP_DETECT_STEPTIME_MIN_MASK;</Line>
  <Line number="3924">			/* Adding steptime_min */</Line>
  <Line number="3925">			data_array[0<CheckRefs ids="1474">]</CheckRefs> = <CheckRefs ids="1476">temp</CheckRefs> <CheckRefs ids="1475">|</CheckRefs> (<CheckRefs ids="1477">(</CheckRefs>step_detect_int_cfg-&gt;steptime_min)</Line>
  <Line number="3926">					&amp; BMI160_STEP_DETECT_STEPTIME_MIN_MASK);</Line>
  <Line number="3927"></Line>
  <Line number="3928">			temp = <CheckRefs ids="1479">data_array</CheckRefs>[1<CheckRefs ids="1480">]</CheckRefs> <CheckRefs ids="1478">&amp;</CheckRefs> ~BMI160_STEP_MIN_BUF_MASK;</Line>
  <Line number="3929">			/* Adding steptime_min */</Line>
  <Line number="3930">			data_array[1<CheckRefs ids="1481">]</CheckRefs> = <CheckRefs ids="1483">temp</CheckRefs> <CheckRefs ids="1482">|</CheckRefs> (<CheckRefs ids="1484">(</CheckRefs>step_detect_int_cfg-&gt;step_min_buf) &amp; BMI160_STEP_MIN_BUF_MASK);</Line>
  <Line number="3931"></Line>
  <Line number="3932">		}</Line>
  <Line number="3933">	}</Line>
  <Line number="3934"></Line>
  <Line number="3935">	/* Write data to STEP_CONFIG register */</Line>
  <Line number="3936">	rslt = bmi160_set_regs(<CheckRefs ids="1485">BMI160_INT_STEP_CONFIG_0_ADDR</CheckRefs>, data_array, <CheckRefs ids="1486">2</CheckRefs>, dev);</Line>
  <Line number="3937"></Line>
  <Line number="3938">	return rslt;</Line>
  <Line number="3939">}</Line>
  <Line number="3940"></Line>
  <Line number="3941">/*!</Line>
  <Line number="3942"> * @brief This API enables the single/double tap interrupt.</Line>
  <Line number="3943"> */</Line>
  <Line number="3944">static int8_t enable_tap_int(const struct bmi160_int_settg *int_config,</Line>
  <Line number="3945">				const struct bmi160_acc_tap_int_cfg *tap_int_cfg,</Line>
  <Line number="3946">				const struct bmi160_dev *dev)</Line>
  <Line number="3947">{ INIT_STUBS(dev);</Line>
  <Line number="3948">	int8_t rslt;</Line>
  <Line number="3949">	uint8_t data = <CheckRefs ids="1487">0</CheckRefs>;</Line>
  <Line number="3950">	uint8_t temp = <CheckRefs ids="1488">0</CheckRefs>;</Line>
  <Line number="3951"></Line>
  <Line number="3952">	/* Enable single tap or double tap interrupt in Int Enable 0 register */</Line>
  <Line number="3953">	rslt = bmi160_get_regs(<CheckRefs ids="1489">BMI160_INT_ENABLE_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1490">1</CheckRefs>, dev);</Line>
  <Line number="3954">	if (<CheckRefs ids="1491">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3955">		if (<CheckRefs ids="1492">int_config</CheckRefs>-&gt;int_type == <CheckRefs ids="1493">BMI160_ACC_SINGLE_TAP_INT</CheckRefs>) {</Line>
  <Line number="3956">			temp = <CheckRefs ids="1495">data</CheckRefs> <CheckRefs ids="1494">&amp;</CheckRefs> ~BMI160_SINGLE_TAP_INT_EN_MASK;</Line>
  <Line number="3957">			data = <CheckRefs ids="1497">temp</CheckRefs> <CheckRefs ids="1496">|</CheckRefs> (<CheckRefs ids="1498">(</CheckRefs><CheckRefs ids="1502">tap_int_cfg</CheckRefs>-&gt;tap_en <CheckRefs ids="1499,1500,1501">&lt;&lt;</CheckRefs> 5) &amp; BMI160_SINGLE_TAP_INT_EN_MASK);</Line>
  <Line number="3958">		} else {</Line>
  <Line number="3959">			temp = <CheckRefs ids="1504">data</CheckRefs> <CheckRefs ids="1503">&amp;</CheckRefs> ~BMI160_DOUBLE_TAP_INT_EN_MASK;</Line>
  <Line number="3960">			data = <CheckRefs ids="1506">temp</CheckRefs> <CheckRefs ids="1505">|</CheckRefs> (<CheckRefs ids="1507">(</CheckRefs><CheckRefs ids="1511">tap_int_cfg</CheckRefs>-&gt;tap_en <CheckRefs ids="1508,1509,1510">&lt;&lt;</CheckRefs> 4) &amp; BMI160_DOUBLE_TAP_INT_EN_MASK);</Line>
  <Line number="3961">		}</Line>
  <Line number="3962">		/* Write to Enable 0 Address */</Line>
  <Line number="3963">		rslt = bmi160_set_regs(<CheckRefs ids="1512">BMI160_INT_ENABLE_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1513">1</CheckRefs>, dev);</Line>
  <Line number="3964">	}</Line>
  <Line number="3965">	return rslt;</Line>
  <Line number="3966">}</Line>
  <Line number="3967"></Line>
  <Line number="3968">/*!</Line>
  <Line number="3969"> * @brief This API configure the interrupt PIN setting for</Line>
  <Line number="3970"> * tap interrupt.</Line>
  <Line number="3971"> */</Line>
  <Line number="3972">static int8_t config_tap_int_settg(const struct bmi160_int_settg *int_config,</Line>
  <Line number="3973">					const struct bmi160_acc_tap_int_cfg *tap_int_cfg,</Line>
  <Line number="3974">					const struct bmi160_dev *dev)</Line>
  <Line number="3975">{ INIT_STUBS(dev);</Line>
  <Line number="3976">	int8_t rslt;</Line>
  <Line number="3977"></Line>
  <Line number="3978">	/* Configure Interrupt pins */</Line>
  <Line number="3979">	rslt = set_intr_pin_config(int_config, dev);</Line>
  <Line number="3980">	if (<CheckRefs ids="1514">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3981">		rslt = map_feature_interrupt(int_config, dev);</Line>
  <Line number="3982">		if (<CheckRefs ids="1515">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="3983">			rslt = config_tap_data_src(tap_int_cfg, dev);</Line>
  <Line number="3984">			if (<CheckRefs ids="1516">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="3985">				rslt = config_tap_param(int_config, tap_int_cfg, dev);</Line>
  <Line number="3986">		}</Line>
  <Line number="3987">	}</Line>
  <Line number="3988"></Line>
  <Line number="3989">	return rslt;</Line>
  <Line number="3990">}</Line>
  <Line number="3991"></Line>
  <Line number="3992">/*!</Line>
  <Line number="3993"> * @brief This API configure the source of data(filter &amp; pre-filter)</Line>
  <Line number="3994"> * for tap interrupt.</Line>
  <Line number="3995"> */</Line>
  <Line number="3996">static int8_t config_tap_data_src(const struct bmi160_acc_tap_int_cfg *tap_int_cfg, const struct bmi160_dev *dev)</Line>
  <Line number="3997">{ INIT_STUBS(dev);</Line>
  <Line number="3998">	int8_t rslt;</Line>
  <Line number="3999">	uint8_t data = <CheckRefs ids="1517">0</CheckRefs>;</Line>
  <Line number="4000">	uint8_t temp = <CheckRefs ids="1518">0</CheckRefs>;</Line>
  <Line number="4001"></Line>
  <Line number="4002">	/* Configure Int data 0 register to add source of interrupt */</Line>
  <Line number="4003">	rslt = bmi160_get_regs(<CheckRefs ids="1519">BMI160_INT_DATA_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1520">1</CheckRefs>, dev);</Line>
  <Line number="4004">	if (<CheckRefs ids="1521">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4005">		temp = <CheckRefs ids="1523">data</CheckRefs> <CheckRefs ids="1522">&amp;</CheckRefs> ~BMI160_TAP_SRC_INT_MASK;</Line>
  <Line number="4006">		data = <CheckRefs ids="1525">temp</CheckRefs> <CheckRefs ids="1524">|</CheckRefs> (<CheckRefs ids="1526">(</CheckRefs><CheckRefs ids="1530">tap_int_cfg</CheckRefs>-&gt;tap_data_src <CheckRefs ids="1527,1528,1529">&lt;&lt;</CheckRefs> 3) &amp; BMI160_TAP_SRC_INT_MASK);</Line>
  <Line number="4007">		/* Write data to Data 0 address */</Line>
  <Line number="4008">		rslt = bmi160_set_regs(<CheckRefs ids="1531">BMI160_INT_DATA_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1532">1</CheckRefs>, dev);</Line>
  <Line number="4009">	}</Line>
  <Line number="4010"></Line>
  <Line number="4011">	return rslt;</Line>
  <Line number="4012">}</Line>
  <Line number="4013"></Line>
  <Line number="4014">/*!</Line>
  <Line number="4015"> * @brief This API configure the  parameters of tap interrupt.</Line>
  <Line number="4016"> * Threshold, quite, shock, and duration.</Line>
  <Line number="4017"> */</Line>
  <Line number="4018">static int8_t config_tap_param(const struct bmi160_int_settg *int_config,</Line>
  <Line number="4019">				const struct bmi160_acc_tap_int_cfg *tap_int_cfg,</Line>
  <Line number="4020">				const struct bmi160_dev *dev)</Line>
  <Line number="4021">{ INIT_STUBS(dev);</Line>
  <Line number="4022">	int8_t rslt;</Line>
  <Line number="4023">	uint8_t temp = <CheckRefs ids="1533">0</CheckRefs>;</Line>
  <Line number="4024">	uint8_t data = <CheckRefs ids="1534">0</CheckRefs>;</Line>
  <Line number="4025">	uint8_t data_array[2] = {<CheckRefs ids="1535">0</CheckRefs>};</Line>
  <Line number="4026">	uint8_t count = <CheckRefs ids="1536">0</CheckRefs>;</Line>
  <Line number="4027">	uint8_t dur, shock, quiet, thres;</Line>
  <Line number="4028"></Line>
  <Line number="4029">	/* Configure tap 0 register for tap shock,tap quiet duration</Line>
  <Line number="4030">	 * in case of single tap interrupt */</Line>
  <Line number="4031">	rslt = bmi160_get_regs(<CheckRefs ids="1537">BMI160_INT_TAP_0_ADDR</CheckRefs>, data_array, <CheckRefs ids="1538">2</CheckRefs>, dev);</Line>
  <Line number="4032">	if (<CheckRefs ids="1539">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4033">		data = data_array[count<CheckRefs ids="1540">]</CheckRefs>;</Line>
  <Line number="4034"></Line>
  <Line number="4035">		if (<CheckRefs ids="1541">int_config</CheckRefs>-&gt;int_type == <CheckRefs ids="1542">BMI160_ACC_DOUBLE_TAP_INT</CheckRefs>) {</Line>
  <Line number="4036">			dur  = <CheckRefs ids="1543">(</CheckRefs>uint8_t)tap_int_cfg-&gt;tap_dur;</Line>
  <Line number="4037">			temp = <CheckRefs ids="1544">(</CheckRefs><CheckRefs ids="1545">data</CheckRefs> &amp; ~BMI160_TAP_DUR_MASK);</Line>
  <Line number="4038">			/* Add tap duration data in case of</Line>
  <Line number="4039">			 * double tap interrupt */</Line>
  <Line number="4040">			data = <CheckRefs ids="1547">temp</CheckRefs> <CheckRefs ids="1546">|</CheckRefs> (<CheckRefs ids="1548">dur</CheckRefs> &amp; BMI160_TAP_DUR_MASK);</Line>
  <Line number="4041">		}</Line>
  <Line number="4042"></Line>
  <Line number="4043">		shock = <CheckRefs ids="1549">(</CheckRefs>uint8_t)tap_int_cfg-&gt;tap_shock;</Line>
  <Line number="4044">		temp = <CheckRefs ids="1551">data</CheckRefs> <CheckRefs ids="1550">&amp;</CheckRefs> ~BMI160_TAP_SHOCK_DUR_MASK;</Line>
  <Line number="4045">		data = <CheckRefs ids="1553">temp</CheckRefs> <CheckRefs ids="1552">|</CheckRefs> (<CheckRefs ids="1554">(</CheckRefs><CheckRefs ids="1558">shock</CheckRefs> <CheckRefs ids="1555,1556,1557">&lt;&lt;</CheckRefs> 6) &amp; BMI160_TAP_SHOCK_DUR_MASK);</Line>
  <Line number="4046"></Line>
  <Line number="4047">		quiet = <CheckRefs ids="1559">(</CheckRefs>uint8_t)tap_int_cfg-&gt;tap_quiet;</Line>
  <Line number="4048">		temp = <CheckRefs ids="1561">data</CheckRefs> <CheckRefs ids="1560">&amp;</CheckRefs> ~BMI160_TAP_QUIET_DUR_MASK;</Line>
  <Line number="4049">		data = <CheckRefs ids="1563">temp</CheckRefs> <CheckRefs ids="1562">|</CheckRefs> (<CheckRefs ids="1564">(</CheckRefs><CheckRefs ids="1568">quiet</CheckRefs> <CheckRefs ids="1565,1566,1567">&lt;&lt;</CheckRefs> 7) &amp; BMI160_TAP_QUIET_DUR_MASK);</Line>
  <Line number="4050"></Line>
  <Line number="4051">		data_array[count<CheckRefs ids="1570">++</CheckRefs><CheckRefs ids="1569">]</CheckRefs> = data;</Line>
  <Line number="4052"></Line>
  <Line number="4053">		data = data_array[count<CheckRefs ids="1571">]</CheckRefs>;</Line>
  <Line number="4054">		thres = <CheckRefs ids="1572">(</CheckRefs>uint8_t)tap_int_cfg-&gt;tap_thr;</Line>
  <Line number="4055">		temp = <CheckRefs ids="1574">data</CheckRefs> <CheckRefs ids="1573">&amp;</CheckRefs> ~BMI160_TAP_THRES_MASK;</Line>
  <Line number="4056">		data = <CheckRefs ids="1576">temp</CheckRefs> <CheckRefs ids="1575">|</CheckRefs> (<CheckRefs ids="1577">thres</CheckRefs> &amp; BMI160_TAP_THRES_MASK);</Line>
  <Line number="4057"></Line>
  <Line number="4058">		data_array[count<CheckRefs ids="1579">++</CheckRefs><CheckRefs ids="1578">]</CheckRefs> = data;</Line>
  <Line number="4059">		/* TAP 0 and TAP 1 address lie consecutively,</Line>
  <Line number="4060">		hence writing data to respective registers at one go */</Line>
  <Line number="4061">		/* Writing to Tap 0 and Tap 1 Address simultaneously */</Line>
  <Line number="4062">		rslt = bmi160_set_regs(<CheckRefs ids="1580">BMI160_INT_TAP_0_ADDR</CheckRefs>, data_array, <CheckRefs ids="1581">count</CheckRefs>, dev);</Line>
  <Line number="4063">	}</Line>
  <Line number="4064"></Line>
  <Line number="4065">	return rslt;</Line>
  <Line number="4066">}</Line>
  <Line number="4067"></Line>
  <Line number="4068">/*!</Line>
  <Line number="4069"> * @brief This API configure the secondary interface.</Line>
  <Line number="4070"> */</Line>
  <Line number="4071">static int8_t config_sec_if(const struct bmi160_dev *dev)</Line>
  <Line number="4072">{ INIT_STUBS(dev);</Line>
  <Line number="4073">	int8_t rslt;</Line>
  <Line number="4074">	uint8_t if_conf = <CheckRefs ids="1582">0</CheckRefs>;</Line>
  <Line number="4075">	uint8_t cmd = <CheckRefs ids="1583">BMI160_AUX_NORMAL_MODE</CheckRefs>;</Line>
  <Line number="4076"></Line>
  <Line number="4077">	/* set the aux power mode to normal*/</Line>
  <Line number="4078">	rslt = bmi160_set_regs(<CheckRefs ids="1584">BMI160_COMMAND_REG_ADDR</CheckRefs>, &amp;cmd, <CheckRefs ids="1585">1</CheckRefs>, dev);</Line>
  <Line number="4079">	if (<CheckRefs ids="1586">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4080">		dev-&gt;delay_ms(<CheckRefs ids="1587">60</CheckRefs>);</Line>
  <Line number="4081">		rslt = bmi160_get_regs(<CheckRefs ids="1588">BMI160_IF_CONF_ADDR</CheckRefs>, &amp;if_conf, <CheckRefs ids="1589">1</CheckRefs>, dev);</Line>
  <Line number="4082">		if_conf |= <CheckRefs ids="1591,1590">(</CheckRefs>uint8_t)(1 <CheckRefs ids="1592,1593,1594">&lt;&lt;</CheckRefs> 5);</Line>
  <Line number="4083">		if (<CheckRefs ids="1595">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="4084">			/*enable the secondary interface also*/</Line>
  <Line number="4085">			rslt = bmi160_set_regs(<CheckRefs ids="1596">BMI160_IF_CONF_ADDR</CheckRefs>, &amp;if_conf, <CheckRefs ids="1597">1</CheckRefs>, dev);</Line>
  <Line number="4086">	}</Line>
  <Line number="4087"></Line>
  <Line number="4088">	return rslt;</Line>
  <Line number="4089">}</Line>
  <Line number="4090"></Line>
  <Line number="4091">/*!</Line>
  <Line number="4092"> * @brief This API configure the ODR of the auxiliary sensor.</Line>
  <Line number="4093"> */</Line>
  <Line number="4094">static int8_t config_aux_odr(const struct bmi160_dev *dev)</Line>
  <Line number="4095">{ INIT_STUBS(dev);</Line>
  <Line number="4096">	int8_t rslt;</Line>
  <Line number="4097">	uint8_t aux_odr;</Line>
  <Line number="4098"></Line>
  <Line number="4099">	rslt = bmi160_get_regs(<CheckRefs ids="1598">BMI160_AUX_ODR_ADDR</CheckRefs>, &amp;aux_odr, <CheckRefs ids="1599">1</CheckRefs>, dev);</Line>
  <Line number="4100">	if (<CheckRefs ids="1600">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4101">		aux_odr = (uint8_t)(dev-&gt;aux_cfg.aux_odr);</Line>
  <Line number="4102">		/* Set the secondary interface ODR</Line>
  <Line number="4103">		   i.e polling rate of secondary sensor */</Line>
  <Line number="4104">		rslt = bmi160_set_regs(<CheckRefs ids="1601">BMI160_AUX_ODR_ADDR</CheckRefs>, &amp;aux_odr, <CheckRefs ids="1602">1</CheckRefs>, dev);</Line>
  <Line number="4105">		dev-&gt;delay_ms(BMI160_AUX_COM_DELAY);</Line>
  <Line number="4106">	}</Line>
  <Line number="4107"></Line>
  <Line number="4108">	return rslt;</Line>
  <Line number="4109">}</Line>
  <Line number="4110"></Line>
  <Line number="4111">/*!</Line>
  <Line number="4112"> * @brief This API maps the actual burst read length set by user.</Line>
  <Line number="4113"> */</Line>
  <Line number="4114">static int8_t map_read_len(uint16_t *len, const struct bmi160_dev *dev)</Line>
  <Line number="4115">{ INIT_STUBS(dev);</Line>
  <Line number="4116">	int8_t rslt = <CheckRefs ids="1603">BMI160_OK</CheckRefs>;</Line>
  <Line number="4117"></Line>
  <Line number="4118">	switch (<CheckRefs ids="1604">dev</CheckRefs>-&gt;aux_cfg.aux_rd_burst_len) {</Line>
  <Line number="4119"></Line>
  <Line number="4120">	case BMI160_AUX_READ_LEN_0:</Line>
  <Line number="4121">		*len = <CheckRefs ids="1605">1</CheckRefs>;</Line>
  <Line number="4122">		break;</Line>
  <Line number="4123">	case BMI160_AUX_READ_LEN_1:</Line>
  <Line number="4124">		*len = <CheckRefs ids="1606">2</CheckRefs>;</Line>
  <Line number="4125">		break;</Line>
  <Line number="4126">	case BMI160_AUX_READ_LEN_2:</Line>
  <Line number="4127">		*len = <CheckRefs ids="1607">6</CheckRefs>;</Line>
  <Line number="4128">		break;</Line>
  <Line number="4129">	case BMI160_AUX_READ_LEN_3:</Line>
  <Line number="4130">		*len = <CheckRefs ids="1608">8</CheckRefs>;</Line>
  <Line number="4131">		break;</Line>
  <Line number="4132">	default:</Line>
  <Line number="4133">		rslt = <CheckRefs ids="1609,1610">BMI160_E_INVALID_INPUT</CheckRefs>;</Line>
  <Line number="4134">		break;</Line>
  <Line number="4135">	}</Line>
  <Line number="4136"></Line>
  <Line number="4137">	return rslt;</Line>
  <Line number="4138">}</Line>
  <Line number="4139"></Line>
  <Line number="4140">/*!</Line>
  <Line number="4141"> * @brief This API configure the settings of auxiliary sensor.</Line>
  <Line number="4142"> */</Line>
  <Line number="4143">static int8_t config_aux_settg(const struct bmi160_dev *dev)</Line>
  <Line number="4144">{ INIT_STUBS(dev);</Line>
  <Line number="4145">	int8_t rslt;</Line>
  <Line number="4146"></Line>
  <Line number="4147">	rslt = config_sec_if(dev);</Line>
  <Line number="4148">	if (<CheckRefs ids="1611">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4149">		/* Configures the auxiliary interface settings */</Line>
  <Line number="4150">		rslt = bmi160_config_aux_mode(dev);</Line>
  <Line number="4151">	}</Line>
  <Line number="4152"></Line>
  <Line number="4153">	return rslt;</Line>
  <Line number="4154">}</Line>
  <Line number="4155"></Line>
  <Line number="4156">/*!</Line>
  <Line number="4157"> * @brief This API extract the read data from auxiliary sensor.</Line>
  <Line number="4158"> */</Line>
  <Line number="4159">static int8_t extract_aux_read(uint16_t map_len, uint8_t reg_addr, uint8_t *aux_data, uint16_t len,</Line>
  <Line number="4160">											const struct bmi160_dev *dev)</Line>
  <Line number="4161">{ INIT_STUBS(dev);</Line>
  <Line number="4162">	int8_t rslt = <CheckRefs ids="1612">BMI160_OK</CheckRefs>;</Line>
  <Line number="4163">	uint8_t data[8] = {<CheckRefs ids="1613">0</CheckRefs>,};</Line>
  <Line number="4164">	uint8_t read_addr = <CheckRefs ids="1614">BMI160_AUX_DATA_ADDR</CheckRefs>;</Line>
  <Line number="4165">	uint8_t count = <CheckRefs ids="1615">0</CheckRefs>;</Line>
  <Line number="4166">	uint8_t read_count;</Line>
  <Line number="4167">	uint8_t read_len = <CheckRefs ids="1616">(</CheckRefs>uint8_t)map_len;</Line>
  <Line number="4168"></Line>
  <Line number="4169">	for (; <CheckRefs ids="1617">count</CheckRefs> &lt; <CheckRefs ids="1618">len</CheckRefs>;) {</Line>
  <Line number="4170">		/* set address to read */</Line>
  <Line number="4171">		rslt = bmi160_set_regs(<CheckRefs ids="1619">BMI160_AUX_IF_2_ADDR</CheckRefs>, &amp;reg_addr, <CheckRefs ids="1620">1</CheckRefs>, dev);</Line>
  <Line number="4172">		dev-&gt;delay_ms(BMI160_AUX_COM_DELAY);</Line>
  <Line number="4173">		if (<CheckRefs ids="1621">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4174">			rslt = bmi160_get_regs(read_addr, data, map_len, dev);</Line>
  <Line number="4175">			if (<CheckRefs ids="1622">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4176">				read_count = <CheckRefs ids="1623">0</CheckRefs>;</Line>
  <Line number="4177">				/* if read len is less the burst read len</Line>
  <Line number="4178">				 * mention by user*/</Line>
  <Line number="4179">				if (<CheckRefs ids="1624">len</CheckRefs> &lt; <CheckRefs ids="1625">map_len</CheckRefs>) {</Line>
  <Line number="4180">					read_len = <CheckRefs ids="1626">(</CheckRefs>uint8_t)len;</Line>
  <Line number="4181">				} else {</Line>
  <Line number="4182">					if ((<CheckRefs ids="1628">len</CheckRefs> <CheckRefs ids="1627">-</CheckRefs> <CheckRefs ids="1629">count</CheckRefs>) &lt; <CheckRefs ids="1630">map_len</CheckRefs>)</Line>
  <Line number="4183">						read_len = <CheckRefs ids="1631">(</CheckRefs>uint8_t)(<CheckRefs ids="1633">len</CheckRefs> <CheckRefs ids="1632">-</CheckRefs> <CheckRefs ids="1634">count</CheckRefs>);</Line>
  <Line number="4184">				}</Line>
  <Line number="4185"></Line>
  <Line number="4186">				for (; <CheckRefs ids="1635">read_count</CheckRefs> &lt; <CheckRefs ids="1636">read_len</CheckRefs>; read_count<CheckRefs ids="1637">++</CheckRefs>)</Line>
  <Line number="4187">					aux_data[<CheckRefs ids="1639">count</CheckRefs> <CheckRefs ids="1638">+</CheckRefs> <CheckRefs ids="1640">read_count</CheckRefs>] = data[read_count<CheckRefs ids="1641">]</CheckRefs>;</Line>
  <Line number="4188"></Line>
  <Line number="4189">				reg_addr <CheckRefs ids="1642">+=</CheckRefs> <CheckRefs ids="1643,1644">(</CheckRefs>uint8_t)map_len;</Line>
  <Line number="4190">				count <CheckRefs ids="1645">+=</CheckRefs> <CheckRefs ids="1646,1647">(</CheckRefs>uint8_t)map_len;</Line>
  <Line number="4191">			} else {</Line>
  <Line number="4192">				rslt = <CheckRefs ids="1648,1649">BMI160_E_COM_FAIL</CheckRefs>;</Line>
  <Line number="4193">				break;</Line>
  <Line number="4194">			}</Line>
  <Line number="4195">		}</Line>
  <Line number="4196">	}</Line>
  <Line number="4197"></Line>
  <Line number="4198">	return rslt;</Line>
  <Line number="4199">}</Line>
  <Line number="4200"></Line>
  <Line number="4201">/*!</Line>
  <Line number="4202"> * @brief This API enables the orient interrupt.</Line>
  <Line number="4203"> */</Line>
  <Line number="4204">static int8_t enable_orient_int(const struct bmi160_acc_orient_int_cfg *orient_int_cfg, const struct bmi160_dev *dev)</Line>
  <Line number="4205">{ INIT_STUBS(dev);</Line>
  <Line number="4206">	int8_t rslt;</Line>
  <Line number="4207">	uint8_t data = <CheckRefs ids="1650">0</CheckRefs>;</Line>
  <Line number="4208">	uint8_t temp = <CheckRefs ids="1651">0</CheckRefs>;</Line>
  <Line number="4209"></Line>
  <Line number="4210">	/* Enable data ready interrupt in Int Enable 0 register */</Line>
  <Line number="4211">	rslt = bmi160_get_regs(<CheckRefs ids="1652">BMI160_INT_ENABLE_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1653">1</CheckRefs>, dev);</Line>
  <Line number="4212">	if (<CheckRefs ids="1654">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4213">		temp = <CheckRefs ids="1656">data</CheckRefs> <CheckRefs ids="1655">&amp;</CheckRefs> ~BMI160_ORIENT_INT_EN_MASK;</Line>
  <Line number="4214">		data = <CheckRefs ids="1658">temp</CheckRefs> <CheckRefs ids="1657">|</CheckRefs> (<CheckRefs ids="1659">(</CheckRefs><CheckRefs ids="1663">orient_int_cfg</CheckRefs>-&gt;orient_en <CheckRefs ids="1661,1660,1662">&lt;&lt;</CheckRefs> 6) &amp; BMI160_ORIENT_INT_EN_MASK);</Line>
  <Line number="4215">		/* write data to Int Enable 0 register */</Line>
  <Line number="4216">		rslt = bmi160_set_regs(<CheckRefs ids="1664">BMI160_INT_ENABLE_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1665">1</CheckRefs>, dev);</Line>
  <Line number="4217">	}</Line>
  <Line number="4218"></Line>
  <Line number="4219">	return rslt;</Line>
  <Line number="4220">}</Line>
  <Line number="4221"></Line>
  <Line number="4222"></Line>
  <Line number="4223">/*!</Line>
  <Line number="4224"> * @brief This API configure the necessary setting of orientation interrupt.</Line>
  <Line number="4225"> */</Line>
  <Line number="4226">static int8_t config_orient_int_settg(const struct bmi160_acc_orient_int_cfg *orient_int_cfg,</Line>
  <Line number="4227">					const struct bmi160_dev *dev)</Line>
  <Line number="4228">{ INIT_STUBS(dev);</Line>
  <Line number="4229">	int8_t rslt;</Line>
  <Line number="4230">	uint8_t data = <CheckRefs ids="1666">0</CheckRefs>;</Line>
  <Line number="4231">	uint8_t temp = <CheckRefs ids="1667">0</CheckRefs>;</Line>
  <Line number="4232">	uint8_t data_array[2] = {<CheckRefs ids="1668">0</CheckRefs>, <CheckRefs ids="1669">0</CheckRefs>};</Line>
  <Line number="4233"></Line>
  <Line number="4234">	/* Configuring INT_ORIENT registers */</Line>
  <Line number="4235">	rslt = bmi160_get_regs(<CheckRefs ids="1670">BMI160_INT_ORIENT_0_ADDR</CheckRefs>, data_array, <CheckRefs ids="1671">2</CheckRefs>, dev);</Line>
  <Line number="4236">	if (<CheckRefs ids="1672">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4237">		data = data_array[0<CheckRefs ids="1673">]</CheckRefs>;</Line>
  <Line number="4238">		temp = <CheckRefs ids="1675">data</CheckRefs> <CheckRefs ids="1674">&amp;</CheckRefs> ~BMI160_ORIENT_MODE_MASK;</Line>
  <Line number="4239">		/* Adding Orientation mode */</Line>
  <Line number="4240">		data = <CheckRefs ids="1677">temp</CheckRefs> <CheckRefs ids="1676">|</CheckRefs> (<CheckRefs ids="1678">(</CheckRefs>orient_int_cfg-&gt;orient_mode) &amp; BMI160_ORIENT_MODE_MASK);</Line>
  <Line number="4241">		temp = <CheckRefs ids="1680">data</CheckRefs> <CheckRefs ids="1679">&amp;</CheckRefs> ~BMI160_ORIENT_BLOCK_MASK;</Line>
  <Line number="4242">		/* Adding Orientation blocking */</Line>
  <Line number="4243">		data = <CheckRefs ids="1682">temp</CheckRefs> <CheckRefs ids="1681">|</CheckRefs> (<CheckRefs ids="1683">(</CheckRefs><CheckRefs ids="1687">orient_int_cfg</CheckRefs>-&gt;orient_blocking <CheckRefs ids="1684,1685,1686">&lt;&lt;</CheckRefs> 2) &amp; BMI160_ORIENT_BLOCK_MASK);</Line>
  <Line number="4244">		temp = <CheckRefs ids="1689">data</CheckRefs> <CheckRefs ids="1688">&amp;</CheckRefs> ~BMI160_ORIENT_HYST_MASK;</Line>
  <Line number="4245">		 /* Adding Orientation hysteresis */</Line>
  <Line number="4246">		data = <CheckRefs ids="1691">temp</CheckRefs> <CheckRefs ids="1690">|</CheckRefs> (<CheckRefs ids="1692">(</CheckRefs><CheckRefs ids="1696">orient_int_cfg</CheckRefs>-&gt;orient_hyst <CheckRefs ids="1693,1694,1695">&lt;&lt;</CheckRefs> 4) &amp; BMI160_ORIENT_HYST_MASK);</Line>
  <Line number="4247">		data_array[0<CheckRefs ids="1697">]</CheckRefs> = data;</Line>
  <Line number="4248"></Line>
  <Line number="4249">		data = data_array[1<CheckRefs ids="1698">]</CheckRefs>;</Line>
  <Line number="4250">		temp = <CheckRefs ids="1700">data</CheckRefs> <CheckRefs ids="1699">&amp;</CheckRefs> ~BMI160_ORIENT_THETA_MASK;</Line>
  <Line number="4251">		/* Adding Orientation threshold */</Line>
  <Line number="4252">		data = <CheckRefs ids="1702">temp</CheckRefs> <CheckRefs ids="1701">|</CheckRefs> (<CheckRefs ids="1703">(</CheckRefs>orient_int_cfg-&gt;orient_theta) &amp; BMI160_ORIENT_THETA_MASK);</Line>
  <Line number="4253">		temp = <CheckRefs ids="1705">data</CheckRefs> <CheckRefs ids="1704">&amp;</CheckRefs> ~BMI160_ORIENT_UD_ENABLE;</Line>
  <Line number="4254">		/* Adding Orient_ud_en */</Line>
  <Line number="4255">		data = <CheckRefs ids="1707">temp</CheckRefs> <CheckRefs ids="1706">|</CheckRefs> (<CheckRefs ids="1708">(</CheckRefs><CheckRefs ids="1712">orient_int_cfg</CheckRefs>-&gt;orient_ud_en <CheckRefs ids="1709,1710,1711">&lt;&lt;</CheckRefs> 6) &amp; BMI160_ORIENT_UD_ENABLE);</Line>
  <Line number="4256">		temp = <CheckRefs ids="1714">data</CheckRefs> <CheckRefs ids="1713">&amp;</CheckRefs> ~BMI160_AXES_EN_MASK;</Line>
  <Line number="4257">		/* Adding axes_en */</Line>
  <Line number="4258">		data = <CheckRefs ids="1716">temp</CheckRefs> <CheckRefs ids="1715">|</CheckRefs> (<CheckRefs ids="1717">(</CheckRefs><CheckRefs ids="1721">orient_int_cfg</CheckRefs>-&gt;axes_ex <CheckRefs ids="1718,1719,1720">&lt;&lt;</CheckRefs> 7) &amp; BMI160_AXES_EN_MASK);</Line>
  <Line number="4259">		data_array[1<CheckRefs ids="1722">]</CheckRefs> = data;</Line>
  <Line number="4260">		/* Writing data to INT_ORIENT 0 and INT_ORIENT 1</Line>
  <Line number="4261">		 * registers simultaneously */</Line>
  <Line number="4262">		rslt = bmi160_set_regs(<CheckRefs ids="1723">BMI160_INT_ORIENT_0_ADDR</CheckRefs>, data_array, <CheckRefs ids="1724">2</CheckRefs>, dev);</Line>
  <Line number="4263">	}</Line>
  <Line number="4264"></Line>
  <Line number="4265">	return rslt;</Line>
  <Line number="4266">}</Line>
  <Line number="4267"></Line>
  <Line number="4268">/*!</Line>
  <Line number="4269"> * @brief This API enables the flat interrupt.</Line>
  <Line number="4270"> */</Line>
  <Line number="4271">static int8_t enable_flat_int(const struct bmi160_acc_flat_detect_int_cfg *flat_int, const struct bmi160_dev *dev)</Line>
  <Line number="4272">{ INIT_STUBS(dev);</Line>
  <Line number="4273">	int8_t rslt;</Line>
  <Line number="4274">	uint8_t data = <CheckRefs ids="1725">0</CheckRefs>;</Line>
  <Line number="4275">	uint8_t temp = <CheckRefs ids="1726">0</CheckRefs>;</Line>
  <Line number="4276"></Line>
  <Line number="4277">	/* Enable flat interrupt in Int Enable 0 register */</Line>
  <Line number="4278">	rslt = bmi160_get_regs(<CheckRefs ids="1727">BMI160_INT_ENABLE_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1728">1</CheckRefs>, dev);</Line>
  <Line number="4279">	if (<CheckRefs ids="1729">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4280">		temp = <CheckRefs ids="1731">data</CheckRefs> <CheckRefs ids="1730">&amp;</CheckRefs> ~BMI160_FLAT_INT_EN_MASK;</Line>
  <Line number="4281">		data = <CheckRefs ids="1733">temp</CheckRefs> <CheckRefs ids="1732">|</CheckRefs> (<CheckRefs ids="1734">(</CheckRefs><CheckRefs ids="1738">flat_int</CheckRefs>-&gt;flat_en <CheckRefs ids="1735,1736,1737">&lt;&lt;</CheckRefs> 7) &amp; BMI160_FLAT_INT_EN_MASK);</Line>
  <Line number="4282">		/* write data to Int Enable 0 register */</Line>
  <Line number="4283">		rslt = bmi160_set_regs(<CheckRefs ids="1739">BMI160_INT_ENABLE_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1740">1</CheckRefs>, dev);</Line>
  <Line number="4284">	}</Line>
  <Line number="4285"></Line>
  <Line number="4286">	return rslt;</Line>
  <Line number="4287">}</Line>
  <Line number="4288"></Line>
  <Line number="4289"></Line>
  <Line number="4290">/*!</Line>
  <Line number="4291"> * @brief This API configure the necessary setting of flat interrupt.</Line>
  <Line number="4292"> */</Line>
  <Line number="4293">static int8_t config_flat_int_settg(const struct bmi160_acc_flat_detect_int_cfg *flat_int, const struct bmi160_dev *dev)</Line>
  <Line number="4294">{ INIT_STUBS(dev);</Line>
  <Line number="4295">	int8_t rslt;</Line>
  <Line number="4296">	uint8_t data = <CheckRefs ids="1741">0</CheckRefs>;</Line>
  <Line number="4297">	uint8_t temp = <CheckRefs ids="1742">0</CheckRefs>;</Line>
  <Line number="4298">	uint8_t data_array[2] = {<CheckRefs ids="1743">0</CheckRefs>, <CheckRefs ids="1744">0</CheckRefs>};</Line>
  <Line number="4299"></Line>
  <Line number="4300">	/* Configuring INT_FLAT register */</Line>
  <Line number="4301">	rslt = bmi160_get_regs(<CheckRefs ids="1745">BMI160_INT_FLAT_0_ADDR</CheckRefs>, data_array, <CheckRefs ids="1746">2</CheckRefs>, dev);</Line>
  <Line number="4302">	if (<CheckRefs ids="1747">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4303">		data = data_array[0<CheckRefs ids="1748">]</CheckRefs>;</Line>
  <Line number="4304">		temp = <CheckRefs ids="1750">data</CheckRefs> <CheckRefs ids="1749">&amp;</CheckRefs> ~BMI160_FLAT_THRES_MASK;</Line>
  <Line number="4305">		/* Adding flat theta */</Line>
  <Line number="4306">		data = <CheckRefs ids="1752">temp</CheckRefs> <CheckRefs ids="1751">|</CheckRefs> (<CheckRefs ids="1753">(</CheckRefs>flat_int-&gt;flat_theta) &amp; BMI160_FLAT_THRES_MASK);</Line>
  <Line number="4307">		data_array[0<CheckRefs ids="1754">]</CheckRefs> = data;</Line>
  <Line number="4308"></Line>
  <Line number="4309">		data = data_array[1<CheckRefs ids="1755">]</CheckRefs>;</Line>
  <Line number="4310">		temp = <CheckRefs ids="1757">data</CheckRefs> <CheckRefs ids="1756">&amp;</CheckRefs> ~BMI160_FLAT_HOLD_TIME_MASK;</Line>
  <Line number="4311">		/* Adding flat hold time */</Line>
  <Line number="4312">		data = <CheckRefs ids="1759">temp</CheckRefs> <CheckRefs ids="1758">|</CheckRefs> (<CheckRefs ids="1760">(</CheckRefs><CheckRefs ids="1764">flat_int</CheckRefs>-&gt;flat_hold_time <CheckRefs ids="1761,1762,1763">&lt;&lt;</CheckRefs> 4) &amp; BMI160_FLAT_HOLD_TIME_MASK);</Line>
  <Line number="4313">		temp = <CheckRefs ids="1766">data</CheckRefs> <CheckRefs ids="1765">&amp;</CheckRefs> ~BMI160_FLAT_HYST_MASK;</Line>
  <Line number="4314">		/* Adding flat hysteresis */</Line>
  <Line number="4315">		data = <CheckRefs ids="1768">temp</CheckRefs> <CheckRefs ids="1767">|</CheckRefs> (<CheckRefs ids="1769">(</CheckRefs>flat_int-&gt;flat_hy) &amp; BMI160_FLAT_HYST_MASK);</Line>
  <Line number="4316">		data_array[1<CheckRefs ids="1770">]</CheckRefs> = data;</Line>
  <Line number="4317">		/* Writing data to INT_FLAT 0 and INT_FLAT 1</Line>
  <Line number="4318">		 * registers simultaneously */</Line>
  <Line number="4319">		rslt = bmi160_set_regs(<CheckRefs ids="1771">BMI160_INT_FLAT_0_ADDR</CheckRefs>, data_array, <CheckRefs ids="1772">2</CheckRefs>, dev);</Line>
  <Line number="4320">	}</Line>
  <Line number="4321"></Line>
  <Line number="4322">	return rslt;</Line>
  <Line number="4323">}</Line>
  <Line number="4324"></Line>
  <Line number="4325">/*!</Line>
  <Line number="4326"> * @brief This API enables the Low-g interrupt.</Line>
  <Line number="4327"> */</Line>
  <Line number="4328">static int8_t enable_low_g_int(const struct bmi160_acc_low_g_int_cfg *low_g_int, const struct bmi160_dev *dev)</Line>
  <Line number="4329">{ INIT_STUBS(dev);</Line>
  <Line number="4330">	int8_t rslt;</Line>
  <Line number="4331">	uint8_t data = <CheckRefs ids="1773">0</CheckRefs>;</Line>
  <Line number="4332">	uint8_t temp = <CheckRefs ids="1774">0</CheckRefs>;</Line>
  <Line number="4333"></Line>
  <Line number="4334">	/* Enable low-g interrupt in Int Enable 1 register */</Line>
  <Line number="4335">	rslt = bmi160_get_regs(<CheckRefs ids="1775">BMI160_INT_ENABLE_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1776">1</CheckRefs>, dev);</Line>
  <Line number="4336">	if (<CheckRefs ids="1777">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4337">		temp = <CheckRefs ids="1779">data</CheckRefs> <CheckRefs ids="1778">&amp;</CheckRefs> ~BMI160_LOW_G_INT_EN_MASK;</Line>
  <Line number="4338">		data = <CheckRefs ids="1781">temp</CheckRefs> <CheckRefs ids="1780">|</CheckRefs> (<CheckRefs ids="1782">(</CheckRefs><CheckRefs ids="1786">low_g_int</CheckRefs>-&gt;low_en <CheckRefs ids="1783,1784,1785">&lt;&lt;</CheckRefs> 3) &amp; BMI160_LOW_G_INT_EN_MASK);</Line>
  <Line number="4339">		/* write data to Int Enable 0 register */</Line>
  <Line number="4340">		rslt = bmi160_set_regs(<CheckRefs ids="1787">BMI160_INT_ENABLE_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1788">1</CheckRefs>, dev);</Line>
  <Line number="4341">	}</Line>
  <Line number="4342"></Line>
  <Line number="4343">	return rslt;</Line>
  <Line number="4344">}</Line>
  <Line number="4345"></Line>
  <Line number="4346">/*!</Line>
  <Line number="4347"> * @brief This API configure the source of data(filter &amp; pre-filter)</Line>
  <Line number="4348"> * for low-g interrupt.</Line>
  <Line number="4349"> */</Line>
  <Line number="4350">static int8_t config_low_g_data_src(const struct bmi160_acc_low_g_int_cfg *low_g_int, const struct bmi160_dev *dev)</Line>
  <Line number="4351">{ INIT_STUBS(dev);</Line>
  <Line number="4352">	int8_t rslt;</Line>
  <Line number="4353">	uint8_t data = <CheckRefs ids="1789">0</CheckRefs>;</Line>
  <Line number="4354">	uint8_t temp = <CheckRefs ids="1790">0</CheckRefs>;</Line>
  <Line number="4355"></Line>
  <Line number="4356">	/* Configure Int data 0 register to add source of interrupt */</Line>
  <Line number="4357">	rslt = bmi160_get_regs(<CheckRefs ids="1791">BMI160_INT_DATA_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1792">1</CheckRefs>, dev);</Line>
  <Line number="4358">	if (<CheckRefs ids="1793">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4359">		temp = <CheckRefs ids="1795">data</CheckRefs> <CheckRefs ids="1794">&amp;</CheckRefs> ~BMI160_LOW_HIGH_SRC_INT_MASK;</Line>
  <Line number="4360">		data = <CheckRefs ids="1797">temp</CheckRefs> <CheckRefs ids="1796">|</CheckRefs> (<CheckRefs ids="1798">(</CheckRefs><CheckRefs ids="1802">low_g_int</CheckRefs>-&gt;low_data_src <CheckRefs ids="1799,1800,1801">&lt;&lt;</CheckRefs> 7) &amp; BMI160_LOW_HIGH_SRC_INT_MASK);</Line>
  <Line number="4361">		/* Write data to Data 0 address */</Line>
  <Line number="4362">		rslt = bmi160_set_regs(<CheckRefs ids="1803">BMI160_INT_DATA_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1804">1</CheckRefs>, dev);</Line>
  <Line number="4363">	}</Line>
  <Line number="4364"></Line>
  <Line number="4365">	return rslt;</Line>
  <Line number="4366">}</Line>
  <Line number="4367"></Line>
  <Line number="4368">/*!</Line>
  <Line number="4369"> * @brief This API configure the necessary setting of low-g interrupt.</Line>
  <Line number="4370"> */</Line>
  <Line number="4371">static int8_t config_low_g_int_settg(const struct bmi160_acc_low_g_int_cfg *low_g_int,  const struct bmi160_dev *dev)</Line>
  <Line number="4372">{ INIT_STUBS(dev);</Line>
  <Line number="4373">	int8_t rslt;</Line>
  <Line number="4374">	uint8_t temp = <CheckRefs ids="1805">0</CheckRefs>;</Line>
  <Line number="4375">	uint8_t data_array[3] = {<CheckRefs ids="1806">0</CheckRefs>, <CheckRefs ids="1807">0</CheckRefs>, <CheckRefs ids="1808">0</CheckRefs>};</Line>
  <Line number="4376"></Line>
  <Line number="4377">	/* Configuring INT_LOWHIGH register for low-g interrupt */</Line>
  <Line number="4378">	rslt = bmi160_get_regs(<CheckRefs ids="1809">BMI160_INT_LOWHIGH_2_ADDR</CheckRefs>, &amp;data_array[2<CheckRefs ids="1810">]</CheckRefs>, <CheckRefs ids="1811">1</CheckRefs>, dev);</Line>
  <Line number="4379"></Line>
  <Line number="4380">	if (<CheckRefs ids="1812">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4381">		temp = <CheckRefs ids="1814">data_array</CheckRefs>[2<CheckRefs ids="1815">]</CheckRefs> <CheckRefs ids="1813">&amp;</CheckRefs> ~BMI160_LOW_G_HYST_MASK;</Line>
  <Line number="4382">		/* Adding low-g hysteresis */</Line>
  <Line number="4383">		data_array[2<CheckRefs ids="1816">]</CheckRefs> = <CheckRefs ids="1818">temp</CheckRefs> <CheckRefs ids="1817">|</CheckRefs> (<CheckRefs ids="1819">low_g_int</CheckRefs>-&gt;low_hyst &amp; BMI160_LOW_G_HYST_MASK);</Line>
  <Line number="4384">		temp = <CheckRefs ids="1821">data_array</CheckRefs>[2<CheckRefs ids="1822">]</CheckRefs> <CheckRefs ids="1820">&amp;</CheckRefs> ~BMI160_LOW_G_LOW_MODE_MASK;</Line>
  <Line number="4385">		/* Adding low-mode */</Line>
  <Line number="4386">		data_array[2<CheckRefs ids="1823">]</CheckRefs> = <CheckRefs ids="1825">temp</CheckRefs> <CheckRefs ids="1824">|</CheckRefs> (<CheckRefs ids="1826">(</CheckRefs><CheckRefs ids="1830">low_g_int</CheckRefs>-&gt;low_mode <CheckRefs ids="1828,1827,1829">&lt;&lt;</CheckRefs> 2) &amp; BMI160_LOW_G_LOW_MODE_MASK);</Line>
  <Line number="4387"></Line>
  <Line number="4388">		/* Adding low-g threshold */</Line>
  <Line number="4389">		data_array[1<CheckRefs ids="1831">]</CheckRefs> = low_g_int-&gt;low_thres;</Line>
  <Line number="4390">		/* Adding low-g interrupt delay */</Line>
  <Line number="4391">		data_array[0<CheckRefs ids="1832">]</CheckRefs> = low_g_int-&gt;low_dur;</Line>
  <Line number="4392">		/* Writing data to INT_LOWHIGH 0,1,2 registers simultaneously*/</Line>
  <Line number="4393">		rslt = bmi160_set_regs(<CheckRefs ids="1833">BMI160_INT_LOWHIGH_0_ADDR</CheckRefs>, data_array, <CheckRefs ids="1834">3</CheckRefs>, dev);</Line>
  <Line number="4394">	}</Line>
  <Line number="4395"></Line>
  <Line number="4396">	return rslt;</Line>
  <Line number="4397">}</Line>
  <Line number="4398"></Line>
  <Line number="4399">/*!</Line>
  <Line number="4400"> * @brief This API enables the high-g interrupt.</Line>
  <Line number="4401"> */</Line>
  <Line number="4402">static int8_t enable_high_g_int(const struct bmi160_acc_high_g_int_cfg *high_g_int_cfg, const struct bmi160_dev *dev)</Line>
  <Line number="4403">{ INIT_STUBS(dev);</Line>
  <Line number="4404">	int8_t rslt;</Line>
  <Line number="4405">	uint8_t data = <CheckRefs ids="1835">0</CheckRefs>;</Line>
  <Line number="4406">	uint8_t temp = <CheckRefs ids="1836">0</CheckRefs>;</Line>
  <Line number="4407"></Line>
  <Line number="4408">	/* Enable low-g interrupt in Int Enable 1 register */</Line>
  <Line number="4409">	rslt = bmi160_get_regs(<CheckRefs ids="1837">BMI160_INT_ENABLE_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1838">1</CheckRefs>, dev);</Line>
  <Line number="4410"></Line>
  <Line number="4411">	if (<CheckRefs ids="1839">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4412"></Line>
  <Line number="4413">		/* Adding high-g X-axis */</Line>
  <Line number="4414">		temp = <CheckRefs ids="1841">data</CheckRefs> <CheckRefs ids="1840">&amp;</CheckRefs> ~BMI160_HIGH_G_X_INT_EN_MASK;</Line>
  <Line number="4415">		data = <CheckRefs ids="1843">temp</CheckRefs> <CheckRefs ids="1842">|</CheckRefs> (<CheckRefs ids="1844">high_g_int_cfg</CheckRefs>-&gt;high_g_x &amp; BMI160_HIGH_G_X_INT_EN_MASK);</Line>
  <Line number="4416"></Line>
  <Line number="4417">		/* Adding high-g Y-axis */</Line>
  <Line number="4418">		temp = <CheckRefs ids="1846">data</CheckRefs> <CheckRefs ids="1845">&amp;</CheckRefs> ~BMI160_HIGH_G_Y_INT_EN_MASK;</Line>
  <Line number="4419">		data = <CheckRefs ids="1848">temp</CheckRefs> <CheckRefs ids="1847">|</CheckRefs> (<CheckRefs ids="1849">(</CheckRefs><CheckRefs ids="1853">high_g_int_cfg</CheckRefs>-&gt;high_g_y <CheckRefs ids="1851,1850,1852">&lt;&lt;</CheckRefs> 1) &amp; BMI160_HIGH_G_Y_INT_EN_MASK);</Line>
  <Line number="4420"></Line>
  <Line number="4421">		/* Adding high-g Z-axis */</Line>
  <Line number="4422">		temp = <CheckRefs ids="1855">data</CheckRefs> <CheckRefs ids="1854">&amp;</CheckRefs> ~BMI160_HIGH_G_Z_INT_EN_MASK;</Line>
  <Line number="4423">		data = <CheckRefs ids="1857">temp</CheckRefs> <CheckRefs ids="1856">|</CheckRefs> (<CheckRefs ids="1858">(</CheckRefs><CheckRefs ids="1862">high_g_int_cfg</CheckRefs>-&gt;high_g_z <CheckRefs ids="1860,1859,1861">&lt;&lt;</CheckRefs> 2) &amp; BMI160_HIGH_G_Z_INT_EN_MASK);</Line>
  <Line number="4424"></Line>
  <Line number="4425">		/* write data to Int Enable 0 register */</Line>
  <Line number="4426">		rslt = bmi160_set_regs(<CheckRefs ids="1863">BMI160_INT_ENABLE_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1864">1</CheckRefs>, dev);</Line>
  <Line number="4427">	}</Line>
  <Line number="4428"></Line>
  <Line number="4429">	return rslt;</Line>
  <Line number="4430">}</Line>
  <Line number="4431"></Line>
  <Line number="4432">/*!</Line>
  <Line number="4433"> * @brief This API configure the source of data(filter &amp; pre-filter)</Line>
  <Line number="4434"> * for high-g interrupt.</Line>
  <Line number="4435"> */</Line>
  <Line number="4436">static int8_t config_high_g_data_src(const struct bmi160_acc_high_g_int_cfg *high_g_int_cfg,</Line>
  <Line number="4437">					const struct bmi160_dev *dev)</Line>
  <Line number="4438">{ INIT_STUBS(dev);</Line>
  <Line number="4439">	int8_t rslt;</Line>
  <Line number="4440">	uint8_t data = <CheckRefs ids="1865">0</CheckRefs>;</Line>
  <Line number="4441">	uint8_t temp = <CheckRefs ids="1866">0</CheckRefs>;</Line>
  <Line number="4442"></Line>
  <Line number="4443">	/* Configure Int data 0 register to add source of interrupt */</Line>
  <Line number="4444">	rslt = bmi160_get_regs(<CheckRefs ids="1867">BMI160_INT_DATA_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1868">1</CheckRefs>, dev);</Line>
  <Line number="4445">	if (<CheckRefs ids="1869">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4446">		temp = <CheckRefs ids="1871">data</CheckRefs> <CheckRefs ids="1870">&amp;</CheckRefs> ~BMI160_LOW_HIGH_SRC_INT_MASK;</Line>
  <Line number="4447">		data = <CheckRefs ids="1873">temp</CheckRefs> <CheckRefs ids="1872">|</CheckRefs> (<CheckRefs ids="1874">(</CheckRefs><CheckRefs ids="1878">high_g_int_cfg</CheckRefs>-&gt;high_data_src <CheckRefs ids="1875,1876,1877">&lt;&lt;</CheckRefs> 7) &amp; BMI160_LOW_HIGH_SRC_INT_MASK);</Line>
  <Line number="4448">		/* Write data to Data 0 address */</Line>
  <Line number="4449">		rslt = bmi160_set_regs(<CheckRefs ids="1879">BMI160_INT_DATA_0_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1880">1</CheckRefs>, dev);</Line>
  <Line number="4450">	}</Line>
  <Line number="4451"></Line>
  <Line number="4452">	return rslt;</Line>
  <Line number="4453">}</Line>
  <Line number="4454"></Line>
  <Line number="4455">/*!</Line>
  <Line number="4456"> * @brief This API configure the necessary setting of high-g interrupt.</Line>
  <Line number="4457"> */</Line>
  <Line number="4458">static int8_t config_high_g_int_settg(const struct bmi160_acc_high_g_int_cfg *high_g_int_cfg,</Line>
  <Line number="4459">					const struct bmi160_dev *dev)</Line>
  <Line number="4460">{ INIT_STUBS(dev);</Line>
  <Line number="4461">	int8_t rslt;</Line>
  <Line number="4462">	uint8_t temp = <CheckRefs ids="1881">0</CheckRefs>;</Line>
  <Line number="4463">	uint8_t data_array[3] = {<CheckRefs ids="1882">0</CheckRefs>, <CheckRefs ids="1883">0</CheckRefs>, <CheckRefs ids="1884">0</CheckRefs>};</Line>
  <Line number="4464"></Line>
  <Line number="4465">	rslt = bmi160_get_regs(<CheckRefs ids="1885">BMI160_INT_LOWHIGH_2_ADDR</CheckRefs>, &amp;data_array[0<CheckRefs ids="1886">]</CheckRefs>, <CheckRefs ids="1887">1</CheckRefs>, dev);</Line>
  <Line number="4466">	if (<CheckRefs ids="1888">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4467">		temp = <CheckRefs ids="1890">data_array</CheckRefs>[0<CheckRefs ids="1891">]</CheckRefs> <CheckRefs ids="1889">&amp;</CheckRefs> ~BMI160_HIGH_G_HYST_MASK;</Line>
  <Line number="4468">		/* Adding high-g hysteresis */</Line>
  <Line number="4469">		data_array[0<CheckRefs ids="1892">]</CheckRefs> = <CheckRefs ids="1894">temp</CheckRefs> <CheckRefs ids="1893">|</CheckRefs> (<CheckRefs ids="1895">(</CheckRefs><CheckRefs ids="1899">high_g_int_cfg</CheckRefs>-&gt;high_hy <CheckRefs ids="1896,1897,1898">&lt;&lt;</CheckRefs> 6) &amp; BMI160_HIGH_G_HYST_MASK);</Line>
  <Line number="4470">		/* Adding high-g duration */</Line>
  <Line number="4471">		data_array[1<CheckRefs ids="1900">]</CheckRefs> = high_g_int_cfg-&gt;high_dur;</Line>
  <Line number="4472">		/* Adding high-g threshold */</Line>
  <Line number="4473">		data_array[2<CheckRefs ids="1901">]</CheckRefs> = high_g_int_cfg-&gt;high_thres;</Line>
  <Line number="4474">		rslt = bmi160_set_regs(<CheckRefs ids="1902">BMI160_INT_LOWHIGH_2_ADDR</CheckRefs>, data_array, <CheckRefs ids="1903">3</CheckRefs>, dev);</Line>
  <Line number="4475">	}</Line>
  <Line number="4476"></Line>
  <Line number="4477">	return rslt;</Line>
  <Line number="4478">}</Line>
  <Line number="4479"></Line>
  <Line number="4480">/*!</Line>
  <Line number="4481"> * @brief This API configure the behavioural setting of interrupt pin.</Line>
  <Line number="4482"> */</Line>
  <Line number="4483">static int8_t config_int_out_ctrl(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="4484">{ INIT_STUBS(dev);</Line>
  <Line number="4485">	int8_t rslt;</Line>
  <Line number="4486">	uint8_t temp = <CheckRefs ids="1904">0</CheckRefs>;</Line>
  <Line number="4487">	uint8_t data = <CheckRefs ids="1905">0</CheckRefs>;</Line>
  <Line number="4488"></Line>
  <Line number="4489">	/* Configuration of output interrupt signals on pins INT1 and INT2 are</Line>
  <Line number="4490">	 * done in BMI160_INT_OUT_CTRL_ADDR register*/</Line>
  <Line number="4491">	rslt = bmi160_get_regs(<CheckRefs ids="1906">BMI160_INT_OUT_CTRL_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1907">1</CheckRefs>, dev);</Line>
  <Line number="4492"></Line>
  <Line number="4493">	if (<CheckRefs ids="1908">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4494">		/* updating the interrupt pin structure to local structure */</Line>
  <Line number="4495">		const struct bmi160_int_pin_settg *intr_pin_sett = &amp;(int_config-&gt;int_pin_settg);</Line>
  <Line number="4496"></Line>
  <Line number="4497">		/* Configuring channel 1 */</Line>
  <Line number="4498">		if (<CheckRefs ids="1909">int_config</CheckRefs>-&gt;int_channel == <CheckRefs ids="1910">BMI160_INT_CHANNEL_1</CheckRefs>) {</Line>
  <Line number="4499"></Line>
  <Line number="4500">			/* Output enable */</Line>
  <Line number="4501">			temp = <CheckRefs ids="1912">data</CheckRefs> <CheckRefs ids="1911">&amp;</CheckRefs> ~BMI160_INT1_OUTPUT_EN_MASK;</Line>
  <Line number="4502">			data = <CheckRefs ids="1914">temp</CheckRefs> <CheckRefs ids="1913">|</CheckRefs> (<CheckRefs ids="1915">(</CheckRefs><CheckRefs ids="1919">intr_pin_sett</CheckRefs>-&gt;output_en <CheckRefs ids="1916,1917,1918">&lt;&lt;</CheckRefs> 3) &amp; BMI160_INT1_OUTPUT_EN_MASK);</Line>
  <Line number="4503"></Line>
  <Line number="4504">			/* Output mode */</Line>
  <Line number="4505">			temp = <CheckRefs ids="1921">data</CheckRefs> <CheckRefs ids="1920">&amp;</CheckRefs> ~BMI160_INT1_OUTPUT_MODE_MASK;</Line>
  <Line number="4506">			data = <CheckRefs ids="1923">temp</CheckRefs> <CheckRefs ids="1922">|</CheckRefs> (<CheckRefs ids="1924">(</CheckRefs><CheckRefs ids="1928">intr_pin_sett</CheckRefs>-&gt;output_mode <CheckRefs ids="1925,1926,1927">&lt;&lt;</CheckRefs> 2) &amp; BMI160_INT1_OUTPUT_MODE_MASK);</Line>
  <Line number="4507"></Line>
  <Line number="4508">			/* Output type */</Line>
  <Line number="4509">			temp = <CheckRefs ids="1930">data</CheckRefs> <CheckRefs ids="1929">&amp;</CheckRefs> ~BMI160_INT1_OUTPUT_TYPE_MASK;</Line>
  <Line number="4510">			data = <CheckRefs ids="1932">temp</CheckRefs> <CheckRefs ids="1931">|</CheckRefs> (<CheckRefs ids="1933">(</CheckRefs><CheckRefs ids="1937">intr_pin_sett</CheckRefs>-&gt;output_type <CheckRefs ids="1934,1935,1936">&lt;&lt;</CheckRefs> 1) &amp; BMI160_INT1_OUTPUT_TYPE_MASK);</Line>
  <Line number="4511"></Line>
  <Line number="4512">			/* edge control */</Line>
  <Line number="4513">			temp = <CheckRefs ids="1939">data</CheckRefs> <CheckRefs ids="1938">&amp;</CheckRefs> ~BMI160_INT1_EDGE_CTRL_MASK;</Line>
  <Line number="4514">			data = <CheckRefs ids="1941">temp</CheckRefs> <CheckRefs ids="1940">|</CheckRefs> (<CheckRefs ids="1942">(</CheckRefs>intr_pin_sett-&gt;edge_ctrl) &amp; BMI160_INT1_EDGE_CTRL_MASK);</Line>
  <Line number="4515"></Line>
  <Line number="4516">		} else {</Line>
  <Line number="4517">			/* Configuring channel 2 */</Line>
  <Line number="4518">			/* Output enable */</Line>
  <Line number="4519">			temp = <CheckRefs ids="1944">data</CheckRefs> <CheckRefs ids="1943">&amp;</CheckRefs> ~BMI160_INT2_OUTPUT_EN_MASK;</Line>
  <Line number="4520">			data = <CheckRefs ids="1946">temp</CheckRefs> <CheckRefs ids="1945">|</CheckRefs> (<CheckRefs ids="1947">(</CheckRefs><CheckRefs ids="1951">intr_pin_sett</CheckRefs>-&gt;output_en <CheckRefs ids="1948,1949,1950">&lt;&lt;</CheckRefs> 7) &amp; BMI160_INT2_OUTPUT_EN_MASK);</Line>
  <Line number="4521"></Line>
  <Line number="4522">			/* Output mode */</Line>
  <Line number="4523">			temp = <CheckRefs ids="1953">data</CheckRefs> <CheckRefs ids="1952">&amp;</CheckRefs> ~BMI160_INT2_OUTPUT_MODE_MASK;</Line>
  <Line number="4524">			data = <CheckRefs ids="1955">temp</CheckRefs> <CheckRefs ids="1954">|</CheckRefs> (<CheckRefs ids="1956">(</CheckRefs><CheckRefs ids="1960">intr_pin_sett</CheckRefs>-&gt;output_mode <CheckRefs ids="1957,1958,1959">&lt;&lt;</CheckRefs> 6) &amp; BMI160_INT2_OUTPUT_MODE_MASK);</Line>
  <Line number="4525"></Line>
  <Line number="4526">			/* Output type */</Line>
  <Line number="4527">			temp = <CheckRefs ids="1962">data</CheckRefs> <CheckRefs ids="1961">&amp;</CheckRefs> ~BMI160_INT2_OUTPUT_TYPE_MASK;</Line>
  <Line number="4528">			data = <CheckRefs ids="1964">temp</CheckRefs> <CheckRefs ids="1963">|</CheckRefs> (<CheckRefs ids="1965">(</CheckRefs><CheckRefs ids="1969">intr_pin_sett</CheckRefs>-&gt;output_type <CheckRefs ids="1966,1967,1968">&lt;&lt;</CheckRefs> 5) &amp; BMI160_INT2_OUTPUT_TYPE_MASK);</Line>
  <Line number="4529"></Line>
  <Line number="4530">			/* edge control */</Line>
  <Line number="4531">			temp = <CheckRefs ids="1971">data</CheckRefs> <CheckRefs ids="1970">&amp;</CheckRefs> ~BMI160_INT2_EDGE_CTRL_MASK;</Line>
  <Line number="4532">			data = <CheckRefs ids="1973">temp</CheckRefs> <CheckRefs ids="1972">|</CheckRefs> (<CheckRefs ids="1974">(</CheckRefs><CheckRefs ids="1978">intr_pin_sett</CheckRefs>-&gt;edge_ctrl <CheckRefs ids="1976,1975,1977">&lt;&lt;</CheckRefs> 4) &amp; BMI160_INT2_EDGE_CTRL_MASK);</Line>
  <Line number="4533">		}</Line>
  <Line number="4534"></Line>
  <Line number="4535">		rslt = bmi160_set_regs(<CheckRefs ids="1979">BMI160_INT_OUT_CTRL_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1980">1</CheckRefs>, dev);</Line>
  <Line number="4536">	}</Line>
  <Line number="4537"></Line>
  <Line number="4538">	return rslt;</Line>
  <Line number="4539">}</Line>
  <Line number="4540"></Line>
  <Line number="4541">/*!</Line>
  <Line number="4542"> * @brief This API configure the mode(input enable, latch or non-latch) of interrupt pin.</Line>
  <Line number="4543"> */</Line>
  <Line number="4544">static int8_t config_int_latch(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="4545">{ INIT_STUBS(dev);</Line>
  <Line number="4546">	int8_t rslt;</Line>
  <Line number="4547">	uint8_t temp = <CheckRefs ids="1981">0</CheckRefs>;</Line>
  <Line number="4548">	uint8_t data = <CheckRefs ids="1982">0</CheckRefs>;</Line>
  <Line number="4549"></Line>
  <Line number="4550">	/* Configuration of latch on pins INT1 and INT2 are done in</Line>
  <Line number="4551">	 * BMI160_INT_LATCH_ADDR register*/</Line>
  <Line number="4552">	rslt = bmi160_get_regs(<CheckRefs ids="1983">BMI160_INT_LATCH_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="1984">1</CheckRefs>, dev);</Line>
  <Line number="4553"></Line>
  <Line number="4554">	if (<CheckRefs ids="1985">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4555">		/* updating the interrupt pin structure to local structure */</Line>
  <Line number="4556">		const struct bmi160_int_pin_settg *intr_pin_sett = &amp;(int_config-&gt;int_pin_settg);</Line>
  <Line number="4557"></Line>
  <Line number="4558">		if (<CheckRefs ids="1986">int_config</CheckRefs>-&gt;int_channel == <CheckRefs ids="1987">BMI160_INT_CHANNEL_1</CheckRefs>) {</Line>
  <Line number="4559">			/* Configuring channel 1 */</Line>
  <Line number="4560">			/* Input enable */</Line>
  <Line number="4561">			temp = <CheckRefs ids="1989">data</CheckRefs> <CheckRefs ids="1988">&amp;</CheckRefs> ~BMI160_INT1_INPUT_EN_MASK;</Line>
  <Line number="4562">			data = <CheckRefs ids="1991">temp</CheckRefs> <CheckRefs ids="1990">|</CheckRefs> (<CheckRefs ids="1992">(</CheckRefs><CheckRefs ids="1996">intr_pin_sett</CheckRefs>-&gt;input_en <CheckRefs ids="1994,1993,1995">&lt;&lt;</CheckRefs> 4) &amp; BMI160_INT1_INPUT_EN_MASK);</Line>
  <Line number="4563">		} else {</Line>
  <Line number="4564">			/* Configuring channel 2 */</Line>
  <Line number="4565">			/* Input enable */</Line>
  <Line number="4566">			temp = <CheckRefs ids="1998">data</CheckRefs> <CheckRefs ids="1997">&amp;</CheckRefs> ~BMI160_INT2_INPUT_EN_MASK;</Line>
  <Line number="4567">			data = <CheckRefs ids="2000">temp</CheckRefs> <CheckRefs ids="1999">|</CheckRefs> (<CheckRefs ids="2001">(</CheckRefs><CheckRefs ids="2005">intr_pin_sett</CheckRefs>-&gt;input_en <CheckRefs ids="2002,2003,2004">&lt;&lt;</CheckRefs> 5) &amp; BMI160_INT2_INPUT_EN_MASK);</Line>
  <Line number="4568">		}</Line>
  <Line number="4569"></Line>
  <Line number="4570">		/* In case of latch interrupt,update the latch duration */</Line>
  <Line number="4571">		/* Latching holds the interrupt for the amount of latch</Line>
  <Line number="4572">		 * duration time */</Line>
  <Line number="4573">		temp = <CheckRefs ids="2007">data</CheckRefs> <CheckRefs ids="2006">&amp;</CheckRefs> ~BMI160_INT_LATCH_MASK;</Line>
  <Line number="4574">		data = <CheckRefs ids="2009">temp</CheckRefs> <CheckRefs ids="2008">|</CheckRefs> (<CheckRefs ids="2010">intr_pin_sett</CheckRefs>-&gt;latch_dur &amp; BMI160_INT_LATCH_MASK);</Line>
  <Line number="4575"></Line>
  <Line number="4576">		/* OUT_CTRL_INT and LATCH_INT address lie consecutively,</Line>
  <Line number="4577">		 * hence writing data to respective registers at one go */</Line>
  <Line number="4578">		rslt = bmi160_set_regs(<CheckRefs ids="2011">BMI160_INT_LATCH_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="2012">1</CheckRefs>, dev);</Line>
  <Line number="4579">	}</Line>
  <Line number="4580">	return rslt;</Line>
  <Line number="4581">}</Line>
  <Line number="4582"></Line>
  <Line number="4583">/*!</Line>
  <Line number="4584"> * @brief This API performs the self test for accelerometer of BMI160</Line>
  <Line number="4585"> */</Line>
  <Line number="4586">static int8_t perform_accel_self_test(struct bmi160_dev *dev)</Line>
  <Line number="4587">{ INIT_STUBS(dev);</Line>
  <Line number="4588">	int8_t rslt;</Line>
  <Line number="4589">	struct bmi160_sensor_data accel_pos, accel_neg;</Line>
  <Line number="4590"></Line>
  <Line number="4591">	/* Enable Gyro self test bit */</Line>
  <Line number="4592">	rslt = enable_accel_self_test(dev);</Line>
  <Line number="4593">	if (<CheckRefs ids="2013">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4594">		/* Perform accel self test with positive excitation */</Line>
  <Line number="4595">		rslt = accel_self_test_positive_excitation(&amp;accel_pos, dev);</Line>
  <Line number="4596">		if (<CheckRefs ids="2014">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4597">			/* Perform accel self test with negative excitation */</Line>
  <Line number="4598">			rslt = accel_self_test_negative_excitation(&amp;accel_neg, dev);</Line>
  <Line number="4599">			if (<CheckRefs ids="2015">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4600">				/* Validate the self test result */</Line>
  <Line number="4601">				rslt = validate_accel_self_test(&amp;accel_pos, &amp;accel_neg);</Line>
  <Line number="4602">			}</Line>
  <Line number="4603">		}</Line>
  <Line number="4604">	}</Line>
  <Line number="4605"></Line>
  <Line number="4606">	return rslt;</Line>
  <Line number="4607">}</Line>
  <Line number="4608"></Line>
  <Line number="4609">/*!</Line>
  <Line number="4610"> * @brief This API enables to perform the accel self test by setting proper</Line>
  <Line number="4611"> * configurations to facilitate accel self test</Line>
  <Line number="4612"> */</Line>
  <Line number="4613">static int8_t enable_accel_self_test(struct bmi160_dev *dev)</Line>
  <Line number="4614">{ INIT_STUBS(dev);</Line>
  <Line number="4615">	int8_t rslt;</Line>
  <Line number="4616">	uint8_t reg_data;</Line>
  <Line number="4617"></Line>
  <Line number="4618">	/* Set the Accel power mode as normal mode */</Line>
  <Line number="4619">	dev-&gt;accel_cfg.power = <CheckRefs ids="2016">BMI160_ACCEL_NORMAL_MODE</CheckRefs>;</Line>
  <Line number="4620">	/* Set the sensor range configuration as 8G */</Line>
  <Line number="4621">	dev-&gt;accel_cfg.range = <CheckRefs ids="2017">BMI160_ACCEL_RANGE_8G</CheckRefs>;</Line>
  <Line number="4622">	rslt = bmi160_set_sens_conf(dev);</Line>
  <Line number="4623">	if (<CheckRefs ids="2018">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4624">		/* Accel configurations are set to facilitate self test</Line>
  <Line number="4625">		 * acc_odr - 1600Hz ; acc_bwp = 2 ; acc_us = 0 */</Line>
  <Line number="4626">		reg_data = <CheckRefs ids="2019">BMI160_ACCEL_SELF_TEST_CONFIG</CheckRefs>;</Line>
  <Line number="4627">		rslt = bmi160_set_regs(<CheckRefs ids="2020">BMI160_ACCEL_CONFIG_ADDR</CheckRefs>, &amp;reg_data, <CheckRefs ids="2021">1</CheckRefs>, dev);</Line>
  <Line number="4628">	}</Line>
  <Line number="4629"></Line>
  <Line number="4630">	return rslt;</Line>
  <Line number="4631">}</Line>
  <Line number="4632"></Line>
  <Line number="4633">/*!</Line>
  <Line number="4634"> * @brief This API performs accel self test with positive excitation</Line>
  <Line number="4635"> */</Line>
  <Line number="4636">static int8_t accel_self_test_positive_excitation(struct bmi160_sensor_data *accel_pos, const struct bmi160_dev *dev)</Line>
  <Line number="4637">{ INIT_STUBS(dev);</Line>
  <Line number="4638">	int8_t rslt;</Line>
  <Line number="4639">	uint8_t reg_data;</Line>
  <Line number="4640"></Line>
  <Line number="4641">	/* Enable accel self test with positive self-test excitation</Line>
  <Line number="4642">	   and with amplitude of deflection set as high */</Line>
  <Line number="4643">	reg_data = <CheckRefs ids="2022">BMI160_ACCEL_SELF_TEST_POSITIVE_EN</CheckRefs>;</Line>
  <Line number="4644">	rslt = bmi160_set_regs(<CheckRefs ids="2023">BMI160_SELF_TEST_ADDR</CheckRefs>, &amp;reg_data, <CheckRefs ids="2024">1</CheckRefs>, dev);</Line>
  <Line number="4645">	if (<CheckRefs ids="2025">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4646">		/* Read the data after a delay of 50ms */</Line>
  <Line number="4647">		dev-&gt;delay_ms(BMI160_ACCEL_SELF_TEST_DELAY);</Line>
  <Line number="4648">		rslt = bmi160_get_sensor_data(<CheckRefs ids="2026">BMI160_ACCEL_ONLY</CheckRefs>, accel_pos, NULL, dev);</Line>
  <Line number="4649">	}</Line>
  <Line number="4650"></Line>
  <Line number="4651">	return rslt;</Line>
  <Line number="4652">}</Line>
  <Line number="4653"></Line>
  <Line number="4654">/*!</Line>
  <Line number="4655"> * @brief This API performs accel self test with negative excitation</Line>
  <Line number="4656"> */</Line>
  <Line number="4657">static int8_t accel_self_test_negative_excitation(struct bmi160_sensor_data *accel_neg, const struct bmi160_dev *dev)</Line>
  <Line number="4658">{ INIT_STUBS(dev);</Line>
  <Line number="4659">	int8_t rslt;</Line>
  <Line number="4660">	uint8_t reg_data;</Line>
  <Line number="4661"></Line>
  <Line number="4662">	/* Enable accel self test with negative self-test excitation</Line>
  <Line number="4663">	   and with amplitude of deflection set as high */</Line>
  <Line number="4664">	reg_data = <CheckRefs ids="2027">BMI160_ACCEL_SELF_TEST_NEGATIVE_EN</CheckRefs>;</Line>
  <Line number="4665">	rslt = bmi160_set_regs(<CheckRefs ids="2028">BMI160_SELF_TEST_ADDR</CheckRefs>, &amp;reg_data, <CheckRefs ids="2029">1</CheckRefs>, dev);</Line>
  <Line number="4666">	if (<CheckRefs ids="2030">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4667">		/* Read the data after a delay of 50ms */</Line>
  <Line number="4668">		dev-&gt;delay_ms(BMI160_ACCEL_SELF_TEST_DELAY);</Line>
  <Line number="4669">		rslt = bmi160_get_sensor_data(<CheckRefs ids="2031">BMI160_ACCEL_ONLY</CheckRefs>, accel_neg, NULL, dev);</Line>
  <Line number="4670">	}</Line>
  <Line number="4671"></Line>
  <Line number="4672">	return rslt;</Line>
  <Line number="4673">}</Line>
  <Line number="4674"></Line>
  <Line number="4675">/*!</Line>
  <Line number="4676"> * @brief This API validates the accel self test results</Line>
  <Line number="4677"> */</Line>
  <Line number="4678">static int8_t validate_accel_self_test(const struct bmi160_sensor_data *accel_pos,</Line>
  <Line number="4679">					const struct bmi160_sensor_data *accel_neg)</Line>
  <Line number="4680">{</Line>
  <Line number="4681">	int8_t rslt;</Line>
  <Line number="4682"></Line>
  <Line number="4683">	/* Validate the results of self test */</Line>
  <Line number="4684">	if ((<CheckRefs ids="2032">(</CheckRefs><CheckRefs ids="2034">accel_neg</CheckRefs>-&gt;x <CheckRefs ids="2033">-</CheckRefs> <CheckRefs ids="2035">accel_pos</CheckRefs>-&gt;x) &gt; BMI160_ACCEL_SELF_TEST_LIMIT)</Line>
  <Line number="4685">		&amp;&amp; (<CheckRefs ids="2036">(</CheckRefs><CheckRefs ids="2038">accel_neg</CheckRefs>-&gt;y <CheckRefs ids="2037">-</CheckRefs> <CheckRefs ids="2039">accel_pos</CheckRefs>-&gt;y) &gt; BMI160_ACCEL_SELF_TEST_LIMIT)</Line>
  <Line number="4686">		&amp;&amp; (<CheckRefs ids="2040">(</CheckRefs><CheckRefs ids="2042">accel_neg</CheckRefs>-&gt;z <CheckRefs ids="2041">-</CheckRefs> <CheckRefs ids="2043">accel_pos</CheckRefs>-&gt;z) &gt; BMI160_ACCEL_SELF_TEST_LIMIT)) {</Line>
  <Line number="4687">		/* Self test pass condition */</Line>
  <Line number="4688">		rslt = <CheckRefs ids="2044">BMI160_OK</CheckRefs>;</Line>
  <Line number="4689">	} else {</Line>
  <Line number="4690">		rslt = <CheckRefs ids="2045">BMI160_W_ACCEl_SELF_TEST_FAIL</CheckRefs>;</Line>
  <Line number="4691">	}</Line>
  <Line number="4692"></Line>
  <Line number="4693">	return rslt;</Line>
  <Line number="4694">}</Line>
  <Line number="4695"></Line>
  <Line number="4696">/*!</Line>
  <Line number="4697"> * @brief This API performs the self test for gyroscope of BMI160</Line>
  <Line number="4698"> */</Line>
  <Line number="4699">static int8_t perform_gyro_self_test(const struct bmi160_dev *dev)</Line>
  <Line number="4700">{ INIT_STUBS(dev);</Line>
  <Line number="4701">	int8_t rslt;</Line>
  <Line number="4702"></Line>
  <Line number="4703">	/* Enable Gyro self test bit */</Line>
  <Line number="4704">	rslt = enable_gyro_self_test(dev);</Line>
  <Line number="4705">	if (<CheckRefs ids="2046">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4706">		/* Validate the gyro self test results */</Line>
  <Line number="4707">		rslt = validate_gyro_self_test(dev);</Line>
  <Line number="4708">	}</Line>
  <Line number="4709"></Line>
  <Line number="4710">	return rslt;</Line>
  <Line number="4711">}</Line>
  <Line number="4712"></Line>
  <Line number="4713">/*!</Line>
  <Line number="4714"> * @brief This API enables the self test bit to trigger self test for Gyro</Line>
  <Line number="4715"> */</Line>
  <Line number="4716">static int8_t enable_gyro_self_test(const struct bmi160_dev *dev)</Line>
  <Line number="4717">{ INIT_STUBS(dev);</Line>
  <Line number="4718">	int8_t rslt;</Line>
  <Line number="4719">	uint8_t reg_data;</Line>
  <Line number="4720"></Line>
  <Line number="4721">	/* Enable the Gyro self test bit to trigger the self test */</Line>
  <Line number="4722">	rslt = bmi160_get_regs(<CheckRefs ids="2047">BMI160_SELF_TEST_ADDR</CheckRefs>, &amp;reg_data, <CheckRefs ids="2048">1</CheckRefs>, dev);</Line>
  <Line number="4723">	if (<CheckRefs ids="2049">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4724">		reg_data = <CheckRefs ids="2055,2054,2053,2051,2052,2050">BMI160_SET_BITS</CheckRefs>(reg_data, BMI160_GYRO_SELF_TEST, 1);</Line>
  <Line number="4725">		rslt = bmi160_set_regs(<CheckRefs ids="2056">BMI160_SELF_TEST_ADDR</CheckRefs>, &amp;reg_data, <CheckRefs ids="2057">1</CheckRefs>, dev);</Line>
  <Line number="4726">		if (<CheckRefs ids="2058">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4727">			/* Delay to enable gyro self test */</Line>
  <Line number="4728">			dev-&gt;delay_ms(BMI160_GYRO_SELF_TEST_DELAY);</Line>
  <Line number="4729">		}</Line>
  <Line number="4730">	}</Line>
  <Line number="4731"></Line>
  <Line number="4732">	return rslt;</Line>
  <Line number="4733">}</Line>
  <Line number="4734"></Line>
  <Line number="4735">/*!</Line>
  <Line number="4736"> * @brief This API validates the self test results of Gyro</Line>
  <Line number="4737"> */</Line>
  <Line number="4738">static int8_t validate_gyro_self_test(const struct bmi160_dev *dev)</Line>
  <Line number="4739">{ INIT_STUBS(dev);</Line>
  <Line number="4740">	int8_t rslt;</Line>
  <Line number="4741">	uint8_t reg_data;</Line>
  <Line number="4742"></Line>
  <Line number="4743">	/* Validate the Gyro self test result */</Line>
  <Line number="4744">	rslt = bmi160_get_regs(<CheckRefs ids="2059">BMI160_STATUS_ADDR</CheckRefs>, &amp;reg_data, <CheckRefs ids="2060">1</CheckRefs>, dev);</Line>
  <Line number="4745">	if (<CheckRefs ids="2061">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4746">		reg_data = <CheckRefs ids="2063,2064,2062">BMI160_GET_BITS</CheckRefs>(reg_data, BMI160_GYRO_SELF_TEST_STATUS);</Line>
  <Line number="4747">		if (<CheckRefs ids="2065">reg_data</CheckRefs> == BMI160_ENABLE) {</Line>
  <Line number="4748">			/* Gyro self test success case */</Line>
  <Line number="4749">			rslt = <CheckRefs ids="2066">BMI160_OK</CheckRefs>;</Line>
  <Line number="4750">		} else {</Line>
  <Line number="4751">			rslt = <CheckRefs ids="2067">BMI160_W_GYRO_SELF_TEST_FAIL</CheckRefs>;</Line>
  <Line number="4752">		}</Line>
  <Line number="4753">	}</Line>
  <Line number="4754"></Line>
  <Line number="4755">	return rslt;</Line>
  <Line number="4756">}</Line>
  <Line number="4757"></Line>
  <Line number="4758">/*!</Line>
  <Line number="4759">*  @brief This API sets FIFO full interrupt of the sensor.This interrupt</Line>
  <Line number="4760">*  occurs when the FIFO is full and the next full data sample would cause</Line>
  <Line number="4761">*  a FIFO overflow, which may delete the old samples.</Line>
  <Line number="4762">*/</Line>
  <Line number="4763">static int8_t set_fifo_full_int(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="4764">{ INIT_STUBS(dev);</Line>
  <Line number="4765">	int8_t rslt = <CheckRefs ids="2068">BMI160_OK</CheckRefs>;</Line>
  <Line number="4766"></Line>
  <Line number="4767">	/* Null-pointer check */</Line>
  <Line number="4768">	if ((dev == NULL) || (dev-&gt;delay_ms == NULL)) {</Line>
  <Line number="4769">		rslt = <CheckRefs ids="2069,2070">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="4770">	} else {</Line>
  <Line number="4771">		/*enable the fifo full interrupt */</Line>
  <Line number="4772">		rslt = enable_fifo_full_int(int_config, dev);</Line>
  <Line number="4773">		if (<CheckRefs ids="2071">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4774">			/* Configure Interrupt pins */</Line>
  <Line number="4775">			rslt = set_intr_pin_config(int_config, dev);</Line>
  <Line number="4776">			if (<CheckRefs ids="2072">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="4777">				rslt = map_hardware_interrupt(int_config, dev);</Line>
  <Line number="4778">		}</Line>
  <Line number="4779">	}</Line>
  <Line number="4780">	return rslt;</Line>
  <Line number="4781">}</Line>
  <Line number="4782"></Line>
  <Line number="4783">/*!</Line>
  <Line number="4784"> * @brief This enable the FIFO full interrupt engine.</Line>
  <Line number="4785"> */</Line>
  <Line number="4786">static int8_t enable_fifo_full_int(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="4787">{ INIT_STUBS(dev);</Line>
  <Line number="4788">	int8_t rslt;</Line>
  <Line number="4789">	uint8_t data = <CheckRefs ids="2073">0</CheckRefs>;</Line>
  <Line number="4790"></Line>
  <Line number="4791">	rslt = bmi160_get_regs(<CheckRefs ids="2074">BMI160_INT_ENABLE_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="2075">1</CheckRefs>, dev);</Line>
  <Line number="4792"></Line>
  <Line number="4793">	if (<CheckRefs ids="2076">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4794">		data = <CheckRefs ids="2078,2080,2081,2083,2077,2079,2082">BMI160_SET_BITS</CheckRefs>(data, BMI160_FIFO_FULL_INT, int_config-&gt;fifo_full_int_en);</Line>
  <Line number="4795">		/* Writing data to INT ENABLE 1 Address */</Line>
  <Line number="4796">		rslt = bmi160_set_regs(<CheckRefs ids="2084">BMI160_INT_ENABLE_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="2085">1</CheckRefs>, dev);</Line>
  <Line number="4797">	}</Line>
  <Line number="4798"></Line>
  <Line number="4799">	return rslt;</Line>
  <Line number="4800">}</Line>
  <Line number="4801"></Line>
  <Line number="4802">/*!</Line>
  <Line number="4803"> *  @brief This API sets FIFO watermark interrupt of the sensor.The FIFO</Line>
  <Line number="4804"> *  watermark interrupt is fired, when the FIFO fill level is above a fifo</Line>
  <Line number="4805"> *  watermark.</Line>
  <Line number="4806"> */</Line>
  <Line number="4807">static int8_t set_fifo_watermark_int(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="4808">{ INIT_STUBS(dev);</Line>
  <Line number="4809">	int8_t rslt = <CheckRefs ids="2086">BMI160_OK</CheckRefs>;</Line>
  <Line number="4810"></Line>
  <Line number="4811">	if ((dev == NULL) || (dev-&gt;delay_ms == NULL)) {</Line>
  <Line number="4812">		rslt = <CheckRefs ids="2087,2088">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="4813">	} else {</Line>
  <Line number="4814">		/* Enable fifo-watermark interrupt in Int Enable 1 register */</Line>
  <Line number="4815">		rslt = enable_fifo_wtm_int(int_config, dev);</Line>
  <Line number="4816">		if (<CheckRefs ids="2089">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4817">			/* Configure Interrupt pins */</Line>
  <Line number="4818">			rslt = set_intr_pin_config(int_config, dev);</Line>
  <Line number="4819">			if (<CheckRefs ids="2090">rslt</CheckRefs> == BMI160_OK)</Line>
  <Line number="4820">				rslt = map_hardware_interrupt(int_config, dev);</Line>
  <Line number="4821">		}</Line>
  <Line number="4822">	}</Line>
  <Line number="4823"></Line>
  <Line number="4824">	return rslt;</Line>
  <Line number="4825">}</Line>
  <Line number="4826"></Line>
  <Line number="4827">/*!</Line>
  <Line number="4828"> * @brief This enable the FIFO watermark interrupt engine.</Line>
  <Line number="4829"> */</Line>
  <Line number="4830">static int8_t enable_fifo_wtm_int(const struct bmi160_int_settg *int_config, const struct bmi160_dev *dev)</Line>
  <Line number="4831">{ INIT_STUBS(dev);</Line>
  <Line number="4832">	int8_t rslt;</Line>
  <Line number="4833">	uint8_t data = <CheckRefs ids="2091">0</CheckRefs>;</Line>
  <Line number="4834"></Line>
  <Line number="4835">	rslt = bmi160_get_regs(<CheckRefs ids="2092">BMI160_INT_ENABLE_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="2093">1</CheckRefs>, dev);</Line>
  <Line number="4836"></Line>
  <Line number="4837">	if (<CheckRefs ids="2094">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="4838">		data = <CheckRefs ids="2096,2098,2099,2101,2095,2097,2100">BMI160_SET_BITS</CheckRefs>(data, BMI160_FIFO_WTM_INT, int_config-&gt;fifo_WTM_int_en);</Line>
  <Line number="4839">		/* Writing data to INT ENABLE 1 Address */</Line>
  <Line number="4840">		rslt = bmi160_set_regs(<CheckRefs ids="2102">BMI160_INT_ENABLE_1_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="2103">1</CheckRefs>, dev);</Line>
  <Line number="4841">	}</Line>
  <Line number="4842"></Line>
  <Line number="4843">	return rslt;</Line>
  <Line number="4844">}</Line>
  <Line number="4845"></Line>
  <Line number="4846">/*!</Line>
  <Line number="4847"> *  @brief This API is used to reset the FIFO related configurations</Line>
  <Line number="4848"> *  in the fifo_frame structure.</Line>
  <Line number="4849"> */</Line>
  <Line number="4850">static void reset_fifo_data_structure(const struct bmi160_dev *dev)</Line>
  <Line number="4851">{ INIT_STUBS(dev);</Line>
  <Line number="4852">	/*Prepare for next FIFO read by resetting FIFO&apos;s</Line>
  <Line number="4853">	internal data structures*/</Line>
  <Line number="4854">	dev-&gt;fifo-&gt;accel_byte_start_idx = <CheckRefs ids="2104">0</CheckRefs>;</Line>
  <Line number="4855">	dev-&gt;fifo-&gt;gyro_byte_start_idx = <CheckRefs ids="2105">0</CheckRefs>;</Line>
  <Line number="4856">	dev-&gt;fifo-&gt;aux_byte_start_idx = <CheckRefs ids="2106">0</CheckRefs>;</Line>
  <Line number="4857">	dev-&gt;fifo-&gt;sensor_time = <CheckRefs ids="2107">0</CheckRefs>;</Line>
  <Line number="4858">	dev-&gt;fifo-&gt;skipped_frame_count = <CheckRefs ids="2108">0</CheckRefs>;</Line>
  <Line number="4859">}</Line>
  <Line number="4860"></Line>
  <Line number="4861">/*!</Line>
  <Line number="4862"> *  @brief This API is used to read fifo_byte_counter value (i.e)</Line>
  <Line number="4863"> *  current fill-level in Fifo buffer.</Line>
  <Line number="4864"> */</Line>
  <Line number="4865">static int8_t get_fifo_byte_counter(uint16_t *bytes_to_read, struct bmi160_dev const *dev)</Line>
  <Line number="4866">{ INIT_STUBS(dev);</Line>
  <Line number="4867">	int8_t rslt = <CheckRefs ids="2109">0</CheckRefs>;</Line>
  <Line number="4868">	uint8_t data[2];</Line>
  <Line number="4869">	uint8_t addr = <CheckRefs ids="2110">BMI160_FIFO_LENGTH_ADDR</CheckRefs>;</Line>
  <Line number="4870"></Line>
  <Line number="4871">	rslt |= <CheckRefs ids="2111">bmi160_get_regs</CheckRefs>(addr, data, <CheckRefs ids="2112">2</CheckRefs>, dev);</Line>
  <Line number="4872">	data[1<CheckRefs ids="2113">]</CheckRefs> = <CheckRefs ids="2115">data</CheckRefs>[1<CheckRefs ids="2116">]</CheckRefs> <CheckRefs ids="2114">&amp;</CheckRefs> BMI160_FIFO_BYTE_COUNTER_MASK;</Line>
  <Line number="4873"></Line>
  <Line number="4874">	/* Available data in FIFO is stored in bytes_to_read*/</Line>
  <Line number="4875">	*bytes_to_read = <CheckRefs ids="2117">(</CheckRefs>(<CheckRefs ids="2121,2122">(</CheckRefs>uint16_t)data[1<CheckRefs ids="2123">]</CheckRefs> <CheckRefs ids="2118,2119,2120">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="2124">(</CheckRefs><CheckRefs ids="2125">(</CheckRefs>uint16_t)data[0<CheckRefs ids="2126">]</CheckRefs>));</Line>
  <Line number="4876"></Line>
  <Line number="4877">	return rslt;</Line>
  <Line number="4878">}</Line>
  <Line number="4879"></Line>
  <Line number="4880">/*!</Line>
  <Line number="4881"> *  @brief This API is used to compute the number of bytes of accel FIFO data</Line>
  <Line number="4882"> *  which is to be parsed in header-less mode</Line>
  <Line number="4883"> */</Line>
  <Line number="4884">static void get_accel_len_to_parse(uint16_t *data_index, uint16_t *data_read_length, const uint8_t *acc_frame_count,</Line>
  <Line number="4885">				const struct bmi160_dev *dev)</Line>
  <Line number="4886">{ INIT_STUBS(dev);</Line>
  <Line number="4887">	/* Data start index */</Line>
  <Line number="4888">	*data_index = dev-&gt;fifo-&gt;accel_byte_start_idx;</Line>
  <Line number="4889"></Line>
  <Line number="4890">	if (<CheckRefs ids="2127">dev</CheckRefs>-&gt;fifo-&gt;fifo_data_enable == BMI160_FIFO_A_ENABLE) {</Line>
  <Line number="4891">		*data_read_length = <CheckRefs ids="2130">(</CheckRefs>*acc_frame_count) <CheckRefs ids="2128,2129">*</CheckRefs> BMI160_FIFO_A_LENGTH;</Line>
  <Line number="4892">	} else if (<CheckRefs ids="2131">dev</CheckRefs>-&gt;fifo-&gt;fifo_data_enable == BMI160_FIFO_G_A_ENABLE) {</Line>
  <Line number="4893">		*data_read_length = <CheckRefs ids="2134">(</CheckRefs>*acc_frame_count) <CheckRefs ids="2132,2133">*</CheckRefs> BMI160_FIFO_GA_LENGTH;</Line>
  <Line number="4894">	} else if (<CheckRefs ids="2135">dev</CheckRefs>-&gt;fifo-&gt;fifo_data_enable == BMI160_FIFO_M_A_ENABLE) {</Line>
  <Line number="4895">		*data_read_length = <CheckRefs ids="2138">(</CheckRefs>*acc_frame_count) <CheckRefs ids="2136,2137">*</CheckRefs> BMI160_FIFO_MA_LENGTH;</Line>
  <Line number="4896">	} else if (<CheckRefs ids="2139">dev</CheckRefs>-&gt;fifo-&gt;fifo_data_enable == BMI160_FIFO_M_G_A_ENABLE) {</Line>
  <Line number="4897">		*data_read_length = <CheckRefs ids="2142">(</CheckRefs>*acc_frame_count) <CheckRefs ids="2141,2140">*</CheckRefs> BMI160_FIFO_MGA_LENGTH;</Line>
  <Line number="4898">	} else {</Line>
  <Line number="4899">		/* When accel is not enabled ,there will be no accel data.</Line>
  <Line number="4900">		so we update the data index as complete */</Line>
  <Line number="4901">		*data_index = dev-&gt;fifo-&gt;length;</Line>
  <Line number="4902">	}</Line>
  <Line number="4903"></Line>
  <Line number="4904">	if (<CheckRefs ids="2143">*</CheckRefs>data_read_length &gt; <CheckRefs ids="2144">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="4905">		/* Handling the case where more data is requested</Line>
  <Line number="4906">		than that is available*/</Line>
  <Line number="4907">		*data_read_length = dev-&gt;fifo-&gt;length;</Line>
  <Line number="4908">	}</Line>
  <Line number="4909"></Line>
  <Line number="4910">}</Line>
  <Line number="4911"></Line>
  <Line number="4912">/*!</Line>
  <Line number="4913"> *  @brief This API is used to parse the accelerometer data from the</Line>
  <Line number="4914"> *  FIFO data in both header mode and header-less mode.</Line>
  <Line number="4915"> *  It updates the idx value which is used to store the index of</Line>
  <Line number="4916"> *  the current data byte which is parsed.</Line>
  <Line number="4917"> */</Line>
  <Line number="4918">static void unpack_accel_frame(struct bmi160_sensor_data *acc, uint16_t *idx, uint8_t *acc_idx, uint8_t frame_info,</Line>
  <Line number="4919">				const struct bmi160_dev *dev)</Line>
  <Line number="4920">{ INIT_STUBS(dev);</Line>
  <Line number="4921">	switch (<CheckRefs ids="2145">frame_info</CheckRefs>) {</Line>
  <Line number="4922">	case <CheckRefs ids="2146">BMI160_FIFO_HEAD_A</CheckRefs>:</Line>
  <Line number="4923">	case <CheckRefs ids="2147">BMI160_FIFO_A_ENABLE</CheckRefs>:</Line>
  <Line number="4924">		/*Partial read, then skip the data*/</Line>
  <Line number="4925">		if ((<CheckRefs ids="2149">*</CheckRefs>idx <CheckRefs ids="2148">+</CheckRefs> BMI160_FIFO_A_LENGTH) &gt; <CheckRefs ids="2150">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="4926">			/*Update the data index as complete*/</Line>
  <Line number="4927">			*idx = dev-&gt;fifo-&gt;length;</Line>
  <Line number="4928">			break;</Line>
  <Line number="4929">		}</Line>
  <Line number="4930">		/*Unpack the data array into the structure instance &quot;acc&quot; */</Line>
  <Line number="4931">		unpack_accel_data(&amp;acc[*acc_idx], *idx, dev);</Line>
  <Line number="4932">		/*Move the data index*/</Line>
  <Line number="4933">		*idx = <CheckRefs ids="2153">*</CheckRefs>idx <CheckRefs ids="2152,2151">+</CheckRefs> BMI160_FIFO_A_LENGTH;</Line>
  <Line number="4934">		(*acc_idx)<CheckRefs ids="2154">++</CheckRefs>;</Line>
  <Line number="4935">		break;</Line>
  <Line number="4936">	case <CheckRefs ids="2155">BMI160_FIFO_HEAD_G_A</CheckRefs>:</Line>
  <Line number="4937">	case <CheckRefs ids="2156">BMI160_FIFO_G_A_ENABLE</CheckRefs>:</Line>
  <Line number="4938">		/*Partial read, then skip the data*/</Line>
  <Line number="4939">		if ((<CheckRefs ids="2158">*</CheckRefs>idx <CheckRefs ids="2157">+</CheckRefs> BMI160_FIFO_GA_LENGTH) &gt; <CheckRefs ids="2159">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="4940">			/*Update the data index as complete*/</Line>
  <Line number="4941">			*idx = dev-&gt;fifo-&gt;length;</Line>
  <Line number="4942">			break;</Line>
  <Line number="4943">		}</Line>
  <Line number="4944">		/*Unpack the data array into structure instance &quot;acc&quot;*/</Line>
  <Line number="4945">		unpack_accel_data(&amp;acc[*acc_idx], <CheckRefs ids="2162">*</CheckRefs>idx <CheckRefs ids="2161,2160">+</CheckRefs> BMI160_FIFO_G_LENGTH, dev);</Line>
  <Line number="4946">		/*Move the data index*/</Line>
  <Line number="4947">		*idx = <CheckRefs ids="2165">*</CheckRefs>idx <CheckRefs ids="2164,2163">+</CheckRefs> BMI160_FIFO_GA_LENGTH;</Line>
  <Line number="4948">		(*acc_idx)<CheckRefs ids="2166">++</CheckRefs>;</Line>
  <Line number="4949">		break;</Line>
  <Line number="4950">	case <CheckRefs ids="2167">BMI160_FIFO_HEAD_M_A</CheckRefs>:</Line>
  <Line number="4951">	case <CheckRefs ids="2168">BMI160_FIFO_M_A_ENABLE</CheckRefs>:</Line>
  <Line number="4952">		/*Partial read, then skip the data*/</Line>
  <Line number="4953">		if ((<CheckRefs ids="2170">*</CheckRefs>idx <CheckRefs ids="2169">+</CheckRefs> BMI160_FIFO_MA_LENGTH) &gt; <CheckRefs ids="2171">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="4954">			/*Update the data index as complete*/</Line>
  <Line number="4955">			*idx = dev-&gt;fifo-&gt;length;</Line>
  <Line number="4956">			break;</Line>
  <Line number="4957">		}</Line>
  <Line number="4958">		/*Unpack the data array into structure instance &quot;acc&quot;*/</Line>
  <Line number="4959">		unpack_accel_data(&amp;acc[*acc_idx], <CheckRefs ids="2174">*</CheckRefs>idx <CheckRefs ids="2173,2172">+</CheckRefs> BMI160_FIFO_M_LENGTH, dev);</Line>
  <Line number="4960">		/*Move the data index*/</Line>
  <Line number="4961">		*idx = <CheckRefs ids="2177">*</CheckRefs>idx <CheckRefs ids="2176,2175">+</CheckRefs> BMI160_FIFO_MA_LENGTH;</Line>
  <Line number="4962">		(*acc_idx)<CheckRefs ids="2178">++</CheckRefs>;</Line>
  <Line number="4963">		break;</Line>
  <Line number="4964">	case <CheckRefs ids="2179">BMI160_FIFO_HEAD_M_G_A</CheckRefs>:</Line>
  <Line number="4965">	case <CheckRefs ids="2180">BMI160_FIFO_M_G_A_ENABLE</CheckRefs>:</Line>
  <Line number="4966">		/*Partial read, then skip the data*/</Line>
  <Line number="4967">		if ((<CheckRefs ids="2182">*</CheckRefs>idx <CheckRefs ids="2181">+</CheckRefs> BMI160_FIFO_MGA_LENGTH) &gt; <CheckRefs ids="2183">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="4968">			/*Update the data index as complete*/</Line>
  <Line number="4969">			*idx = dev-&gt;fifo-&gt;length;</Line>
  <Line number="4970">			break;</Line>
  <Line number="4971">		}</Line>
  <Line number="4972">		/*Unpack the data array into structure instance &quot;acc&quot;*/</Line>
  <Line number="4973">		unpack_accel_data(&amp;acc[*acc_idx], <CheckRefs ids="2186">*</CheckRefs>idx <CheckRefs ids="2185,2184">+</CheckRefs> BMI160_FIFO_MG_LENGTH, dev);</Line>
  <Line number="4974">		/*Move the data index*/</Line>
  <Line number="4975">		*idx = <CheckRefs ids="2189">*</CheckRefs>idx <CheckRefs ids="2188,2187">+</CheckRefs> BMI160_FIFO_MGA_LENGTH;</Line>
  <Line number="4976">		(*acc_idx)<CheckRefs ids="2190">++</CheckRefs>;</Line>
  <Line number="4977">		break;</Line>
  <Line number="4978">	case <CheckRefs ids="2191">BMI160_FIFO_HEAD_M</CheckRefs>:</Line>
  <Line number="4979">	case <CheckRefs ids="2192">BMI160_FIFO_M_ENABLE</CheckRefs>:</Line>
  <Line number="4980">		(*idx) = <CheckRefs ids="2195">(</CheckRefs>*idx) <CheckRefs ids="2194,2193">+</CheckRefs> BMI160_FIFO_M_LENGTH;</Line>
  <Line number="4981">		break;</Line>
  <Line number="4982">	case <CheckRefs ids="2196">BMI160_FIFO_HEAD_G</CheckRefs>:</Line>
  <Line number="4983">	case <CheckRefs ids="2197">BMI160_FIFO_G_ENABLE</CheckRefs>:</Line>
  <Line number="4984">		(*idx) = <CheckRefs ids="2200">(</CheckRefs>*idx) <CheckRefs ids="2199,2198">+</CheckRefs> BMI160_FIFO_G_LENGTH;</Line>
  <Line number="4985">		break;</Line>
  <Line number="4986">	case <CheckRefs ids="2201">BMI160_FIFO_HEAD_M_G</CheckRefs>:</Line>
  <Line number="4987">	case <CheckRefs ids="2202">BMI160_FIFO_M_G_ENABLE</CheckRefs>:</Line>
  <Line number="4988">		(*idx) = <CheckRefs ids="2205">(</CheckRefs>*idx) <CheckRefs ids="2204,2203">+</CheckRefs> BMI160_FIFO_MG_LENGTH;</Line>
  <Line number="4989">		break;</Line>
  <Line number="4990">	default:</Line>
  <Line number="4991">		break;</Line>
  <Line number="4992">	}</Line>
  <Line number="4993"></Line>
  <Line number="4994">}</Line>
  <Line number="4995"></Line>
  <Line number="4996">/*!</Line>
  <Line number="4997"> *  @brief This API is used to parse the accelerometer data from the</Line>
  <Line number="4998"> *  FIFO data and store it in the instance of the structure bmi160_sensor_data.</Line>
  <Line number="4999"> */</Line>
  <Line number="5000">static void unpack_accel_data(struct bmi160_sensor_data *accel_data, uint16_t data_start_index,</Line>
  <Line number="5001">				const struct bmi160_dev *dev)</Line>
  <Line number="5002">{ INIT_STUBS(dev);</Line>
  <Line number="5003">	uint16_t data_lsb;</Line>
  <Line number="5004">	uint16_t data_msb;</Line>
  <Line number="5005"></Line>
  <Line number="5006">	/* Accel raw x data */</Line>
  <Line number="5007">	data_lsb = <CheckRefs ids="2206">dev</CheckRefs>-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2207">++</CheckRefs>];</Line>
  <Line number="5008">	data_msb = <CheckRefs ids="2208">dev</CheckRefs>-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2209">++</CheckRefs>];</Line>
  <Line number="5009">	accel_data-&gt;x = <CheckRefs ids="2210">(</CheckRefs>int16_t)((<CheckRefs ids="2214">data_msb</CheckRefs> <CheckRefs ids="2212,2211,2213">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="2215">data_lsb</CheckRefs>);</Line>
  <Line number="5010"></Line>
  <Line number="5011">	/* Accel raw y data */</Line>
  <Line number="5012">	data_lsb = <CheckRefs ids="2216">dev</CheckRefs>-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2217">++</CheckRefs>];</Line>
  <Line number="5013">	data_msb = <CheckRefs ids="2218">dev</CheckRefs>-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2219">++</CheckRefs>];</Line>
  <Line number="5014">	accel_data-&gt;y = <CheckRefs ids="2220">(</CheckRefs>int16_t)((<CheckRefs ids="2224">data_msb</CheckRefs> <CheckRefs ids="2221,2222,2223">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="2225">data_lsb</CheckRefs>);</Line>
  <Line number="5015"></Line>
  <Line number="5016">	/* Accel raw z data */</Line>
  <Line number="5017">	data_lsb = <CheckRefs ids="2226">dev</CheckRefs>-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2227">++</CheckRefs>];</Line>
  <Line number="5018">	data_msb = <CheckRefs ids="2228">dev</CheckRefs>-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2229">++</CheckRefs>];</Line>
  <Line number="5019">	accel_data-&gt;z = <CheckRefs ids="2230">(</CheckRefs>int16_t)((<CheckRefs ids="2234">data_msb</CheckRefs> <CheckRefs ids="2231,2232,2233">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="2235">data_lsb</CheckRefs>);</Line>
  <Line number="5020"></Line>
  <Line number="5021">}</Line>
  <Line number="5022"></Line>
  <Line number="5023">/*!</Line>
  <Line number="5024"> *  @brief This API is used to parse the accelerometer data from the</Line>
  <Line number="5025"> *  FIFO data in header mode.</Line>
  <Line number="5026"> */</Line>
  <Line number="5027">static void extract_accel_header_mode(struct bmi160_sensor_data *accel_data, uint8_t *accel_length,</Line>
  <Line number="5028">					const struct bmi160_dev *dev)</Line>
  <Line number="5029">{ INIT_STUBS(dev);</Line>
  <Line number="5030">	uint8_t frame_header = <CheckRefs ids="2236">0</CheckRefs>;</Line>
  <Line number="5031">	uint16_t data_index;</Line>
  <Line number="5032">	uint8_t accel_index = <CheckRefs ids="2237">0</CheckRefs>;</Line>
  <Line number="5033"></Line>
  <Line number="5034">	for (data_index = dev-&gt;fifo-&gt;accel_byte_start_idx; <CheckRefs ids="2238">data_index</CheckRefs> &lt; <CheckRefs ids="2239">dev</CheckRefs>-&gt;fifo-&gt;length;) {</Line>
  <Line number="5035">		/* extracting Frame header */</Line>
  <Line number="5036">		frame_header = <CheckRefs ids="2240">(</CheckRefs><CheckRefs ids="2241">dev</CheckRefs>-&gt;fifo-&gt;data[data_index] &amp; BMI160_FIFO_TAG_INTR_MASK);</Line>
  <Line number="5037">		/*Index is moved to next byte where the data is starting*/</Line>
  <Line number="5038">		data_index<CheckRefs ids="2242">++</CheckRefs>;</Line>
  <Line number="5039"></Line>
  <Line number="5040">		switch (<CheckRefs ids="2243">frame_header</CheckRefs>) {</Line>
  <Line number="5041">		/* Accel frame */</Line>
  <Line number="5042">		case <CheckRefs ids="2244">BMI160_FIFO_HEAD_A</CheckRefs>:</Line>
  <Line number="5043">		case <CheckRefs ids="2245">BMI160_FIFO_HEAD_M_A</CheckRefs>:</Line>
  <Line number="5044">		case <CheckRefs ids="2246">BMI160_FIFO_HEAD_G_A</CheckRefs>:</Line>
  <Line number="5045">		case <CheckRefs ids="2247">BMI160_FIFO_HEAD_M_G_A</CheckRefs>:</Line>
  <Line number="5046">			unpack_accel_frame(accel_data, &amp;data_index, &amp;accel_index, frame_header, dev);</Line>
  <Line number="5047">			break;</Line>
  <Line number="5048">		case <CheckRefs ids="2248">BMI160_FIFO_HEAD_M</CheckRefs>:</Line>
  <Line number="5049">			move_next_frame(&amp;data_index, <CheckRefs ids="2249">BMI160_FIFO_M_LENGTH</CheckRefs>, dev);</Line>
  <Line number="5050">			break;</Line>
  <Line number="5051"></Line>
  <Line number="5052">		case <CheckRefs ids="2250">BMI160_FIFO_HEAD_G</CheckRefs>:</Line>
  <Line number="5053">			move_next_frame(&amp;data_index, <CheckRefs ids="2251">BMI160_FIFO_G_LENGTH</CheckRefs>, dev);</Line>
  <Line number="5054">			break;</Line>
  <Line number="5055">		case <CheckRefs ids="2252">BMI160_FIFO_HEAD_M_G</CheckRefs>:</Line>
  <Line number="5056">			move_next_frame(&amp;data_index, <CheckRefs ids="2253">BMI160_FIFO_MG_LENGTH</CheckRefs>, dev);</Line>
  <Line number="5057">			break;</Line>
  <Line number="5058">			/* Sensor time frame */</Line>
  <Line number="5059">		case <CheckRefs ids="2254">BMI160_FIFO_HEAD_SENSOR_TIME</CheckRefs>:</Line>
  <Line number="5060">			unpack_sensortime_frame(&amp;data_index, dev);</Line>
  <Line number="5061">			break;</Line>
  <Line number="5062">			/* Skip frame */</Line>
  <Line number="5063">		case <CheckRefs ids="2255">BMI160_FIFO_HEAD_SKIP_FRAME</CheckRefs>:</Line>
  <Line number="5064">			unpack_skipped_frame(&amp;data_index, dev);</Line>
  <Line number="5065">			break;</Line>
  <Line number="5066">			/* Input config frame */</Line>
  <Line number="5067">		case <CheckRefs ids="2256">BMI160_FIFO_HEAD_INPUT_CONFIG</CheckRefs>:</Line>
  <Line number="5068">			move_next_frame(&amp;data_index, <CheckRefs ids="2257">1</CheckRefs>, dev);</Line>
  <Line number="5069">			break;</Line>
  <Line number="5070">		case <CheckRefs ids="2258">BMI160_FIFO_HEAD_OVER_READ</CheckRefs>:</Line>
  <Line number="5071">			/* Update the data index as complete in case of Over read */</Line>
  <Line number="5072">			data_index = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5073">			break;</Line>
  <Line number="5074">		default:</Line>
  <Line number="5075">			break;</Line>
  <Line number="5076">		}</Line>
  <Line number="5077">		if (<CheckRefs ids="2259">*</CheckRefs>accel_length == <CheckRefs ids="2260">accel_index</CheckRefs>) {</Line>
  <Line number="5078">			/* Number of frames to read completed */</Line>
  <Line number="5079">			break;</Line>
  <Line number="5080">		}</Line>
  <Line number="5081">	}</Line>
  <Line number="5082"></Line>
  <Line number="5083">	/*Update number of accel data read*/</Line>
  <Line number="5084">	*accel_length = accel_index;</Line>
  <Line number="5085">	/*Update the accel frame index*/</Line>
  <Line number="5086">	dev-&gt;fifo-&gt;accel_byte_start_idx = data_index;</Line>
  <Line number="5087">}</Line>
  <Line number="5088"></Line>
  <Line number="5089">/*!</Line>
  <Line number="5090"> *  @brief This API computes the number of bytes of gyro FIFO data</Line>
  <Line number="5091"> *  which is to be parsed in header-less mode</Line>
  <Line number="5092"> */</Line>
  <Line number="5093">static void get_gyro_len_to_parse(uint16_t *data_index, uint16_t *data_read_length, const uint8_t *gyro_frame_count,</Line>
  <Line number="5094">					const struct bmi160_dev *dev)</Line>
  <Line number="5095">{ INIT_STUBS(dev);</Line>
  <Line number="5096">	/* Data start index */</Line>
  <Line number="5097">	*data_index = dev-&gt;fifo-&gt;gyro_byte_start_idx;</Line>
  <Line number="5098"></Line>
  <Line number="5099">	if (<CheckRefs ids="2261">dev</CheckRefs>-&gt;fifo-&gt;fifo_data_enable == BMI160_FIFO_G_ENABLE) {</Line>
  <Line number="5100">		*data_read_length = <CheckRefs ids="2264">(</CheckRefs>*gyro_frame_count) <CheckRefs ids="2262,2263">*</CheckRefs> BMI160_FIFO_G_LENGTH;</Line>
  <Line number="5101">	} else if (<CheckRefs ids="2265">dev</CheckRefs>-&gt;fifo-&gt;fifo_data_enable == BMI160_FIFO_G_A_ENABLE) {</Line>
  <Line number="5102">		*data_read_length = <CheckRefs ids="2268">(</CheckRefs>*gyro_frame_count) <CheckRefs ids="2266,2267">*</CheckRefs> BMI160_FIFO_GA_LENGTH;</Line>
  <Line number="5103">	} else if (<CheckRefs ids="2269">dev</CheckRefs>-&gt;fifo-&gt;fifo_data_enable == BMI160_FIFO_M_G_ENABLE) {</Line>
  <Line number="5104">		*data_read_length = <CheckRefs ids="2272">(</CheckRefs>*gyro_frame_count) <CheckRefs ids="2270,2271">*</CheckRefs> BMI160_FIFO_MG_LENGTH;</Line>
  <Line number="5105">	} else if (<CheckRefs ids="2273">dev</CheckRefs>-&gt;fifo-&gt;fifo_data_enable == BMI160_FIFO_M_G_A_ENABLE) {</Line>
  <Line number="5106">		*data_read_length = <CheckRefs ids="2276">(</CheckRefs>*gyro_frame_count) <CheckRefs ids="2274,2275">*</CheckRefs> BMI160_FIFO_MGA_LENGTH;</Line>
  <Line number="5107">	} else {</Line>
  <Line number="5108">		/* When gyro is not enabled ,there will be no gyro data.</Line>
  <Line number="5109">		so we update the data index as complete */</Line>
  <Line number="5110">		*data_index = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5111">	}</Line>
  <Line number="5112"></Line>
  <Line number="5113">	if (<CheckRefs ids="2277">*</CheckRefs>data_read_length &gt; <CheckRefs ids="2278">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="5114">		/* Handling the case where more data is requested</Line>
  <Line number="5115">		than that is available*/</Line>
  <Line number="5116">		*data_read_length = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5117">	}</Line>
  <Line number="5118"></Line>
  <Line number="5119">}</Line>
  <Line number="5120"></Line>
  <Line number="5121"></Line>
  <Line number="5122">/*!</Line>
  <Line number="5123"> *  @brief This API is used to parse the gyroscope&apos;s data from the</Line>
  <Line number="5124"> *  FIFO data in both header mode and header-less mode.</Line>
  <Line number="5125"> *  It updates the idx value which is used to store the index of</Line>
  <Line number="5126"> *  the current data byte which is parsed.</Line>
  <Line number="5127"> */</Line>
  <Line number="5128">static void unpack_gyro_frame(struct bmi160_sensor_data *gyro, uint16_t *idx, uint8_t *gyro_idx, uint8_t frame_info,</Line>
  <Line number="5129">				const struct bmi160_dev *dev)</Line>
  <Line number="5130">{ INIT_STUBS(dev);</Line>
  <Line number="5131">	switch (<CheckRefs ids="2279">frame_info</CheckRefs>) {</Line>
  <Line number="5132"></Line>
  <Line number="5133">	case <CheckRefs ids="2280">BMI160_FIFO_HEAD_G</CheckRefs>:</Line>
  <Line number="5134">	case <CheckRefs ids="2281">BMI160_FIFO_G_ENABLE</CheckRefs>:</Line>
  <Line number="5135">		/*Partial read, then skip the data*/</Line>
  <Line number="5136">		if ((<CheckRefs ids="2283">*</CheckRefs>idx <CheckRefs ids="2282">+</CheckRefs> BMI160_FIFO_G_LENGTH) &gt; <CheckRefs ids="2284">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="5137">			/*Update the data index as complete*/</Line>
  <Line number="5138">			*idx = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5139">			break;</Line>
  <Line number="5140">		}</Line>
  <Line number="5141">		/*Unpack the data array into structure instance &quot;gyro&quot;*/</Line>
  <Line number="5142">		unpack_gyro_data(&amp;gyro[*gyro_idx], *idx, dev);</Line>
  <Line number="5143">		/*Move the data index*/</Line>
  <Line number="5144">		(*idx) = <CheckRefs ids="2287">(</CheckRefs>*idx) <CheckRefs ids="2286,2285">+</CheckRefs> BMI160_FIFO_G_LENGTH;</Line>
  <Line number="5145">		(*gyro_idx)<CheckRefs ids="2288">++</CheckRefs>;</Line>
  <Line number="5146">		break;</Line>
  <Line number="5147"></Line>
  <Line number="5148">	case <CheckRefs ids="2289">BMI160_FIFO_HEAD_G_A</CheckRefs>:</Line>
  <Line number="5149">	case <CheckRefs ids="2290">BMI160_FIFO_G_A_ENABLE</CheckRefs>:</Line>
  <Line number="5150">		/*Partial read, then skip the data*/</Line>
  <Line number="5151">		if ((<CheckRefs ids="2292">*</CheckRefs>idx <CheckRefs ids="2291">+</CheckRefs> BMI160_FIFO_GA_LENGTH) &gt; <CheckRefs ids="2293">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="5152">			/*Update the data index as complete*/</Line>
  <Line number="5153">			*idx = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5154">			break;</Line>
  <Line number="5155">		}</Line>
  <Line number="5156">		/* Unpack the data array into structure instance &quot;gyro&quot; */</Line>
  <Line number="5157">		unpack_gyro_data(&amp;gyro[*gyro_idx], *idx, dev);</Line>
  <Line number="5158">		/* Move the data index */</Line>
  <Line number="5159">		*idx = <CheckRefs ids="2296">*</CheckRefs>idx <CheckRefs ids="2295,2294">+</CheckRefs> BMI160_FIFO_GA_LENGTH;</Line>
  <Line number="5160">		(*gyro_idx)<CheckRefs ids="2297">++</CheckRefs>;</Line>
  <Line number="5161">		break;</Line>
  <Line number="5162"></Line>
  <Line number="5163">	case <CheckRefs ids="2298">BMI160_FIFO_HEAD_M_G_A</CheckRefs>:</Line>
  <Line number="5164">	case <CheckRefs ids="2299">BMI160_FIFO_M_G_A_ENABLE</CheckRefs>:</Line>
  <Line number="5165">		/*Partial read, then skip the data*/</Line>
  <Line number="5166">		if ((<CheckRefs ids="2301">*</CheckRefs>idx <CheckRefs ids="2300">+</CheckRefs> BMI160_FIFO_MGA_LENGTH) &gt; <CheckRefs ids="2302">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="5167">			/*Update the data index as complete*/</Line>
  <Line number="5168">			*idx = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5169">			break;</Line>
  <Line number="5170">		}</Line>
  <Line number="5171">		/*Unpack the data array into structure instance &quot;gyro&quot;*/</Line>
  <Line number="5172">		unpack_gyro_data(&amp;gyro[*gyro_idx], <CheckRefs ids="2305">*</CheckRefs>idx <CheckRefs ids="2304,2303">+</CheckRefs> BMI160_FIFO_M_LENGTH, dev);</Line>
  <Line number="5173">		/*Move the data index*/</Line>
  <Line number="5174">		*idx = <CheckRefs ids="2308">*</CheckRefs>idx <CheckRefs ids="2307,2306">+</CheckRefs> BMI160_FIFO_MGA_LENGTH;</Line>
  <Line number="5175">		(*gyro_idx)<CheckRefs ids="2309">++</CheckRefs>;</Line>
  <Line number="5176">		break;</Line>
  <Line number="5177"></Line>
  <Line number="5178"></Line>
  <Line number="5179">	case <CheckRefs ids="2310">BMI160_FIFO_HEAD_M_A</CheckRefs>:</Line>
  <Line number="5180">	case <CheckRefs ids="2311">BMI160_FIFO_M_A_ENABLE</CheckRefs>:</Line>
  <Line number="5181">		/* Move the data index */</Line>
  <Line number="5182">		*idx = <CheckRefs ids="2314">*</CheckRefs>idx <CheckRefs ids="2313,2312">+</CheckRefs> BMI160_FIFO_MA_LENGTH;</Line>
  <Line number="5183">		break;</Line>
  <Line number="5184"></Line>
  <Line number="5185">	case <CheckRefs ids="2315">BMI160_FIFO_HEAD_M</CheckRefs>:</Line>
  <Line number="5186">	case <CheckRefs ids="2316">BMI160_FIFO_M_ENABLE</CheckRefs>:</Line>
  <Line number="5187">		(*idx) = <CheckRefs ids="2319">(</CheckRefs>*idx) <CheckRefs ids="2318,2317">+</CheckRefs> BMI160_FIFO_M_LENGTH;</Line>
  <Line number="5188">		break;</Line>
  <Line number="5189"></Line>
  <Line number="5190">	case <CheckRefs ids="2320">BMI160_FIFO_HEAD_M_G</CheckRefs>:</Line>
  <Line number="5191">	case <CheckRefs ids="2321">BMI160_FIFO_M_G_ENABLE</CheckRefs>:</Line>
  <Line number="5192">		/*Partial read, then skip the data*/</Line>
  <Line number="5193">		if ((<CheckRefs ids="2323">*</CheckRefs>idx <CheckRefs ids="2322">+</CheckRefs> BMI160_FIFO_MG_LENGTH) &gt; <CheckRefs ids="2324">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="5194">			/*Update the data index as complete*/</Line>
  <Line number="5195">			*idx = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5196">			break;</Line>
  <Line number="5197">		}</Line>
  <Line number="5198">		/*Unpack the data array into structure instance &quot;gyro&quot;*/</Line>
  <Line number="5199">		unpack_gyro_data(&amp;gyro[*gyro_idx], <CheckRefs ids="2327">*</CheckRefs>idx <CheckRefs ids="2326,2325">+</CheckRefs> BMI160_FIFO_M_LENGTH, dev);</Line>
  <Line number="5200">		/*Move the data index*/</Line>
  <Line number="5201">		(*idx) = <CheckRefs ids="2330">(</CheckRefs>*idx) <CheckRefs ids="2329,2328">+</CheckRefs> BMI160_FIFO_MG_LENGTH;</Line>
  <Line number="5202">		(*gyro_idx)<CheckRefs ids="2331">++</CheckRefs>;</Line>
  <Line number="5203">		break;</Line>
  <Line number="5204"></Line>
  <Line number="5205">	case <CheckRefs ids="2332">BMI160_FIFO_HEAD_A</CheckRefs>:</Line>
  <Line number="5206">	case <CheckRefs ids="2333">BMI160_FIFO_A_ENABLE</CheckRefs>:</Line>
  <Line number="5207">		/*Move the data index*/</Line>
  <Line number="5208">		*idx = <CheckRefs ids="2336">*</CheckRefs>idx <CheckRefs ids="2335,2334">+</CheckRefs> BMI160_FIFO_A_LENGTH;</Line>
  <Line number="5209">		break;</Line>
  <Line number="5210"></Line>
  <Line number="5211">	default:</Line>
  <Line number="5212">		break;</Line>
  <Line number="5213">	}</Line>
  <Line number="5214"></Line>
  <Line number="5215">}</Line>
  <Line number="5216"></Line>
  <Line number="5217">/*!</Line>
  <Line number="5218"> *  @brief This API is used to parse the gyro data from the</Line>
  <Line number="5219"> *  FIFO data and store it in the instance of the structure bmi160_sensor_data.</Line>
  <Line number="5220"> */</Line>
  <Line number="5221">static void unpack_gyro_data(struct bmi160_sensor_data *gyro_data, uint16_t data_start_index,</Line>
  <Line number="5222">				const struct bmi160_dev *dev)</Line>
  <Line number="5223">{ INIT_STUBS(dev);</Line>
  <Line number="5224">	uint16_t data_lsb;</Line>
  <Line number="5225">	uint16_t data_msb;</Line>
  <Line number="5226"></Line>
  <Line number="5227">	/* Gyro raw x data */</Line>
  <Line number="5228">	data_lsb = <CheckRefs ids="2337">dev</CheckRefs>-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2338">++</CheckRefs>];</Line>
  <Line number="5229">	data_msb = <CheckRefs ids="2339">dev</CheckRefs>-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2340">++</CheckRefs>];</Line>
  <Line number="5230">	gyro_data-&gt;x = <CheckRefs ids="2341">(</CheckRefs>int16_t)((<CheckRefs ids="2345">data_msb</CheckRefs> <CheckRefs ids="2343,2342,2344">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="2346">data_lsb</CheckRefs>);</Line>
  <Line number="5231"></Line>
  <Line number="5232">	/* Gyro raw y data */</Line>
  <Line number="5233">	data_lsb = <CheckRefs ids="2347">dev</CheckRefs>-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2348">++</CheckRefs>];</Line>
  <Line number="5234">	data_msb = <CheckRefs ids="2349">dev</CheckRefs>-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2350">++</CheckRefs>];</Line>
  <Line number="5235">	gyro_data-&gt;y = <CheckRefs ids="2351">(</CheckRefs>int16_t)((<CheckRefs ids="2355">data_msb</CheckRefs> <CheckRefs ids="2352,2353,2354">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="2356">data_lsb</CheckRefs>);</Line>
  <Line number="5236"></Line>
  <Line number="5237">	/* Gyro raw z data */</Line>
  <Line number="5238">	data_lsb = <CheckRefs ids="2357">dev</CheckRefs>-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2358">++</CheckRefs>];</Line>
  <Line number="5239">	data_msb = <CheckRefs ids="2359">dev</CheckRefs>-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2360">++</CheckRefs>];</Line>
  <Line number="5240">	gyro_data-&gt;z = <CheckRefs ids="2361">(</CheckRefs>int16_t)((<CheckRefs ids="2365">data_msb</CheckRefs> <CheckRefs ids="2363,2362,2364">&lt;&lt;</CheckRefs> 8) | <CheckRefs ids="2366">data_lsb</CheckRefs>);</Line>
  <Line number="5241"></Line>
  <Line number="5242">}</Line>
  <Line number="5243"></Line>
  <Line number="5244">/*!</Line>
  <Line number="5245"> *  @brief This API is used to parse the gyro data from the</Line>
  <Line number="5246"> *  FIFO data in header mode.</Line>
  <Line number="5247"> */</Line>
  <Line number="5248">static void extract_gyro_header_mode(struct bmi160_sensor_data *gyro_data, uint8_t *gyro_length,</Line>
  <Line number="5249">					const struct bmi160_dev *dev)</Line>
  <Line number="5250">{ INIT_STUBS(dev);</Line>
  <Line number="5251">	uint8_t frame_header = <CheckRefs ids="2367">0</CheckRefs>;</Line>
  <Line number="5252">	uint16_t data_index;</Line>
  <Line number="5253">	uint8_t gyro_index = <CheckRefs ids="2368">0</CheckRefs>;</Line>
  <Line number="5254"></Line>
  <Line number="5255">	for (data_index = dev-&gt;fifo-&gt;gyro_byte_start_idx; <CheckRefs ids="2369">data_index</CheckRefs> &lt; <CheckRefs ids="2370">dev</CheckRefs>-&gt;fifo-&gt;length;) {</Line>
  <Line number="5256">		/* extracting Frame header */</Line>
  <Line number="5257">		frame_header = <CheckRefs ids="2371">(</CheckRefs><CheckRefs ids="2372">dev</CheckRefs>-&gt;fifo-&gt;data[data_index] &amp; BMI160_FIFO_TAG_INTR_MASK);</Line>
  <Line number="5258">		/*Index is moved to next byte where the data is starting*/</Line>
  <Line number="5259">		data_index<CheckRefs ids="2373">++</CheckRefs>;</Line>
  <Line number="5260"></Line>
  <Line number="5261">		switch (<CheckRefs ids="2374">frame_header</CheckRefs>) {</Line>
  <Line number="5262">			/* GYRO frame */</Line>
  <Line number="5263">		case <CheckRefs ids="2375">BMI160_FIFO_HEAD_G</CheckRefs>:</Line>
  <Line number="5264">		case <CheckRefs ids="2376">BMI160_FIFO_HEAD_G_A</CheckRefs>:</Line>
  <Line number="5265">		case <CheckRefs ids="2377">BMI160_FIFO_HEAD_M_G</CheckRefs>:</Line>
  <Line number="5266">		case <CheckRefs ids="2378">BMI160_FIFO_HEAD_M_G_A</CheckRefs>:</Line>
  <Line number="5267">			unpack_gyro_frame(gyro_data, &amp;data_index, &amp;gyro_index, frame_header, dev);</Line>
  <Line number="5268">			break;</Line>
  <Line number="5269">		case <CheckRefs ids="2379">BMI160_FIFO_HEAD_A</CheckRefs>:</Line>
  <Line number="5270">			move_next_frame(&amp;data_index, <CheckRefs ids="2380">BMI160_FIFO_A_LENGTH</CheckRefs>, dev);</Line>
  <Line number="5271">			break;</Line>
  <Line number="5272">		case <CheckRefs ids="2381">BMI160_FIFO_HEAD_M</CheckRefs>:</Line>
  <Line number="5273">			move_next_frame(&amp;data_index, <CheckRefs ids="2382">BMI160_FIFO_M_LENGTH</CheckRefs>, dev);</Line>
  <Line number="5274">			break;</Line>
  <Line number="5275">		case <CheckRefs ids="2383">BMI160_FIFO_HEAD_M_A</CheckRefs>:</Line>
  <Line number="5276">			move_next_frame(&amp;data_index, <CheckRefs ids="2384">BMI160_FIFO_M_LENGTH</CheckRefs>, dev);</Line>
  <Line number="5277">			break;</Line>
  <Line number="5278">			/* Sensor time frame */</Line>
  <Line number="5279">		case <CheckRefs ids="2385">BMI160_FIFO_HEAD_SENSOR_TIME</CheckRefs>:</Line>
  <Line number="5280">			unpack_sensortime_frame(&amp;data_index, dev);</Line>
  <Line number="5281">			break;</Line>
  <Line number="5282">			/* Skip frame */</Line>
  <Line number="5283">		case <CheckRefs ids="2386">BMI160_FIFO_HEAD_SKIP_FRAME</CheckRefs>:</Line>
  <Line number="5284">			unpack_skipped_frame(&amp;data_index, dev);</Line>
  <Line number="5285">			break;</Line>
  <Line number="5286">			/* Input config frame */</Line>
  <Line number="5287">		case <CheckRefs ids="2387">BMI160_FIFO_HEAD_INPUT_CONFIG</CheckRefs>:</Line>
  <Line number="5288">			move_next_frame(&amp;data_index, <CheckRefs ids="2388">1</CheckRefs>, dev);</Line>
  <Line number="5289">			break;</Line>
  <Line number="5290">		case <CheckRefs ids="2389">BMI160_FIFO_HEAD_OVER_READ</CheckRefs>:</Line>
  <Line number="5291">			/* Update the data index as complete in case of over read */</Line>
  <Line number="5292">			data_index = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5293">			break;</Line>
  <Line number="5294">		default:</Line>
  <Line number="5295">			break;</Line>
  <Line number="5296">		}</Line>
  <Line number="5297">		if (<CheckRefs ids="2390">*</CheckRefs>gyro_length == <CheckRefs ids="2391">gyro_index</CheckRefs>) {</Line>
  <Line number="5298">			/*Number of frames to read completed*/</Line>
  <Line number="5299">			break;</Line>
  <Line number="5300">		}</Line>
  <Line number="5301">	}</Line>
  <Line number="5302"></Line>
  <Line number="5303">	/*Update number of gyro data read*/</Line>
  <Line number="5304">	*gyro_length = gyro_index;</Line>
  <Line number="5305">	/*Update the gyro frame index*/</Line>
  <Line number="5306">	dev-&gt;fifo-&gt;gyro_byte_start_idx = data_index;</Line>
  <Line number="5307">}</Line>
  <Line number="5308"></Line>
  <Line number="5309">/*!</Line>
  <Line number="5310"> *  @brief This API computes the number of bytes of aux FIFO data</Line>
  <Line number="5311"> *  which is to be parsed in header-less mode</Line>
  <Line number="5312"> */</Line>
  <Line number="5313">static void get_aux_len_to_parse(uint16_t *data_index, uint16_t *data_read_length, const uint8_t *aux_frame_count,</Line>
  <Line number="5314">					const struct bmi160_dev *dev)</Line>
  <Line number="5315">{ INIT_STUBS(dev);</Line>
  <Line number="5316">	/* Data start index */</Line>
  <Line number="5317">	*data_index = dev-&gt;fifo-&gt;gyro_byte_start_idx;</Line>
  <Line number="5318"></Line>
  <Line number="5319">	if (<CheckRefs ids="2392">dev</CheckRefs>-&gt;fifo-&gt;fifo_data_enable == BMI160_FIFO_M_ENABLE) {</Line>
  <Line number="5320">		*data_read_length = <CheckRefs ids="2395">(</CheckRefs>*aux_frame_count) <CheckRefs ids="2393,2394">*</CheckRefs> BMI160_FIFO_M_LENGTH;</Line>
  <Line number="5321">	} else if (<CheckRefs ids="2396">dev</CheckRefs>-&gt;fifo-&gt;fifo_data_enable == BMI160_FIFO_M_A_ENABLE) {</Line>
  <Line number="5322">		*data_read_length = <CheckRefs ids="2399">(</CheckRefs>*aux_frame_count) <CheckRefs ids="2397,2398">*</CheckRefs> BMI160_FIFO_MA_LENGTH;</Line>
  <Line number="5323">	} else if (<CheckRefs ids="2400">dev</CheckRefs>-&gt;fifo-&gt;fifo_data_enable == BMI160_FIFO_M_G_ENABLE) {</Line>
  <Line number="5324">		*data_read_length = <CheckRefs ids="2403">(</CheckRefs>*aux_frame_count) <CheckRefs ids="2401,2402">*</CheckRefs> BMI160_FIFO_MG_LENGTH;</Line>
  <Line number="5325">	} else if (<CheckRefs ids="2404">dev</CheckRefs>-&gt;fifo-&gt;fifo_data_enable == BMI160_FIFO_M_G_A_ENABLE) {</Line>
  <Line number="5326">		*data_read_length = <CheckRefs ids="2407">(</CheckRefs>*aux_frame_count) <CheckRefs ids="2405,2406">*</CheckRefs> BMI160_FIFO_MGA_LENGTH;</Line>
  <Line number="5327">	} else {</Line>
  <Line number="5328">		/* When aux is not enabled ,there will be no aux data.</Line>
  <Line number="5329">		 * so we update the data index as complete */</Line>
  <Line number="5330">		*data_index = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5331">	}</Line>
  <Line number="5332"></Line>
  <Line number="5333">	if (<CheckRefs ids="2408">*</CheckRefs>data_read_length &gt; <CheckRefs ids="2409">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="5334">		/* Handling the case where more data is requested</Line>
  <Line number="5335">		 * than that is available */</Line>
  <Line number="5336">		*data_read_length = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5337">	}</Line>
  <Line number="5338">}</Line>
  <Line number="5339"></Line>
  <Line number="5340">/*!</Line>
  <Line number="5341"> *  @brief This API is used to parse the aux&apos;s data from the</Line>
  <Line number="5342"> *  FIFO data in both header mode and header-less mode.</Line>
  <Line number="5343"> *  It updates the idx value which is used to store the index of</Line>
  <Line number="5344"> *  the current data byte which is parsed</Line>
  <Line number="5345"> */</Line>
  <Line number="5346">static void unpack_aux_frame(struct bmi160_aux_data *aux_data, uint16_t *idx, uint8_t *aux_index, uint8_t frame_info,</Line>
  <Line number="5347">				const struct bmi160_dev *dev)</Line>
  <Line number="5348">{ INIT_STUBS(dev);</Line>
  <Line number="5349">	switch (<CheckRefs ids="2410">frame_info</CheckRefs>) {</Line>
  <Line number="5350"></Line>
  <Line number="5351">	case <CheckRefs ids="2411">BMI160_FIFO_HEAD_M</CheckRefs>:</Line>
  <Line number="5352">	case <CheckRefs ids="2412">BMI160_FIFO_M_ENABLE</CheckRefs>:</Line>
  <Line number="5353">		/* Partial read, then skip the data */</Line>
  <Line number="5354">		if ((<CheckRefs ids="2414">*</CheckRefs>idx <CheckRefs ids="2413">+</CheckRefs> BMI160_FIFO_M_LENGTH) &gt; <CheckRefs ids="2415">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="5355">			/* Update the data index as complete */</Line>
  <Line number="5356">			*idx = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5357">			break;</Line>
  <Line number="5358">		}</Line>
  <Line number="5359">		/* Unpack the data array into structure instance */</Line>
  <Line number="5360">		unpack_aux_data(&amp;aux_data[*aux_index], *idx, dev);</Line>
  <Line number="5361">		/* Move the data index */</Line>
  <Line number="5362">		*idx = <CheckRefs ids="2418">*</CheckRefs>idx <CheckRefs ids="2417,2416">+</CheckRefs> BMI160_FIFO_M_LENGTH;</Line>
  <Line number="5363">		(*aux_index)<CheckRefs ids="2419">++</CheckRefs>;</Line>
  <Line number="5364">		break;</Line>
  <Line number="5365"></Line>
  <Line number="5366">	case <CheckRefs ids="2420">BMI160_FIFO_HEAD_M_A</CheckRefs>:</Line>
  <Line number="5367">	case <CheckRefs ids="2421">BMI160_FIFO_M_A_ENABLE</CheckRefs>:</Line>
  <Line number="5368">		/* Partial read, then skip the data */</Line>
  <Line number="5369">		if ((<CheckRefs ids="2423">*</CheckRefs>idx <CheckRefs ids="2422">+</CheckRefs> BMI160_FIFO_MA_LENGTH) &gt; <CheckRefs ids="2424">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="5370">			/* Update the data index as complete */</Line>
  <Line number="5371">			*idx = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5372">			break;</Line>
  <Line number="5373">		}</Line>
  <Line number="5374">		/* Unpack the data array into structure instance */</Line>
  <Line number="5375">		unpack_aux_data(&amp;aux_data[*aux_index], *idx, dev);</Line>
  <Line number="5376">		/* Move the data index */</Line>
  <Line number="5377">		*idx = <CheckRefs ids="2427">*</CheckRefs>idx <CheckRefs ids="2426,2425">+</CheckRefs> BMI160_FIFO_MA_LENGTH;</Line>
  <Line number="5378">		(*aux_index)<CheckRefs ids="2428">++</CheckRefs>;</Line>
  <Line number="5379">		break;</Line>
  <Line number="5380"></Line>
  <Line number="5381"></Line>
  <Line number="5382">	case <CheckRefs ids="2429">BMI160_FIFO_HEAD_M_G</CheckRefs>:</Line>
  <Line number="5383">	case <CheckRefs ids="2430">BMI160_FIFO_M_G_ENABLE</CheckRefs>:</Line>
  <Line number="5384">		/* Partial read, then skip the data */</Line>
  <Line number="5385">		if ((<CheckRefs ids="2432">*</CheckRefs>idx <CheckRefs ids="2431">+</CheckRefs> BMI160_FIFO_MG_LENGTH) &gt; <CheckRefs ids="2433">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="5386">			/* Update the data index as complete */</Line>
  <Line number="5387">			*idx = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5388">			break;</Line>
  <Line number="5389">		}</Line>
  <Line number="5390">		/* Unpack the data array into structure instance */</Line>
  <Line number="5391">		unpack_aux_data(&amp;aux_data[*aux_index], *idx, dev);</Line>
  <Line number="5392">		/* Move the data index */</Line>
  <Line number="5393">		(*idx) = <CheckRefs ids="2436">(</CheckRefs>*idx) <CheckRefs ids="2435,2434">+</CheckRefs> BMI160_FIFO_MG_LENGTH;</Line>
  <Line number="5394">		(*aux_index)<CheckRefs ids="2437">++</CheckRefs>;</Line>
  <Line number="5395">		break;</Line>
  <Line number="5396"></Line>
  <Line number="5397">	case <CheckRefs ids="2438">BMI160_FIFO_HEAD_M_G_A</CheckRefs>:</Line>
  <Line number="5398">	case <CheckRefs ids="2439">BMI160_FIFO_M_G_A_ENABLE</CheckRefs>:</Line>
  <Line number="5399">		/*Partial read, then skip the data*/</Line>
  <Line number="5400">		if ((<CheckRefs ids="2441">*</CheckRefs>idx <CheckRefs ids="2440">+</CheckRefs> BMI160_FIFO_MGA_LENGTH) &gt; <CheckRefs ids="2442">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="5401">			/* Update the data index as complete */</Line>
  <Line number="5402">			*idx = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5403">			break;</Line>
  <Line number="5404">		}</Line>
  <Line number="5405">		/* Unpack the data array into structure instance */</Line>
  <Line number="5406">		unpack_aux_data(&amp;aux_data[*aux_index], *idx, dev);</Line>
  <Line number="5407">		/*Move the data index*/</Line>
  <Line number="5408">		*idx = <CheckRefs ids="2445">*</CheckRefs>idx <CheckRefs ids="2444,2443">+</CheckRefs> BMI160_FIFO_MGA_LENGTH;</Line>
  <Line number="5409">		(*aux_index)<CheckRefs ids="2446">++</CheckRefs>;</Line>
  <Line number="5410">		break;</Line>
  <Line number="5411"></Line>
  <Line number="5412">	case <CheckRefs ids="2447">BMI160_FIFO_HEAD_G</CheckRefs>:</Line>
  <Line number="5413">	case <CheckRefs ids="2448">BMI160_FIFO_G_ENABLE</CheckRefs>:</Line>
  <Line number="5414">		/* Move the data index */</Line>
  <Line number="5415">		(*idx) = <CheckRefs ids="2451">(</CheckRefs>*idx) <CheckRefs ids="2450,2449">+</CheckRefs> BMI160_FIFO_G_LENGTH;</Line>
  <Line number="5416">		break;</Line>
  <Line number="5417"></Line>
  <Line number="5418">	case <CheckRefs ids="2452">BMI160_FIFO_HEAD_G_A</CheckRefs>:</Line>
  <Line number="5419">	case <CheckRefs ids="2453">BMI160_FIFO_G_A_ENABLE</CheckRefs>:</Line>
  <Line number="5420">		/* Move the data index */</Line>
  <Line number="5421">		*idx = <CheckRefs ids="2456">*</CheckRefs>idx <CheckRefs ids="2455,2454">+</CheckRefs> BMI160_FIFO_GA_LENGTH;</Line>
  <Line number="5422">		break;</Line>
  <Line number="5423"></Line>
  <Line number="5424">	case <CheckRefs ids="2457">BMI160_FIFO_HEAD_A</CheckRefs>:</Line>
  <Line number="5425">	case <CheckRefs ids="2458">BMI160_FIFO_A_ENABLE</CheckRefs>:</Line>
  <Line number="5426">		/* Move the data index */</Line>
  <Line number="5427">		*idx = <CheckRefs ids="2461">*</CheckRefs>idx <CheckRefs ids="2460,2459">+</CheckRefs> BMI160_FIFO_A_LENGTH;</Line>
  <Line number="5428">		break;</Line>
  <Line number="5429"></Line>
  <Line number="5430">	default:</Line>
  <Line number="5431">		break;</Line>
  <Line number="5432">	}</Line>
  <Line number="5433"></Line>
  <Line number="5434">}</Line>
  <Line number="5435"></Line>
  <Line number="5436">/*!</Line>
  <Line number="5437"> *  @brief This API is used to parse the aux data from the</Line>
  <Line number="5438"> *  FIFO data and store it in the instance of the structure bmi160_aux_data.</Line>
  <Line number="5439"> */</Line>
  <Line number="5440">static void unpack_aux_data(struct bmi160_aux_data *aux_data, uint16_t data_start_index,</Line>
  <Line number="5441">				const struct bmi160_dev *dev)</Line>
  <Line number="5442">{ INIT_STUBS(dev);</Line>
  <Line number="5443">	/* Aux data bytes */</Line>
  <Line number="5444">	aux_data-&gt;data[0<CheckRefs ids="2462">]</CheckRefs> = dev-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2463">++</CheckRefs>];</Line>
  <Line number="5445">	aux_data-&gt;data[1<CheckRefs ids="2464">]</CheckRefs> = dev-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2465">++</CheckRefs>];</Line>
  <Line number="5446">	aux_data-&gt;data[2<CheckRefs ids="2466">]</CheckRefs> = dev-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2467">++</CheckRefs>];</Line>
  <Line number="5447">	aux_data-&gt;data[3<CheckRefs ids="2468">]</CheckRefs> = dev-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2469">++</CheckRefs>];</Line>
  <Line number="5448">	aux_data-&gt;data[4<CheckRefs ids="2470">]</CheckRefs> = dev-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2471">++</CheckRefs>];</Line>
  <Line number="5449">	aux_data-&gt;data[5<CheckRefs ids="2472">]</CheckRefs> = dev-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2473">++</CheckRefs>];</Line>
  <Line number="5450">	aux_data-&gt;data[6<CheckRefs ids="2474">]</CheckRefs> = dev-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2475">++</CheckRefs>];</Line>
  <Line number="5451">	aux_data-&gt;data[7<CheckRefs ids="2476">]</CheckRefs> = dev-&gt;fifo-&gt;data[data_start_index<CheckRefs ids="2477">++</CheckRefs>];</Line>
  <Line number="5452">}</Line>
  <Line number="5453"></Line>
  <Line number="5454">/*!</Line>
  <Line number="5455"> *  @brief This API is used to parse the aux data from the</Line>
  <Line number="5456"> *  FIFO data in header mode.</Line>
  <Line number="5457"> */</Line>
  <Line number="5458">static void extract_aux_header_mode(struct bmi160_aux_data *aux_data, uint8_t *aux_length,</Line>
  <Line number="5459">					const struct bmi160_dev *dev)</Line>
  <Line number="5460">{ INIT_STUBS(dev);</Line>
  <Line number="5461">	uint8_t frame_header = <CheckRefs ids="2478">0</CheckRefs>;</Line>
  <Line number="5462">	uint16_t data_index;</Line>
  <Line number="5463">	uint8_t aux_index = <CheckRefs ids="2479">0</CheckRefs>;</Line>
  <Line number="5464"></Line>
  <Line number="5465">	for (data_index = dev-&gt;fifo-&gt;aux_byte_start_idx; <CheckRefs ids="2480">data_index</CheckRefs> &lt; <CheckRefs ids="2481">dev</CheckRefs>-&gt;fifo-&gt;length;) {</Line>
  <Line number="5466">		/* extracting Frame header */</Line>
  <Line number="5467">		frame_header = <CheckRefs ids="2482">(</CheckRefs><CheckRefs ids="2483">dev</CheckRefs>-&gt;fifo-&gt;data[data_index] &amp; BMI160_FIFO_TAG_INTR_MASK);</Line>
  <Line number="5468">		/*Index is moved to next byte where the data is starting*/</Line>
  <Line number="5469">		data_index<CheckRefs ids="2484">++</CheckRefs>;</Line>
  <Line number="5470"></Line>
  <Line number="5471">		switch (<CheckRefs ids="2485">frame_header</CheckRefs>) {</Line>
  <Line number="5472">			/* Aux frame */</Line>
  <Line number="5473">		case <CheckRefs ids="2486">BMI160_FIFO_HEAD_M</CheckRefs>:</Line>
  <Line number="5474">		case <CheckRefs ids="2487">BMI160_FIFO_HEAD_M_A</CheckRefs>:</Line>
  <Line number="5475">		case <CheckRefs ids="2488">BMI160_FIFO_HEAD_M_G</CheckRefs>:</Line>
  <Line number="5476">		case <CheckRefs ids="2489">BMI160_FIFO_HEAD_M_G_A</CheckRefs>:</Line>
  <Line number="5477">			unpack_aux_frame(aux_data, &amp;data_index, &amp;aux_index, frame_header, dev);</Line>
  <Line number="5478">			break;</Line>
  <Line number="5479">		case <CheckRefs ids="2490">BMI160_FIFO_HEAD_G</CheckRefs>:</Line>
  <Line number="5480">			move_next_frame(&amp;data_index, <CheckRefs ids="2491">BMI160_FIFO_G_LENGTH</CheckRefs>, dev);</Line>
  <Line number="5481">			break;</Line>
  <Line number="5482">		case <CheckRefs ids="2492">BMI160_FIFO_HEAD_G_A</CheckRefs>:</Line>
  <Line number="5483">			move_next_frame(&amp;data_index, <CheckRefs ids="2493">BMI160_FIFO_GA_LENGTH</CheckRefs>, dev);</Line>
  <Line number="5484">			break;</Line>
  <Line number="5485">		case <CheckRefs ids="2494">BMI160_FIFO_HEAD_A</CheckRefs>:</Line>
  <Line number="5486">			move_next_frame(&amp;data_index, <CheckRefs ids="2495">BMI160_FIFO_A_LENGTH</CheckRefs>, dev);</Line>
  <Line number="5487">			break;</Line>
  <Line number="5488">			/* Sensor time frame */</Line>
  <Line number="5489">		case <CheckRefs ids="2496">BMI160_FIFO_HEAD_SENSOR_TIME</CheckRefs>:</Line>
  <Line number="5490">			unpack_sensortime_frame(&amp;data_index, dev);</Line>
  <Line number="5491">			break;</Line>
  <Line number="5492">			/* Skip frame */</Line>
  <Line number="5493">		case <CheckRefs ids="2497">BMI160_FIFO_HEAD_SKIP_FRAME</CheckRefs>:</Line>
  <Line number="5494">			unpack_skipped_frame(&amp;data_index, dev);</Line>
  <Line number="5495">			break;</Line>
  <Line number="5496">			/* Input config frame */</Line>
  <Line number="5497">		case <CheckRefs ids="2498">BMI160_FIFO_HEAD_INPUT_CONFIG</CheckRefs>:</Line>
  <Line number="5498">			move_next_frame(&amp;data_index, <CheckRefs ids="2499">1</CheckRefs>, dev);</Line>
  <Line number="5499">			break;</Line>
  <Line number="5500">		case <CheckRefs ids="2500">BMI160_FIFO_HEAD_OVER_READ</CheckRefs>:</Line>
  <Line number="5501">			/* Update the data index as complete in case</Line>
  <Line number="5502">			 * of over read */</Line>
  <Line number="5503">			data_index = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5504">			break;</Line>
  <Line number="5505">		default:</Line>
  <Line number="5506">			/* Update the data index as complete in case of</Line>
  <Line number="5507">			 * getting other headers like 0x00 */</Line>
  <Line number="5508">			data_index = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5509">			break;</Line>
  <Line number="5510">		}</Line>
  <Line number="5511">		if (<CheckRefs ids="2501">*</CheckRefs>aux_length == <CheckRefs ids="2502">aux_index</CheckRefs>) {</Line>
  <Line number="5512">			/*Number of frames to read completed*/</Line>
  <Line number="5513">			break;</Line>
  <Line number="5514">		}</Line>
  <Line number="5515">	}</Line>
  <Line number="5516"></Line>
  <Line number="5517">	/* Update number of aux data read */</Line>
  <Line number="5518">	*aux_length = aux_index;</Line>
  <Line number="5519">	/* Update the aux frame index */</Line>
  <Line number="5520">	dev-&gt;fifo-&gt;aux_byte_start_idx = data_index;</Line>
  <Line number="5521">}</Line>
  <Line number="5522"></Line>
  <Line number="5523">/*!</Line>
  <Line number="5524"> *  @brief This API checks the presence of non-valid frames in the read fifo data.</Line>
  <Line number="5525"> */</Line>
  <Line number="5526">static void check_frame_validity(uint16_t *data_index, const struct bmi160_dev *dev)</Line>
  <Line number="5527">{ INIT_STUBS(dev);</Line>
  <Line number="5528">	if ((<CheckRefs ids="2504">*</CheckRefs>data_index <CheckRefs ids="2503">+</CheckRefs> 2) &lt; <CheckRefs ids="2505">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="5529">		/* Check if FIFO is empty */</Line>
  <Line number="5530">		if ((<CheckRefs ids="2506">dev</CheckRefs>-&gt;fifo-&gt;data[*data_index] == FIFO_CONFIG_MSB_CHECK)</Line>
  <Line number="5531">			&amp;&amp; (<CheckRefs ids="2507">dev</CheckRefs>-&gt;fifo-&gt;data[<CheckRefs ids="2509">*</CheckRefs>data_index <CheckRefs ids="2508">+</CheckRefs> 1] == FIFO_CONFIG_LSB_CHECK)) {</Line>
  <Line number="5532">			/*Update the data index as complete*/</Line>
  <Line number="5533">			*data_index = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5534">		}</Line>
  <Line number="5535">	}</Line>
  <Line number="5536">}</Line>
  <Line number="5537"></Line>
  <Line number="5538">/*!</Line>
  <Line number="5539"> *  @brief This API is used to move the data index ahead of the</Line>
  <Line number="5540"> *  current_frame_length parameter when unnecessary FIFO data appears while</Line>
  <Line number="5541"> *  extracting the user specified data.</Line>
  <Line number="5542"> */</Line>
  <Line number="5543">static void move_next_frame(uint16_t *data_index, uint8_t current_frame_length, const struct bmi160_dev *dev)</Line>
  <Line number="5544">{ INIT_STUBS(dev);</Line>
  <Line number="5545">	/*Partial read, then move the data index to last data*/</Line>
  <Line number="5546">	if ((<CheckRefs ids="2511">*</CheckRefs>data_index <CheckRefs ids="2510">+</CheckRefs> <CheckRefs ids="2512">current_frame_length</CheckRefs>) &gt; <CheckRefs ids="2513">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="5547">		/*Update the data index as complete*/</Line>
  <Line number="5548">		*data_index = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5549">	} else {</Line>
  <Line number="5550">		/*Move the data index to next frame*/</Line>
  <Line number="5551">		*data_index = <CheckRefs ids="2516">*</CheckRefs>data_index <CheckRefs ids="2515,2514">+</CheckRefs> <CheckRefs ids="2517">current_frame_length</CheckRefs>;</Line>
  <Line number="5552">	}</Line>
  <Line number="5553">}</Line>
  <Line number="5554"></Line>
  <Line number="5555">/*!</Line>
  <Line number="5556"> *  @brief This API is used to parse and store the sensor time from the</Line>
  <Line number="5557"> *  FIFO data in the structure instance dev.</Line>
  <Line number="5558"> */</Line>
  <Line number="5559">static void unpack_sensortime_frame(uint16_t *data_index, const struct bmi160_dev *dev)</Line>
  <Line number="5560">{ INIT_STUBS(dev);</Line>
  <Line number="5561">	uint32_t sensor_time_byte3 = <CheckRefs ids="2518">0</CheckRefs>;</Line>
  <Line number="5562">	uint16_t sensor_time_byte2 = <CheckRefs ids="2519">0</CheckRefs>;</Line>
  <Line number="5563">	uint8_t sensor_time_byte1 = <CheckRefs ids="2520">0</CheckRefs>;</Line>
  <Line number="5564"></Line>
  <Line number="5565">	/*Partial read, then move the data index to last data*/</Line>
  <Line number="5566">	if ((<CheckRefs ids="2522">*</CheckRefs>data_index <CheckRefs ids="2521">+</CheckRefs> BMI160_SENSOR_TIME_LENGTH) &gt; <CheckRefs ids="2523">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="5567">		/*Update the data index as complete*/</Line>
  <Line number="5568">		*data_index = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5569">	} else {</Line>
  <Line number="5570">		sensor_time_byte3 = <CheckRefs ids="2528">dev</CheckRefs>-&gt;fifo-&gt;data[<CheckRefs ids="2530">(</CheckRefs>*data_index) <CheckRefs ids="2529">+</CheckRefs> BMI160_SENSOR_TIME_MSB_BYTE] <CheckRefs ids="2525,2526,2527,2524">&lt;&lt;</CheckRefs> 16;</Line>
  <Line number="5571">		sensor_time_byte2 = <CheckRefs ids="2535">dev</CheckRefs>-&gt;fifo-&gt;data[<CheckRefs ids="2537">(</CheckRefs>*data_index) <CheckRefs ids="2536">+</CheckRefs> BMI160_SENSOR_TIME_XLSB_BYTE] <CheckRefs ids="2533,2532,2531,2534">&lt;&lt;</CheckRefs> 8;</Line>
  <Line number="5572">		sensor_time_byte1 = dev-&gt;fifo-&gt;data[(*data_index)];</Line>
  <Line number="5573">		/* Sensor time */</Line>
  <Line number="5574">		dev-&gt;fifo-&gt;sensor_time = (uint32_t)(sensor_time_byte3 | <CheckRefs ids="2538">sensor_time_byte2</CheckRefs> | <CheckRefs ids="2539">sensor_time_byte1</CheckRefs>);</Line>
  <Line number="5575">		*data_index = <CheckRefs ids="2542">(</CheckRefs>*data_index) <CheckRefs ids="2541,2540">+</CheckRefs> BMI160_SENSOR_TIME_LENGTH;</Line>
  <Line number="5576">	}</Line>
  <Line number="5577">}</Line>
  <Line number="5578"></Line>
  <Line number="5579">/*!</Line>
  <Line number="5580"> *  @brief This API is used to parse and store the skipped_frame_count from</Line>
  <Line number="5581"> *  the FIFO data in the structure instance dev.</Line>
  <Line number="5582"> */</Line>
  <Line number="5583">static void unpack_skipped_frame(uint16_t *data_index, const struct bmi160_dev *dev)</Line>
  <Line number="5584">{ INIT_STUBS(dev);</Line>
  <Line number="5585">	/*Partial read, then move the data index to last data*/</Line>
  <Line number="5586">	if (<CheckRefs ids="2543">*</CheckRefs>data_index &gt;= <CheckRefs ids="2544">dev</CheckRefs>-&gt;fifo-&gt;length) {</Line>
  <Line number="5587">		/*Update the data index as complete*/</Line>
  <Line number="5588">		*data_index = dev-&gt;fifo-&gt;length;</Line>
  <Line number="5589">	} else {</Line>
  <Line number="5590">		dev-&gt;fifo-&gt;skipped_frame_count = dev-&gt;fifo-&gt;data[*data_index];</Line>
  <Line number="5591">		/*Move the data index*/</Line>
  <Line number="5592">		*data_index = <CheckRefs ids="2547">(</CheckRefs>*data_index) <CheckRefs ids="2546,2545">+</CheckRefs> 1;</Line>
  <Line number="5593">	}</Line>
  <Line number="5594">}</Line>
  <Line number="5595"></Line>
  <Line number="5596">/*!</Line>
  <Line number="5597"> *  @brief This API is used to get the FOC status from the sensor</Line>
  <Line number="5598"> */</Line>
  <Line number="5599">static int8_t get_foc_status(uint8_t *foc_status, struct bmi160_dev const *dev)</Line>
  <Line number="5600">{ INIT_STUBS(dev);</Line>
  <Line number="5601">	int8_t rslt;</Line>
  <Line number="5602">	uint8_t data;</Line>
  <Line number="5603"></Line>
  <Line number="5604">	/* Read the FOC status from sensor */</Line>
  <Line number="5605">	rslt = bmi160_get_regs(<CheckRefs ids="2548">BMI160_STATUS_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="2549">1</CheckRefs>, dev);</Line>
  <Line number="5606">	if (<CheckRefs ids="2550">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="5607">		/* Get the foc_status bit */</Line>
  <Line number="5608">		*foc_status = <CheckRefs ids="2552,2553,2551">BMI160_GET_BITS</CheckRefs>(data, BMI160_FOC_STATUS);</Line>
  <Line number="5609">	}</Line>
  <Line number="5610"></Line>
  <Line number="5611">	return rslt;</Line>
  <Line number="5612">}</Line>
  <Line number="5613"></Line>
  <Line number="5614">/*!</Line>
  <Line number="5615"> *  @brief This API is used to configure the offset enable bits in the sensor</Line>
  <Line number="5616"> */</Line>
  <Line number="5617">static int8_t configure_offset_enable(const struct bmi160_foc_conf *foc_conf, struct bmi160_dev const *dev)</Line>
  <Line number="5618">{ INIT_STUBS(dev);</Line>
  <Line number="5619">	int8_t rslt;</Line>
  <Line number="5620">	uint8_t data;</Line>
  <Line number="5621"></Line>
  <Line number="5622">	/* Null-pointer check */</Line>
  <Line number="5623">	rslt = null_ptr_check(dev);</Line>
  <Line number="5624"></Line>
  <Line number="5625">	if (<CheckRefs ids="2554">rslt</CheckRefs> != BMI160_OK) {</Line>
  <Line number="5626">		rslt = <CheckRefs ids="2556,2555">BMI160_E_NULL_PTR</CheckRefs>;</Line>
  <Line number="5627">	} else {</Line>
  <Line number="5628">		/* Read the FOC config from the sensor */</Line>
  <Line number="5629">		rslt = bmi160_get_regs(<CheckRefs ids="2557">BMI160_OFFSET_CONF_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="2558">1</CheckRefs>, dev);</Line>
  <Line number="5630"></Line>
  <Line number="5631">		if (<CheckRefs ids="2559">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="5632">			/* Set the offset enable/disable for gyro */</Line>
  <Line number="5633">			data = <CheckRefs ids="2566,2564,2563,2561,2562,2565,2560">BMI160_SET_BITS</CheckRefs>(data, BMI160_GYRO_OFFSET_EN, foc_conf-&gt;gyro_off_en);</Line>
  <Line number="5634"></Line>
  <Line number="5635">			/* Set the offset enable/disable for accel */</Line>
  <Line number="5636">			data = <CheckRefs ids="2568,2570,2571,2573,2567,2569,2572">BMI160_SET_BITS</CheckRefs>(data, BMI160_ACCEL_OFFSET_EN, foc_conf-&gt;acc_off_en);</Line>
  <Line number="5637"></Line>
  <Line number="5638">			/* Set the offset config in the sensor */</Line>
  <Line number="5639">			rslt = bmi160_set_regs(<CheckRefs ids="2574">BMI160_OFFSET_CONF_ADDR</CheckRefs>, &amp;data, <CheckRefs ids="2575">1</CheckRefs>, dev);</Line>
  <Line number="5640">		}</Line>
  <Line number="5641">	}</Line>
  <Line number="5642"></Line>
  <Line number="5643">	return rslt;</Line>
  <Line number="5644">}</Line>
  <Line number="5645"></Line>
  <Line number="5646">static int8_t trigger_foc(struct bmi160_offsets *offset, struct bmi160_dev const *dev)</Line>
  <Line number="5647">{ INIT_STUBS(dev);</Line>
  <Line number="5648">	int8_t rslt;</Line>
  <Line number="5649">	uint8_t foc_status;</Line>
  <Line number="5650">	uint8_t cmd = <CheckRefs ids="2576">BMI160_START_FOC_CMD</CheckRefs>;</Line>
  <Line number="5651">	uint8_t timeout = <CheckRefs ids="2577">0</CheckRefs>;</Line>
  <Line number="5652">	uint8_t data_array[20];</Line>
  <Line number="5653"></Line>
  <Line number="5654">	/* Start the FOC process */</Line>
  <Line number="5655">	rslt = bmi160_set_regs(<CheckRefs ids="2578">BMI160_COMMAND_REG_ADDR</CheckRefs>, &amp;cmd, <CheckRefs ids="2579">1</CheckRefs>, dev);</Line>
  <Line number="5656">	if (<CheckRefs ids="2580">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="5657">		/* Check the FOC status*/</Line>
  <Line number="5658">		rslt = get_foc_status(&amp;foc_status, dev);</Line>
  <Line number="5659">		if ((<CheckRefs ids="2581">rslt</CheckRefs> != BMI160_OK) || (<CheckRefs ids="2582">foc_status</CheckRefs> != BMI160_ENABLE)) {</Line>
  <Line number="5660">			while ((<CheckRefs ids="2583">foc_status</CheckRefs> != BMI160_ENABLE) &amp;&amp; (<CheckRefs ids="2584">timeout</CheckRefs> &lt; 11)) {</Line>
  <Line number="5661">				/* Maximum time of 250ms is given in 10</Line>
  <Line number="5662">				 * steps of 25ms each */</Line>
  <Line number="5663">				dev-&gt;delay_ms(<CheckRefs ids="2585">25</CheckRefs>);</Line>
  <Line number="5664">				/* Check the FOC status*/</Line>
  <Line number="5665">				rslt = get_foc_status(&amp;foc_status, dev);</Line>
  <Line number="5666">				timeout<CheckRefs ids="2586">++</CheckRefs>;</Line>
  <Line number="5667">			}</Line>
  <Line number="5668"></Line>
  <Line number="5669">			if ((<CheckRefs ids="2587">rslt</CheckRefs> == BMI160_OK) &amp;&amp; (<CheckRefs ids="2588">foc_status</CheckRefs> == BMI160_ENABLE)) {</Line>
  <Line number="5670">				/* Get offset values from sensor */</Line>
  <Line number="5671">				rslt = bmi160_get_offsets(offset, dev);</Line>
  <Line number="5672">			} else {</Line>
  <Line number="5673">				/* FOC failure case */</Line>
  <Line number="5674">				rslt = <CheckRefs ids="2589,2590">BMI160_FOC_FAILURE</CheckRefs>;</Line>
  <Line number="5675">			}</Line>
  <Line number="5676">		}</Line>
  <Line number="5677"></Line>
  <Line number="5678">		if (<CheckRefs ids="2591">rslt</CheckRefs> == BMI160_OK) {</Line>
  <Line number="5679">			/* Read registers 0x04-0x17 */</Line>
  <Line number="5680">			rslt = bmi160_get_regs(<CheckRefs ids="2592">BMI160_GYRO_DATA_ADDR</CheckRefs>,</Line>
  <Line number="5681">				data_array, <CheckRefs ids="2593">20</CheckRefs>, dev);</Line>
  <Line number="5682">		}</Line>
  <Line number="5683">	}</Line>
  <Line number="5684"></Line>
  <Line number="5685"></Line>
  <Line number="5686">	return rslt;</Line>
  <Line number="5687">}</Line>
  <Line number="5688"></Line>
  <Line number="5689">/** @}*/</Line>
</SourceFile>
