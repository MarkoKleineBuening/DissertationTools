<SourceFile>
  <Line number="1">/* DO NOT EDIT!</Line>
  <Line number="2">** This file is automatically generated by the script in the canonical</Line>
  <Line number="3">** SQLite source tree at tool/mkshellc.tcl.  That script combines source</Line>
  <Line number="4">** code from various constituent source files of SQLite into this single</Line>
  <Line number="5">** &quot;shell.c&quot; file used to implement the SQLite command-line shell.</Line>
  <Line number="6">**</Line>
  <Line number="7">** Most of the code found below comes from the &quot;src/shell.c.in&quot; file in</Line>
  <Line number="8">** the canonical SQLite source tree.  That main file contains &quot;INCLUDE&quot;</Line>
  <Line number="9">** lines that specify other files in the canonical source tree that are</Line>
  <Line number="10">** inserted to getnerate this complete program source file.</Line>
  <Line number="11">**</Line>
  <Line number="12">** The code from multiple files is combined into this single &quot;shell.c&quot;</Line>
  <Line number="13">** source file to help make the command-line program easier to compile.</Line>
  <Line number="14">**</Line>
  <Line number="15">** To modify this program, get a copy of the canonical SQLite source tree,</Line>
  <Line number="16">** edit the src/shell.c.in&quot; and/or some of the other files that are included</Line>
  <Line number="17">** by &quot;src/shell.c.in&quot;, then rerun the tool/mkshellc.tcl script.</Line>
  <Line number="18">*/</Line>
  <Line number="19">/*</Line>
  <Line number="20">** 2001 September 15</Line>
  <Line number="21">**</Line>
  <Line number="22">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="23">** a legal notice, here is a blessing:</Line>
  <Line number="24">**</Line>
  <Line number="25">**    May you do good and not evil.</Line>
  <Line number="26">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="27">**    May you share freely, never taking more than you give.</Line>
  <Line number="28">**</Line>
  <Line number="29">*************************************************************************</Line>
  <Line number="30"></Line>
  <Line number="31"></Line>
  <Line number="32"></Line>
  <Line number="33">** This file contains code to implement the &quot;sqlite&quot; command line</Line>
  <Line number="34">** utility for accessing SQLite databases.</Line>
  <Line number="35">*/</Line>
  <Line number="36">#if (defined(_WIN32) || defined(WIN32)) &amp;&amp; !defined(_CRT_SECURE_NO_WARNINGS)</Line>
  <Line number="37">/* This needs to come before any includes for MSVC compiler */</Line>
  <Line number="38">#define _CRT_SECURE_NO_WARNINGS</Line>
  <Line number="39">#endif</Line>
  <Line number="40"></Line>
  <Line number="41">/*</Line>
  <Line number="42">** Determine if we are dealing with WinRT, which provides only a subset of</Line>
  <Line number="43">** the full Win32 API.</Line>
  <Line number="44">*/</Line>
  <Line number="45">#if !defined(SQLITE_OS_WINRT)</Line>
  <Line number="46"># define SQLITE_OS_WINRT 0</Line>
  <Line number="47">#endif</Line>
  <Line number="48"></Line>
  <Line number="49">/*</Line>
  <Line number="50">** Warning pragmas copied from msvc.h in the core.</Line>
  <Line number="51">*/</Line>
  <Line number="52">#if defined(_MSC_VER)</Line>
  <Line number="53">#pragma warning(disable : 4054)</Line>
  <Line number="54">#pragma warning(disable : 4055)</Line>
  <Line number="55">#pragma warning(disable : 4100)</Line>
  <Line number="56">#pragma warning(disable : 4127)</Line>
  <Line number="57">#pragma warning(disable : 4130)</Line>
  <Line number="58">#pragma warning(disable : 4152)</Line>
  <Line number="59">#pragma warning(disable : 4189)</Line>
  <Line number="60">#pragma warning(disable : 4206)</Line>
  <Line number="61">#pragma warning(disable : 4210)</Line>
  <Line number="62">#pragma warning(disable : 4232)</Line>
  <Line number="63">#pragma warning(disable : 4244)</Line>
  <Line number="64">#pragma warning(disable : 4305)</Line>
  <Line number="65">#pragma warning(disable : 4306)</Line>
  <Line number="66">#pragma warning(disable : 4702)</Line>
  <Line number="67">#pragma warning(disable : 4706)</Line>
  <Line number="68">#endif /* defined(_MSC_VER) */</Line>
  <Line number="69"></Line>
  <Line number="70"></Line>
  <Line number="71">//mkb: </Line>
  <Line number="72">#define	errno 0</Line>
  <Line number="73">#define EISDIR 0</Line>
  <Line number="74">#define EACCES 0</Line>
  <Line number="75">#define ENOENT 0</Line>
  <Line number="76">#define EINTR 0</Line>
  <Line number="77">#define EAGAIN 0</Line>
  <Line number="78">#define ETIMEDOUT 0</Line>
  <Line number="79">#define EBUSY 0</Line>
  <Line number="80">#define ENOLCK 0</Line>
  <Line number="81">#define EPERM 0</Line>
  <Line number="82">#define EEXIST 0</Line>
  <Line number="83">#define ERANGE 0</Line>
  <Line number="84">#define EIO 0</Line>
  <Line number="85">#define ENOSPC 0</Line>
  <Line number="86"></Line>
  <Line number="87"></Line>
  <Line number="88">/*</Line>
  <Line number="89">** No support for loadable extensions in VxWorks.</Line>
  <Line number="90">*/</Line>
  <Line number="91">#if (defined(__RTP__) || defined(_WRS_KERNEL)) &amp;&amp; !SQLITE_OMIT_LOAD_EXTENSION</Line>
  <Line number="92"># define SQLITE_OMIT_LOAD_EXTENSION 1</Line>
  <Line number="93">#endif</Line>
  <Line number="94"></Line>
  <Line number="95">/*</Line>
  <Line number="96">** Enable large-file support for fopen() and friends on unix.</Line>
  <Line number="97">*/</Line>
  <Line number="98">#ifndef SQLITE_DISABLE_LFS</Line>
  <Line number="99"># define _LARGE_FILE       1</Line>
  <Line number="100"># ifndef _FILE_OFFSET_BITS</Line>
  <Line number="101">#   define _FILE_OFFSET_BITS 64</Line>
  <Line number="102"># endif</Line>
  <Line number="103"># define _LARGEFILE_SOURCE 1</Line>
  <Line number="104">#endif</Line>
  <Line number="105"></Line>
  <Line number="106">#include &lt;stdlib.h&gt;</Line>
  <Line number="107">#include &lt;string.h&gt;</Line>
  <Line number="108">#include &lt;stdio.h&gt;</Line>
  <Line number="109">#include &lt;assert.h&gt;</Line>
  <Line number="110">#include &quot;sqlite3.h&quot;</Line>
  <Line number="111">typedef sqlite3_int64 i64;</Line>
  <Line number="112">typedef sqlite3_uint64 u64;</Line>
  <Line number="113">typedef unsigned char u8;</Line>
  <Line number="114">#if SQLITE_USER_AUTHENTICATION</Line>
  <Line number="115"># include &quot;sqlite3userauth.h&quot;</Line>
  <Line number="116">#endif</Line>
  <Line number="117">#include &lt;ctype.h&gt;</Line>
  <Line number="118">#include &lt;stdarg.h&gt;</Line>
  <Line number="119"></Line>
  <Line number="120">#if !defined(_WIN32) &amp;&amp; !defined(WIN32)</Line>
  <Line number="121"># include &lt;signal.h&gt;</Line>
  <Line number="122"># if !defined(__RTP__) &amp;&amp; !defined(_WRS_KERNEL)</Line>
  <Line number="123">#  include &lt;pwd.h&gt;</Line>
  <Line number="124"># endif</Line>
  <Line number="125">#endif</Line>
  <Line number="126">#if (!defined(_WIN32) &amp;&amp; !defined(WIN32)) || defined(__MINGW32__)</Line>
  <Line number="127"># include &lt;unistd.h&gt;</Line>
  <Line number="128"># include &lt;dirent.h&gt;</Line>
  <Line number="129"># define GETPID getpid</Line>
  <Line number="130"># if defined(__MINGW32__)</Line>
  <Line number="131">#  define DIRENT dirent</Line>
  <Line number="132">#  ifndef S_ISLNK</Line>
  <Line number="133">#   define S_ISLNK(mode) (0)</Line>
  <Line number="134">#  endif</Line>
  <Line number="135"># endif</Line>
  <Line number="136">#else</Line>
  <Line number="137"># define GETPID (int)GetCurrentProcessId</Line>
  <Line number="138">#endif</Line>
  <Line number="139">#include &lt;sys/types.h&gt;</Line>
  <Line number="140">#include &lt;sys/stat.h&gt;</Line>
  <Line number="141"></Line>
  <Line number="142">#if HAVE_READLINE</Line>
  <Line number="143"># include &lt;readline/readline.h&gt;</Line>
  <Line number="144"># include &lt;readline/history.h&gt;</Line>
  <Line number="145">#endif</Line>
  <Line number="146"></Line>
  <Line number="147">#if HAVE_EDITLINE</Line>
  <Line number="148"># include &lt;editline/readline.h&gt;</Line>
  <Line number="149">#endif</Line>
  <Line number="150"></Line>
  <Line number="151">#if HAVE_EDITLINE || HAVE_READLINE</Line>
  <Line number="152"></Line>
  <Line number="153"># define shell_add_history(X) add_history(X)</Line>
  <Line number="154"># define shell_read_history(X) read_history(X)</Line>
  <Line number="155"># define shell_write_history(X) write_history(X)</Line>
  <Line number="156"># define shell_stifle_history(X) stifle_history(X)</Line>
  <Line number="157"># define shell_readline(X) readline(X)</Line>
  <Line number="158"></Line>
  <Line number="159">#elif HAVE_LINENOISE</Line>
  <Line number="160"></Line>
  <Line number="161"># include &quot;linenoise.h&quot;</Line>
  <Line number="162"># define shell_add_history(X) linenoiseHistoryAdd(X)</Line>
  <Line number="163"># define shell_read_history(X) linenoiseHistoryLoad(X)</Line>
  <Line number="164"># define shell_write_history(X) linenoiseHistorySave(X)</Line>
  <Line number="165"># define shell_stifle_history(X) linenoiseHistorySetMaxLen(X)</Line>
  <Line number="166"># define shell_readline(X) linenoise(X)</Line>
  <Line number="167"></Line>
  <Line number="168">#else</Line>
  <Line number="169"></Line>
  <Line number="170"># define shell_read_history(X)</Line>
  <Line number="171"># define shell_write_history(X)</Line>
  <Line number="172"># define shell_stifle_history(X)</Line>
  <Line number="173"></Line>
  <Line number="174"># define SHELL_USE_LOCAL_GETLINE 1</Line>
  <Line number="175">#endif</Line>
  <Line number="176"></Line>
  <Line number="177"></Line>
  <Line number="178">#if defined(_WIN32) || defined(WIN32)</Line>
  <Line number="179"># if SQLITE_OS_WINRT</Line>
  <Line number="180">#  define SQLITE_OMIT_POPEN 1</Line>
  <Line number="181"># else</Line>
  <Line number="182">#  include &lt;io.h&gt;</Line>
  <Line number="183">#  include &lt;fcntl.h&gt;</Line>
  <Line number="184">#  define isatty(h) _isatty(h)</Line>
  <Line number="185">#  ifndef access</Line>
  <Line number="186">#   define access(f,m) _access((f),(m))</Line>
  <Line number="187">#  endif</Line>
  <Line number="188">#  ifndef unlink</Line>
  <Line number="189">#   define unlink _unlink</Line>
  <Line number="190">#  endif</Line>
  <Line number="191">#  ifndef strdup</Line>
  <Line number="192">#   define strdup _strdup</Line>
  <Line number="193">#  endif</Line>
  <Line number="194">#  undef popen</Line>
  <Line number="195">#  define popen _popen</Line>
  <Line number="196">#  undef pclose</Line>
  <Line number="197">#  define pclose _pclose</Line>
  <Line number="198"># endif</Line>
  <Line number="199">#else</Line>
  <Line number="200"> /* Make sure isatty() has a prototype. */</Line>
  <Line number="201"> extern int isatty(int);</Line>
  <Line number="202"></Line>
  <Line number="203"># if !defined(__RTP__) &amp;&amp; !defined(_WRS_KERNEL)</Line>
  <Line number="204">  /* popen and pclose are not C89 functions and so are</Line>
  <Line number="205">  ** sometimes omitted from the &lt;stdio.h&gt; header */</Line>
  <Line number="206">   extern FILE *popen(const char*,const char*);</Line>
  <Line number="207">   extern int pclose(FILE*);</Line>
  <Line number="208"># else</Line>
  <Line number="209">#  define SQLITE_OMIT_POPEN 1</Line>
  <Line number="210"># endif</Line>
  <Line number="211">#endif</Line>
  <Line number="212"></Line>
  <Line number="213">#if defined(_WIN32_WCE)</Line>
  <Line number="214">/* Windows CE (arm-wince-mingw32ce-gcc) does not provide isatty()</Line>
  <Line number="215"> * thus we always assume that we have a console. That can be</Line>
  <Line number="216"> * overridden with the -batch command line option.</Line>
  <Line number="217"> */</Line>
  <Line number="218">#define isatty(x) 1</Line>
  <Line number="219">#endif</Line>
  <Line number="220"></Line>
  <Line number="221">/* ctype macros that work with signed characters */</Line>
  <Line number="222">#define IsSpace(X)  isspace((unsigned char)X)</Line>
  <Line number="223">#define IsDigit(X)  isdigit((unsigned char)X)</Line>
  <Line number="224">#define ToLower(X)  (char)tolower((unsigned char)X)</Line>
  <Line number="225"></Line>
  <Line number="226">#if defined(_WIN32) || defined(WIN32)</Line>
  <Line number="227">#if SQLITE_OS_WINRT</Line>
  <Line number="228">#include &lt;intrin.h&gt;</Line>
  <Line number="229">#endif</Line>
  <Line number="230">#include &lt;windows.h&gt;</Line>
  <Line number="231"></Line>
  <Line number="232">/* string conversion routines only needed on Win32 */</Line>
  <Line number="233">extern char *sqlite3_win32_unicode_to_utf8(LPCWSTR);</Line>
  <Line number="234">extern char *sqlite3_win32_mbcs_to_utf8_v2(const char *, int);</Line>
  <Line number="235">extern char *sqlite3_win32_utf8_to_mbcs_v2(const char *, int);</Line>
  <Line number="236">extern LPWSTR sqlite3_win32_utf8_to_unicode(const char *zText);</Line>
  <Line number="237">#endif</Line>
  <Line number="238"></Line>
  <Line number="239">/* On Windows, we normally run with output mode of TEXT so that \n characters</Line>
  <Line number="240">** are automatically translated into \r\n.  However, this behavior needs</Line>
  <Line number="241">** to be disabled in some cases (ex: when generating CSV output and when</Line>
  <Line number="242">** rendering quoted strings that contain \n characters).  The following</Line>
  <Line number="243">** routines take care of that.</Line>
  <Line number="244">*/</Line>
  <Line number="245">#if (defined(_WIN32) || defined(WIN32)) &amp;&amp; !SQLITE_OS_WINRT</Line>
  <Line number="246">static void setBinaryMode(FILE *file, int isOutput){</Line>
  <Line number="247">  if( isOutput ) fflush(file);</Line>
  <Line number="248">  _setmode(_fileno(file), _O_BINARY);</Line>
  <Line number="249">}</Line>
  <Line number="250">static void setTextMode(FILE *file, int isOutput){</Line>
  <Line number="251">  if( isOutput ) fflush(file);</Line>
  <Line number="252">  _setmode(_fileno(file), _O_TEXT);</Line>
  <Line number="253">}</Line>
  <Line number="254">#else</Line>
  <Line number="255"># define setBinaryMode(X,Y)</Line>
  <Line number="256"># define setTextMode(X,Y)</Line>
  <Line number="257">#endif</Line>
  <Line number="258"></Line>
  <Line number="259"></Line>
  <Line number="260">/* True if the timer is enabled */</Line>
  <Line number="261">static int enableTimer = 0;</Line>
  <Line number="262"></Line>
  <Line number="263">/* Return the current wall-clock time */</Line>
  <Line number="264">static sqlite3_int64 timeOfDay(void){</Line>
  <Line number="265">  static sqlite3_vfs *clockVfs = 0;</Line>
  <Line number="266">  sqlite3_int64 t;</Line>
  <Line number="267">  if( clockVfs==0 ) clockVfs = sqlite3_vfs_find(0);</Line>
  <Line number="268">  if( clockVfs==0 ) return <CheckRefs ids="200">0</CheckRefs>;  /* Never actually happens */</Line>
  <Line number="269">  if( clockVfs-&gt;iVersion&gt;=2 &amp;&amp; clockVfs-&gt;xCurrentTimeInt64!=0 ){</Line>
  <Line number="270">    clockVfs-&gt;xCurrentTimeInt64(clockVfs, &amp;t);</Line>
  <Line number="271">  }else{</Line>
  <Line number="272">    double r;</Line>
  <Line number="273">    clockVfs-&gt;xCurrentTime(clockVfs, &amp;r);</Line>
  <Line number="274">    t = <CheckRefs ids="201">(</CheckRefs>sqlite3_int64)(r<CheckRefs ids="202">*</CheckRefs>86400000.0);</Line>
  <Line number="275">  }</Line>
  <Line number="276">  return t;</Line>
  <Line number="277">}</Line>
  <Line number="278"></Line>
  <Line number="279">#if !defined(_WIN32) &amp;&amp; !defined(WIN32) &amp;&amp; !defined(__minux)</Line>
  <Line number="280">#include &lt;sys/time.h&gt;</Line>
  <Line number="281">#include &lt;sys/resource.h&gt;</Line>
  <Line number="282"></Line>
  <Line number="283">/* VxWorks does not support getrusage() as far as we can determine */</Line>
  <Line number="284">#if defined(_WRS_KERNEL) || defined(__RTP__)</Line>
  <Line number="285">struct rusage {</Line>
  <Line number="286">  struct timeval ru_utime; /* user CPU time used */</Line>
  <Line number="287">  struct timeval ru_stime; /* system CPU time used */</Line>
  <Line number="288">};</Line>
  <Line number="289">#define getrusage(A,B) memset(B,0,sizeof(*B))</Line>
  <Line number="290">#endif</Line>
  <Line number="291"></Line>
  <Line number="292">/* Saved resource information for the beginning of an operation */</Line>
  <Line number="293">static struct rusage sBegin;  /* CPU time at start */</Line>
  <Line number="294">static sqlite3_int64 iBegin;  /* Wall-clock time at start */</Line>
  <Line number="295"></Line>
  <Line number="296">/*</Line>
  <Line number="297">** Begin timing an operation</Line>
  <Line number="298">*/</Line>
  <Line number="299">static void beginTimer(void){</Line>
  <Line number="300">  if( enableTimer ){</Line>
  <Line number="301">    getrusage(RUSAGE_SELF, &amp;sBegin);</Line>
  <Line number="302">    iBegin = timeOfDay();</Line>
  <Line number="303">  }</Line>
  <Line number="304">}</Line>
  <Line number="305"></Line>
  <Line number="306">/* Return the difference of two time_structs in seconds */</Line>
  <Line number="307">static double timeDiff(struct timeval *pStart, struct timeval *pEnd){</Line>
  <Line number="308">  return <CheckRefs ids="206">(</CheckRefs>pEnd-&gt;tv_usec <CheckRefs ids="207">-</CheckRefs> pStart-&gt;tv_usec)<CheckRefs ids="205">*</CheckRefs>0.000001 <CheckRefs ids="204">+</CheckRefs></Line>
  <Line number="309">         <CheckRefs ids="208">(</CheckRefs>double)(pEnd-&gt;tv_sec <CheckRefs ids="209">-</CheckRefs> pStart-&gt;tv_sec);</Line>
  <Line number="310">}</Line>
  <Line number="311"></Line>
  <Line number="312">/*</Line>
  <Line number="313">** Print the timing results.</Line>
  <Line number="314">*/</Line>
  <Line number="315">static void endTimer(void){</Line>
  <Line number="316">  if( enableTimer ){</Line>
  <Line number="317">    sqlite3_int64 iEnd = timeOfDay();</Line>
  <Line number="318">    struct rusage sEnd;</Line>
  <Line number="319">    getrusage(RUSAGE_SELF, &amp;sEnd);</Line>
  <Line number="320">    printf(&quot;Run Time: real %.3f user %f sys %f\n&quot;,</Line>
  <Line number="321">       <CheckRefs ids="211">(</CheckRefs>iEnd <CheckRefs ids="212">-</CheckRefs> iBegin)<CheckRefs ids="210">*</CheckRefs>0.001,</Line>
  <Line number="322">       timeDiff(&amp;sBegin.ru_utime, &amp;sEnd.ru_utime),</Line>
  <Line number="323">       timeDiff(&amp;sBegin.ru_stime, &amp;sEnd.ru_stime));</Line>
  <Line number="324">  }</Line>
  <Line number="325">}</Line>
  <Line number="326"></Line>
  <Line number="327">#define BEGIN_TIMER beginTimer()</Line>
  <Line number="328">#define END_TIMER endTimer()</Line>
  <Line number="329">#define HAS_TIMER 1</Line>
  <Line number="330"></Line>
  <Line number="331">#elif (defined(_WIN32) || defined(WIN32))</Line>
  <Line number="332"></Line>
  <Line number="333">/* Saved resource information for the beginning of an operation */</Line>
  <Line number="334">static HANDLE hProcess;</Line>
  <Line number="335">static FILETIME ftKernelBegin;</Line>
  <Line number="336">static FILETIME ftUserBegin;</Line>
  <Line number="337">static sqlite3_int64 ftWallBegin;</Line>
  <Line number="338">typedef BOOL (WINAPI *GETPROCTIMES)(HANDLE, LPFILETIME, LPFILETIME,</Line>
  <Line number="339">                                    LPFILETIME, LPFILETIME);</Line>
  <Line number="340">static GETPROCTIMES getProcessTimesAddr = NULL;</Line>
  <Line number="341"></Line>
  <Line number="342">/*</Line>
  <Line number="343">** Check to see if we have timer support.  Return 1 if necessary</Line>
  <Line number="344">** support found (or found previously).</Line>
  <Line number="345">*/</Line>
  <Line number="346">static int hasTimer(void){</Line>
  <Line number="347">  if( getProcessTimesAddr ){</Line>
  <Line number="348">    return 1;</Line>
  <Line number="349">  } else {</Line>
  <Line number="350">#if !SQLITE_OS_WINRT</Line>
  <Line number="351">    /* GetProcessTimes() isn&apos;t supported in WIN95 and some other Windows</Line>
  <Line number="352">    ** versions. See if the version we are running on has it, and if it</Line>
  <Line number="353">    ** does, save off a pointer to it and the current process handle.</Line>
  <Line number="354">    */</Line>
  <Line number="355">    hProcess = GetCurrentProcess();</Line>
  <Line number="356">    if( hProcess ){</Line>
  <Line number="357">      HINSTANCE hinstLib = LoadLibrary(TEXT(&quot;Kernel32.dll&quot;));</Line>
  <Line number="358">      if( NULL != hinstLib ){</Line>
  <Line number="359">        getProcessTimesAddr =</Line>
  <Line number="360">            (GETPROCTIMES) GetProcAddress(hinstLib, &quot;GetProcessTimes&quot;);</Line>
  <Line number="361">        if( NULL != getProcessTimesAddr ){</Line>
  <Line number="362">          return 1;</Line>
  <Line number="363">        }</Line>
  <Line number="364">        FreeLibrary(hinstLib);</Line>
  <Line number="365">      }</Line>
  <Line number="366">    }</Line>
  <Line number="367">#endif</Line>
  <Line number="368">  }</Line>
  <Line number="369">  return 0;</Line>
  <Line number="370">}</Line>
  <Line number="371"></Line>
  <Line number="372">/*</Line>
  <Line number="373">** Begin timing an operation</Line>
  <Line number="374">*/</Line>
  <Line number="375">static void beginTimer(void){</Line>
  <Line number="376">  if( enableTimer &amp;&amp; getProcessTimesAddr ){</Line>
  <Line number="377">    FILETIME ftCreation, ftExit;</Line>
  <Line number="378">    getProcessTimesAddr(hProcess,&amp;ftCreation,&amp;ftExit,</Line>
  <Line number="379">                        &amp;ftKernelBegin,&amp;ftUserBegin);</Line>
  <Line number="380">    ftWallBegin = timeOfDay();</Line>
  <Line number="381">  }</Line>
  <Line number="382">}</Line>
  <Line number="383"></Line>
  <Line number="384">/* Return the difference of two FILETIME structs in seconds */</Line>
  <Line number="385">static double timeDiff(FILETIME *pStart, FILETIME *pEnd){</Line>
  <Line number="386">  sqlite_int64 i64Start = *((sqlite_int64 *) pStart);</Line>
  <Line number="387">  sqlite_int64 i64End = *((sqlite_int64 *) pEnd);</Line>
  <Line number="388">  return (double) ((i64End - i64Start) / 10000000.0);</Line>
  <Line number="389">}</Line>
  <Line number="390"></Line>
  <Line number="391">/*</Line>
  <Line number="392">** Print the timing results.</Line>
  <Line number="393">*/</Line>
  <Line number="394">static void endTimer(void){</Line>
  <Line number="395">  if( enableTimer &amp;&amp; getProcessTimesAddr){</Line>
  <Line number="396">    FILETIME ftCreation, ftExit, ftKernelEnd, ftUserEnd;</Line>
  <Line number="397">    sqlite3_int64 ftWallEnd = timeOfDay();</Line>
  <Line number="398">    getProcessTimesAddr(hProcess,&amp;ftCreation,&amp;ftExit,&amp;ftKernelEnd,&amp;ftUserEnd);</Line>
  <Line number="399">    printf(&quot;Run Time: real %.3f user %f sys %f\n&quot;,</Line>
  <Line number="400">       (ftWallEnd - ftWallBegin)*0.001,</Line>
  <Line number="401">       timeDiff(&amp;ftUserBegin, &amp;ftUserEnd),</Line>
  <Line number="402">       timeDiff(&amp;ftKernelBegin, &amp;ftKernelEnd));</Line>
  <Line number="403">  }</Line>
  <Line number="404">}</Line>
  <Line number="405"></Line>
  <Line number="406">#define BEGIN_TIMER beginTimer()</Line>
  <Line number="407">#define END_TIMER endTimer()</Line>
  <Line number="408">#define HAS_TIMER hasTimer()</Line>
  <Line number="409"></Line>
  <Line number="410">#else</Line>
  <Line number="411">#define BEGIN_TIMER</Line>
  <Line number="412">#define END_TIMER</Line>
  <Line number="413">#define HAS_TIMER 0</Line>
  <Line number="414">#endif</Line>
  <Line number="415"></Line>
  <Line number="416">/*</Line>
  <Line number="417">** Used to prevent warnings about unused parameters</Line>
  <Line number="418">*/</Line>
  <Line number="419">#define UNUSED_PARAMETER(x) (void)(x)</Line>
  <Line number="420"></Line>
  <Line number="421">/*</Line>
  <Line number="422">** Number of elements in an array</Line>
  <Line number="423">*/</Line>
  <Line number="424">#define ArraySize(X)  (int)(sizeof(X)/sizeof(X[0]))</Line>
  <Line number="425"></Line>
  <Line number="426">/*</Line>
  <Line number="427">** If the following flag is set, then command execution stops</Line>
  <Line number="428">** at an error if we are not interactive.</Line>
  <Line number="429">*/</Line>
  <Line number="430">static int bail_on_error = 0;</Line>
  <Line number="431"></Line>
  <Line number="432">/*</Line>
  <Line number="433">** Threat stdin as an interactive input if the following variable</Line>
  <Line number="434">** is true.  Otherwise, assume stdin is connected to a file or pipe.</Line>
  <Line number="435">*/</Line>
  <Line number="436">static int stdin_is_interactive = 1;</Line>
  <Line number="437"></Line>
  <Line number="438">/*</Line>
  <Line number="439">** On Windows systems we have to know if standard output is a console</Line>
  <Line number="440">** in order to translate UTF-8 into MBCS.  The following variable is</Line>
  <Line number="441">** true if translation is required.</Line>
  <Line number="442">*/</Line>
  <Line number="443">static int stdout_is_console = 1;</Line>
  <Line number="444"></Line>
  <Line number="445">/*</Line>
  <Line number="446">** The following is the open SQLite database.  We make a pointer</Line>
  <Line number="447">** to this database a static variable so that it can be accessed</Line>
  <Line number="448">** by the SIGINT handler to interrupt database processing.</Line>
  <Line number="449">*/</Line>
  <Line number="450">static sqlite3 *globalDb = 0;</Line>
  <Line number="451"></Line>
  <Line number="452">/*</Line>
  <Line number="453">** True if an interrupt (Control-C) has been received.</Line>
  <Line number="454">*/</Line>
  <Line number="455">static volatile int seenInterrupt = 0;</Line>
  <Line number="456"></Line>
  <Line number="457">#ifdef SQLITE_DEBUG</Line>
  <Line number="458">/*</Line>
  <Line number="459">** Out-of-memory simulator variables</Line>
  <Line number="460">*/</Line>
  <Line number="461">static unsigned int oomCounter = 0;    /* Simulate OOM when equals 1 */</Line>
  <Line number="462">static unsigned int oomRepeat = 0;     /* Number of OOMs in a row */</Line>
  <Line number="463">static void*(*defaultMalloc)(int) = 0; /* The low-level malloc routine */</Line>
  <Line number="464">#endif /* SQLITE_DEBUG */</Line>
  <Line number="465"></Line>
  <Line number="466">/*</Line>
  <Line number="467">** This is the name of our program. It is set in main(), used</Line>
  <Line number="468">** in a number of other places, mostly for error messages.</Line>
  <Line number="469">*/</Line>
  <Line number="470">static char *Argv0;</Line>
  <Line number="471"></Line>
  <Line number="472">/*</Line>
  <Line number="473">** Prompt strings. Initialized in main. Settable with</Line>
  <Line number="474">**   .prompt main continue</Line>
  <Line number="475">*/</Line>
  <Line number="476">static char mainPrompt[20];     /* First line prompt. default: &quot;sqlite&gt; &quot;*/</Line>
  <Line number="477">static char continuePrompt[20]; /* Continuation prompt. default: &quot;   ...&gt; &quot; */</Line>
  <Line number="478"></Line>
  <Line number="479">/*</Line>
  <Line number="480">** Render output like fprintf().  Except, if the output is going to the</Line>
  <Line number="481">** console and if this is running on a Windows machine, translate the</Line>
  <Line number="482">** output from UTF-8 into MBCS.</Line>
  <Line number="483">*/</Line>
  <Line number="484">#if defined(_WIN32) || defined(WIN32)</Line>
  <Line number="485">void utf8_printf(FILE *out, const char *zFormat, ...){</Line>
  <Line number="486">  va_list ap;</Line>
  <Line number="487">  va_start(ap, zFormat);</Line>
  <Line number="488">  if( stdout_is_console &amp;&amp; (out==stdout || out==stderr) ){</Line>
  <Line number="489">    char *z1 = sqlite3_vmprintf(zFormat, ap);</Line>
  <Line number="490">    char *z2 = sqlite3_win32_utf8_to_mbcs_v2(z1, 0);</Line>
  <Line number="491">    sqlite3_free(z1);</Line>
  <Line number="492">    fputs(z2, out);</Line>
  <Line number="493">    sqlite3_free(z2);</Line>
  <Line number="494">  }else{</Line>
  <Line number="495">    vfprintf(out, zFormat, ap);</Line>
  <Line number="496">  }</Line>
  <Line number="497">  va_end(ap);</Line>
  <Line number="498">}</Line>
  <Line number="499">#elif !defined(utf8_printf)</Line>
  <Line number="500"># define utf8_printf fprintf</Line>
  <Line number="501">#endif</Line>
  <Line number="502"></Line>
  <Line number="503">/*</Line>
  <Line number="504">** Render output like fprintf().  This should not be used on anything that</Line>
  <Line number="505">** includes string formatting (e.g. &quot;%s&quot;).</Line>
  <Line number="506">*/</Line>
  <Line number="507">#if !defined(raw_printf)</Line>
  <Line number="508"># define raw_printf fprintf</Line>
  <Line number="509">#endif</Line>
  <Line number="510"></Line>
  <Line number="511">/* Indicate out-of-memory and exit. */</Line>
  <Line number="512">static void shell_out_of_memory(void){</Line>
  <Line number="513">  raw_printf(stderr,&quot;Error: out of memory\n&quot;);</Line>
  <Line number="514">  exit(1);</Line>
  <Line number="515">}</Line>
  <Line number="516"></Line>
  <Line number="517">#ifdef SQLITE_DEBUG</Line>
  <Line number="518">/* This routine is called when a simulated OOM occurs.  It is broken</Line>
  <Line number="519">** out as a separate routine to make it easy to set a breakpoint on</Line>
  <Line number="520">** the OOM</Line>
  <Line number="521">*/</Line>
  <Line number="522">void shellOomFault(void){</Line>
  <Line number="523">  if( oomRepeat&gt;0 ){</Line>
  <Line number="524">    oomRepeat--;</Line>
  <Line number="525">  }else{</Line>
  <Line number="526">    oomCounter--;</Line>
  <Line number="527">  }</Line>
  <Line number="528">}</Line>
  <Line number="529">#endif /* SQLITE_DEBUG */</Line>
  <Line number="530"></Line>
  <Line number="531">#ifdef SQLITE_DEBUG</Line>
  <Line number="532">/* This routine is a replacement malloc() that is used to simulate</Line>
  <Line number="533">** Out-Of-Memory (OOM) errors for testing purposes.</Line>
  <Line number="534">*/</Line>
  <Line number="535">static void *oomMalloc(int nByte){</Line>
  <Line number="536">  if( oomCounter ){</Line>
  <Line number="537">    if( oomCounter==1 ){</Line>
  <Line number="538">      shellOomFault();</Line>
  <Line number="539">      return 0;</Line>
  <Line number="540">    }else{</Line>
  <Line number="541">      oomCounter--;</Line>
  <Line number="542">    }</Line>
  <Line number="543">  }</Line>
  <Line number="544">  return defaultMalloc(nByte);</Line>
  <Line number="545">}</Line>
  <Line number="546">#endif /* SQLITE_DEBUG */</Line>
  <Line number="547"></Line>
  <Line number="548">#ifdef SQLITE_DEBUG</Line>
  <Line number="549">/* Register the OOM simulator.  This must occur before any memory</Line>
  <Line number="550">** allocations */</Line>
  <Line number="551">static void registerOomSimulator(void){</Line>
  <Line number="552">  sqlite3_mem_methods mem;</Line>
  <Line number="553">  sqlite3_config(SQLITE_CONFIG_GETMALLOC, &amp;mem);</Line>
  <Line number="554">  defaultMalloc = mem.xMalloc;</Line>
  <Line number="555">  mem.xMalloc = oomMalloc;</Line>
  <Line number="556">  sqlite3_config(SQLITE_CONFIG_MALLOC, &amp;mem);</Line>
  <Line number="557">}</Line>
  <Line number="558">#endif</Line>
  <Line number="559"></Line>
  <Line number="560">/*</Line>
  <Line number="561">** Write I/O traces to the following stream.</Line>
  <Line number="562">*/</Line>
  <Line number="563">#ifdef SQLITE_ENABLE_IOTRACE</Line>
  <Line number="564">static FILE *iotrace = 0;</Line>
  <Line number="565">#endif</Line>
  <Line number="566"></Line>
  <Line number="567">/*</Line>
  <Line number="568">** This routine works like printf in that its first argument is a</Line>
  <Line number="569">** format string and subsequent arguments are values to be substituted</Line>
  <Line number="570">** in place of % fields.  The result of formatting this string</Line>
  <Line number="571">** is written to iotrace.</Line>
  <Line number="572">*/</Line>
  <Line number="573">#ifdef SQLITE_ENABLE_IOTRACE</Line>
  <Line number="574">static void SQLITE_CDECL iotracePrintf(const char *zFormat, ...){</Line>
  <Line number="575">  va_list ap;</Line>
  <Line number="576">  char *z;</Line>
  <Line number="577">  if( iotrace==0 ) return;</Line>
  <Line number="578">  va_start(ap, zFormat);</Line>
  <Line number="579">  z = sqlite3_vmprintf(zFormat, ap);</Line>
  <Line number="580">  va_end(ap);</Line>
  <Line number="581">  utf8_printf(iotrace, &quot;%s&quot;, z);</Line>
  <Line number="582">  sqlite3_free(z);</Line>
  <Line number="583">}</Line>
  <Line number="584">#endif</Line>
  <Line number="585"></Line>
  <Line number="586">/*</Line>
  <Line number="587">** Output string zUtf to stream pOut as w characters.  If w is negative,</Line>
  <Line number="588">** then right-justify the text.  W is the width in UTF-8 characters, not</Line>
  <Line number="589">** in bytes.  This is different from the %*.*s specification in printf</Line>
  <Line number="590">** since with %*.*s the width is measured in bytes, not characters.</Line>
  <Line number="591">*/</Line>
  <Line number="592">static void utf8_width_print(FILE *pOut, int w, const char *zUtf){</Line>
  <Line number="593">  int i;</Line>
  <Line number="594">  int n;</Line>
  <Line number="595">  int aw = w&lt;0 ? <CheckRefs ids="213">-</CheckRefs>w : w;</Line>
  <Line number="596">  for(i=n=0; zUtf[i]; i<CheckRefs ids="214">++</CheckRefs>){</Line>
  <Line number="597">    if( (<CheckRefs ids="215">zUtf</CheckRefs>[i]&amp;0xc0)!=0x80 ){</Line>
  <Line number="598">      n<CheckRefs ids="216">++</CheckRefs>;</Line>
  <Line number="599">      if( n==aw ){</Line>
  <Line number="600">        do{ i<CheckRefs ids="217">++</CheckRefs>; }while( (<CheckRefs ids="218">zUtf</CheckRefs>[i]&amp;0xc0)==0x80 );</Line>
  <Line number="601">        break;</Line>
  <Line number="602">      }</Line>
  <Line number="603">    }</Line>
  <Line number="604">  }</Line>
  <Line number="605">  if( n&gt;=aw ){</Line>
  <Line number="606">    utf8_printf(pOut, &quot;%.*s&quot;, i, zUtf);</Line>
  <Line number="607">  }else if( w&lt;0 ){</Line>
  <Line number="608">    utf8_printf(pOut, &quot;%*s%s&quot;, aw<CheckRefs ids="219">-</CheckRefs>n, &quot;&quot;, zUtf);</Line>
  <Line number="609">  }else{</Line>
  <Line number="610">    utf8_printf(pOut, &quot;%s%*s&quot;, zUtf, aw<CheckRefs ids="220">-</CheckRefs>n, &quot;&quot;);</Line>
  <Line number="611">  }</Line>
  <Line number="612">}</Line>
  <Line number="613"></Line>
  <Line number="614"></Line>
  <Line number="615">/*</Line>
  <Line number="616">** Determines if a string is a number of not.</Line>
  <Line number="617">*/</Line>
  <Line number="618">static int isNumber(const char *z, int *realnum){</Line>
  <Line number="619">  if( <CheckRefs ids="221">*</CheckRefs>z==&apos;-&apos; || <CheckRefs ids="222">*</CheckRefs>z==&apos;+&apos; ) z++;</Line>
  <Line number="620">  if( !<CheckRefs ids="224,227,226,223,225">IsDigit</CheckRefs>(*z) ){</Line>
  <Line number="621">    return 0;</Line>
  <Line number="622">  }</Line>
  <Line number="623">  z++;</Line>
  <Line number="624">  if( realnum ) *realnum = 0;</Line>
  <Line number="625">  while( <CheckRefs ids="228,229,231,232,230">IsDigit</CheckRefs>(*z) ){ z++; }</Line>
  <Line number="626">  if( <CheckRefs ids="233">*</CheckRefs>z==&apos;.&apos; ){</Line>
  <Line number="627">    z++;</Line>
  <Line number="628">    if( !<CheckRefs ids="234,235,237,238,236">IsDigit</CheckRefs>(*z) ) return 0;</Line>
  <Line number="629">    while( <CheckRefs ids="239,240,242,243,241">IsDigit</CheckRefs>(*z) ){ z++; }</Line>
  <Line number="630">    if( realnum ) *realnum = 1;</Line>
  <Line number="631">  }</Line>
  <Line number="632">  if( <CheckRefs ids="244">*</CheckRefs>z==&apos;e&apos; || <CheckRefs ids="245">*</CheckRefs>z==&apos;E&apos; ){</Line>
  <Line number="633">    z++;</Line>
  <Line number="634">    if( <CheckRefs ids="246">*</CheckRefs>z==&apos;+&apos; || <CheckRefs ids="247">*</CheckRefs>z==&apos;-&apos; ) z++;</Line>
  <Line number="635">    if( !<CheckRefs ids="248,249,251,252,250">IsDigit</CheckRefs>(*z) ) return 0;</Line>
  <Line number="636">    while( <CheckRefs ids="253,254,256,257,255">IsDigit</CheckRefs>(*z) ){ z++; }</Line>
  <Line number="637">    if( realnum ) *realnum = 1;</Line>
  <Line number="638">  }</Line>
  <Line number="639">  return <CheckRefs ids="258">*</CheckRefs>z==0;</Line>
  <Line number="640">}</Line>
  <Line number="641"></Line>
  <Line number="642">/*</Line>
  <Line number="643">** Compute a string length that is limited to what can be stored in</Line>
  <Line number="644">** lower 30 bits of a 32-bit signed integer.</Line>
  <Line number="645">*/</Line>
  <Line number="646">static int strlen30(const char *z){</Line>
  <Line number="647">  const char *z2 = z;</Line>
  <Line number="648">  while( *z2 ){ z2++; }</Line>
  <Line number="649">  return 0x3fffffff &amp; <CheckRefs ids="259">(</CheckRefs>int)(z2 <CheckRefs ids="260">-</CheckRefs> z);</Line>
  <Line number="650">}</Line>
  <Line number="651"></Line>
  <Line number="652">/*</Line>
  <Line number="653">** Return the length of a string in characters.  Multibyte UTF8 characters</Line>
  <Line number="654">** count as a single character.</Line>
  <Line number="655">*/</Line>
  <Line number="656">static int strlenChar(const char *z){</Line>
  <Line number="657">  int n = 0;</Line>
  <Line number="658">  while( *z ){</Line>
  <Line number="659">    if( (0xc0&amp;<CheckRefs ids="261">*</CheckRefs>(z++))!=0x80 ) n<CheckRefs ids="262">++</CheckRefs>;</Line>
  <Line number="660">  }</Line>
  <Line number="661">  return n;</Line>
  <Line number="662">}</Line>
  <Line number="663"></Line>
  <Line number="664">/*</Line>
  <Line number="665">** Return true if zFile does not exist or if it is not an ordinary file.</Line>
  <Line number="666">*/</Line>
  <Line number="667">#ifdef _WIN32</Line>
  <Line number="668"># define notNormalFile(X) 0</Line>
  <Line number="669">#else</Line>
  <Line number="670">static int notNormalFile(const char *zFile){</Line>
  <Line number="671">  struct stat x;</Line>
  <Line number="672">  int rc;</Line>
  <Line number="673">  memset(&amp;x, 0, sizeof(x));</Line>
  <Line number="674">  rc = stat(zFile, &amp;x);</Line>
  <Line number="675">  return rc || !<CheckRefs ids="263,264">S_ISREG</CheckRefs>(x.st_mode);</Line>
  <Line number="676">}</Line>
  <Line number="677">#endif</Line>
  <Line number="678"></Line>
  <Line number="679">/*</Line>
  <Line number="680">** This routine reads a line of text from FILE in, stores</Line>
  <Line number="681">** the text in memory obtained from malloc() and returns a pointer</Line>
  <Line number="682">** to the text.  NULL is returned at end of file, or if malloc()</Line>
  <Line number="683">** fails.</Line>
  <Line number="684">**</Line>
  <Line number="685">** If zLine is not NULL then it is a malloced buffer returned from</Line>
  <Line number="686">** a previous call to this routine that may be reused.</Line>
  <Line number="687">*/</Line>
  <Line number="688">static char *local_getline(char *zLine, FILE *in){</Line>
  <Line number="689">  int nLine = zLine==0 ? 0 : 100;</Line>
  <Line number="690">  int n = 0;</Line>
  <Line number="691"></Line>
  <Line number="692">  while( 1 ){</Line>
  <Line number="693">    if( n<CheckRefs ids="265">+</CheckRefs>100&gt;nLine ){</Line>
  <Line number="694">      nLine = nLine<CheckRefs ids="267">*</CheckRefs>2 <CheckRefs ids="266">+</CheckRefs> 100;</Line>
  <Line number="695">      zLine = realloc(zLine, <CheckRefs ids="268">nLine</CheckRefs>);</Line>
  <Line number="696">      if( zLine==0 ) shell_out_of_memory();</Line>
  <Line number="697">    }</Line>
  <Line number="698">    if( fgets(&amp;zLine[n], nLine <CheckRefs ids="269">-</CheckRefs> n, in)==0 ){</Line>
  <Line number="699">      if( n==0 ){</Line>
  <Line number="700">        free(zLine);</Line>
  <Line number="701">        return 0;</Line>
  <Line number="702">      }</Line>
  <Line number="703">      zLine[n] = <CheckRefs ids="270">0</CheckRefs>;</Line>
  <Line number="704">      break;</Line>
  <Line number="705">    }</Line>
  <Line number="706">    while( zLine[n] ) n<CheckRefs ids="271">++</CheckRefs>;</Line>
  <Line number="707">    if( n&gt;0 &amp;&amp; <CheckRefs ids="272">zLine</CheckRefs>[n<CheckRefs ids="273">-</CheckRefs>1]==&apos;\n&apos; ){</Line>
  <Line number="708">      n<CheckRefs ids="274">--</CheckRefs>;</Line>
  <Line number="709">      if( n&gt;0 &amp;&amp; <CheckRefs ids="275">zLine</CheckRefs>[n<CheckRefs ids="276">-</CheckRefs>1]==&apos;\r&apos; ) n<CheckRefs ids="277">--</CheckRefs>;</Line>
  <Line number="710">      zLine[n] = <CheckRefs ids="278">0</CheckRefs>;</Line>
  <Line number="711">      break;</Line>
  <Line number="712">    }</Line>
  <Line number="713">  }</Line>
  <Line number="714">#if defined(_WIN32) || defined(WIN32)</Line>
  <Line number="715">  /* For interactive input on Windows systems, translate the</Line>
  <Line number="716">  ** multi-byte characterset characters into UTF-8. */</Line>
  <Line number="717">  if( stdin_is_interactive &amp;&amp; in==stdin ){</Line>
  <Line number="718">    char *zTrans = sqlite3_win32_mbcs_to_utf8_v2(zLine, 0);</Line>
  <Line number="719">    if( zTrans ){</Line>
  <Line number="720">      int nTrans = strlen30(zTrans)+1;</Line>
  <Line number="721">      if( nTrans&gt;nLine ){</Line>
  <Line number="722">        zLine = realloc(zLine, nTrans);</Line>
  <Line number="723">        if( zLine==0 ) shell_out_of_memory();</Line>
  <Line number="724">      }</Line>
  <Line number="725">      memcpy(zLine, zTrans, nTrans);</Line>
  <Line number="726">      sqlite3_free(zTrans);</Line>
  <Line number="727">    }</Line>
  <Line number="728">  }</Line>
  <Line number="729">#endif /* defined(_WIN32) || defined(WIN32) */</Line>
  <Line number="730">  return zLine;</Line>
  <Line number="731">}</Line>
  <Line number="732"></Line>
  <Line number="733">/*</Line>
  <Line number="734">** Retrieve a single line of input text.</Line>
  <Line number="735">**</Line>
  <Line number="736">** If in==0 then read from standard input and prompt before each line.</Line>
  <Line number="737">** If isContinuation is true, then a continuation prompt is appropriate.</Line>
  <Line number="738">** If isContinuation is zero, then the main prompt should be used.</Line>
  <Line number="739">**</Line>
  <Line number="740">** If zPrior is not NULL then it is a buffer from a prior call to this</Line>
  <Line number="741">** routine that can be reused.</Line>
  <Line number="742">**</Line>
  <Line number="743">** The result is stored in space obtained from malloc() and must either</Line>
  <Line number="744">** be freed by the caller or else passed back into this routine via the</Line>
  <Line number="745">** zPrior argument for reuse.</Line>
  <Line number="746">*/</Line>
  <Line number="747">static char *one_input_line(FILE *in, char *zPrior, int isContinuation){</Line>
  <Line number="748">  char *zPrompt;</Line>
  <Line number="749">  char *zResult;</Line>
  <Line number="750">  if( in!=0 ){</Line>
  <Line number="751">    zResult = local_getline(zPrior, in);</Line>
  <Line number="752">  }else{</Line>
  <Line number="753">    zPrompt = isContinuation ? continuePrompt : mainPrompt;</Line>
  <Line number="754">#if SHELL_USE_LOCAL_GETLINE</Line>
  <Line number="755">    printf(&quot;%s&quot;, zPrompt);</Line>
  <Line number="756">    fflush(stdout);</Line>
  <Line number="757">    zResult = local_getline(zPrior, stdin);</Line>
  <Line number="758">#else</Line>
  <Line number="759">    free(zPrior);</Line>
  <Line number="760">    zResult = shell_readline(zPrompt);</Line>
  <Line number="761">    if( zResult &amp;&amp; *zResult ) shell_add_history(zResult);</Line>
  <Line number="762">#endif</Line>
  <Line number="763">  }</Line>
  <Line number="764">  return zResult;</Line>
  <Line number="765">}</Line>
  <Line number="766"></Line>
  <Line number="767"></Line>
  <Line number="768">/*</Line>
  <Line number="769">** Return the value of a hexadecimal digit.  Return -1 if the input</Line>
  <Line number="770">** is not a hex digit.</Line>
  <Line number="771">*/</Line>
  <Line number="772">static int hexDigitValue(char c){</Line>
  <Line number="773">  if( <CheckRefs ids="279">c</CheckRefs>&gt;=&apos;0&apos; &amp;&amp; <CheckRefs ids="280">c</CheckRefs>&lt;=&apos;9&apos; ) return <CheckRefs ids="282">c</CheckRefs> <CheckRefs ids="281">-</CheckRefs> &apos;0&apos;;</Line>
  <Line number="774">  if( <CheckRefs ids="283">c</CheckRefs>&gt;=&apos;a&apos; &amp;&amp; <CheckRefs ids="284">c</CheckRefs>&lt;=&apos;f&apos; ) return <CheckRefs ids="287">c</CheckRefs> <CheckRefs ids="286">-</CheckRefs> &apos;a&apos; <CheckRefs ids="285">+</CheckRefs> 10;</Line>
  <Line number="775">  if( <CheckRefs ids="288">c</CheckRefs>&gt;=&apos;A&apos; &amp;&amp; <CheckRefs ids="289">c</CheckRefs>&lt;=&apos;F&apos; ) return <CheckRefs ids="292">c</CheckRefs> <CheckRefs ids="291">-</CheckRefs> &apos;A&apos; <CheckRefs ids="290">+</CheckRefs> 10;</Line>
  <Line number="776">  return <CheckRefs ids="293">-</CheckRefs>1;</Line>
  <Line number="777">}</Line>
  <Line number="778"></Line>
  <Line number="779">/*</Line>
  <Line number="780">** Interpret zArg as an integer value, possibly with suffixes.</Line>
  <Line number="781">*/</Line>
  <Line number="782">static sqlite3_int64 integerValue(const char *zArg){</Line>
  <Line number="783">  sqlite3_int64 v = <CheckRefs ids="294">0</CheckRefs>;</Line>
  <Line number="784">  static const struct { char *zSuffix; int iMult; } aMult[] = {</Line>
  <Line number="785">    { &quot;KiB&quot;, 1024 },</Line>
  <Line number="786">    { &quot;MiB&quot;, 1024<CheckRefs ids="295">*</CheckRefs>1024 },</Line>
  <Line number="787">    { &quot;GiB&quot;, 1024<CheckRefs ids="297">*</CheckRefs>1024<CheckRefs ids="296">*</CheckRefs>1024 },</Line>
  <Line number="788">    { &quot;KB&quot;,  1000 },</Line>
  <Line number="789">    { &quot;MB&quot;,  1000000 },</Line>
  <Line number="790">    { &quot;GB&quot;,  1000000000 },</Line>
  <Line number="791">    { &quot;K&quot;,   1000 },</Line>
  <Line number="792">    { &quot;M&quot;,   1000000 },</Line>
  <Line number="793">    { &quot;G&quot;,   1000000000 },</Line>
  <Line number="794">  };</Line>
  <Line number="795">  int i;</Line>
  <Line number="796">  int isNeg = 0;</Line>
  <Line number="797">  if( <CheckRefs ids="298">zArg</CheckRefs>[0]==&apos;-&apos; ){</Line>
  <Line number="798">    isNeg = 1;</Line>
  <Line number="799">    zArg++;</Line>
  <Line number="800">  }else if( <CheckRefs ids="299">zArg</CheckRefs>[0]==&apos;+&apos; ){</Line>
  <Line number="801">    zArg++;</Line>
  <Line number="802">  }</Line>
  <Line number="803">  if( <CheckRefs ids="300">zArg</CheckRefs>[0]==&apos;0&apos; &amp;&amp; <CheckRefs ids="301">zArg</CheckRefs>[1]==&apos;x&apos; ){</Line>
  <Line number="804">    int x;</Line>
  <Line number="805">    zArg += 2;</Line>
  <Line number="806">    while( (x = hexDigitValue(zArg[0]))&gt;=0 ){</Line>
  <Line number="807">      v = (v<CheckRefs ids="303,304,305">&lt;&lt;</CheckRefs>4) <CheckRefs ids="302">+</CheckRefs> <CheckRefs ids="306">x</CheckRefs>;</Line>
  <Line number="808">      zArg++;</Line>
  <Line number="809">    }</Line>
  <Line number="810">  }else{</Line>
  <Line number="811">    while( <CheckRefs ids="311,308,310,307,309">IsDigit</CheckRefs>(zArg[0]) ){</Line>
  <Line number="812">      v = v<CheckRefs ids="314">*</CheckRefs><CheckRefs ids="315">10</CheckRefs> <CheckRefs ids="313">+</CheckRefs> <CheckRefs ids="316">zArg</CheckRefs>[0] <CheckRefs ids="312">-</CheckRefs> <CheckRefs ids="317">&apos;0&apos;</CheckRefs>;</Line>
  <Line number="813">      zArg++;</Line>
  <Line number="814">    }</Line>
  <Line number="815">  }</Line>
  <Line number="816">  for(i=0; i&lt;<CheckRefs ids="318,319,320">ArraySize</CheckRefs>(aMult); i<CheckRefs ids="321">++</CheckRefs>){</Line>
  <Line number="817">    if( sqlite3_stricmp(aMult[i<CheckRefs ids="322">]</CheckRefs>.zSuffix, zArg)==0 ){</Line>
  <Line number="818">      v <CheckRefs ids="323">*=</CheckRefs> <CheckRefs ids="324">aMult</CheckRefs>[i<CheckRefs ids="325">]</CheckRefs>.iMult;</Line>
  <Line number="819">      break;</Line>
  <Line number="820">    }</Line>
  <Line number="821">  }</Line>
  <Line number="822">  return isNeg? <CheckRefs ids="326">-</CheckRefs>v : v;</Line>
  <Line number="823">}</Line>
  <Line number="824"></Line>
  <Line number="825">/*</Line>
  <Line number="826">** A variable length string to which one can append text.</Line>
  <Line number="827">*/</Line>
  <Line number="828">typedef struct ShellText ShellText;</Line>
  <Line number="829">struct ShellText {</Line>
  <Line number="830">  char *z;</Line>
  <Line number="831">  int n;</Line>
  <Line number="832">  int nAlloc;</Line>
  <Line number="833">};</Line>
  <Line number="834"></Line>
  <Line number="835">/*</Line>
  <Line number="836">** Initialize and destroy a ShellText object</Line>
  <Line number="837">*/</Line>
  <Line number="838">static void initText(ShellText *p){</Line>
  <Line number="839">  memset(p, 0, sizeof(*p));</Line>
  <Line number="840">}</Line>
  <Line number="841">static void freeText(ShellText *p){</Line>
  <Line number="842">  free(p-&gt;z);</Line>
  <Line number="843">  initText(p);</Line>
  <Line number="844">}</Line>
  <Line number="845"></Line>
  <Line number="846">/* zIn is either a pointer to a NULL-terminated string in memory obtained</Line>
  <Line number="847">** from malloc(), or a NULL pointer. The string pointed to by zAppend is</Line>
  <Line number="848">** added to zIn, and the result returned in memory obtained from malloc().</Line>
  <Line number="849">** zIn, if it was not NULL, is freed.</Line>
  <Line number="850">**</Line>
  <Line number="851">** If the third argument, quote, is not &apos;\0&apos;, then it is used as a</Line>
  <Line number="852">** quote character for zAppend.</Line>
  <Line number="853">*/</Line>
  <Line number="854">static void appendText(ShellText *p, char const *zAppend, char quote){</Line>
  <Line number="855">  int len;</Line>
  <Line number="856">  int i;</Line>
  <Line number="857">  int nAppend = strlen30(zAppend);</Line>
  <Line number="858"></Line>
  <Line number="859">  len = nAppend<CheckRefs ids="328">+</CheckRefs>p-&gt;n<CheckRefs ids="327">+</CheckRefs>1;</Line>
  <Line number="860">  if( quote ){</Line>
  <Line number="861">    len <CheckRefs ids="329">+=</CheckRefs> 2;</Line>
  <Line number="862">    for(i=0; i&lt;nAppend; i<CheckRefs ids="330">++</CheckRefs>){</Line>
  <Line number="863">      if( <CheckRefs ids="331">zAppend</CheckRefs>[i]==<CheckRefs ids="332">quote</CheckRefs> ) len<CheckRefs ids="333">++</CheckRefs>;</Line>
  <Line number="864">    }</Line>
  <Line number="865">  }</Line>
  <Line number="866"></Line>
  <Line number="867">  if( p-&gt;n<CheckRefs ids="334">+</CheckRefs>len&gt;=p-&gt;nAlloc ){</Line>
  <Line number="868">    p-&gt;nAlloc = p-&gt;nAlloc<CheckRefs ids="337">*</CheckRefs>2 <CheckRefs ids="336">+</CheckRefs> len <CheckRefs ids="335">+</CheckRefs> 20;</Line>
  <Line number="869">    p-&gt;z = realloc(p-&gt;z, <CheckRefs ids="338">p</CheckRefs>-&gt;nAlloc);</Line>
  <Line number="870">    if( p-&gt;z==0 ) shell_out_of_memory();</Line>
  <Line number="871">  }</Line>
  <Line number="872"></Line>
  <Line number="873">  if( quote ){</Line>
  <Line number="874">    char *zCsr = p-&gt;z+p-&gt;n;</Line>
  <Line number="875">    *zCsr++ = quote;</Line>
  <Line number="876">    for(i=0; i&lt;nAppend; i<CheckRefs ids="339">++</CheckRefs>){</Line>
  <Line number="877">      *zCsr++ = zAppend[i];</Line>
  <Line number="878">      if( <CheckRefs ids="340">zAppend</CheckRefs>[i]==<CheckRefs ids="341">quote</CheckRefs> ) *zCsr++ = quote;</Line>
  <Line number="879">    }</Line>
  <Line number="880">    *zCsr++ = quote;</Line>
  <Line number="881">    p-&gt;n = <CheckRefs ids="342">(</CheckRefs>int)(zCsr <CheckRefs ids="343">-</CheckRefs> p-&gt;z);</Line>
  <Line number="882">    *zCsr = <CheckRefs ids="344">&apos;\0&apos;</CheckRefs>;</Line>
  <Line number="883">  }else{</Line>
  <Line number="884">    memcpy(p-&gt;z+p-&gt;n, zAppend, <CheckRefs ids="345">nAppend</CheckRefs>);</Line>
  <Line number="885">    p-&gt;n <CheckRefs ids="346">+=</CheckRefs> nAppend;</Line>
  <Line number="886">    p-&gt;z[p-&gt;n] = <CheckRefs ids="347">&apos;\0&apos;</CheckRefs>;</Line>
  <Line number="887">  }</Line>
  <Line number="888">}</Line>
  <Line number="889"></Line>
  <Line number="890">/*</Line>
  <Line number="891">** Attempt to determine if identifier zName needs to be quoted, either</Line>
  <Line number="892">** because it contains non-alphanumeric characters, or because it is an</Line>
  <Line number="893">** SQLite keyword.  Be conservative in this estimate:  When in doubt assume</Line>
  <Line number="894">** that quoting is required.</Line>
  <Line number="895">**</Line>
  <Line number="896">** Return &apos;&quot;&apos; if quoting is required.  Return 0 if no quoting is required.</Line>
  <Line number="897">*/</Line>
  <Line number="898">static char quoteChar(const char *zName){</Line>
  <Line number="899">  int i;</Line>
  <Line number="900">  if( !<CheckRefs ids="348,349,351,352,350">isalpha</CheckRefs>((unsigned char)zName[0]) &amp;&amp; <CheckRefs ids="353">zName</CheckRefs>[0]!=&apos;_&apos; ) return <CheckRefs ids="354">&apos;&quot;&apos;</CheckRefs>;</Line>
  <Line number="901">  for(i=0; zName[i]; i<CheckRefs ids="355">++</CheckRefs>){</Line>
  <Line number="902">    if( !<CheckRefs ids="359,360,357,356,358">isalnum</CheckRefs>((unsigned char)zName[i]) &amp;&amp; <CheckRefs ids="361">zName</CheckRefs>[i]!=&apos;_&apos; ) return <CheckRefs ids="362">&apos;&quot;&apos;</CheckRefs>;</Line>
  <Line number="903">  }</Line>
  <Line number="904">  return <CheckRefs ids="363">sqlite3_keyword_check</CheckRefs>(zName, i) ? &apos;&quot;&apos; : 0;</Line>
  <Line number="905">}</Line>
  <Line number="906"></Line>
  <Line number="907">/*</Line>
  <Line number="908">** Construct a fake object name and column list to describe the structure</Line>
  <Line number="909">** of the view, virtual table, or table valued function zSchema.zName.</Line>
  <Line number="910">*/</Line>
  <Line number="911">static char *shellFakeSchema(</Line>
  <Line number="912">  sqlite3 *db,            /* The database connection containing the vtab */</Line>
  <Line number="913">  const char *zSchema,    /* Schema of the database holding the vtab */</Line>
  <Line number="914">  const char *zName       /* The name of the virtual table */</Line>
  <Line number="915">){</Line>
  <Line number="916">  sqlite3_stmt *pStmt = 0;</Line>
  <Line number="917">  char *zSql;</Line>
  <Line number="918">  ShellText s;</Line>
  <Line number="919">  char cQuote;</Line>
  <Line number="920">  char *zDiv = &quot;(&quot;;</Line>
  <Line number="921">  int nRow = 0;</Line>
  <Line number="922"></Line>
  <Line number="923">  zSql = sqlite3_mprintf(&quot;PRAGMA \&quot;%w\&quot;.table_info=%Q;&quot;,</Line>
  <Line number="924">                         zSchema ? zSchema : &quot;main&quot;, zName);</Line>
  <Line number="925">  sqlite3_prepare_v2(db, zSql, <CheckRefs ids="364">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="926">  sqlite3_free(zSql);</Line>
  <Line number="927">  initText(&amp;s);</Line>
  <Line number="928">  if( zSchema ){</Line>
  <Line number="929">    cQuote = quoteChar(zSchema);</Line>
  <Line number="930">    if( <CheckRefs ids="365">cQuote</CheckRefs> &amp;&amp; sqlite3_stricmp(zSchema,&quot;temp&quot;)==0 ) cQuote = <CheckRefs ids="366">0</CheckRefs>;</Line>
  <Line number="931">    appendText(&amp;s, zSchema, cQuote);</Line>
  <Line number="932">    appendText(&amp;s, &quot;.&quot;, <CheckRefs ids="367">0</CheckRefs>);</Line>
  <Line number="933">  }</Line>
  <Line number="934">  cQuote = quoteChar(zName);</Line>
  <Line number="935">  appendText(&amp;s, zName, cQuote);</Line>
  <Line number="936">  while( sqlite3_step(pStmt)==SQLITE_ROW ){</Line>
  <Line number="937">    const char *zCol = (const char*)sqlite3_column_text(pStmt, 1);</Line>
  <Line number="938">    nRow<CheckRefs ids="368">++</CheckRefs>;</Line>
  <Line number="939">    appendText(&amp;s, zDiv, <CheckRefs ids="369">0</CheckRefs>);</Line>
  <Line number="940">    zDiv = &quot;,&quot;;</Line>
  <Line number="941">    cQuote = quoteChar(zCol);</Line>
  <Line number="942">    appendText(&amp;s, zCol, cQuote);</Line>
  <Line number="943">  }</Line>
  <Line number="944">  appendText(&amp;s, &quot;)&quot;, <CheckRefs ids="370">0</CheckRefs>);</Line>
  <Line number="945">  sqlite3_finalize(pStmt);</Line>
  <Line number="946">  if( nRow==0 ){</Line>
  <Line number="947">    freeText(&amp;s);</Line>
  <Line number="948">    s.z = 0;</Line>
  <Line number="949">  }</Line>
  <Line number="950">  return s.z;</Line>
  <Line number="951">}</Line>
  <Line number="952"></Line>
  <Line number="953">/*</Line>
  <Line number="954">** SQL function:  shell_module_schema(X)</Line>
  <Line number="955">**</Line>
  <Line number="956">** Return a fake schema for the table-valued function or eponymous virtual</Line>
  <Line number="957">** table X.</Line>
  <Line number="958">*/</Line>
  <Line number="959">static void shellModuleSchema(</Line>
  <Line number="960">  sqlite3_context *pCtx,</Line>
  <Line number="961">  int nVal,</Line>
  <Line number="962">  sqlite3_value **apVal</Line>
  <Line number="963">){</Line>
  <Line number="964">  const char *zName = (const char*)sqlite3_value_text(apVal[0]);</Line>
  <Line number="965">  char *zFake = shellFakeSchema(sqlite3_context_db_handle(pCtx), 0, zName);</Line>
  <Line number="966">  UNUSED_PARAMETER(nVal);</Line>
  <Line number="967">  if( zFake ){</Line>
  <Line number="968">    sqlite3_result_text(pCtx, sqlite3_mprintf(&quot;/* %s */&quot;, zFake),</Line>
  <Line number="969">                        <CheckRefs ids="371">-</CheckRefs>1, sqlite3_free);</Line>
  <Line number="970">    free(zFake);</Line>
  <Line number="971">  }</Line>
  <Line number="972">}</Line>
  <Line number="973"></Line>
  <Line number="974">/*</Line>
  <Line number="975">** SQL function:  shell_add_schema(S,X)</Line>
  <Line number="976">**</Line>
  <Line number="977">** Add the schema name X to the CREATE statement in S and return the result.</Line>
  <Line number="978">** Examples:</Line>
  <Line number="979">**</Line>
  <Line number="980">**    CREATE TABLE t1(x)   -&gt;   CREATE TABLE xyz.t1(x);</Line>
  <Line number="981">**</Line>
  <Line number="982">** Also works on</Line>
  <Line number="983">**</Line>
  <Line number="984">**    CREATE INDEX</Line>
  <Line number="985">**    CREATE UNIQUE INDEX</Line>
  <Line number="986">**    CREATE VIEW</Line>
  <Line number="987">**    CREATE TRIGGER</Line>
  <Line number="988">**    CREATE VIRTUAL TABLE</Line>
  <Line number="989">**</Line>
  <Line number="990">** This UDF is used by the .schema command to insert the schema name of</Line>
  <Line number="991">** attached databases into the middle of the sqlite_schema.sql field.</Line>
  <Line number="992">*/</Line>
  <Line number="993">static void shellAddSchemaName(</Line>
  <Line number="994">  sqlite3_context *pCtx,</Line>
  <Line number="995">  int nVal,</Line>
  <Line number="996">  sqlite3_value **apVal</Line>
  <Line number="997">){</Line>
  <Line number="998">  static const char *aPrefix[] = {</Line>
  <Line number="999">     &quot;TABLE&quot;,</Line>
  <Line number="1000">     &quot;INDEX&quot;,</Line>
  <Line number="1001">     &quot;UNIQUE INDEX&quot;,</Line>
  <Line number="1002">     &quot;VIEW&quot;,</Line>
  <Line number="1003">     &quot;TRIGGER&quot;,</Line>
  <Line number="1004">     &quot;VIRTUAL TABLE&quot;</Line>
  <Line number="1005">  };</Line>
  <Line number="1006">  int i = 0;</Line>
  <Line number="1007">  const char *zIn = (const char*)sqlite3_value_text(apVal[0]);</Line>
  <Line number="1008">  const char *zSchema = (const char*)sqlite3_value_text(apVal[1]);</Line>
  <Line number="1009">  const char *zName = (const char*)sqlite3_value_text(apVal[2]);</Line>
  <Line number="1010">  sqlite3 *db = sqlite3_context_db_handle(pCtx);</Line>
  <Line number="1011">  UNUSED_PARAMETER(nVal);</Line>
  <Line number="1012">  if( zIn!=0 &amp;&amp; strncmp(zIn, &quot;CREATE &quot;, <CheckRefs ids="372">7</CheckRefs>)==0 ){</Line>
  <Line number="1013">    for(i=0; i&lt;<CheckRefs ids="373">(</CheckRefs>int)(sizeof(aPrefix)<CheckRefs ids="374">/</CheckRefs>sizeof(aPrefix[0<CheckRefs ids="375">]</CheckRefs>)); i<CheckRefs ids="376">++</CheckRefs>){</Line>
  <Line number="1014">      int n = strlen30(aPrefix[i<CheckRefs ids="377">]</CheckRefs>);</Line>
  <Line number="1015">      if( strncmp(zIn+7, aPrefix[i<CheckRefs ids="378">]</CheckRefs>, <CheckRefs ids="379">n</CheckRefs>)==0 &amp;&amp; <CheckRefs ids="380">zIn</CheckRefs>[n<CheckRefs ids="381">+</CheckRefs>7]==&apos; &apos; ){</Line>
  <Line number="1016">        char *z = 0;</Line>
  <Line number="1017">        char *zFake = 0;</Line>
  <Line number="1018">        if( zSchema ){</Line>
  <Line number="1019">          char cQuote = quoteChar(zSchema);</Line>
  <Line number="1020">          if( <CheckRefs ids="382">cQuote</CheckRefs> &amp;&amp; sqlite3_stricmp(zSchema,&quot;temp&quot;)!=0 ){</Line>
  <Line number="1021">            z = sqlite3_mprintf(&quot;%.*s \&quot;%w\&quot;.%s&quot;, n<CheckRefs ids="383">+</CheckRefs>7, zIn, zSchema, zIn+n+8);</Line>
  <Line number="1022">          }else{</Line>
  <Line number="1023">            z = sqlite3_mprintf(&quot;%.*s %s.%s&quot;, n<CheckRefs ids="384">+</CheckRefs>7, zIn, zSchema, zIn+n+8);</Line>
  <Line number="1024">          }</Line>
  <Line number="1025">        }</Line>
  <Line number="1026">        if( zName</Line>
  <Line number="1027">         &amp;&amp; <CheckRefs ids="385">aPrefix</CheckRefs>[i<CheckRefs ids="386">]</CheckRefs>[0]==&apos;V&apos;</Line>
  <Line number="1028">         &amp;&amp; (zFake = shellFakeSchema(db, zSchema, zName))!=0</Line>
  <Line number="1029">        ){</Line>
  <Line number="1030">          if( z==0 ){</Line>
  <Line number="1031">            z = sqlite3_mprintf(&quot;%s\n/* %s */&quot;, zIn, zFake);</Line>
  <Line number="1032">          }else{</Line>
  <Line number="1033">            z = sqlite3_mprintf(&quot;%z\n/* %s */&quot;, z, zFake);</Line>
  <Line number="1034">          }</Line>
  <Line number="1035">          free(zFake);</Line>
  <Line number="1036">        }</Line>
  <Line number="1037">        if( z ){</Line>
  <Line number="1038">          sqlite3_result_text(pCtx, z, <CheckRefs ids="387">-</CheckRefs>1, sqlite3_free);</Line>
  <Line number="1039">          return;</Line>
  <Line number="1040">        }</Line>
  <Line number="1041">      }</Line>
  <Line number="1042">    }</Line>
  <Line number="1043">  }</Line>
  <Line number="1044">  sqlite3_result_value(pCtx, apVal[0]);</Line>
  <Line number="1045">}</Line>
  <Line number="1046"></Line>
  <Line number="1047">/*</Line>
  <Line number="1048">** The source code for several run-time loadable extensions is inserted</Line>
  <Line number="1049">** below by the ../tool/mkshellc.tcl script.  Before processing that included</Line>
  <Line number="1050">** code, we need to override some macros to make the included program code</Line>
  <Line number="1051">** work here in the middle of this regular program.</Line>
  <Line number="1052">*/</Line>
  <Line number="1053">#define SQLITE_EXTENSION_INIT1</Line>
  <Line number="1054">#define SQLITE_EXTENSION_INIT2(X) (void)(X)</Line>
  <Line number="1055"></Line>
  <Line number="1056">#if defined(_WIN32) &amp;&amp; defined(_MSC_VER)</Line>
  <Line number="1057">/************************* Begin test_windirent.h ******************/</Line>
  <Line number="1058">/*</Line>
  <Line number="1059">** 2015 November 30</Line>
  <Line number="1060">**</Line>
  <Line number="1061">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="1062">** a legal notice, here is a blessing:</Line>
  <Line number="1063">**</Line>
  <Line number="1064">**    May you do good and not evil.</Line>
  <Line number="1065">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="1066">**    May you share freely, never taking more than you give.</Line>
  <Line number="1067">**</Line>
  <Line number="1068">*************************************************************************</Line>
  <Line number="1069">** This file contains declarations for most of the opendir() family of</Line>
  <Line number="1070">** POSIX functions on Win32 using the MSVCRT.</Line>
  <Line number="1071">*/</Line>
  <Line number="1072"></Line>
  <Line number="1073">#if defined(_WIN32) &amp;&amp; defined(_MSC_VER) &amp;&amp; !defined(SQLITE_WINDIRENT_H)</Line>
  <Line number="1074">#define SQLITE_WINDIRENT_H</Line>
  <Line number="1075"></Line>
  <Line number="1076">/*</Line>
  <Line number="1077">** We need several data types from the Windows SDK header.</Line>
  <Line number="1078">*/</Line>
  <Line number="1079"></Line>
  <Line number="1080">#ifndef WIN32_LEAN_AND_MEAN</Line>
  <Line number="1081">#define WIN32_LEAN_AND_MEAN</Line>
  <Line number="1082">#endif</Line>
  <Line number="1083"></Line>
  <Line number="1084">#include &quot;windows.h&quot;</Line>
  <Line number="1085"></Line>
  <Line number="1086">/*</Line>
  <Line number="1087">** We need several support functions from the SQLite core.</Line>
  <Line number="1088">*/</Line>
  <Line number="1089"></Line>
  <Line number="1090">/* #include &quot;sqlite3.h&quot; */</Line>
  <Line number="1091"></Line>
  <Line number="1092">/*</Line>
  <Line number="1093">** We need several things from the ANSI and MSVCRT headers.</Line>
  <Line number="1094">*/</Line>
  <Line number="1095"></Line>
  <Line number="1096">#include &lt;stdio.h&gt;</Line>
  <Line number="1097">#include &lt;stdlib.h&gt;</Line>
  <Line number="1098">#include &lt;errno.h&gt;</Line>
  <Line number="1099">#include &lt;io.h&gt;</Line>
  <Line number="1100">#include &lt;limits.h&gt;</Line>
  <Line number="1101">#include &lt;sys/types.h&gt;</Line>
  <Line number="1102">#include &lt;sys/stat.h&gt;</Line>
  <Line number="1103"></Line>
  <Line number="1104">/*</Line>
  <Line number="1105">** We may need several defines that should have been in &quot;sys/stat.h&quot;.</Line>
  <Line number="1106">*/</Line>
  <Line number="1107"></Line>
  <Line number="1108">#ifndef S_ISREG</Line>
  <Line number="1109">#define S_ISREG(mode) (((mode) &amp; S_IFMT) == S_IFREG)</Line>
  <Line number="1110">#endif</Line>
  <Line number="1111"></Line>
  <Line number="1112">#ifndef S_ISDIR</Line>
  <Line number="1113">#define S_ISDIR(mode) (((mode) &amp; S_IFMT) == S_IFDIR)</Line>
  <Line number="1114">#endif</Line>
  <Line number="1115"></Line>
  <Line number="1116">#ifndef S_ISLNK</Line>
  <Line number="1117">#define S_ISLNK(mode) (0)</Line>
  <Line number="1118">#endif</Line>
  <Line number="1119"></Line>
  <Line number="1120">/*</Line>
  <Line number="1121">** We may need to provide the &quot;mode_t&quot; type.</Line>
  <Line number="1122">*/</Line>
  <Line number="1123"></Line>
  <Line number="1124">#ifndef MODE_T_DEFINED</Line>
  <Line number="1125">  #define MODE_T_DEFINED</Line>
  <Line number="1126">  typedef unsigned short mode_t;</Line>
  <Line number="1127">#endif</Line>
  <Line number="1128"></Line>
  <Line number="1129">/*</Line>
  <Line number="1130">** We may need to provide the &quot;ino_t&quot; type.</Line>
  <Line number="1131">*/</Line>
  <Line number="1132"></Line>
  <Line number="1133">#ifndef INO_T_DEFINED</Line>
  <Line number="1134">  #define INO_T_DEFINED</Line>
  <Line number="1135">  typedef unsigned short ino_t;</Line>
  <Line number="1136">#endif</Line>
  <Line number="1137"></Line>
  <Line number="1138">/*</Line>
  <Line number="1139">** We need to define &quot;NAME_MAX&quot; if it was not present in &quot;limits.h&quot;.</Line>
  <Line number="1140">*/</Line>
  <Line number="1141"></Line>
  <Line number="1142">#ifndef NAME_MAX</Line>
  <Line number="1143">#  ifdef FILENAME_MAX</Line>
  <Line number="1144">#    define NAME_MAX (FILENAME_MAX)</Line>
  <Line number="1145">#  else</Line>
  <Line number="1146">#    define NAME_MAX (260)</Line>
  <Line number="1147">#  endif</Line>
  <Line number="1148">#endif</Line>
  <Line number="1149"></Line>
  <Line number="1150">//mkb:</Line>
  <Line number="1151">#ifndef FILENAME_MAX</Line>
  <Line number="1152">#	define FILENAME_MAX 10</Line>
  <Line number="1153">#endif</Line>
  <Line number="1154"></Line>
  <Line number="1155">/*</Line>
  <Line number="1156">** We need to define &quot;NULL_INTPTR_T&quot; and &quot;BAD_INTPTR_T&quot;.</Line>
  <Line number="1157">*/</Line>
  <Line number="1158"></Line>
  <Line number="1159">#ifndef NULL_INTPTR_T</Line>
  <Line number="1160">#  define NULL_INTPTR_T ((intptr_t)(0))</Line>
  <Line number="1161">#endif</Line>
  <Line number="1162"></Line>
  <Line number="1163">#ifndef BAD_INTPTR_T</Line>
  <Line number="1164">#  define BAD_INTPTR_T ((intptr_t)(-1))</Line>
  <Line number="1165">#endif</Line>
  <Line number="1166"></Line>
  <Line number="1167">/*</Line>
  <Line number="1168">** We need to provide the necessary structures and related types.</Line>
  <Line number="1169">*/</Line>
  <Line number="1170"></Line>
  <Line number="1171">#ifndef DIRENT_DEFINED</Line>
  <Line number="1172">#define DIRENT_DEFINED</Line>
  <Line number="1173">typedef struct DIRENT DIRENT;</Line>
  <Line number="1174">typedef DIRENT *LPDIRENT;</Line>
  <Line number="1175">struct DIRENT {</Line>
  <Line number="1176">  ino_t d_ino;               /* Sequence number, do not use. */</Line>
  <Line number="1177">  unsigned d_attributes;     /* Win32 file attributes. */</Line>
  <Line number="1178">  char d_name[NAME_MAX + 1]; /* Name within the directory. */</Line>
  <Line number="1179">};</Line>
  <Line number="1180">#endif</Line>
  <Line number="1181"></Line>
  <Line number="1182">#ifndef DIR_DEFINED</Line>
  <Line number="1183">#define DIR_DEFINED</Line>
  <Line number="1184">typedef struct DIR DIR;</Line>
  <Line number="1185">typedef DIR *LPDIR;</Line>
  <Line number="1186">struct DIR {</Line>
  <Line number="1187">  intptr_t d_handle; /* Value returned by &quot;_findfirst&quot;. */</Line>
  <Line number="1188">  DIRENT d_first;    /* DIRENT constructed based on &quot;_findfirst&quot;. */</Line>
  <Line number="1189">  DIRENT d_next;     /* DIRENT constructed based on &quot;_findnext&quot;. */</Line>
  <Line number="1190">};</Line>
  <Line number="1191">#endif</Line>
  <Line number="1192"></Line>
  <Line number="1193">/*</Line>
  <Line number="1194">** Provide a macro, for use by the implementation, to determine if a</Line>
  <Line number="1195">** particular directory entry should be skipped over when searching for</Line>
  <Line number="1196">** the next directory entry that should be returned by the readdir() or</Line>
  <Line number="1197">** readdir_r() functions.</Line>
  <Line number="1198">*/</Line>
  <Line number="1199"></Line>
  <Line number="1200">#ifndef is_filtered</Line>
  <Line number="1201">#  define is_filtered(a) ((((a).attrib)&amp;_A_HIDDEN) || (((a).attrib)&amp;_A_SYSTEM))</Line>
  <Line number="1202">#endif</Line>
  <Line number="1203"></Line>
  <Line number="1204">/*</Line>
  <Line number="1205">** Provide the function prototype for the POSIX compatiable getenv()</Line>
  <Line number="1206">** function.  This function is not thread-safe.</Line>
  <Line number="1207">*/</Line>
  <Line number="1208"></Line>
  <Line number="1209">extern const char *windirent_getenv(const char *name);</Line>
  <Line number="1210"></Line>
  <Line number="1211">/*</Line>
  <Line number="1212">** Finally, we can provide the function prototypes for the opendir(),</Line>
  <Line number="1213">** readdir(), readdir_r(), and closedir() POSIX functions.</Line>
  <Line number="1214">*/</Line>
  <Line number="1215"></Line>
  <Line number="1216">extern LPDIR opendir(const char *dirname);</Line>
  <Line number="1217">extern LPDIRENT readdir(LPDIR dirp);</Line>
  <Line number="1218">extern INT readdir_r(LPDIR dirp, LPDIRENT entry, LPDIRENT *result);</Line>
  <Line number="1219">extern INT closedir(LPDIR dirp);</Line>
  <Line number="1220"></Line>
  <Line number="1221">#endif /* defined(WIN32) &amp;&amp; defined(_MSC_VER) */</Line>
  <Line number="1222"></Line>
  <Line number="1223">/************************* End test_windirent.h ********************/</Line>
  <Line number="1224">/************************* Begin test_windirent.c ******************/</Line>
  <Line number="1225">/*</Line>
  <Line number="1226">** 2015 November 30</Line>
  <Line number="1227">**</Line>
  <Line number="1228">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="1229">** a legal notice, here is a blessing:</Line>
  <Line number="1230">**</Line>
  <Line number="1231">**    May you do good and not evil.</Line>
  <Line number="1232">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="1233">**    May you share freely, never taking more than you give.</Line>
  <Line number="1234">**</Line>
  <Line number="1235">*************************************************************************</Line>
  <Line number="1236">** This file contains code to implement most of the opendir() family of</Line>
  <Line number="1237">** POSIX functions on Win32 using the MSVCRT.</Line>
  <Line number="1238">*/</Line>
  <Line number="1239"></Line>
  <Line number="1240">#if defined(_WIN32) &amp;&amp; defined(_MSC_VER)</Line>
  <Line number="1241">/* #include &quot;test_windirent.h&quot; */</Line>
  <Line number="1242"></Line>
  <Line number="1243">/*</Line>
  <Line number="1244">** Implementation of the POSIX getenv() function using the Win32 API.</Line>
  <Line number="1245">** This function is not thread-safe.</Line>
  <Line number="1246">*/</Line>
  <Line number="1247">const char *windirent_getenv(</Line>
  <Line number="1248">  const char *name</Line>
  <Line number="1249">){</Line>
  <Line number="1250">  static char value[32768]; /* Maximum length, per MSDN */</Line>
  <Line number="1251">  DWORD dwSize = sizeof(value) / sizeof(char); /* Size in chars */</Line>
  <Line number="1252">  DWORD dwRet; /* Value returned by GetEnvironmentVariableA() */</Line>
  <Line number="1253"></Line>
  <Line number="1254">  memset(value, 0, sizeof(value));</Line>
  <Line number="1255">  dwRet = GetEnvironmentVariableA(name, value, dwSize);</Line>
  <Line number="1256">  if( dwRet==0 || dwRet&gt;dwSize ){</Line>
  <Line number="1257">    /*</Line>
  <Line number="1258">    ** The function call to GetEnvironmentVariableA() failed -OR-</Line>
  <Line number="1259">    ** the buffer is not large enough.  Either way, return NULL.</Line>
  <Line number="1260">    */</Line>
  <Line number="1261">    return 0;</Line>
  <Line number="1262">  }else{</Line>
  <Line number="1263">    /*</Line>
  <Line number="1264">    ** The function call to GetEnvironmentVariableA() succeeded</Line>
  <Line number="1265">    ** -AND- the buffer contains the entire value.</Line>
  <Line number="1266">    */</Line>
  <Line number="1267">    return value;</Line>
  <Line number="1268">  }</Line>
  <Line number="1269">}</Line>
  <Line number="1270"></Line>
  <Line number="1271">/*</Line>
  <Line number="1272">** Implementation of the POSIX opendir() function using the MSVCRT.</Line>
  <Line number="1273">*/</Line>
  <Line number="1274">LPDIR opendir(</Line>
  <Line number="1275">  const char *dirname</Line>
  <Line number="1276">){</Line>
  <Line number="1277">  struct _finddata_t data;</Line>
  <Line number="1278">  LPDIR dirp = (LPDIR)sqlite3_malloc(sizeof(DIR));</Line>
  <Line number="1279">  SIZE_T namesize = sizeof(data.name) / sizeof(data.name[0]);</Line>
  <Line number="1280"></Line>
  <Line number="1281">  if( dirp==NULL ) return NULL;</Line>
  <Line number="1282">  memset(dirp, 0, sizeof(DIR));</Line>
  <Line number="1283"></Line>
  <Line number="1284">  /* TODO: Remove this if Unix-style root paths are not used. */</Line>
  <Line number="1285">  if( sqlite3_stricmp(dirname, &quot;/&quot;)==0 ){</Line>
  <Line number="1286">    dirname = windirent_getenv(&quot;SystemDrive&quot;);</Line>
  <Line number="1287">  }</Line>
  <Line number="1288"></Line>
  <Line number="1289">  memset(&amp;data, 0, sizeof(struct _finddata_t));</Line>
  <Line number="1290">  _snprintf(data.name, namesize, &quot;%s\\*&quot;, dirname);</Line>
  <Line number="1291">  dirp-&gt;d_handle = _findfirst(data.name, &amp;data);</Line>
  <Line number="1292"></Line>
  <Line number="1293">  if( dirp-&gt;d_handle==BAD_INTPTR_T ){</Line>
  <Line number="1294">    closedir(dirp);</Line>
  <Line number="1295">    return NULL;</Line>
  <Line number="1296">  }</Line>
  <Line number="1297"></Line>
  <Line number="1298">  /* TODO: Remove this block to allow hidden and/or system files. */</Line>
  <Line number="1299">  if( is_filtered(data) ){</Line>
  <Line number="1300">next:</Line>
  <Line number="1301"></Line>
  <Line number="1302">    memset(&amp;data, 0, sizeof(struct _finddata_t));</Line>
  <Line number="1303">    if( _findnext(dirp-&gt;d_handle, &amp;data)==-1 ){</Line>
  <Line number="1304">      closedir(dirp);</Line>
  <Line number="1305">      return NULL;</Line>
  <Line number="1306">    }</Line>
  <Line number="1307"></Line>
  <Line number="1308">    /* TODO: Remove this block to allow hidden and/or system files. */</Line>
  <Line number="1309">    if( is_filtered(data) ) goto next;</Line>
  <Line number="1310">  }</Line>
  <Line number="1311"></Line>
  <Line number="1312">  dirp-&gt;d_first.d_attributes = data.attrib;</Line>
  <Line number="1313">  strncpy(dirp-&gt;d_first.d_name, data.name, NAME_MAX);</Line>
  <Line number="1314">  dirp-&gt;d_first.d_name[NAME_MAX] = &apos;\0&apos;;</Line>
  <Line number="1315"></Line>
  <Line number="1316">  return dirp;</Line>
  <Line number="1317">}</Line>
  <Line number="1318"></Line>
  <Line number="1319">/*</Line>
  <Line number="1320">** Implementation of the POSIX readdir() function using the MSVCRT.</Line>
  <Line number="1321">*/</Line>
  <Line number="1322">LPDIRENT readdir(</Line>
  <Line number="1323">  LPDIR dirp</Line>
  <Line number="1324">){</Line>
  <Line number="1325">  struct _finddata_t data;</Line>
  <Line number="1326"></Line>
  <Line number="1327">  if( dirp==NULL ) return NULL;</Line>
  <Line number="1328"></Line>
  <Line number="1329">  if( dirp-&gt;d_first.d_ino==0 ){</Line>
  <Line number="1330">    dirp-&gt;d_first.d_ino++;</Line>
  <Line number="1331">    dirp-&gt;d_next.d_ino++;</Line>
  <Line number="1332"></Line>
  <Line number="1333">    return &amp;dirp-&gt;d_first;</Line>
  <Line number="1334">  }</Line>
  <Line number="1335"></Line>
  <Line number="1336">next:</Line>
  <Line number="1337"></Line>
  <Line number="1338">  memset(&amp;data, 0, sizeof(struct _finddata_t));</Line>
  <Line number="1339">  if( _findnext(dirp-&gt;d_handle, &amp;data)==-1 ) return NULL;</Line>
  <Line number="1340"></Line>
  <Line number="1341">  /* TODO: Remove this block to allow hidden and/or system files. */</Line>
  <Line number="1342">  if( is_filtered(data) ) goto next;</Line>
  <Line number="1343"></Line>
  <Line number="1344">  dirp-&gt;d_next.d_ino++;</Line>
  <Line number="1345">  dirp-&gt;d_next.d_attributes = data.attrib;</Line>
  <Line number="1346">  strncpy(dirp-&gt;d_next.d_name, data.name, NAME_MAX);</Line>
  <Line number="1347">  dirp-&gt;d_next.d_name[NAME_MAX] = &apos;\0&apos;;</Line>
  <Line number="1348"></Line>
  <Line number="1349">  return &amp;dirp-&gt;d_next;</Line>
  <Line number="1350">}</Line>
  <Line number="1351"></Line>
  <Line number="1352">/*</Line>
  <Line number="1353">** Implementation of the POSIX readdir_r() function using the MSVCRT.</Line>
  <Line number="1354">*/</Line>
  <Line number="1355">INT readdir_r(</Line>
  <Line number="1356">  LPDIR dirp,</Line>
  <Line number="1357">  LPDIRENT entry,</Line>
  <Line number="1358">  LPDIRENT *result</Line>
  <Line number="1359">){</Line>
  <Line number="1360">  struct _finddata_t data;</Line>
  <Line number="1361"></Line>
  <Line number="1362">  if( dirp==NULL ) return EBADF;</Line>
  <Line number="1363"></Line>
  <Line number="1364">  if( dirp-&gt;d_first.d_ino==0 ){</Line>
  <Line number="1365">    dirp-&gt;d_first.d_ino++;</Line>
  <Line number="1366">    dirp-&gt;d_next.d_ino++;</Line>
  <Line number="1367"></Line>
  <Line number="1368">    entry-&gt;d_ino = dirp-&gt;d_first.d_ino;</Line>
  <Line number="1369">    entry-&gt;d_attributes = dirp-&gt;d_first.d_attributes;</Line>
  <Line number="1370">    strncpy(entry-&gt;d_name, dirp-&gt;d_first.d_name, NAME_MAX);</Line>
  <Line number="1371">    entry-&gt;d_name[NAME_MAX] = &apos;\0&apos;;</Line>
  <Line number="1372"></Line>
  <Line number="1373">    *result = entry;</Line>
  <Line number="1374">    return 0;</Line>
  <Line number="1375">  }</Line>
  <Line number="1376"></Line>
  <Line number="1377">next:</Line>
  <Line number="1378"></Line>
  <Line number="1379">  memset(&amp;data, 0, sizeof(struct _finddata_t));</Line>
  <Line number="1380">  if( _findnext(dirp-&gt;d_handle, &amp;data)==-1 ){</Line>
  <Line number="1381">    *result = NULL;</Line>
  <Line number="1382">    return ENOENT;</Line>
  <Line number="1383">  }</Line>
  <Line number="1384"></Line>
  <Line number="1385">  /* TODO: Remove this block to allow hidden and/or system files. */</Line>
  <Line number="1386">  if( is_filtered(data) ) goto next;</Line>
  <Line number="1387"></Line>
  <Line number="1388">  entry-&gt;d_ino = (ino_t)-1; /* not available */</Line>
  <Line number="1389">  entry-&gt;d_attributes = data.attrib;</Line>
  <Line number="1390">  strncpy(entry-&gt;d_name, data.name, NAME_MAX);</Line>
  <Line number="1391">  entry-&gt;d_name[NAME_MAX] = &apos;\0&apos;;</Line>
  <Line number="1392"></Line>
  <Line number="1393">  *result = entry;</Line>
  <Line number="1394">  return 0;</Line>
  <Line number="1395">}</Line>
  <Line number="1396"></Line>
  <Line number="1397">/*</Line>
  <Line number="1398">** Implementation of the POSIX closedir() function using the MSVCRT.</Line>
  <Line number="1399">*/</Line>
  <Line number="1400">INT closedir(</Line>
  <Line number="1401">  LPDIR dirp</Line>
  <Line number="1402">){</Line>
  <Line number="1403">  INT result = 0;</Line>
  <Line number="1404"></Line>
  <Line number="1405">  if( dirp==NULL ) return EINVAL;</Line>
  <Line number="1406"></Line>
  <Line number="1407">  if( dirp-&gt;d_handle!=NULL_INTPTR_T &amp;&amp; dirp-&gt;d_handle!=BAD_INTPTR_T ){</Line>
  <Line number="1408">    result = _findclose(dirp-&gt;d_handle);</Line>
  <Line number="1409">  }</Line>
  <Line number="1410"></Line>
  <Line number="1411">  sqlite3_free(dirp);</Line>
  <Line number="1412">  return result;</Line>
  <Line number="1413">}</Line>
  <Line number="1414"></Line>
  <Line number="1415">#endif /* defined(WIN32) &amp;&amp; defined(_MSC_VER) */</Line>
  <Line number="1416"></Line>
  <Line number="1417">/************************* End test_windirent.c ********************/</Line>
  <Line number="1418">#define dirent DIRENT</Line>
  <Line number="1419">#endif</Line>
  <Line number="1420">/************************* Begin ../ext/misc/shathree.c ******************/</Line>
  <Line number="1421">/*</Line>
  <Line number="1422">** 2017-03-08</Line>
  <Line number="1423">**</Line>
  <Line number="1424">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="1425">** a legal notice, here is a blessing:</Line>
  <Line number="1426">**</Line>
  <Line number="1427">**    May you do good and not evil.</Line>
  <Line number="1428">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="1429">**    May you share freely, never taking more than you give.</Line>
  <Line number="1430">**</Line>
  <Line number="1431">******************************************************************************</Line>
  <Line number="1432">**</Line>
  <Line number="1433">** This SQLite extension implements functions that compute SHA3 hashes.</Line>
  <Line number="1434">** Two SQL functions are implemented:</Line>
  <Line number="1435">**</Line>
  <Line number="1436">**     sha3(X,SIZE)</Line>
  <Line number="1437">**     sha3_query(Y,SIZE)</Line>
  <Line number="1438">**</Line>
  <Line number="1439">** The sha3(X) function computes the SHA3 hash of the input X, or NULL if</Line>
  <Line number="1440">** X is NULL.</Line>
  <Line number="1441">**</Line>
  <Line number="1442">** The sha3_query(Y) function evalutes all queries in the SQL statements of Y</Line>
  <Line number="1443">** and returns a hash of their results.</Line>
  <Line number="1444">**</Line>
  <Line number="1445">** The SIZE argument is optional.  If omitted, the SHA3-256 hash algorithm</Line>
  <Line number="1446">** is used.  If SIZE is included it must be one of the integers 224, 256,</Line>
  <Line number="1447">** 384, or 512, to determine SHA3 hash variant that is computed.</Line>
  <Line number="1448">*/</Line>
  <Line number="1449">/* #include &quot;sqlite3ext.h&quot; */</Line>
  <Line number="1450">SQLITE_EXTENSION_INIT1</Line>
  <Line number="1451">#include &lt;assert.h&gt;</Line>
  <Line number="1452">#include &lt;string.h&gt;</Line>
  <Line number="1453">#include &lt;stdarg.h&gt;</Line>
  <Line number="1454"></Line>
  <Line number="1455">#ifndef SQLITE_AMALGAMATION</Line>
  <Line number="1456">/* typedef sqlite3_uint64 u64; */</Line>
  <Line number="1457">#endif /* SQLITE_AMALGAMATION */</Line>
  <Line number="1458"></Line>
  <Line number="1459">/******************************************************************************</Line>
  <Line number="1460">** The Hash Engine</Line>
  <Line number="1461">*/</Line>
  <Line number="1462">/*</Line>
  <Line number="1463">** Macros to determine whether the machine is big or little endian,</Line>
  <Line number="1464">** and whether or not that determination is run-time or compile-time.</Line>
  <Line number="1465">**</Line>
  <Line number="1466">** For best performance, an attempt is made to guess at the byte-order</Line>
  <Line number="1467">** using C-preprocessor macros.  If that is unsuccessful, or if</Line>
  <Line number="1468">** -DSHA3_BYTEORDER=0 is set, then byte-order is determined</Line>
  <Line number="1469">** at run-time.</Line>
  <Line number="1470">*/</Line>
  <Line number="1471">#ifndef SHA3_BYTEORDER</Line>
  <Line number="1472"># if defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \</Line>
  <Line number="1473">     defined(__x86_64) || defined(__x86_64__) || defined(_M_X64)  ||    \</Line>
  <Line number="1474">     defined(_M_AMD64) || defined(_M_ARM)     || defined(__x86)   ||    \</Line>
  <Line number="1475">     defined(__arm__)</Line>
  <Line number="1476">#   define SHA3_BYTEORDER    1234</Line>
  <Line number="1477"># elif defined(sparc)    || defined(__ppc__)</Line>
  <Line number="1478">#   define SHA3_BYTEORDER    4321</Line>
  <Line number="1479"># else</Line>
  <Line number="1480">#   define SHA3_BYTEORDER 0</Line>
  <Line number="1481"># endif</Line>
  <Line number="1482">#endif</Line>
  <Line number="1483"></Line>
  <Line number="1484"></Line>
  <Line number="1485">/*</Line>
  <Line number="1486">** State structure for a SHA3 hash in progress</Line>
  <Line number="1487">*/</Line>
  <Line number="1488">typedef struct SHA3Context SHA3Context;</Line>
  <Line number="1489">struct SHA3Context {</Line>
  <Line number="1490">  union {</Line>
  <Line number="1491">    u64 s[25];                /* Keccak state. 5x5 lines of 64 bits each */</Line>
  <Line number="1492">    unsigned char x[1600];    /* ... or 1600 bytes */</Line>
  <Line number="1493">  } u;</Line>
  <Line number="1494">  unsigned nRate;        /* Bytes of input accepted per Keccak iteration */</Line>
  <Line number="1495">  unsigned nLoaded;      /* Input bytes loaded into u.x[] so far this cycle */</Line>
  <Line number="1496">  unsigned ixMask;       /* Insert next input into u.x[nLoaded^ixMask]. */</Line>
  <Line number="1497">};</Line>
  <Line number="1498"></Line>
  <Line number="1499">/*</Line>
  <Line number="1500">** A single step of the Keccak mixing function for a 1600-bit state</Line>
  <Line number="1501">*/</Line>
  <Line number="1502">static void KeccakF1600Step(SHA3Context *p){</Line>
  <Line number="1503">  int i;</Line>
  <Line number="1504">  u64 b0, b1, b2, b3, b4;</Line>
  <Line number="1505">  u64 c0, c1, c2, c3, c4;</Line>
  <Line number="1506">  u64 d0, d1, d2, d3, d4;</Line>
  <Line number="1507">  static const u64 RC[] = {</Line>
  <Line number="1508">    0x0000000000000001ULL,  0x0000000000008082ULL,</Line>
  <Line number="1509">    0x800000000000808aULL,  0x8000000080008000ULL,</Line>
  <Line number="1510">    0x000000000000808bULL,  0x0000000080000001ULL,</Line>
  <Line number="1511">    0x8000000080008081ULL,  0x8000000000008009ULL,</Line>
  <Line number="1512">    0x000000000000008aULL,  0x0000000000000088ULL,</Line>
  <Line number="1513">    0x0000000080008009ULL,  0x000000008000000aULL,</Line>
  <Line number="1514">    0x000000008000808bULL,  0x800000000000008bULL,</Line>
  <Line number="1515">    0x8000000000008089ULL,  0x8000000000008003ULL,</Line>
  <Line number="1516">    0x8000000000008002ULL,  0x8000000000000080ULL,</Line>
  <Line number="1517">    0x000000000000800aULL,  0x800000008000000aULL,</Line>
  <Line number="1518">    0x8000000080008081ULL,  0x8000000000008080ULL,</Line>
  <Line number="1519">    0x0000000080000001ULL,  0x8000000080008008ULL</Line>
  <Line number="1520">  };</Line>
  <Line number="1521"># define a00 (p-&gt;u.s[0])</Line>
  <Line number="1522"># define a01 (p-&gt;u.s[1])</Line>
  <Line number="1523"># define a02 (p-&gt;u.s[2])</Line>
  <Line number="1524"># define a03 (p-&gt;u.s[3])</Line>
  <Line number="1525"># define a04 (p-&gt;u.s[4])</Line>
  <Line number="1526"># define a10 (p-&gt;u.s[5])</Line>
  <Line number="1527"># define a11 (p-&gt;u.s[6])</Line>
  <Line number="1528"># define a12 (p-&gt;u.s[7])</Line>
  <Line number="1529"># define a13 (p-&gt;u.s[8])</Line>
  <Line number="1530"># define a14 (p-&gt;u.s[9])</Line>
  <Line number="1531"># define a20 (p-&gt;u.s[10])</Line>
  <Line number="1532"># define a21 (p-&gt;u.s[11])</Line>
  <Line number="1533"># define a22 (p-&gt;u.s[12])</Line>
  <Line number="1534"># define a23 (p-&gt;u.s[13])</Line>
  <Line number="1535"># define a24 (p-&gt;u.s[14])</Line>
  <Line number="1536"># define a30 (p-&gt;u.s[15])</Line>
  <Line number="1537"># define a31 (p-&gt;u.s[16])</Line>
  <Line number="1538"># define a32 (p-&gt;u.s[17])</Line>
  <Line number="1539"># define a33 (p-&gt;u.s[18])</Line>
  <Line number="1540"># define a34 (p-&gt;u.s[19])</Line>
  <Line number="1541"># define a40 (p-&gt;u.s[20])</Line>
  <Line number="1542"># define a41 (p-&gt;u.s[21])</Line>
  <Line number="1543"># define a42 (p-&gt;u.s[22])</Line>
  <Line number="1544"># define a43 (p-&gt;u.s[23])</Line>
  <Line number="1545"># define a44 (p-&gt;u.s[24])</Line>
  <Line number="1546"># define ROL64(a,x) ((a&lt;&lt;x)|(a&gt;&gt;(64-x)))</Line>
  <Line number="1547"></Line>
  <Line number="1548">  for(i=0; i&lt;24; i<CheckRefs ids="388">+=</CheckRefs>4){</Line>
  <Line number="1549">    c0 = <CheckRefs ids="389">a00</CheckRefs>^<CheckRefs ids="390">a10</CheckRefs>^<CheckRefs ids="391">a20</CheckRefs>^<CheckRefs ids="392">a30</CheckRefs>^<CheckRefs ids="393">a40</CheckRefs>;</Line>
  <Line number="1550">    c1 = <CheckRefs ids="394">a01</CheckRefs>^<CheckRefs ids="395">a11</CheckRefs>^<CheckRefs ids="396">a21</CheckRefs>^<CheckRefs ids="397">a31</CheckRefs>^<CheckRefs ids="398">a41</CheckRefs>;</Line>
  <Line number="1551">    c2 = <CheckRefs ids="399">a02</CheckRefs>^<CheckRefs ids="400">a12</CheckRefs>^<CheckRefs ids="401">a22</CheckRefs>^<CheckRefs ids="402">a32</CheckRefs>^<CheckRefs ids="403">a42</CheckRefs>;</Line>
  <Line number="1552">    c3 = <CheckRefs ids="404">a03</CheckRefs>^<CheckRefs ids="405">a13</CheckRefs>^<CheckRefs ids="406">a23</CheckRefs>^<CheckRefs ids="407">a33</CheckRefs>^<CheckRefs ids="408">a43</CheckRefs>;</Line>
  <Line number="1553">    c4 = <CheckRefs ids="409">a04</CheckRefs>^<CheckRefs ids="410">a14</CheckRefs>^<CheckRefs ids="411">a24</CheckRefs>^<CheckRefs ids="412">a34</CheckRefs>^<CheckRefs ids="413">a44</CheckRefs>;</Line>
  <Line number="1554">    d0 = c4^<CheckRefs ids="415,416,414">ROL64</CheckRefs>(c1, 1);</Line>
  <Line number="1555">    d1 = c0^<CheckRefs ids="417,418,419">ROL64</CheckRefs>(c2, 1);</Line>
  <Line number="1556">    d2 = c1^<CheckRefs ids="420,421,422">ROL64</CheckRefs>(c3, 1);</Line>
  <Line number="1557">    d3 = c2^<CheckRefs ids="423,425,424">ROL64</CheckRefs>(c4, 1);</Line>
  <Line number="1558">    d4 = c3^<CheckRefs ids="426,427,428">ROL64</CheckRefs>(c0, 1);</Line>
  <Line number="1559"></Line>
  <Line number="1560">    b0 = (<CheckRefs ids="429">a00</CheckRefs>^d0);</Line>
  <Line number="1561">    b1 = <CheckRefs ids="430,431,432,433">ROL64</CheckRefs>((a11^d1), 44);</Line>
  <Line number="1562">    b2 = <CheckRefs ids="434,435,436,437">ROL64</CheckRefs>((a22^d2), 43);</Line>
  <Line number="1563">    b3 = <CheckRefs ids="438,441,439,440">ROL64</CheckRefs>((a33^d3), 21);</Line>
  <Line number="1564">    b4 = <CheckRefs ids="442,443,444,445">ROL64</CheckRefs>((a44^d4), 14);</Line>
  <Line number="1565">    <CheckRefs ids="446">a00</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1566">    <CheckRefs ids="447">a00</CheckRefs> ^= RC[i<CheckRefs ids="448">]</CheckRefs>;</Line>
  <Line number="1567">    <CheckRefs ids="449">a11</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1568">    <CheckRefs ids="450">a22</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1569">    <CheckRefs ids="451">a33</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1570">    <CheckRefs ids="452">a44</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1571"></Line>
  <Line number="1572">    b2 = <CheckRefs ids="455,456,454,453">ROL64</CheckRefs>((a20^d0), 3);</Line>
  <Line number="1573">    b3 = <CheckRefs ids="457,458,459,460">ROL64</CheckRefs>((a31^d1), 45);</Line>
  <Line number="1574">    b4 = <CheckRefs ids="461,462,463,464">ROL64</CheckRefs>((a42^d2), 61);</Line>
  <Line number="1575">    b0 = <CheckRefs ids="465,466,467,468">ROL64</CheckRefs>((a03^d3), 28);</Line>
  <Line number="1576">    b1 = <CheckRefs ids="472,471,469,470">ROL64</CheckRefs>((a14^d4), 20);</Line>
  <Line number="1577">    <CheckRefs ids="473">a20</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1578">    <CheckRefs ids="474">a31</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1579">    <CheckRefs ids="475">a42</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1580">    <CheckRefs ids="476">a03</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1581">    <CheckRefs ids="477">a14</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1582"></Line>
  <Line number="1583">    b4 = <CheckRefs ids="478,479,480,481">ROL64</CheckRefs>((a40^d0), 18);</Line>
  <Line number="1584">    b0 = <CheckRefs ids="483,485,484,482">ROL64</CheckRefs>((a01^d1), 1);</Line>
  <Line number="1585">    b1 = <CheckRefs ids="486,487,488,489">ROL64</CheckRefs>((a12^d2), 6);</Line>
  <Line number="1586">    b2 = <CheckRefs ids="490,493,492,491">ROL64</CheckRefs>((a23^d3), 25);</Line>
  <Line number="1587">    b3 = <CheckRefs ids="494,495,496,497">ROL64</CheckRefs>((a34^d4), 8);</Line>
  <Line number="1588">    <CheckRefs ids="498">a40</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1589">    <CheckRefs ids="499">a01</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1590">    <CheckRefs ids="500">a12</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1591">    <CheckRefs ids="501">a23</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1592">    <CheckRefs ids="502">a34</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1593"></Line>
  <Line number="1594">    b1 = <CheckRefs ids="506,505,503,504">ROL64</CheckRefs>((a10^d0), 36);</Line>
  <Line number="1595">    b2 = <CheckRefs ids="507,508,509,510">ROL64</CheckRefs>((a21^d1), 10);</Line>
  <Line number="1596">    b3 = <CheckRefs ids="511,512,513,514">ROL64</CheckRefs>((a32^d2), 15);</Line>
  <Line number="1597">    b4 = <CheckRefs ids="515,516,517,518">ROL64</CheckRefs>((a43^d3), 56);</Line>
  <Line number="1598">    b0 = <CheckRefs ids="521,522,519,520">ROL64</CheckRefs>((a04^d4), 27);</Line>
  <Line number="1599">    <CheckRefs ids="523">a10</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1600">    <CheckRefs ids="524">a21</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1601">    <CheckRefs ids="525">a32</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1602">    <CheckRefs ids="526">a43</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1603">    <CheckRefs ids="527">a04</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1604"></Line>
  <Line number="1605">    b3 = <CheckRefs ids="529,531,530,528">ROL64</CheckRefs>((a30^d0), 41);</Line>
  <Line number="1606">    b4 = <CheckRefs ids="532,533,534,535">ROL64</CheckRefs>((a41^d1), 2);</Line>
  <Line number="1607">    b0 = <CheckRefs ids="539,538,536,537">ROL64</CheckRefs>((a02^d2), 62);</Line>
  <Line number="1608">    b1 = <CheckRefs ids="541,540,543,542">ROL64</CheckRefs>((a13^d3), 55);</Line>
  <Line number="1609">    b2 = <CheckRefs ids="544,545,546,547">ROL64</CheckRefs>((a24^d4), 39);</Line>
  <Line number="1610">    <CheckRefs ids="548">a30</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1611">    <CheckRefs ids="549">a41</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1612">    <CheckRefs ids="550">a02</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1613">    <CheckRefs ids="551">a13</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1614">    <CheckRefs ids="552">a24</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1615"></Line>
  <Line number="1616">    c0 = <CheckRefs ids="553">a00</CheckRefs>^<CheckRefs ids="554">a20</CheckRefs>^<CheckRefs ids="555">a40</CheckRefs>^<CheckRefs ids="556">a10</CheckRefs>^<CheckRefs ids="557">a30</CheckRefs>;</Line>
  <Line number="1617">    c1 = <CheckRefs ids="558">a11</CheckRefs>^<CheckRefs ids="559">a31</CheckRefs>^<CheckRefs ids="560">a01</CheckRefs>^<CheckRefs ids="561">a21</CheckRefs>^<CheckRefs ids="562">a41</CheckRefs>;</Line>
  <Line number="1618">    c2 = <CheckRefs ids="563">a22</CheckRefs>^<CheckRefs ids="564">a42</CheckRefs>^<CheckRefs ids="565">a12</CheckRefs>^<CheckRefs ids="566">a32</CheckRefs>^<CheckRefs ids="567">a02</CheckRefs>;</Line>
  <Line number="1619">    c3 = <CheckRefs ids="568">a33</CheckRefs>^<CheckRefs ids="569">a03</CheckRefs>^<CheckRefs ids="570">a23</CheckRefs>^<CheckRefs ids="571">a43</CheckRefs>^<CheckRefs ids="572">a13</CheckRefs>;</Line>
  <Line number="1620">    c4 = <CheckRefs ids="573">a44</CheckRefs>^<CheckRefs ids="574">a14</CheckRefs>^<CheckRefs ids="575">a34</CheckRefs>^<CheckRefs ids="576">a04</CheckRefs>^<CheckRefs ids="577">a24</CheckRefs>;</Line>
  <Line number="1621">    d0 = c4^<CheckRefs ids="578,579,580">ROL64</CheckRefs>(c1, 1);</Line>
  <Line number="1622">    d1 = c0^<CheckRefs ids="581,582,583">ROL64</CheckRefs>(c2, 1);</Line>
  <Line number="1623">    d2 = c1^<CheckRefs ids="584,585,586">ROL64</CheckRefs>(c3, 1);</Line>
  <Line number="1624">    d3 = c2^<CheckRefs ids="589,588,587">ROL64</CheckRefs>(c4, 1);</Line>
  <Line number="1625">    d4 = c3^<CheckRefs ids="590,591,592">ROL64</CheckRefs>(c0, 1);</Line>
  <Line number="1626"></Line>
  <Line number="1627">    b0 = (<CheckRefs ids="593">a00</CheckRefs>^d0);</Line>
  <Line number="1628">    b1 = <CheckRefs ids="594,595,596,597">ROL64</CheckRefs>((a31^d1), 44);</Line>
  <Line number="1629">    b2 = <CheckRefs ids="598,599,600,601">ROL64</CheckRefs>((a12^d2), 43);</Line>
  <Line number="1630">    b3 = <CheckRefs ids="605,604,602,603">ROL64</CheckRefs>((a43^d3), 21);</Line>
  <Line number="1631">    b4 = <CheckRefs ids="607,606,609,608">ROL64</CheckRefs>((a24^d4), 14);</Line>
  <Line number="1632">    <CheckRefs ids="610">a00</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1633">    <CheckRefs ids="611">a00</CheckRefs> ^= RC[i<CheckRefs ids="613">+</CheckRefs>1<CheckRefs ids="612">]</CheckRefs>;</Line>
  <Line number="1634">    <CheckRefs ids="614">a31</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1635">    <CheckRefs ids="615">a12</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1636">    <CheckRefs ids="616">a43</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1637">    <CheckRefs ids="617">a24</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1638"></Line>
  <Line number="1639">    b2 = <CheckRefs ids="618,619,620,621">ROL64</CheckRefs>((a40^d0), 3);</Line>
  <Line number="1640">    b3 = <CheckRefs ids="624,625,623,622">ROL64</CheckRefs>((a21^d1), 45);</Line>
  <Line number="1641">    b4 = <CheckRefs ids="626,627,628,629">ROL64</CheckRefs>((a02^d2), 61);</Line>
  <Line number="1642">    b0 = <CheckRefs ids="630,631,632,633">ROL64</CheckRefs>((a33^d3), 28);</Line>
  <Line number="1643">    b1 = <CheckRefs ids="634,635,636,637">ROL64</CheckRefs>((a14^d4), 20);</Line>
  <Line number="1644">    <CheckRefs ids="638">a40</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1645">    <CheckRefs ids="639">a21</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1646">    <CheckRefs ids="640">a02</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1647">    <CheckRefs ids="641">a33</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1648">    <CheckRefs ids="642">a14</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1649"></Line>
  <Line number="1650">    b4 = <CheckRefs ids="643,644,645,646">ROL64</CheckRefs>((a30^d0), 18);</Line>
  <Line number="1651">    b0 = <CheckRefs ids="647,648,649,650">ROL64</CheckRefs>((a11^d1), 1);</Line>
  <Line number="1652">    b1 = <CheckRefs ids="654,653,651,652">ROL64</CheckRefs>((a42^d2), 6);</Line>
  <Line number="1653">    b2 = <CheckRefs ids="655,656,657,658">ROL64</CheckRefs>((a23^d3), 25);</Line>
  <Line number="1654">    b3 = <CheckRefs ids="661,662,660,659">ROL64</CheckRefs>((a04^d4), 8);</Line>
  <Line number="1655">    <CheckRefs ids="663">a30</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1656">    <CheckRefs ids="664">a11</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1657">    <CheckRefs ids="665">a42</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1658">    <CheckRefs ids="666">a23</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1659">    <CheckRefs ids="667">a04</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1660"></Line>
  <Line number="1661">    b1 = <CheckRefs ids="671,670,668,669">ROL64</CheckRefs>((a20^d0), 36);</Line>
  <Line number="1662">    b2 = <CheckRefs ids="673,674,675,672">ROL64</CheckRefs>((a01^d1), 10);</Line>
  <Line number="1663">    b3 = <CheckRefs ids="676,677,678,679">ROL64</CheckRefs>((a32^d2), 15);</Line>
  <Line number="1664">    b4 = <CheckRefs ids="680,681,682,683">ROL64</CheckRefs>((a13^d3), 56);</Line>
  <Line number="1665">    b0 = <CheckRefs ids="687,686,684,685">ROL64</CheckRefs>((a44^d4), 27);</Line>
  <Line number="1666">    <CheckRefs ids="688">a20</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1667">    <CheckRefs ids="689">a01</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1668">    <CheckRefs ids="690">a32</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1669">    <CheckRefs ids="691">a13</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1670">    <CheckRefs ids="692">a44</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1671"></Line>
  <Line number="1672">    b3 = <CheckRefs ids="694,696,695,693">ROL64</CheckRefs>((a10^d0), 41);</Line>
  <Line number="1673">    b4 = <CheckRefs ids="697,698,699,700">ROL64</CheckRefs>((a41^d1), 2);</Line>
  <Line number="1674">    b0 = <CheckRefs ids="704,703,701,702">ROL64</CheckRefs>((a22^d2), 62);</Line>
  <Line number="1675">    b1 = <CheckRefs ids="705,706,707,708">ROL64</CheckRefs>((a03^d3), 55);</Line>
  <Line number="1676">    b2 = <CheckRefs ids="709,710,711,712">ROL64</CheckRefs>((a34^d4), 39);</Line>
  <Line number="1677">    <CheckRefs ids="713">a10</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1678">    <CheckRefs ids="714">a41</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1679">    <CheckRefs ids="715">a22</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1680">    <CheckRefs ids="716">a03</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1681">    <CheckRefs ids="717">a34</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1682"></Line>
  <Line number="1683">    c0 = <CheckRefs ids="718">a00</CheckRefs>^<CheckRefs ids="719">a40</CheckRefs>^<CheckRefs ids="720">a30</CheckRefs>^<CheckRefs ids="721">a20</CheckRefs>^<CheckRefs ids="722">a10</CheckRefs>;</Line>
  <Line number="1684">    c1 = <CheckRefs ids="723">a31</CheckRefs>^<CheckRefs ids="724">a21</CheckRefs>^<CheckRefs ids="725">a11</CheckRefs>^<CheckRefs ids="726">a01</CheckRefs>^<CheckRefs ids="727">a41</CheckRefs>;</Line>
  <Line number="1685">    c2 = <CheckRefs ids="728">a12</CheckRefs>^<CheckRefs ids="729">a02</CheckRefs>^<CheckRefs ids="730">a42</CheckRefs>^<CheckRefs ids="731">a32</CheckRefs>^<CheckRefs ids="732">a22</CheckRefs>;</Line>
  <Line number="1686">    c3 = <CheckRefs ids="733">a43</CheckRefs>^<CheckRefs ids="734">a33</CheckRefs>^<CheckRefs ids="735">a23</CheckRefs>^<CheckRefs ids="736">a13</CheckRefs>^<CheckRefs ids="737">a03</CheckRefs>;</Line>
  <Line number="1687">    c4 = <CheckRefs ids="738">a24</CheckRefs>^<CheckRefs ids="739">a14</CheckRefs>^<CheckRefs ids="740">a04</CheckRefs>^<CheckRefs ids="741">a44</CheckRefs>^<CheckRefs ids="742">a34</CheckRefs>;</Line>
  <Line number="1688">    d0 = c4^<CheckRefs ids="744,743,745">ROL64</CheckRefs>(c1, 1);</Line>
  <Line number="1689">    d1 = c0^<CheckRefs ids="746,747,748">ROL64</CheckRefs>(c2, 1);</Line>
  <Line number="1690">    d2 = c1^<CheckRefs ids="749,750,751">ROL64</CheckRefs>(c3, 1);</Line>
  <Line number="1691">    d3 = c2^<CheckRefs ids="752,753,754">ROL64</CheckRefs>(c4, 1);</Line>
  <Line number="1692">    d4 = c3^<CheckRefs ids="755,756,757">ROL64</CheckRefs>(c0, 1);</Line>
  <Line number="1693"></Line>
  <Line number="1694">    b0 = (<CheckRefs ids="758">a00</CheckRefs>^d0);</Line>
  <Line number="1695">    b1 = <CheckRefs ids="760,762,761,759">ROL64</CheckRefs>((a21^d1), 44);</Line>
  <Line number="1696">    b2 = <CheckRefs ids="763,764,765,766">ROL64</CheckRefs>((a42^d2), 43);</Line>
  <Line number="1697">    b3 = <CheckRefs ids="767,768,769,770">ROL64</CheckRefs>((a13^d3), 21);</Line>
  <Line number="1698">    b4 = <CheckRefs ids="771,772,773,774">ROL64</CheckRefs>((a34^d4), 14);</Line>
  <Line number="1699">    <CheckRefs ids="775">a00</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1700">    <CheckRefs ids="776">a00</CheckRefs> ^= RC[i<CheckRefs ids="778">+</CheckRefs>2<CheckRefs ids="777">]</CheckRefs>;</Line>
  <Line number="1701">    <CheckRefs ids="779">a21</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1702">    <CheckRefs ids="780">a42</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1703">    <CheckRefs ids="781">a13</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1704">    <CheckRefs ids="782">a34</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1705"></Line>
  <Line number="1706">    b2 = <CheckRefs ids="784,786,785,783">ROL64</CheckRefs>((a30^d0), 3);</Line>
  <Line number="1707">    b3 = <CheckRefs ids="787,788,789,790">ROL64</CheckRefs>((a01^d1), 45);</Line>
  <Line number="1708">    b4 = <CheckRefs ids="791,794,793,792">ROL64</CheckRefs>((a22^d2), 61);</Line>
  <Line number="1709">    b0 = <CheckRefs ids="795,796,797,798">ROL64</CheckRefs>((a43^d3), 28);</Line>
  <Line number="1710">    b1 = <CheckRefs ids="799,800,801,802">ROL64</CheckRefs>((a14^d4), 20);</Line>
  <Line number="1711">    <CheckRefs ids="803">a30</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1712">    <CheckRefs ids="804">a01</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1713">    <CheckRefs ids="805">a22</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1714">    <CheckRefs ids="806">a43</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1715">    <CheckRefs ids="807">a14</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1716"></Line>
  <Line number="1717">    b4 = <CheckRefs ids="808,811,809,810">ROL64</CheckRefs>((a10^d0), 18);</Line>
  <Line number="1718">    b0 = <CheckRefs ids="812,813,814,815">ROL64</CheckRefs>((a31^d1), 1);</Line>
  <Line number="1719">    b1 = <CheckRefs ids="816,817,818,819">ROL64</CheckRefs>((a02^d2), 6);</Line>
  <Line number="1720">    b2 = <CheckRefs ids="820,821,822,823">ROL64</CheckRefs>((a23^d3), 25);</Line>
  <Line number="1721">    b3 = <CheckRefs ids="824,827,826,825">ROL64</CheckRefs>((a44^d4), 8);</Line>
  <Line number="1722">    <CheckRefs ids="828">a10</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1723">    <CheckRefs ids="829">a31</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1724">    <CheckRefs ids="830">a02</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1725">    <CheckRefs ids="831">a23</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1726">    <CheckRefs ids="832">a44</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1727"></Line>
  <Line number="1728">    b1 = <CheckRefs ids="833,834,835,836">ROL64</CheckRefs>((a40^d0), 36);</Line>
  <Line number="1729">    b2 = <CheckRefs ids="840,839,837,838">ROL64</CheckRefs>((a11^d1), 10);</Line>
  <Line number="1730">    b3 = <CheckRefs ids="841,842,843,844">ROL64</CheckRefs>((a32^d2), 15);</Line>
  <Line number="1731">    b4 = <CheckRefs ids="845,846,847,848">ROL64</CheckRefs>((a03^d3), 56);</Line>
  <Line number="1732">    b0 = <CheckRefs ids="849,850,851,852">ROL64</CheckRefs>((a24^d4), 27);</Line>
  <Line number="1733">    <CheckRefs ids="853">a40</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1734">    <CheckRefs ids="854">a11</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1735">    <CheckRefs ids="855">a32</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1736">    <CheckRefs ids="856">a03</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1737">    <CheckRefs ids="857">a24</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1738"></Line>
  <Line number="1739">    b3 = <CheckRefs ids="858,859,860,861">ROL64</CheckRefs>((a20^d0), 41);</Line>
  <Line number="1740">    b4 = <CheckRefs ids="862,863,864,865">ROL64</CheckRefs>((a41^d1), 2);</Line>
  <Line number="1741">    b0 = <CheckRefs ids="866,867,868,869">ROL64</CheckRefs>((a12^d2), 62);</Line>
  <Line number="1742">    b1 = <CheckRefs ids="873,871,870,872">ROL64</CheckRefs>((a33^d3), 55);</Line>
  <Line number="1743">    b2 = <CheckRefs ids="875,874,877,876">ROL64</CheckRefs>((a04^d4), 39);</Line>
  <Line number="1744">    <CheckRefs ids="878">a20</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1745">    <CheckRefs ids="879">a41</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1746">    <CheckRefs ids="880">a12</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1747">    <CheckRefs ids="881">a33</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1748">    <CheckRefs ids="882">a04</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1749"></Line>
  <Line number="1750">    c0 = <CheckRefs ids="883">a00</CheckRefs>^<CheckRefs ids="884">a30</CheckRefs>^<CheckRefs ids="885">a10</CheckRefs>^<CheckRefs ids="886">a40</CheckRefs>^<CheckRefs ids="887">a20</CheckRefs>;</Line>
  <Line number="1751">    c1 = <CheckRefs ids="888">a21</CheckRefs>^<CheckRefs ids="889">a01</CheckRefs>^<CheckRefs ids="890">a31</CheckRefs>^<CheckRefs ids="891">a11</CheckRefs>^<CheckRefs ids="892">a41</CheckRefs>;</Line>
  <Line number="1752">    c2 = <CheckRefs ids="893">a42</CheckRefs>^<CheckRefs ids="894">a22</CheckRefs>^<CheckRefs ids="895">a02</CheckRefs>^<CheckRefs ids="896">a32</CheckRefs>^<CheckRefs ids="897">a12</CheckRefs>;</Line>
  <Line number="1753">    c3 = <CheckRefs ids="898">a13</CheckRefs>^<CheckRefs ids="899">a43</CheckRefs>^<CheckRefs ids="900">a23</CheckRefs>^<CheckRefs ids="901">a03</CheckRefs>^<CheckRefs ids="902">a33</CheckRefs>;</Line>
  <Line number="1754">    c4 = <CheckRefs ids="903">a34</CheckRefs>^<CheckRefs ids="904">a14</CheckRefs>^<CheckRefs ids="905">a44</CheckRefs>^<CheckRefs ids="906">a24</CheckRefs>^<CheckRefs ids="907">a04</CheckRefs>;</Line>
  <Line number="1755">    d0 = c4^<CheckRefs ids="908,909,910">ROL64</CheckRefs>(c1, 1);</Line>
  <Line number="1756">    d1 = c0^<CheckRefs ids="911,912,913">ROL64</CheckRefs>(c2, 1);</Line>
  <Line number="1757">    d2 = c1^<CheckRefs ids="914,915,916">ROL64</CheckRefs>(c3, 1);</Line>
  <Line number="1758">    d3 = c2^<CheckRefs ids="917,918,919">ROL64</CheckRefs>(c4, 1);</Line>
  <Line number="1759">    d4 = c3^<CheckRefs ids="922,920,921">ROL64</CheckRefs>(c0, 1);</Line>
  <Line number="1760"></Line>
  <Line number="1761">    b0 = (<CheckRefs ids="923">a00</CheckRefs>^d0);</Line>
  <Line number="1762">    b1 = <CheckRefs ids="924,925,926,927">ROL64</CheckRefs>((a01^d1), 44);</Line>
  <Line number="1763">    b2 = <CheckRefs ids="929,931,930,928">ROL64</CheckRefs>((a02^d2), 43);</Line>
  <Line number="1764">    b3 = <CheckRefs ids="932,933,934,935">ROL64</CheckRefs>((a03^d3), 21);</Line>
  <Line number="1765">    b4 = <CheckRefs ids="939,938,936,937">ROL64</CheckRefs>((a04^d4), 14);</Line>
  <Line number="1766">    <CheckRefs ids="940">a00</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1767">    <CheckRefs ids="941">a00</CheckRefs> ^= RC[i<CheckRefs ids="943">+</CheckRefs>3<CheckRefs ids="942">]</CheckRefs>;</Line>
  <Line number="1768">    <CheckRefs ids="944">a01</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1769">    <CheckRefs ids="945">a02</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1770">    <CheckRefs ids="946">a03</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1771">    <CheckRefs ids="947">a04</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1772"></Line>
  <Line number="1773">    b2 = <CheckRefs ids="949,951,950,948">ROL64</CheckRefs>((a10^d0), 3);</Line>
  <Line number="1774">    b3 = <CheckRefs ids="952,953,954,955">ROL64</CheckRefs>((a11^d1), 45);</Line>
  <Line number="1775">    b4 = <CheckRefs ids="956,959,958,957">ROL64</CheckRefs>((a12^d2), 61);</Line>
  <Line number="1776">    b0 = <CheckRefs ids="960,961,962,963">ROL64</CheckRefs>((a13^d3), 28);</Line>
  <Line number="1777">    b1 = <CheckRefs ids="964,965,966,967">ROL64</CheckRefs>((a14^d4), 20);</Line>
  <Line number="1778">    <CheckRefs ids="968">a10</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1779">    <CheckRefs ids="969">a11</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1780">    <CheckRefs ids="970">a12</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1781">    <CheckRefs ids="971">a13</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1782">    <CheckRefs ids="972">a14</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1783"></Line>
  <Line number="1784">    b4 = <CheckRefs ids="973,974,975,976">ROL64</CheckRefs>((a20^d0), 18);</Line>
  <Line number="1785">    b0 = <CheckRefs ids="977,978,979,980">ROL64</CheckRefs>((a21^d1), 1);</Line>
  <Line number="1786">    b1 = <CheckRefs ids="981,982,983,984">ROL64</CheckRefs>((a22^d2), 6);</Line>
  <Line number="1787">    b2 = <CheckRefs ids="988,987,985,986">ROL64</CheckRefs>((a23^d3), 25);</Line>
  <Line number="1788">    b3 = <CheckRefs ids="989,990,991,992">ROL64</CheckRefs>((a24^d4), 8);</Line>
  <Line number="1789">    <CheckRefs ids="993">a20</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1790">    <CheckRefs ids="994">a21</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1791">    <CheckRefs ids="995">a22</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1792">    <CheckRefs ids="996">a23</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1793">    <CheckRefs ids="997">a24</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1794"></Line>
  <Line number="1795">    b1 = <CheckRefs ids="998,999,1000,1001">ROL64</CheckRefs>((a30^d0), 36);</Line>
  <Line number="1796">    b2 = <CheckRefs ids="1005,1003,1002,1004">ROL64</CheckRefs>((a31^d1), 10);</Line>
  <Line number="1797">    b3 = <CheckRefs ids="1007,1006,1009,1008">ROL64</CheckRefs>((a32^d2), 15);</Line>
  <Line number="1798">    b4 = <CheckRefs ids="1010,1013,1011,1012">ROL64</CheckRefs>((a33^d3), 56);</Line>
  <Line number="1799">    b0 = <CheckRefs ids="1014,1015,1016,1017">ROL64</CheckRefs>((a34^d4), 27);</Line>
  <Line number="1800">    <CheckRefs ids="1018">a30</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1801">    <CheckRefs ids="1019">a31</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1802">    <CheckRefs ids="1020">a32</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1803">    <CheckRefs ids="1021">a33</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1804">    <CheckRefs ids="1022">a34</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1805"></Line>
  <Line number="1806">    b3 = <CheckRefs ids="1026,1025,1024,1023">ROL64</CheckRefs>((a40^d0), 41);</Line>
  <Line number="1807">    b4 = <CheckRefs ids="1027,1028,1029,1030">ROL64</CheckRefs>((a41^d1), 2);</Line>
  <Line number="1808">    b0 = <CheckRefs ids="1031,1032,1033,1034">ROL64</CheckRefs>((a42^d2), 62);</Line>
  <Line number="1809">    b1 = <CheckRefs ids="1035,1036,1037,1038">ROL64</CheckRefs>((a43^d3), 55);</Line>
  <Line number="1810">    b2 = <CheckRefs ids="1042,1040,1039,1041">ROL64</CheckRefs>((a44^d4), 39);</Line>
  <Line number="1811">    <CheckRefs ids="1043">a40</CheckRefs> =   b0 ^((~b1)&amp;  b2 );</Line>
  <Line number="1812">    <CheckRefs ids="1044">a41</CheckRefs> =   b1 ^((~b2)&amp;  b3 );</Line>
  <Line number="1813">    <CheckRefs ids="1045">a42</CheckRefs> =   b2 ^((~b3)&amp;  b4 );</Line>
  <Line number="1814">    <CheckRefs ids="1046">a43</CheckRefs> =   b3 ^((~b4)&amp;  b0 );</Line>
  <Line number="1815">    <CheckRefs ids="1047">a44</CheckRefs> =   b4 ^((~b0)&amp;  b1 );</Line>
  <Line number="1816">  }</Line>
  <Line number="1817">}</Line>
  <Line number="1818"></Line>
  <Line number="1819">/*</Line>
  <Line number="1820">** Initialize a new hash.  iSize determines the size of the hash</Line>
  <Line number="1821">** in bits and should be one of 224, 256, 384, or 512.  Or iSize</Line>
  <Line number="1822">** can be zero to use the default hash size of 256 bits.</Line>
  <Line number="1823">*/</Line>
  <Line number="1824">static void SHA3Init(SHA3Context *p, int iSize){</Line>
  <Line number="1825">  memset(p, 0, sizeof(*p));</Line>
  <Line number="1826">  if( iSize&gt;=128 &amp;&amp; iSize&lt;=512 ){</Line>
  <Line number="1827">    p-&gt;nRate = (1600 <CheckRefs ids="1051">-</CheckRefs> ((iSize <CheckRefs ids="1053">+</CheckRefs> 31)&amp;~31)<CheckRefs ids="1052">*</CheckRefs>2)<CheckRefs ids="1049,1050,1048">/</CheckRefs>8;</Line>
  <Line number="1828">  }else{</Line>
  <Line number="1829">    p-&gt;nRate = (1600 <CheckRefs ids="1057">-</CheckRefs> 2<CheckRefs ids="1058">*</CheckRefs>256)<CheckRefs ids="1056,1055,1054">/</CheckRefs>8;</Line>
  <Line number="1830">  }</Line>
  <Line number="1831">#if SHA3_BYTEORDER==1234</Line>
  <Line number="1832">  /* Known to be little-endian at compile-time. No-op */</Line>
  <Line number="1833">#elif SHA3_BYTEORDER==4321</Line>
  <Line number="1834">  p-&gt;ixMask = 7;  /* Big-endian */</Line>
  <Line number="1835">#else</Line>
  <Line number="1836">  {</Line>
  <Line number="1837">    static unsigned int one = 1;</Line>
  <Line number="1838">    if( 1==*(unsigned char*)&amp;one ){</Line>
  <Line number="1839">      /* Little endian.  No byte swapping. */</Line>
  <Line number="1840">      p-&gt;ixMask = 0;</Line>
  <Line number="1841">    }else{</Line>
  <Line number="1842">      /* Big endian.  Byte swap. */</Line>
  <Line number="1843">      p-&gt;ixMask = 7;</Line>
  <Line number="1844">    }</Line>
  <Line number="1845">  }</Line>
  <Line number="1846">#endif</Line>
  <Line number="1847">}</Line>
  <Line number="1848"></Line>
  <Line number="1849">/*</Line>
  <Line number="1850">** Make consecutive calls to the SHA3Update function to add new content</Line>
  <Line number="1851">** to the hash</Line>
  <Line number="1852">*/</Line>
  <Line number="1853">static void SHA3Update(</Line>
  <Line number="1854">  SHA3Context *p,</Line>
  <Line number="1855">  const unsigned char *aData,</Line>
  <Line number="1856">  unsigned int nData</Line>
  <Line number="1857">){</Line>
  <Line number="1858">  unsigned int i = <CheckRefs ids="1059">0</CheckRefs>;</Line>
  <Line number="1859">#if SHA3_BYTEORDER==1234</Line>
  <Line number="1860">  if( (p-&gt;nLoaded <CheckRefs ids="1060">%</CheckRefs> <CheckRefs ids="1061">8</CheckRefs>)==<CheckRefs ids="1062">0</CheckRefs> &amp;&amp; ((aData <CheckRefs ids="1063">-</CheckRefs> (const unsigned char*)0)&amp;<CheckRefs ids="1064">7</CheckRefs>)==<CheckRefs ids="1065">0</CheckRefs> ){</Line>
  <Line number="1861">    for(; i<CheckRefs ids="1066">+</CheckRefs><CheckRefs ids="1067">7</CheckRefs>&lt;nData; i<CheckRefs ids="1068">+=</CheckRefs><CheckRefs ids="1069">8</CheckRefs>){</Line>
  <Line number="1862">      p-&gt;u.s[p-&gt;nLoaded<CheckRefs ids="1071">/</CheckRefs><CheckRefs ids="1072">8</CheckRefs><CheckRefs ids="1070">]</CheckRefs> ^= *(u64*)&amp;aData[i];</Line>
  <Line number="1863">      p-&gt;nLoaded <CheckRefs ids="1073">+=</CheckRefs> <CheckRefs ids="1074">8</CheckRefs>;</Line>
  <Line number="1864">      if( p-&gt;nLoaded&gt;=p-&gt;nRate ){</Line>
  <Line number="1865">        KeccakF1600Step(p);</Line>
  <Line number="1866">        p-&gt;nLoaded = <CheckRefs ids="1075">0</CheckRefs>;</Line>
  <Line number="1867">      }</Line>
  <Line number="1868">    }</Line>
  <Line number="1869">  }</Line>
  <Line number="1870">#endif</Line>
  <Line number="1871">  for(; i&lt;nData; i<CheckRefs ids="1076">++</CheckRefs>){</Line>
  <Line number="1872">#if SHA3_BYTEORDER==1234</Line>
  <Line number="1873">    p-&gt;u.x[p-&gt;nLoaded<CheckRefs ids="1077">]</CheckRefs> ^= <CheckRefs ids="1078">aData</CheckRefs>[i];</Line>
  <Line number="1874">#elif SHA3_BYTEORDER==4321</Line>
  <Line number="1875">    p-&gt;u.x[p-&gt;nLoaded^0x07] ^= aData[i];</Line>
  <Line number="1876">#else</Line>
  <Line number="1877">    p-&gt;u.x[p-&gt;nLoaded^p-&gt;ixMask] ^= aData[i];</Line>
  <Line number="1878">#endif</Line>
  <Line number="1879">    p-&gt;nLoaded<CheckRefs ids="1079">++</CheckRefs>;</Line>
  <Line number="1880">    if( p-&gt;nLoaded==p-&gt;nRate ){</Line>
  <Line number="1881">      KeccakF1600Step(p);</Line>
  <Line number="1882">      p-&gt;nLoaded = <CheckRefs ids="1080">0</CheckRefs>;</Line>
  <Line number="1883">    }</Line>
  <Line number="1884">  }</Line>
  <Line number="1885">}</Line>
  <Line number="1886"></Line>
  <Line number="1887">/*</Line>
  <Line number="1888">** After all content has been added, invoke SHA3Final() to compute</Line>
  <Line number="1889">** the final hash.  The function returns a pointer to the binary</Line>
  <Line number="1890">** hash value.</Line>
  <Line number="1891">*/</Line>
  <Line number="1892">static unsigned char *SHA3Final(SHA3Context *p){</Line>
  <Line number="1893">  unsigned int i;</Line>
  <Line number="1894">  if( p-&gt;nLoaded==p-&gt;nRate<CheckRefs ids="1081">-</CheckRefs><CheckRefs ids="1082">1</CheckRefs> ){</Line>
  <Line number="1895">    const unsigned char c1 = <CheckRefs ids="1083">0x86</CheckRefs>;</Line>
  <Line number="1896">    SHA3Update(p, &amp;c1, <CheckRefs ids="1084">1</CheckRefs>);</Line>
  <Line number="1897">  }else{</Line>
  <Line number="1898">    const unsigned char c2 = <CheckRefs ids="1085">0x06</CheckRefs>;</Line>
  <Line number="1899">    const unsigned char c3 = <CheckRefs ids="1086">0x80</CheckRefs>;</Line>
  <Line number="1900">    SHA3Update(p, &amp;c2, <CheckRefs ids="1087">1</CheckRefs>);</Line>
  <Line number="1901">    p-&gt;nLoaded = p-&gt;nRate <CheckRefs ids="1088">-</CheckRefs> <CheckRefs ids="1089">1</CheckRefs>;</Line>
  <Line number="1902">    SHA3Update(p, &amp;c3, <CheckRefs ids="1090">1</CheckRefs>);</Line>
  <Line number="1903">  }</Line>
  <Line number="1904">  for(i=<CheckRefs ids="1091">0</CheckRefs>; i&lt;p-&gt;nRate; i<CheckRefs ids="1092">++</CheckRefs>){</Line>
  <Line number="1905">    p-&gt;u.x[i<CheckRefs ids="1094">+</CheckRefs>p-&gt;nRate<CheckRefs ids="1093">]</CheckRefs> = p-&gt;u.x[i^p-&gt;ixMask<CheckRefs ids="1095">]</CheckRefs>;</Line>
  <Line number="1906">  }</Line>
  <Line number="1907">  return &amp;p-&gt;u.x[p-&gt;nRate<CheckRefs ids="1096">]</CheckRefs>;</Line>
  <Line number="1908">}</Line>
  <Line number="1909">/* End of the hashing logic</Line>
  <Line number="1910">*****************************************************************************/</Line>
  <Line number="1911"></Line>
  <Line number="1912">/*</Line>
  <Line number="1913">** Implementation of the sha3(X,SIZE) function.</Line>
  <Line number="1914">**</Line>
  <Line number="1915">** Return a BLOB which is the SIZE-bit SHA3 hash of X.  The default</Line>
  <Line number="1916">** size is 256.  If X is a BLOB, it is hashed as is.  </Line>
  <Line number="1917">** For all other non-NULL types of input, X is converted into a UTF-8 string</Line>
  <Line number="1918">** and the string is hashed without the trailing 0x00 terminator.  The hash</Line>
  <Line number="1919">** of a NULL value is NULL.</Line>
  <Line number="1920">*/</Line>
  <Line number="1921">static void sha3Func(</Line>
  <Line number="1922">  sqlite3_context *context,</Line>
  <Line number="1923">  int argc,</Line>
  <Line number="1924">  sqlite3_value **argv</Line>
  <Line number="1925">){</Line>
  <Line number="1926">  SHA3Context cx;</Line>
  <Line number="1927">  int eType = sqlite3_value_type(argv[0]);</Line>
  <Line number="1928">  int nByte = sqlite3_value_bytes(argv[0]);</Line>
  <Line number="1929">  int iSize;</Line>
  <Line number="1930">  if( argc==1 ){</Line>
  <Line number="1931">    iSize = 256;</Line>
  <Line number="1932">  }else{</Line>
  <Line number="1933">    iSize = sqlite3_value_int(argv[1]);</Line>
  <Line number="1934">    if( iSize!=224 &amp;&amp; iSize!=256 &amp;&amp; iSize!=384 &amp;&amp; iSize!=512 ){</Line>
  <Line number="1935">      sqlite3_result_error(context, &quot;SHA3 size should be one of: 224 256 &quot;</Line>
  <Line number="1936">                                    &quot;384 512&quot;, <CheckRefs ids="1097">-</CheckRefs>1);</Line>
  <Line number="1937">      return;</Line>
  <Line number="1938">    }</Line>
  <Line number="1939">  }</Line>
  <Line number="1940">  if( eType==SQLITE_NULL ) return;</Line>
  <Line number="1941">  SHA3Init(&amp;cx, iSize);</Line>
  <Line number="1942">  if( eType==SQLITE_BLOB ){</Line>
  <Line number="1943">    SHA3Update(&amp;cx, sqlite3_value_blob(argv[0]), <CheckRefs ids="1098">nByte</CheckRefs>);</Line>
  <Line number="1944">  }else{</Line>
  <Line number="1945">    SHA3Update(&amp;cx, sqlite3_value_text(argv[0]), <CheckRefs ids="1099">nByte</CheckRefs>);</Line>
  <Line number="1946">  }</Line>
  <Line number="1947">  sqlite3_result_blob(context, SHA3Final(&amp;cx), iSize<CheckRefs ids="1100,1101">/</CheckRefs>8, <CheckRefs ids="1102">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="1948">}</Line>
  <Line number="1949"></Line>
  <Line number="1950">/* Compute a string using sqlite3_vsnprintf() with a maximum length</Line>
  <Line number="1951">** of 50 bytes and add it to the hash.</Line>
  <Line number="1952">*/</Line>
  <Line number="1953">static void hash_step_vformat(</Line>
  <Line number="1954">  SHA3Context *p,                 /* Add content to this context */</Line>
  <Line number="1955">  const char *zFormat,</Line>
  <Line number="1956">  ...</Line>
  <Line number="1957">){</Line>
  <Line number="1958">  va_list ap;</Line>
  <Line number="1959">  int n;</Line>
  <Line number="1960">  char zBuf[50];</Line>
  <Line number="1961">  va_start(ap, zFormat);</Line>
  <Line number="1962">  sqlite3_vsnprintf(<CheckRefs ids="1103">sizeof</CheckRefs>(zBuf),zBuf,zFormat,ap);</Line>
  <Line number="1963">  va_end(ap);</Line>
  <Line number="1964">  n = <CheckRefs ids="1104">(</CheckRefs>int)strlen(zBuf);</Line>
  <Line number="1965">  SHA3Update(p, (unsigned char*)zBuf, <CheckRefs ids="1105">n</CheckRefs>);</Line>
  <Line number="1966">}</Line>
  <Line number="1967"></Line>
  <Line number="1968">/*</Line>
  <Line number="1969">** Implementation of the sha3_query(SQL,SIZE) function.</Line>
  <Line number="1970">**</Line>
  <Line number="1971">** This function compiles and runs the SQL statement(s) given in the</Line>
  <Line number="1972">** argument. The results are hashed using a SIZE-bit SHA3.  The default</Line>
  <Line number="1973">** size is 256.</Line>
  <Line number="1974">**</Line>
  <Line number="1975">** The format of the byte stream that is hashed is summarized as follows:</Line>
  <Line number="1976">**</Line>
  <Line number="1977">**       S&lt;n&gt;:&lt;sql&gt;</Line>
  <Line number="1978">**       R</Line>
  <Line number="1979">**       N</Line>
  <Line number="1980">**       I&lt;int&gt;</Line>
  <Line number="1981">**       F&lt;ieee-float&gt;</Line>
  <Line number="1982">**       B&lt;size&gt;:&lt;bytes&gt;</Line>
  <Line number="1983">**       T&lt;size&gt;:&lt;text&gt;</Line>
  <Line number="1984">**</Line>
  <Line number="1985">** &lt;sql&gt; is the original SQL text for each statement run and &lt;n&gt; is</Line>
  <Line number="1986">** the size of that text.  The SQL text is UTF-8.  A single R character</Line>
  <Line number="1987">** occurs before the start of each row.  N means a NULL value.</Line>
  <Line number="1988">** I mean an 8-byte little-endian integer &lt;int&gt;.  F is a floating point</Line>
  <Line number="1989">** number with an 8-byte little-endian IEEE floating point value &lt;ieee-float&gt;.</Line>
  <Line number="1990">** B means blobs of &lt;size&gt; bytes.  T means text rendered as &lt;size&gt;</Line>
  <Line number="1991">** bytes of UTF-8.  The &lt;n&gt; and &lt;size&gt; values are expressed as an ASCII</Line>
  <Line number="1992">** text integers.</Line>
  <Line number="1993">**</Line>
  <Line number="1994">** For each SQL statement in the X input, there is one S segment.  Each</Line>
  <Line number="1995">** S segment is followed by zero or more R segments, one for each row in the</Line>
  <Line number="1996">** result set.  After each R, there are one or more N, I, F, B, or T segments,</Line>
  <Line number="1997">** one for each column in the result set.  Segments are concatentated directly</Line>
  <Line number="1998">** with no delimiters of any kind.</Line>
  <Line number="1999">*/</Line>
  <Line number="2000">static void sha3QueryFunc(</Line>
  <Line number="2001">  sqlite3_context *context,</Line>
  <Line number="2002">  int argc,</Line>
  <Line number="2003">  sqlite3_value **argv</Line>
  <Line number="2004">){</Line>
  <Line number="2005">  sqlite3 *db = sqlite3_context_db_handle(context);</Line>
  <Line number="2006">  const char *zSql = (const char*)sqlite3_value_text(argv[0]);</Line>
  <Line number="2007">  sqlite3_stmt *pStmt = 0;</Line>
  <Line number="2008">  int nCol;                   /* Number of columns in the result set */</Line>
  <Line number="2009">  int i;                      /* Loop counter */</Line>
  <Line number="2010">  int rc;</Line>
  <Line number="2011">  int n;</Line>
  <Line number="2012">  const char *z;</Line>
  <Line number="2013">  SHA3Context cx;</Line>
  <Line number="2014">  int iSize;</Line>
  <Line number="2015"></Line>
  <Line number="2016">  if( argc==1 ){</Line>
  <Line number="2017">    iSize = 256;</Line>
  <Line number="2018">  }else{</Line>
  <Line number="2019">    iSize = sqlite3_value_int(argv[1]);</Line>
  <Line number="2020">    if( iSize!=224 &amp;&amp; iSize!=256 &amp;&amp; iSize!=384 &amp;&amp; iSize!=512 ){</Line>
  <Line number="2021">      sqlite3_result_error(context, &quot;SHA3 size should be one of: 224 256 &quot;</Line>
  <Line number="2022">                                    &quot;384 512&quot;, <CheckRefs ids="1106">-</CheckRefs>1);</Line>
  <Line number="2023">      return;</Line>
  <Line number="2024">    }</Line>
  <Line number="2025">  }</Line>
  <Line number="2026">  if( zSql==0 ) return;</Line>
  <Line number="2027">  SHA3Init(&amp;cx, iSize);</Line>
  <Line number="2028">  while( zSql[0] ){</Line>
  <Line number="2029">    rc = sqlite3_prepare_v2(db, zSql, <CheckRefs ids="1107">-</CheckRefs>1, &amp;pStmt, &amp;zSql);</Line>
  <Line number="2030">    if( rc ){</Line>
  <Line number="2031">      char *zMsg = sqlite3_mprintf(&quot;error SQL statement [%s]: %s&quot;,</Line>
  <Line number="2032">                                   zSql, sqlite3_errmsg(db));</Line>
  <Line number="2033">      sqlite3_finalize(pStmt);</Line>
  <Line number="2034">      sqlite3_result_error(context, zMsg, <CheckRefs ids="1108">-</CheckRefs>1);</Line>
  <Line number="2035">      sqlite3_free(zMsg);</Line>
  <Line number="2036">      return;</Line>
  <Line number="2037">    }</Line>
  <Line number="2038">    if( !sqlite3_stmt_readonly(pStmt) ){</Line>
  <Line number="2039">      char *zMsg = sqlite3_mprintf(&quot;non-query: [%s]&quot;, sqlite3_sql(pStmt));</Line>
  <Line number="2040">      sqlite3_finalize(pStmt);</Line>
  <Line number="2041">      sqlite3_result_error(context, zMsg, <CheckRefs ids="1109">-</CheckRefs>1);</Line>
  <Line number="2042">      sqlite3_free(zMsg);</Line>
  <Line number="2043">      return;</Line>
  <Line number="2044">    }</Line>
  <Line number="2045">    nCol = sqlite3_column_count(pStmt);</Line>
  <Line number="2046">    z = sqlite3_sql(pStmt);</Line>
  <Line number="2047">    if( z ){</Line>
  <Line number="2048">      n = <CheckRefs ids="1110">(</CheckRefs>int)strlen(z);</Line>
  <Line number="2049">      hash_step_vformat(&amp;cx,&quot;S%d:&quot;,n);</Line>
  <Line number="2050">      SHA3Update(&amp;cx,(unsigned char*)z,<CheckRefs ids="1111">n</CheckRefs>);</Line>
  <Line number="2051">    }</Line>
  <Line number="2052"></Line>
  <Line number="2053">    /* Compute a hash over the result of the query */</Line>
  <Line number="2054">    while( SQLITE_ROW==sqlite3_step(pStmt) ){</Line>
  <Line number="2055">      SHA3Update(&amp;cx,(const unsigned char*)&quot;R&quot;,<CheckRefs ids="1112">1</CheckRefs>);</Line>
  <Line number="2056">      for(i=0; i&lt;nCol; i<CheckRefs ids="1113">++</CheckRefs>){</Line>
  <Line number="2057">        switch( sqlite3_column_type(pStmt,i) ){</Line>
  <Line number="2058">          case SQLITE_NULL: {</Line>
  <Line number="2059">            SHA3Update(&amp;cx, (const unsigned char*)&quot;N&quot;,<CheckRefs ids="1114">1</CheckRefs>);</Line>
  <Line number="2060">            break;</Line>
  <Line number="2061">          }</Line>
  <Line number="2062">          case SQLITE_INTEGER: {</Line>
  <Line number="2063">            sqlite3_uint64 u;</Line>
  <Line number="2064">            int j;</Line>
  <Line number="2065">            unsigned char x[9];</Line>
  <Line number="2066">            sqlite3_int64 v = sqlite3_column_int64(pStmt,i);</Line>
  <Line number="2067">            memcpy(&amp;u, &amp;v, <CheckRefs ids="1115">8</CheckRefs>);</Line>
  <Line number="2068">            for(j=8; j&gt;=1; j<CheckRefs ids="1116">--</CheckRefs>){</Line>
  <Line number="2069">              x[j<CheckRefs ids="1117">]</CheckRefs> = u <CheckRefs ids="1118">&amp;</CheckRefs> <CheckRefs ids="1119">0xff</CheckRefs>;</Line>
  <Line number="2070">              u <CheckRefs ids="1120">&gt;&gt;=</CheckRefs> 8;</Line>
  <Line number="2071">            }</Line>
  <Line number="2072">            x[0<CheckRefs ids="1121">]</CheckRefs> = <CheckRefs ids="1122">&apos;I&apos;</CheckRefs>;</Line>
  <Line number="2073">            SHA3Update(&amp;cx, x, <CheckRefs ids="1123">9</CheckRefs>);</Line>
  <Line number="2074">            break;</Line>
  <Line number="2075">          }</Line>
  <Line number="2076">          case SQLITE_FLOAT: {</Line>
  <Line number="2077">            sqlite3_uint64 u;</Line>
  <Line number="2078">            int j;</Line>
  <Line number="2079">            unsigned char x[9];</Line>
  <Line number="2080">            double r = sqlite3_column_double(pStmt,i);</Line>
  <Line number="2081">            memcpy(&amp;u, &amp;r, <CheckRefs ids="1124">8</CheckRefs>);</Line>
  <Line number="2082">            for(j=8; j&gt;=1; j<CheckRefs ids="1125">--</CheckRefs>){</Line>
  <Line number="2083">              x[j<CheckRefs ids="1126">]</CheckRefs> = u <CheckRefs ids="1127">&amp;</CheckRefs> <CheckRefs ids="1128">0xff</CheckRefs>;</Line>
  <Line number="2084">              u <CheckRefs ids="1129">&gt;&gt;=</CheckRefs> 8;</Line>
  <Line number="2085">            }</Line>
  <Line number="2086">            x[0<CheckRefs ids="1130">]</CheckRefs> = <CheckRefs ids="1131">&apos;F&apos;</CheckRefs>;</Line>
  <Line number="2087">            SHA3Update(&amp;cx,x,<CheckRefs ids="1132">9</CheckRefs>);</Line>
  <Line number="2088">            break;</Line>
  <Line number="2089">          }</Line>
  <Line number="2090">          case SQLITE_TEXT: {</Line>
  <Line number="2091">            int n2 = sqlite3_column_bytes(pStmt, i);</Line>
  <Line number="2092">            const unsigned char *z2 = sqlite3_column_text(pStmt, i);</Line>
  <Line number="2093">            hash_step_vformat(&amp;cx,&quot;T%d:&quot;,n2);</Line>
  <Line number="2094">            SHA3Update(&amp;cx, z2, <CheckRefs ids="1133">n2</CheckRefs>);</Line>
  <Line number="2095">            break;</Line>
  <Line number="2096">          }</Line>
  <Line number="2097">          case SQLITE_BLOB: {</Line>
  <Line number="2098">            int n2 = sqlite3_column_bytes(pStmt, i);</Line>
  <Line number="2099">            const unsigned char *z2 = sqlite3_column_blob(pStmt, i);</Line>
  <Line number="2100">            hash_step_vformat(&amp;cx,&quot;B%d:&quot;,n2);</Line>
  <Line number="2101">            SHA3Update(&amp;cx, z2, <CheckRefs ids="1134">n2</CheckRefs>);</Line>
  <Line number="2102">            break;</Line>
  <Line number="2103">          }</Line>
  <Line number="2104">        }</Line>
  <Line number="2105">      }</Line>
  <Line number="2106">    }</Line>
  <Line number="2107">    sqlite3_finalize(pStmt);</Line>
  <Line number="2108">  }</Line>
  <Line number="2109">  sqlite3_result_blob(context, SHA3Final(&amp;cx), iSize<CheckRefs ids="1136,1135">/</CheckRefs>8, <CheckRefs ids="1137">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="2110">}</Line>
  <Line number="2111"></Line>
  <Line number="2112"></Line>
  <Line number="2113">#ifdef _WIN32</Line>
  <Line number="2114"></Line>
  <Line number="2115">#endif</Line>
  <Line number="2116">int sqlite3_shathree_init(</Line>
  <Line number="2117">  sqlite3 *db,</Line>
  <Line number="2118">  char **pzErrMsg,</Line>
  <Line number="2119">  const sqlite3_api_routines *pApi</Line>
  <Line number="2120">){</Line>
  <Line number="2121">  int rc = SQLITE_OK;</Line>
  <Line number="2122">  SQLITE_EXTENSION_INIT2(pApi);</Line>
  <Line number="2123">  (void)pzErrMsg;  /* Unused parameter */</Line>
  <Line number="2124">  rc = sqlite3_create_function(db, &quot;sha3&quot;, 1,</Line>
  <Line number="2125">                      SQLITE_UTF8 | SQLITE_INNOCUOUS | SQLITE_DETERMINISTIC,</Line>
  <Line number="2126">                      0, sha3Func, 0, 0);</Line>
  <Line number="2127">  if( rc==SQLITE_OK ){</Line>
  <Line number="2128">    rc = sqlite3_create_function(db, &quot;sha3&quot;, 2,</Line>
  <Line number="2129">                      SQLITE_UTF8 | SQLITE_INNOCUOUS | SQLITE_DETERMINISTIC,</Line>
  <Line number="2130">                      0, sha3Func, 0, 0);</Line>
  <Line number="2131">  }</Line>
  <Line number="2132">  if( rc==SQLITE_OK ){</Line>
  <Line number="2133">    rc = sqlite3_create_function(db, &quot;sha3_query&quot;, 1,</Line>
  <Line number="2134">                      SQLITE_UTF8 | SQLITE_DIRECTONLY,</Line>
  <Line number="2135">                      0, sha3QueryFunc, 0, 0);</Line>
  <Line number="2136">  }</Line>
  <Line number="2137">  if( rc==SQLITE_OK ){</Line>
  <Line number="2138">    rc = sqlite3_create_function(db, &quot;sha3_query&quot;, 2,</Line>
  <Line number="2139">                      SQLITE_UTF8 | SQLITE_DIRECTONLY,</Line>
  <Line number="2140">                      0, sha3QueryFunc, 0, 0);</Line>
  <Line number="2141">  }</Line>
  <Line number="2142">  return rc;</Line>
  <Line number="2143">}</Line>
  <Line number="2144"></Line>
  <Line number="2145">/************************* End ../ext/misc/shathree.c ********************/</Line>
  <Line number="2146">/************************* Begin ../ext/misc/fileio.c ******************/</Line>
  <Line number="2147">/*</Line>
  <Line number="2148">** 2014-06-13</Line>
  <Line number="2149">**</Line>
  <Line number="2150">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="2151">** a legal notice, here is a blessing:</Line>
  <Line number="2152">**</Line>
  <Line number="2153">**    May you do good and not evil.</Line>
  <Line number="2154">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="2155">**    May you share freely, never taking more than you give.</Line>
  <Line number="2156">**</Line>
  <Line number="2157">******************************************************************************</Line>
  <Line number="2158">**</Line>
  <Line number="2159">** This SQLite extension implements SQL functions readfile() and</Line>
  <Line number="2160">** writefile(), and eponymous virtual type &quot;fsdir&quot;.</Line>
  <Line number="2161">**</Line>
  <Line number="2162">** WRITEFILE(FILE, DATA [, MODE [, MTIME]]):</Line>
  <Line number="2163">**</Line>
  <Line number="2164">**   If neither of the optional arguments is present, then this UDF</Line>
  <Line number="2165">**   function writes blob DATA to file FILE. If successful, the number</Line>
  <Line number="2166">**   of bytes written is returned. If an error occurs, NULL is returned.</Line>
  <Line number="2167">**</Line>
  <Line number="2168">**   If the first option argument - MODE - is present, then it must</Line>
  <Line number="2169">**   be passed an integer value that corresponds to a POSIX mode</Line>
  <Line number="2170">**   value (file type + permissions, as returned in the stat.st_mode</Line>
  <Line number="2171">**   field by the stat() system call). Three types of files may</Line>
  <Line number="2172">**   be written/created:</Line>
  <Line number="2173">**</Line>
  <Line number="2174">**     regular files:  (mode &amp; 0170000)==0100000</Line>
  <Line number="2175">**     symbolic links: (mode &amp; 0170000)==0120000</Line>
  <Line number="2176">**     directories:    (mode &amp; 0170000)==0040000</Line>
  <Line number="2177">**</Line>
  <Line number="2178">**   For a directory, the DATA is ignored. For a symbolic link, it is</Line>
  <Line number="2179">**   interpreted as text and used as the target of the link. For a</Line>
  <Line number="2180">**   regular file, it is interpreted as a blob and written into the</Line>
  <Line number="2181">**   named file. Regardless of the type of file, its permissions are</Line>
  <Line number="2182">**   set to (mode &amp; 0777) before returning.</Line>
  <Line number="2183">**</Line>
  <Line number="2184">**   If the optional MTIME argument is present, then it is interpreted</Line>
  <Line number="2185">**   as an integer - the number of seconds since the unix epoch. The</Line>
  <Line number="2186">**   modification-time of the target file is set to this value before</Line>
  <Line number="2187">**   returning.</Line>
  <Line number="2188">**</Line>
  <Line number="2189">**   If three or more arguments are passed to this function and an</Line>
  <Line number="2190">**   error is encountered, an exception is raised.</Line>
  <Line number="2191">**</Line>
  <Line number="2192">** READFILE(FILE):</Line>
  <Line number="2193">**</Line>
  <Line number="2194">**   Read and return the contents of file FILE (type blob) from disk.</Line>
  <Line number="2195">**</Line>
  <Line number="2196">** FSDIR:</Line>
  <Line number="2197">**</Line>
  <Line number="2198">**   Used as follows:</Line>
  <Line number="2199">**</Line>
  <Line number="2200">**     SELECT * FROM fsdir($path [, $dir]);</Line>
  <Line number="2201">**</Line>
  <Line number="2202">**   Parameter $path is an absolute or relative pathname. If the file that it</Line>
  <Line number="2203">**   refers to does not exist, it is an error. If the path refers to a regular</Line>
  <Line number="2204">**   file or symbolic link, it returns a single row. Or, if the path refers</Line>
  <Line number="2205">**   to a directory, it returns one row for the directory, and one row for each</Line>
  <Line number="2206">**   file within the hierarchy rooted at $path.</Line>
  <Line number="2207">**</Line>
  <Line number="2208">**   Each row has the following columns:</Line>
  <Line number="2209">**</Line>
  <Line number="2210">**     name:  Path to file or directory (text value).</Line>
  <Line number="2211">**     mode:  Value of stat.st_mode for directory entry (an integer).</Line>
  <Line number="2212">**     mtime: Value of stat.st_mtime for directory entry (an integer).</Line>
  <Line number="2213">**     data:  For a regular file, a blob containing the file data. For a</Line>
  <Line number="2214">**            symlink, a text value containing the text of the link. For a</Line>
  <Line number="2215">**            directory, NULL.</Line>
  <Line number="2216">**</Line>
  <Line number="2217">**   If a non-NULL value is specified for the optional $dir parameter and</Line>
  <Line number="2218">**   $path is a relative path, then $path is interpreted relative to $dir. </Line>
  <Line number="2219">**   And the paths returned in the &quot;name&quot; column of the table are also </Line>
  <Line number="2220">**   relative to directory $dir.</Line>
  <Line number="2221">*/</Line>
  <Line number="2222">/* #include &quot;sqlite3ext.h&quot; */</Line>
  <Line number="2223">SQLITE_EXTENSION_INIT1</Line>
  <Line number="2224">#include &lt;stdio.h&gt;</Line>
  <Line number="2225">#include &lt;string.h&gt;</Line>
  <Line number="2226">#include &lt;assert.h&gt;</Line>
  <Line number="2227"></Line>
  <Line number="2228">#include &lt;sys/types.h&gt;</Line>
  <Line number="2229">#include &lt;sys/stat.h&gt;</Line>
  <Line number="2230">#include &lt;fcntl.h&gt;</Line>
  <Line number="2231">#if !defined(_WIN32) &amp;&amp; !defined(WIN32)</Line>
  <Line number="2232">#  include &lt;unistd.h&gt;</Line>
  <Line number="2233">#  include &lt;dirent.h&gt;</Line>
  <Line number="2234">#  include &lt;utime.h&gt;</Line>
  <Line number="2235">#  include &lt;sys/time.h&gt;</Line>
  <Line number="2236">#else</Line>
  <Line number="2237">#  include &quot;windows.h&quot;</Line>
  <Line number="2238">#  include &lt;io.h&gt;</Line>
  <Line number="2239">#  include &lt;direct.h&gt;</Line>
  <Line number="2240">/* #  include &quot;test_windirent.h&quot; */</Line>
  <Line number="2241">#  define dirent DIRENT</Line>
  <Line number="2242">#  ifndef chmod</Line>
  <Line number="2243">#    define chmod _chmod</Line>
  <Line number="2244">#  endif</Line>
  <Line number="2245">#  ifndef stat</Line>
  <Line number="2246">#    define stat _stat</Line>
  <Line number="2247">#  endif</Line>
  <Line number="2248">#  define mkdir(path,mode) _mkdir(path)</Line>
  <Line number="2249">#  define lstat(path,buf) stat(path,buf)</Line>
  <Line number="2250">#endif</Line>
  <Line number="2251">#include &lt;time.h&gt;</Line>
  <Line number="2252">#include &lt;errno.h&gt;</Line>
  <Line number="2253"></Line>
  <Line number="2254"></Line>
  <Line number="2255">/*</Line>
  <Line number="2256">** Structure of the fsdir() table-valued function</Line>
  <Line number="2257">*/</Line>
  <Line number="2258">                 /*    0    1    2     3    4           5             */</Line>
  <Line number="2259">#define FSDIR_SCHEMA &quot;(name,mode,mtime,data,path HIDDEN,dir HIDDEN)&quot;</Line>
  <Line number="2260">#define FSDIR_COLUMN_NAME     0     /* Name of the file */</Line>
  <Line number="2261">#define FSDIR_COLUMN_MODE     1     /* Access mode */</Line>
  <Line number="2262">#define FSDIR_COLUMN_MTIME    2     /* Last modification time */</Line>
  <Line number="2263">#define FSDIR_COLUMN_DATA     3     /* File content */</Line>
  <Line number="2264">#define FSDIR_COLUMN_PATH     4     /* Path to top of search */</Line>
  <Line number="2265">#define FSDIR_COLUMN_DIR      5     /* Path is relative to this directory */</Line>
  <Line number="2266"></Line>
  <Line number="2267"></Line>
  <Line number="2268">/*</Line>
  <Line number="2269">** Set the result stored by context ctx to a blob containing the </Line>
  <Line number="2270">** contents of file zName.  Or, leave the result unchanged (NULL)</Line>
  <Line number="2271">** if the file does not exist or is unreadable.</Line>
  <Line number="2272">**</Line>
  <Line number="2273">** If the file exceeds the SQLite blob size limit, through an</Line>
  <Line number="2274">** SQLITE_TOOBIG error.</Line>
  <Line number="2275">**</Line>
  <Line number="2276">** Throw an SQLITE_IOERR if there are difficulties pulling the file</Line>
  <Line number="2277">** off of disk.</Line>
  <Line number="2278">*/</Line>
  <Line number="2279">static void readFileContents(sqlite3_context *ctx, const char *zName){</Line>
  <Line number="2280">  FILE *in;</Line>
  <Line number="2281">  sqlite3_int64 nIn;</Line>
  <Line number="2282">  void *pBuf;</Line>
  <Line number="2283">  sqlite3 *db;</Line>
  <Line number="2284">  int mxBlob;</Line>
  <Line number="2285"></Line>
  <Line number="2286">  in = fopen(zName, &quot;rb&quot;);</Line>
  <Line number="2287">  if( in==0 ){</Line>
  <Line number="2288">    /* File does not exist or is unreadable. Leave the result set to NULL. */</Line>
  <Line number="2289">    return;</Line>
  <Line number="2290">  }</Line>
  <Line number="2291">  fseek(in, <CheckRefs ids="1138">0</CheckRefs>, SEEK_END);</Line>
  <Line number="2292">  nIn = <CheckRefs ids="1139">ftell</CheckRefs>(in);</Line>
  <Line number="2293">  rewind(in);</Line>
  <Line number="2294">  db = sqlite3_context_db_handle(ctx);</Line>
  <Line number="2295">  mxBlob = sqlite3_limit(db, SQLITE_LIMIT_LENGTH, <CheckRefs ids="1140">-</CheckRefs>1);</Line>
  <Line number="2296">  if( nIn&gt;<CheckRefs ids="1141">mxBlob</CheckRefs> ){</Line>
  <Line number="2297">    sqlite3_result_error_code(ctx, SQLITE_TOOBIG);</Line>
  <Line number="2298">    fclose(in);</Line>
  <Line number="2299">    return;</Line>
  <Line number="2300">  }</Line>
  <Line number="2301">  pBuf = sqlite3_malloc64( <CheckRefs ids="1142">nIn</CheckRefs> ? nIn : <CheckRefs ids="1143">1</CheckRefs> );</Line>
  <Line number="2302">  if( pBuf==0 ){</Line>
  <Line number="2303">    sqlite3_result_error_nomem(ctx);</Line>
  <Line number="2304">    fclose(in);</Line>
  <Line number="2305">    return;</Line>
  <Line number="2306">  }</Line>
  <Line number="2307">  if( nIn==<CheckRefs ids="1144">(</CheckRefs>sqlite3_int64)fread(pBuf, <CheckRefs ids="1145">1</CheckRefs>, <CheckRefs ids="1146">(</CheckRefs>size_t)nIn, in) ){</Line>
  <Line number="2308">    sqlite3_result_blob64(ctx, pBuf, <CheckRefs ids="1147">nIn</CheckRefs>, sqlite3_free);</Line>
  <Line number="2309">  }else{</Line>
  <Line number="2310">    sqlite3_result_error_code(ctx, SQLITE_IOERR);</Line>
  <Line number="2311">    sqlite3_free(pBuf);</Line>
  <Line number="2312">  }</Line>
  <Line number="2313">  fclose(in);</Line>
  <Line number="2314">}</Line>
  <Line number="2315"></Line>
  <Line number="2316">/*</Line>
  <Line number="2317">** Implementation of the &quot;readfile(X)&quot; SQL function.  The entire content</Line>
  <Line number="2318">** of the file named X is read and returned as a BLOB.  NULL is returned</Line>
  <Line number="2319">** if the file does not exist or is unreadable.</Line>
  <Line number="2320">*/</Line>
  <Line number="2321">static void readfileFunc(</Line>
  <Line number="2322">  sqlite3_context *context,</Line>
  <Line number="2323">  int argc,</Line>
  <Line number="2324">  sqlite3_value **argv</Line>
  <Line number="2325">){</Line>
  <Line number="2326">  const char *zName;</Line>
  <Line number="2327">  (void)(argc);  /* Unused parameter */</Line>
  <Line number="2328">  zName = (const char*)sqlite3_value_text(argv[0]);</Line>
  <Line number="2329">  if( zName==0 ) return;</Line>
  <Line number="2330">  readFileContents(context, zName);</Line>
  <Line number="2331">}</Line>
  <Line number="2332"></Line>
  <Line number="2333">/*</Line>
  <Line number="2334">** Set the error message contained in context ctx to the results of</Line>
  <Line number="2335">** vprintf(zFmt, ...).</Line>
  <Line number="2336">*/</Line>
  <Line number="2337">static void ctxErrorMsg(sqlite3_context *ctx, const char *zFmt, ...){</Line>
  <Line number="2338">  char *zMsg = 0;</Line>
  <Line number="2339">  va_list ap;</Line>
  <Line number="2340">  va_start(ap, zFmt);</Line>
  <Line number="2341">  zMsg = sqlite3_vmprintf(zFmt, ap);</Line>
  <Line number="2342">  sqlite3_result_error(ctx, zMsg, <CheckRefs ids="1148">-</CheckRefs>1);</Line>
  <Line number="2343">  sqlite3_free(zMsg);</Line>
  <Line number="2344">  va_end(ap);</Line>
  <Line number="2345">}</Line>
  <Line number="2346"></Line>
  <Line number="2347">#if defined(_WIN32)</Line>
  <Line number="2348">/*</Line>
  <Line number="2349">** This function is designed to convert a Win32 FILETIME structure into the</Line>
  <Line number="2350">** number of seconds since the Unix Epoch (1970-01-01 00:00:00 UTC).</Line>
  <Line number="2351">*/</Line>
  <Line number="2352">static sqlite3_uint64 fileTimeToUnixTime(</Line>
  <Line number="2353">  LPFILETIME pFileTime</Line>
  <Line number="2354">){</Line>
  <Line number="2355">  SYSTEMTIME epochSystemTime;</Line>
  <Line number="2356">  ULARGE_INTEGER epochIntervals;</Line>
  <Line number="2357">  FILETIME epochFileTime;</Line>
  <Line number="2358">  ULARGE_INTEGER fileIntervals;</Line>
  <Line number="2359"></Line>
  <Line number="2360">  memset(&amp;epochSystemTime, 0, sizeof(SYSTEMTIME));</Line>
  <Line number="2361">  epochSystemTime.wYear = 1970;</Line>
  <Line number="2362">  epochSystemTime.wMonth = 1;</Line>
  <Line number="2363">  epochSystemTime.wDay = 1;</Line>
  <Line number="2364">  SystemTimeToFileTime(&amp;epochSystemTime, &amp;epochFileTime);</Line>
  <Line number="2365">  epochIntervals.LowPart = epochFileTime.dwLowDateTime;</Line>
  <Line number="2366">  epochIntervals.HighPart = epochFileTime.dwHighDateTime;</Line>
  <Line number="2367"></Line>
  <Line number="2368">  fileIntervals.LowPart = pFileTime-&gt;dwLowDateTime;</Line>
  <Line number="2369">  fileIntervals.HighPart = pFileTime-&gt;dwHighDateTime;</Line>
  <Line number="2370"></Line>
  <Line number="2371">  return (fileIntervals.QuadPart - epochIntervals.QuadPart) / 10000000;</Line>
  <Line number="2372">}</Line>
  <Line number="2373"></Line>
  <Line number="2374">/*</Line>
  <Line number="2375">** This function attempts to normalize the time values found in the stat()</Line>
  <Line number="2376">** buffer to UTC.  This is necessary on Win32, where the runtime library</Line>
  <Line number="2377">** appears to return these values as local times.</Line>
  <Line number="2378">*/</Line>
  <Line number="2379">static void statTimesToUtc(</Line>
  <Line number="2380">  const char *zPath,</Line>
  <Line number="2381">  struct stat *pStatBuf</Line>
  <Line number="2382">){</Line>
  <Line number="2383">  HANDLE hFindFile;</Line>
  <Line number="2384">  WIN32_FIND_DATAW fd;</Line>
  <Line number="2385">  LPWSTR zUnicodeName;</Line>
  <Line number="2386">  extern LPWSTR sqlite3_win32_utf8_to_unicode(const char*);</Line>
  <Line number="2387">  zUnicodeName = sqlite3_win32_utf8_to_unicode(zPath);</Line>
  <Line number="2388">  if( zUnicodeName ){</Line>
  <Line number="2389">    memset(&amp;fd, 0, sizeof(WIN32_FIND_DATAW));</Line>
  <Line number="2390">    hFindFile = FindFirstFileW(zUnicodeName, &amp;fd);</Line>
  <Line number="2391">    if( hFindFile!=NULL ){</Line>
  <Line number="2392">      pStatBuf-&gt;st_ctime = (time_t)fileTimeToUnixTime(&amp;fd.ftCreationTime);</Line>
  <Line number="2393">      pStatBuf-&gt;st_atime = (time_t)fileTimeToUnixTime(&amp;fd.ftLastAccessTime);</Line>
  <Line number="2394">      pStatBuf-&gt;st_mtime = (time_t)fileTimeToUnixTime(&amp;fd.ftLastWriteTime);</Line>
  <Line number="2395">      FindClose(hFindFile);</Line>
  <Line number="2396">    }</Line>
  <Line number="2397">    sqlite3_free(zUnicodeName);</Line>
  <Line number="2398">  }</Line>
  <Line number="2399">}</Line>
  <Line number="2400">#endif</Line>
  <Line number="2401"></Line>
  <Line number="2402">/*</Line>
  <Line number="2403">** This function is used in place of stat().  On Windows, special handling</Line>
  <Line number="2404">** is required in order for the included time to be returned as UTC.  On all</Line>
  <Line number="2405">** other systems, this function simply calls stat().</Line>
  <Line number="2406">*/</Line>
  <Line number="2407">static int fileStat(</Line>
  <Line number="2408">  const char *zPath,</Line>
  <Line number="2409">  struct stat *pStatBuf</Line>
  <Line number="2410">){</Line>
  <Line number="2411">#if defined(_WIN32)</Line>
  <Line number="2412">  int rc = stat(zPath, pStatBuf);</Line>
  <Line number="2413">  if( rc==0 ) statTimesToUtc(zPath, pStatBuf);</Line>
  <Line number="2414">  return rc;</Line>
  <Line number="2415">#else</Line>
  <Line number="2416">  return stat(zPath, pStatBuf);</Line>
  <Line number="2417">#endif</Line>
  <Line number="2418">}</Line>
  <Line number="2419"></Line>
  <Line number="2420">/*</Line>
  <Line number="2421">** This function is used in place of lstat().  On Windows, special handling</Line>
  <Line number="2422">** is required in order for the included time to be returned as UTC.  On all</Line>
  <Line number="2423">** other systems, this function simply calls lstat().</Line>
  <Line number="2424">*/</Line>
  <Line number="2425">static int fileLinkStat(</Line>
  <Line number="2426">  const char *zPath,</Line>
  <Line number="2427">  struct stat *pStatBuf</Line>
  <Line number="2428">){</Line>
  <Line number="2429">#if defined(_WIN32)</Line>
  <Line number="2430">  int rc = lstat(zPath, pStatBuf);</Line>
  <Line number="2431">  if( rc==0 ) statTimesToUtc(zPath, pStatBuf);</Line>
  <Line number="2432">  return rc;</Line>
  <Line number="2433">#else</Line>
  <Line number="2434">  return lstat(zPath, pStatBuf);</Line>
  <Line number="2435">#endif</Line>
  <Line number="2436">}</Line>
  <Line number="2437"></Line>
  <Line number="2438">/*</Line>
  <Line number="2439">** Argument zFile is the name of a file that will be created and/or written</Line>
  <Line number="2440">** by SQL function writefile(). This function ensures that the directory</Line>
  <Line number="2441">** zFile will be written to exists, creating it if required. The permissions</Line>
  <Line number="2442">** for any path components created by this function are set in accordance</Line>
  <Line number="2443">** with the current umask.</Line>
  <Line number="2444">**</Line>
  <Line number="2445">** If an OOM condition is encountered, SQLITE_NOMEM is returned. Otherwise,</Line>
  <Line number="2446">** SQLITE_OK is returned if the directory is successfully created, or</Line>
  <Line number="2447">** SQLITE_ERROR otherwise.</Line>
  <Line number="2448">*/</Line>
  <Line number="2449">static int makeDirectory(</Line>
  <Line number="2450">  const char *zFile</Line>
  <Line number="2451">){</Line>
  <Line number="2452">  char *zCopy = sqlite3_mprintf(&quot;%s&quot;, zFile);</Line>
  <Line number="2453">  int rc = SQLITE_OK;</Line>
  <Line number="2454"></Line>
  <Line number="2455">  if( zCopy==0 ){</Line>
  <Line number="2456">    rc = SQLITE_NOMEM;</Line>
  <Line number="2457">  }else{</Line>
  <Line number="2458">    int nCopy = <CheckRefs ids="1149">(</CheckRefs>int)strlen(zCopy);</Line>
  <Line number="2459">    int i = 1;</Line>
  <Line number="2460"></Line>
  <Line number="2461">    while( rc==SQLITE_OK ){</Line>
  <Line number="2462">      struct stat sStat;</Line>
  <Line number="2463">      int rc2;</Line>
  <Line number="2464"></Line>
  <Line number="2465">      for(; <CheckRefs ids="1150">zCopy</CheckRefs>[i]!=&apos;/&apos; &amp;&amp; i&lt;nCopy; i<CheckRefs ids="1151">++</CheckRefs>);</Line>
  <Line number="2466">      if( i==nCopy ) break;</Line>
  <Line number="2467">      zCopy[i] = <CheckRefs ids="1152">&apos;\0&apos;</CheckRefs>;</Line>
  <Line number="2468"></Line>
  <Line number="2469">      rc2 = fileStat(zCopy, &amp;sStat);</Line>
  <Line number="2470">      if( rc2!=0 ){</Line>
  <Line number="2471">        if( mkdir(zCopy, <CheckRefs ids="1153">0777</CheckRefs>) ) rc = SQLITE_ERROR;</Line>
  <Line number="2472">      }else{</Line>
  <Line number="2473">        if( !<CheckRefs ids="1155,1154">S_ISDIR</CheckRefs>(sStat.st_mode) ) rc = SQLITE_ERROR;</Line>
  <Line number="2474">      }</Line>
  <Line number="2475">      zCopy[i] = <CheckRefs ids="1156">&apos;/&apos;</CheckRefs>;</Line>
  <Line number="2476">      i<CheckRefs ids="1157">++</CheckRefs>;</Line>
  <Line number="2477">    }</Line>
  <Line number="2478"></Line>
  <Line number="2479">    sqlite3_free(zCopy);</Line>
  <Line number="2480">  }</Line>
  <Line number="2481"></Line>
  <Line number="2482">  return rc;</Line>
  <Line number="2483">}</Line>
  <Line number="2484"></Line>
  <Line number="2485">/*</Line>
  <Line number="2486">** This function does the work for the writefile() UDF. Refer to </Line>
  <Line number="2487">** header comments at the top of this file for details.</Line>
  <Line number="2488">*/</Line>
  <Line number="2489">static int writeFile(</Line>
  <Line number="2490">  sqlite3_context *pCtx,          /* Context to return bytes written in */</Line>
  <Line number="2491">  const char *zFile,              /* File to write */</Line>
  <Line number="2492">  sqlite3_value *pData,           /* Data to write */</Line>
  <Line number="2493">  mode_t mode,                    /* MODE parameter passed to writefile() */</Line>
  <Line number="2494">  sqlite3_int64 mtime             /* MTIME parameter (or -1 to not set time) */</Line>
  <Line number="2495">){</Line>
  <Line number="2496">#if !defined(_WIN32) &amp;&amp; !defined(WIN32)</Line>
  <Line number="2497">  if( <CheckRefs ids="1158,1159">S_ISLNK</CheckRefs>(mode) ){</Line>
  <Line number="2498">    const char *zTo = (const char*)sqlite3_value_text(pData);</Line>
  <Line number="2499">    if( symlink(zTo, zFile)&lt;0 ) return 1;</Line>
  <Line number="2500">  }else</Line>
  <Line number="2501">#endif</Line>
  <Line number="2502">  {</Line>
  <Line number="2503">    if( <CheckRefs ids="1160,1161">S_ISDIR</CheckRefs>(mode) ){</Line>
  <Line number="2504">      if( mkdir(zFile, mode) ){</Line>
  <Line number="2505">        /* The mkdir() call to create the directory failed. This might not</Line>
  <Line number="2506">        ** be an error though - if there is already a directory at the same</Line>
  <Line number="2507">        ** path and either the permissions already match or can be changed</Line>
  <Line number="2508">        ** to do so using chmod(), it is not an error.  */</Line>
  <Line number="2509">        struct stat sStat;</Line>
  <Line number="2510">        if( errno!=EEXIST</Line>
  <Line number="2511">         || 0!=fileStat(zFile, &amp;sStat)</Line>
  <Line number="2512">         || !<CheckRefs ids="1162,1163">S_ISDIR</CheckRefs>(sStat.st_mode)</Line>
  <Line number="2513">         || ((sStat.st_mode&amp;<CheckRefs ids="1164">0777</CheckRefs>)!=(mode&amp;<CheckRefs ids="1165">0777</CheckRefs>) &amp;&amp; 0!=chmod(zFile, mode&amp;<CheckRefs ids="1166">0777</CheckRefs>))</Line>
  <Line number="2514">        ){</Line>
  <Line number="2515">          return 1;</Line>
  <Line number="2516">        }</Line>
  <Line number="2517">      }</Line>
  <Line number="2518">    }else{</Line>
  <Line number="2519">      sqlite3_int64 nWrite = <CheckRefs ids="1167">0</CheckRefs>;</Line>
  <Line number="2520">      const char *z;</Line>
  <Line number="2521">      int rc = 0;</Line>
  <Line number="2522">      FILE *out = fopen(zFile, &quot;wb&quot;);</Line>
  <Line number="2523">      if( out==0 ) return 1;</Line>
  <Line number="2524">      z = (const char*)sqlite3_value_blob(pData);</Line>
  <Line number="2525">      if( z ){</Line>
  <Line number="2526">        sqlite3_int64 n = <CheckRefs ids="1168">fwrite</CheckRefs>(z, <CheckRefs ids="1169">1</CheckRefs>, <CheckRefs ids="1170">sqlite3_value_bytes</CheckRefs>(pData), out);</Line>
  <Line number="2527">        nWrite = <CheckRefs ids="1171">sqlite3_value_bytes</CheckRefs>(pData);</Line>
  <Line number="2528">        if( nWrite!=n ){</Line>
  <Line number="2529">          rc = 1;</Line>
  <Line number="2530">        }</Line>
  <Line number="2531">      }</Line>
  <Line number="2532">      fclose(out);</Line>
  <Line number="2533">      if( rc==0 &amp;&amp; mode &amp;&amp; chmod(zFile, mode &amp; <CheckRefs ids="1172">0777</CheckRefs>) ){</Line>
  <Line number="2534">        rc = 1;</Line>
  <Line number="2535">      }</Line>
  <Line number="2536">      if( rc ) return 2;</Line>
  <Line number="2537">      sqlite3_result_int64(pCtx, nWrite);</Line>
  <Line number="2538">    }</Line>
  <Line number="2539">  }</Line>
  <Line number="2540"></Line>
  <Line number="2541">  if( mtime&gt;=<CheckRefs ids="1173">0</CheckRefs> ){</Line>
  <Line number="2542">#if defined(_WIN32)</Line>
  <Line number="2543">#if !SQLITE_OS_WINRT</Line>
  <Line number="2544">    /* Windows */</Line>
  <Line number="2545">    FILETIME lastAccess;</Line>
  <Line number="2546">    FILETIME lastWrite;</Line>
  <Line number="2547">    SYSTEMTIME currentTime;</Line>
  <Line number="2548">    LONGLONG intervals;</Line>
  <Line number="2549">    HANDLE hFile;</Line>
  <Line number="2550">    LPWSTR zUnicodeName;</Line>
  <Line number="2551">    extern LPWSTR sqlite3_win32_utf8_to_unicode(const char*);</Line>
  <Line number="2552"></Line>
  <Line number="2553">    GetSystemTime(&amp;currentTime);</Line>
  <Line number="2554">    SystemTimeToFileTime(&amp;currentTime, &amp;lastAccess);</Line>
  <Line number="2555">    intervals = Int32x32To64(mtime, 10000000) + 116444736000000000;</Line>
  <Line number="2556">    lastWrite.dwLowDateTime = (DWORD)intervals;</Line>
  <Line number="2557">    lastWrite.dwHighDateTime = intervals &gt;&gt; 32;</Line>
  <Line number="2558">    zUnicodeName = sqlite3_win32_utf8_to_unicode(zFile);</Line>
  <Line number="2559">    if( zUnicodeName==0 ){</Line>
  <Line number="2560">      return 1;</Line>
  <Line number="2561">    }</Line>
  <Line number="2562">    hFile = CreateFileW(</Line>
  <Line number="2563">      zUnicodeName, FILE_WRITE_ATTRIBUTES, 0, NULL, OPEN_EXISTING,</Line>
  <Line number="2564">      FILE_FLAG_BACKUP_SEMANTICS, NULL</Line>
  <Line number="2565">    );</Line>
  <Line number="2566">    sqlite3_free(zUnicodeName);</Line>
  <Line number="2567">    if( hFile!=INVALID_HANDLE_VALUE ){</Line>
  <Line number="2568">      BOOL bResult = SetFileTime(hFile, NULL, &amp;lastAccess, &amp;lastWrite);</Line>
  <Line number="2569">      CloseHandle(hFile);</Line>
  <Line number="2570">      return !bResult;</Line>
  <Line number="2571">    }else{</Line>
  <Line number="2572">      return 1;</Line>
  <Line number="2573">    }</Line>
  <Line number="2574">#endif</Line>
  <Line number="2575">#elif defined(AT_FDCWD) &amp;&amp; 0 /* utimensat() is not universally available */</Line>
  <Line number="2576">    /* Recent unix */</Line>
  <Line number="2577">    struct timespec times[2];</Line>
  <Line number="2578">    times[0].tv_nsec = times[1].tv_nsec = 0;</Line>
  <Line number="2579">    times[0].tv_sec = time(0);</Line>
  <Line number="2580">    times[1].tv_sec = mtime;</Line>
  <Line number="2581">    if( utimensat(AT_FDCWD, zFile, times, AT_SYMLINK_NOFOLLOW) ){</Line>
  <Line number="2582">      return 1;</Line>
  <Line number="2583">    }</Line>
  <Line number="2584">#else</Line>
  <Line number="2585">    /* Legacy unix */</Line>
  <Line number="2586">    struct timeval times[2];</Line>
  <Line number="2587">    times[0<CheckRefs ids="1174">]</CheckRefs>.tv_usec = times[1<CheckRefs ids="1175">]</CheckRefs>.tv_usec = <CheckRefs ids="1176">0</CheckRefs>;</Line>
  <Line number="2588">    times[0<CheckRefs ids="1177">]</CheckRefs>.tv_sec = time(0);</Line>
  <Line number="2589">    times[1<CheckRefs ids="1178">]</CheckRefs>.tv_sec = <CheckRefs ids="1179">mtime</CheckRefs>;</Line>
  <Line number="2590">    if( utimes(zFile, times) ){</Line>
  <Line number="2591">      return 1;</Line>
  <Line number="2592">    }</Line>
  <Line number="2593">#endif</Line>
  <Line number="2594">  }</Line>
  <Line number="2595"></Line>
  <Line number="2596">  return 0;</Line>
  <Line number="2597">}</Line>
  <Line number="2598"></Line>
  <Line number="2599">/*</Line>
  <Line number="2600">** Implementation of the &quot;writefile(W,X[,Y[,Z]]])&quot; SQL function.  </Line>
  <Line number="2601">** Refer to header comments at the top of this file for details.</Line>
  <Line number="2602">*/</Line>
  <Line number="2603">static void writefileFunc(</Line>
  <Line number="2604">  sqlite3_context *context,</Line>
  <Line number="2605">  int argc,</Line>
  <Line number="2606">  sqlite3_value **argv</Line>
  <Line number="2607">){</Line>
  <Line number="2608">  const char *zFile;</Line>
  <Line number="2609">  mode_t mode = <CheckRefs ids="1180">0</CheckRefs>;</Line>
  <Line number="2610">  int res;</Line>
  <Line number="2611">  sqlite3_int64 mtime = <CheckRefs ids="1181,1182">-</CheckRefs>1;</Line>
  <Line number="2612"></Line>
  <Line number="2613">  if( argc&lt;2 || argc&gt;4 ){</Line>
  <Line number="2614">    sqlite3_result_error(context, </Line>
  <Line number="2615">        &quot;wrong number of arguments to function writefile()&quot;, <CheckRefs ids="1183">-</CheckRefs>1</Line>
  <Line number="2616">    );</Line>
  <Line number="2617">    return;</Line>
  <Line number="2618">  }</Line>
  <Line number="2619"></Line>
  <Line number="2620">  zFile = (const char*)sqlite3_value_text(argv[0]);</Line>
  <Line number="2621">  if( zFile==0 ) return;</Line>
  <Line number="2622">  if( argc&gt;=3 ){</Line>
  <Line number="2623">    mode = <CheckRefs ids="1184">(</CheckRefs>mode_t)sqlite3_value_int(argv[2]);</Line>
  <Line number="2624">  }</Line>
  <Line number="2625">  if( argc==4 ){</Line>
  <Line number="2626">    mtime = sqlite3_value_int64(argv[3]);</Line>
  <Line number="2627">  }</Line>
  <Line number="2628"></Line>
  <Line number="2629">  res = writeFile(context, zFile, argv[1], mode, mtime);</Line>
  <Line number="2630">  if( res==1 &amp;&amp; errno==ENOENT ){</Line>
  <Line number="2631">    if( makeDirectory(zFile)==SQLITE_OK ){</Line>
  <Line number="2632">      res = writeFile(context, zFile, argv[1], mode, mtime);</Line>
  <Line number="2633">    }</Line>
  <Line number="2634">  }</Line>
  <Line number="2635"></Line>
  <Line number="2636">  if( argc&gt;2 &amp;&amp; res!=0 ){</Line>
  <Line number="2637">    if( <CheckRefs ids="1186,1185">S_ISLNK</CheckRefs>(mode) ){</Line>
  <Line number="2638">      ctxErrorMsg(context, &quot;failed to create symlink: %s&quot;, zFile);</Line>
  <Line number="2639">    }else if( <CheckRefs ids="1187,1188">S_ISDIR</CheckRefs>(mode) ){</Line>
  <Line number="2640">      ctxErrorMsg(context, &quot;failed to create directory: %s&quot;, zFile);</Line>
  <Line number="2641">    }else{</Line>
  <Line number="2642">      ctxErrorMsg(context, &quot;failed to write file: %s&quot;, zFile);</Line>
  <Line number="2643">    }</Line>
  <Line number="2644">  }</Line>
  <Line number="2645">}</Line>
  <Line number="2646"></Line>
  <Line number="2647">/*</Line>
  <Line number="2648">** SQL function:   lsmode(MODE)</Line>
  <Line number="2649">**</Line>
  <Line number="2650">** Given a numberic st_mode from stat(), convert it into a human-readable</Line>
  <Line number="2651">** text string in the style of &quot;ls -l&quot;.</Line>
  <Line number="2652">*/</Line>
  <Line number="2653">static void lsModeFunc(</Line>
  <Line number="2654">  sqlite3_context *context,</Line>
  <Line number="2655">  int argc,</Line>
  <Line number="2656">  sqlite3_value **argv</Line>
  <Line number="2657">){</Line>
  <Line number="2658">  int i;</Line>
  <Line number="2659">  int iMode = sqlite3_value_int(argv[0]);</Line>
  <Line number="2660">  char z[16];</Line>
  <Line number="2661">  (void)argc;</Line>
  <Line number="2662">  if( S_ISLNK(iMode) ){</Line>
  <Line number="2663">    z[0<CheckRefs ids="1189">]</CheckRefs> = <CheckRefs ids="1190">&apos;l&apos;</CheckRefs>;</Line>
  <Line number="2664">  }else if( S_ISREG(iMode) ){</Line>
  <Line number="2665">    z[0<CheckRefs ids="1191">]</CheckRefs> = <CheckRefs ids="1192">&apos;-&apos;</CheckRefs>;</Line>
  <Line number="2666">  }else if( S_ISDIR(iMode) ){</Line>
  <Line number="2667">    z[0<CheckRefs ids="1193">]</CheckRefs> = <CheckRefs ids="1194">&apos;d&apos;</CheckRefs>;</Line>
  <Line number="2668">  }else{</Line>
  <Line number="2669">    z[0<CheckRefs ids="1195">]</CheckRefs> = <CheckRefs ids="1196">&apos;?&apos;</CheckRefs>;</Line>
  <Line number="2670">  }</Line>
  <Line number="2671">  for(i=0; i&lt;3; i<CheckRefs ids="1197">++</CheckRefs>){</Line>
  <Line number="2672">    int m = (iMode <CheckRefs ids="1198,1199,1200">&gt;&gt;</CheckRefs> ((2<CheckRefs ids="1202">-</CheckRefs>i)<CheckRefs ids="1201">*</CheckRefs>3));</Line>
  <Line number="2673">    char *a = &amp;z[1 <CheckRefs ids="1204">+</CheckRefs> i<CheckRefs ids="1205">*</CheckRefs>3<CheckRefs ids="1203">]</CheckRefs>;</Line>
  <Line number="2674">    a[0] = <CheckRefs ids="1206">(</CheckRefs>m &amp; 0x4) ? &apos;r&apos; : &apos;-&apos;;</Line>
  <Line number="2675">    a[1] = <CheckRefs ids="1207">(</CheckRefs>m &amp; 0x2) ? &apos;w&apos; : &apos;-&apos;;</Line>
  <Line number="2676">    a[2] = <CheckRefs ids="1208">(</CheckRefs>m &amp; 0x1) ? &apos;x&apos; : &apos;-&apos;;</Line>
  <Line number="2677">  }</Line>
  <Line number="2678">  z[10<CheckRefs ids="1209">]</CheckRefs> = <CheckRefs ids="1210">&apos;\0&apos;</CheckRefs>;</Line>
  <Line number="2679">  sqlite3_result_text(context, z, <CheckRefs ids="1211">-</CheckRefs>1, <CheckRefs ids="1212">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="2680">}</Line>
  <Line number="2681"></Line>
  <Line number="2682">#ifndef SQLITE_OMIT_VIRTUALTABLE</Line>
  <Line number="2683"></Line>
  <Line number="2684">/* </Line>
  <Line number="2685">** Cursor type for recursively iterating through a directory structure.</Line>
  <Line number="2686">*/</Line>
  <Line number="2687">typedef struct fsdir_cursor fsdir_cursor;</Line>
  <Line number="2688">typedef struct FsdirLevel FsdirLevel;</Line>
  <Line number="2689"></Line>
  <Line number="2690">struct FsdirLevel {</Line>
  <Line number="2691">  DIR *pDir;                 /* From opendir() */</Line>
  <Line number="2692">  char *zDir;                /* Name of directory (nul-terminated) */</Line>
  <Line number="2693">};</Line>
  <Line number="2694"></Line>
  <Line number="2695">struct fsdir_cursor {</Line>
  <Line number="2696">  sqlite3_vtab_cursor base;  /* Base class - must be first */</Line>
  <Line number="2697"></Line>
  <Line number="2698">  int nLvl;                  /* Number of entries in aLvl[] array */</Line>
  <Line number="2699">  int iLvl;                  /* Index of current entry */</Line>
  <Line number="2700">  FsdirLevel *aLvl;          /* Hierarchy of directories being traversed */</Line>
  <Line number="2701"></Line>
  <Line number="2702">  const char *zBase;</Line>
  <Line number="2703">  int nBase;</Line>
  <Line number="2704"></Line>
  <Line number="2705">  struct stat sStat;         /* Current lstat() results */</Line>
  <Line number="2706">  char *zPath;               /* Path to current entry */</Line>
  <Line number="2707">  sqlite3_int64 iRowid;      /* Current rowid */</Line>
  <Line number="2708">};</Line>
  <Line number="2709"></Line>
  <Line number="2710">typedef struct fsdir_tab fsdir_tab;</Line>
  <Line number="2711">struct fsdir_tab {</Line>
  <Line number="2712">  sqlite3_vtab base;         /* Base class - must be first */</Line>
  <Line number="2713">};</Line>
  <Line number="2714"></Line>
  <Line number="2715">/*</Line>
  <Line number="2716">** Construct a new fsdir virtual table object.</Line>
  <Line number="2717">*/</Line>
  <Line number="2718">static int fsdirConnect(</Line>
  <Line number="2719">  sqlite3 *db,</Line>
  <Line number="2720">  void *pAux,</Line>
  <Line number="2721">  int argc, const char *const*argv,</Line>
  <Line number="2722">  sqlite3_vtab **ppVtab,</Line>
  <Line number="2723">  char **pzErr</Line>
  <Line number="2724">){</Line>
  <Line number="2725">  fsdir_tab *pNew = 0;</Line>
  <Line number="2726">  int rc;</Line>
  <Line number="2727">  (void)pAux;</Line>
  <Line number="2728">  (void)argc;</Line>
  <Line number="2729">  (void)argv;</Line>
  <Line number="2730">  (void)pzErr;</Line>
  <Line number="2731">  rc = sqlite3_declare_vtab(db, &quot;CREATE TABLE x&quot; FSDIR_SCHEMA);</Line>
  <Line number="2732">  if( rc==SQLITE_OK ){</Line>
  <Line number="2733">    pNew = (fsdir_tab*)sqlite3_malloc( <CheckRefs ids="1213">sizeof</CheckRefs>(*pNew) );</Line>
  <Line number="2734">    if( pNew==0 ) return SQLITE_NOMEM;</Line>
  <Line number="2735">    memset(pNew, 0, sizeof(*pNew));</Line>
  <Line number="2736">    sqlite3_vtab_config(db, SQLITE_VTAB_DIRECTONLY);</Line>
  <Line number="2737">  }</Line>
  <Line number="2738">  *ppVtab = (sqlite3_vtab*)pNew;</Line>
  <Line number="2739">  return rc;</Line>
  <Line number="2740">}</Line>
  <Line number="2741"></Line>
  <Line number="2742">/*</Line>
  <Line number="2743">** This method is the destructor for fsdir vtab objects.</Line>
  <Line number="2744">*/</Line>
  <Line number="2745">static int fsdirDisconnect(sqlite3_vtab *pVtab){</Line>
  <Line number="2746">  sqlite3_free(pVtab);</Line>
  <Line number="2747">  return SQLITE_OK;</Line>
  <Line number="2748">}</Line>
  <Line number="2749"></Line>
  <Line number="2750">/*</Line>
  <Line number="2751">** Constructor for a new fsdir_cursor object.</Line>
  <Line number="2752">*/</Line>
  <Line number="2753">static int fsdirOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){</Line>
  <Line number="2754">  fsdir_cursor *pCur;</Line>
  <Line number="2755">  (void)p;</Line>
  <Line number="2756">  pCur = sqlite3_malloc( <CheckRefs ids="1214">sizeof</CheckRefs>(*pCur) );</Line>
  <Line number="2757">  if( pCur==0 ) return SQLITE_NOMEM;</Line>
  <Line number="2758">  memset(pCur, 0, sizeof(*pCur));</Line>
  <Line number="2759">  pCur-&gt;iLvl = <CheckRefs ids="1215">-</CheckRefs>1;</Line>
  <Line number="2760">  *ppCursor = &amp;pCur-&gt;base;</Line>
  <Line number="2761">  return SQLITE_OK;</Line>
  <Line number="2762">}</Line>
  <Line number="2763"></Line>
  <Line number="2764">/*</Line>
  <Line number="2765">** Reset a cursor back to the state it was in when first returned</Line>
  <Line number="2766">** by fsdirOpen().</Line>
  <Line number="2767">*/</Line>
  <Line number="2768">static void fsdirResetCursor(fsdir_cursor *pCur){</Line>
  <Line number="2769">  int i;</Line>
  <Line number="2770">  for(i=0; i&lt;=pCur-&gt;iLvl; i<CheckRefs ids="1216">++</CheckRefs>){</Line>
  <Line number="2771">    FsdirLevel *pLvl = &amp;pCur-&gt;aLvl[i];</Line>
  <Line number="2772">    if( pLvl-&gt;pDir ) closedir(pLvl-&gt;pDir);</Line>
  <Line number="2773">    sqlite3_free(pLvl-&gt;zDir);</Line>
  <Line number="2774">  }</Line>
  <Line number="2775">  sqlite3_free(pCur-&gt;zPath);</Line>
  <Line number="2776">  sqlite3_free(pCur-&gt;aLvl);</Line>
  <Line number="2777">  pCur-&gt;aLvl = 0;</Line>
  <Line number="2778">  pCur-&gt;zPath = 0;</Line>
  <Line number="2779">  pCur-&gt;zBase = 0;</Line>
  <Line number="2780">  pCur-&gt;nBase = 0;</Line>
  <Line number="2781">  pCur-&gt;nLvl = 0;</Line>
  <Line number="2782">  pCur-&gt;iLvl = <CheckRefs ids="1217">-</CheckRefs>1;</Line>
  <Line number="2783">  pCur-&gt;iRowid = <CheckRefs ids="1218">1</CheckRefs>;</Line>
  <Line number="2784">}</Line>
  <Line number="2785"></Line>
  <Line number="2786">/*</Line>
  <Line number="2787">** Destructor for an fsdir_cursor.</Line>
  <Line number="2788">*/</Line>
  <Line number="2789">static int fsdirClose(sqlite3_vtab_cursor *cur){</Line>
  <Line number="2790">  fsdir_cursor *pCur = (fsdir_cursor*)cur;</Line>
  <Line number="2791"></Line>
  <Line number="2792">  fsdirResetCursor(pCur);</Line>
  <Line number="2793">  sqlite3_free(pCur);</Line>
  <Line number="2794">  return SQLITE_OK;</Line>
  <Line number="2795">}</Line>
  <Line number="2796"></Line>
  <Line number="2797">/*</Line>
  <Line number="2798">** Set the error message for the virtual table associated with cursor</Line>
  <Line number="2799">** pCur to the results of vprintf(zFmt, ...).</Line>
  <Line number="2800">*/</Line>
  <Line number="2801">static void fsdirSetErrmsg(fsdir_cursor *pCur, const char *zFmt, ...){</Line>
  <Line number="2802">  va_list ap;</Line>
  <Line number="2803">  va_start(ap, zFmt);</Line>
  <Line number="2804">  pCur-&gt;base.pVtab-&gt;zErrMsg = sqlite3_vmprintf(zFmt, ap);</Line>
  <Line number="2805">  va_end(ap);</Line>
  <Line number="2806">}</Line>
  <Line number="2807"></Line>
  <Line number="2808"></Line>
  <Line number="2809">/*</Line>
  <Line number="2810">** Advance an fsdir_cursor to its next row of output.</Line>
  <Line number="2811">*/</Line>
  <Line number="2812">static int fsdirNext(sqlite3_vtab_cursor *cur){</Line>
  <Line number="2813">  fsdir_cursor *pCur = (fsdir_cursor*)cur;</Line>
  <Line number="2814">  mode_t m = pCur-&gt;sStat.st_mode;</Line>
  <Line number="2815"></Line>
  <Line number="2816">  pCur-&gt;iRowid<CheckRefs ids="1219">++</CheckRefs>;</Line>
  <Line number="2817">  if( <CheckRefs ids="1221,1220">S_ISDIR</CheckRefs>(m) ){</Line>
  <Line number="2818">    /* Descend into this directory */</Line>
  <Line number="2819">    int iNew = pCur-&gt;iLvl <CheckRefs ids="1222">+</CheckRefs> 1;</Line>
  <Line number="2820">    FsdirLevel *pLvl;</Line>
  <Line number="2821">    if( iNew&gt;=pCur-&gt;nLvl ){</Line>
  <Line number="2822">      int nNew = iNew<CheckRefs ids="1223">+</CheckRefs>1;</Line>
  <Line number="2823">      sqlite3_int64 nByte = <CheckRefs ids="1226">nNew</CheckRefs><CheckRefs ids="1224,1225">*</CheckRefs>sizeof(FsdirLevel);</Line>
  <Line number="2824">      FsdirLevel *aNew = (FsdirLevel*)sqlite3_realloc64(pCur-&gt;aLvl, <CheckRefs ids="1227">nByte</CheckRefs>);</Line>
  <Line number="2825">      if( aNew==0 ) return SQLITE_NOMEM;</Line>
  <Line number="2826">      memset(&amp;aNew[pCur-&gt;nLvl], 0, sizeof(FsdirLevel)<CheckRefs ids="1228">*</CheckRefs><CheckRefs ids="1229">(</CheckRefs>nNew<CheckRefs ids="1230">-</CheckRefs>pCur-&gt;nLvl));</Line>
  <Line number="2827">      pCur-&gt;aLvl = aNew;</Line>
  <Line number="2828">      pCur-&gt;nLvl = nNew;</Line>
  <Line number="2829">    }</Line>
  <Line number="2830">    pCur-&gt;iLvl = iNew;</Line>
  <Line number="2831">    pLvl = &amp;pCur-&gt;aLvl[iNew];</Line>
  <Line number="2832">    </Line>
  <Line number="2833">    pLvl-&gt;zDir = pCur-&gt;zPath;</Line>
  <Line number="2834">    pCur-&gt;zPath = 0;</Line>
  <Line number="2835">    pLvl-&gt;pDir = opendir(pLvl-&gt;zDir);</Line>
  <Line number="2836">    if( pLvl-&gt;pDir==0 ){</Line>
  <Line number="2837">      fsdirSetErrmsg(pCur, &quot;cannot read directory: %s&quot;, pCur-&gt;zPath);</Line>
  <Line number="2838">      return SQLITE_ERROR;</Line>
  <Line number="2839">    }</Line>
  <Line number="2840">  }</Line>
  <Line number="2841"></Line>
  <Line number="2842">  while( pCur-&gt;iLvl&gt;=0 ){</Line>
  <Line number="2843">    FsdirLevel *pLvl = &amp;pCur-&gt;aLvl[pCur-&gt;iLvl];</Line>
  <Line number="2844">    struct dirent *pEntry = readdir(pLvl-&gt;pDir);</Line>
  <Line number="2845">    if( pEntry ){</Line>
  <Line number="2846">      if( <CheckRefs ids="1231">pEntry</CheckRefs>-&gt;d_name[0<CheckRefs ids="1232">]</CheckRefs>==&apos;.&apos; ){</Line>
  <Line number="2847">       if( <CheckRefs ids="1233">pEntry</CheckRefs>-&gt;d_name[1<CheckRefs ids="1234">]</CheckRefs>==&apos;.&apos; &amp;&amp; <CheckRefs ids="1235">pEntry</CheckRefs>-&gt;d_name[2<CheckRefs ids="1236">]</CheckRefs>==&apos;\0&apos; ) continue;</Line>
  <Line number="2848">       if( <CheckRefs ids="1237">pEntry</CheckRefs>-&gt;d_name[1<CheckRefs ids="1238">]</CheckRefs>==&apos;\0&apos; ) continue;</Line>
  <Line number="2849">      }</Line>
  <Line number="2850">      sqlite3_free(pCur-&gt;zPath);</Line>
  <Line number="2851">      pCur-&gt;zPath = sqlite3_mprintf(&quot;%s/%s&quot;, pLvl-&gt;zDir, pEntry-&gt;d_name);</Line>
  <Line number="2852">      if( pCur-&gt;zPath==0 ) return SQLITE_NOMEM;</Line>
  <Line number="2853">      if( fileLinkStat(pCur-&gt;zPath, &amp;pCur-&gt;sStat) ){</Line>
  <Line number="2854">        fsdirSetErrmsg(pCur, &quot;cannot stat file: %s&quot;, pCur-&gt;zPath);</Line>
  <Line number="2855">        return SQLITE_ERROR;</Line>
  <Line number="2856">      }</Line>
  <Line number="2857">      return SQLITE_OK;</Line>
  <Line number="2858">    }</Line>
  <Line number="2859">    closedir(pLvl-&gt;pDir);</Line>
  <Line number="2860">    sqlite3_free(pLvl-&gt;zDir);</Line>
  <Line number="2861">    pLvl-&gt;pDir = 0;</Line>
  <Line number="2862">    pLvl-&gt;zDir = 0;</Line>
  <Line number="2863">    pCur-&gt;iLvl<CheckRefs ids="1239">--</CheckRefs>;</Line>
  <Line number="2864">  }</Line>
  <Line number="2865"></Line>
  <Line number="2866">  /* EOF */</Line>
  <Line number="2867">  sqlite3_free(pCur-&gt;zPath);</Line>
  <Line number="2868">  pCur-&gt;zPath = 0;</Line>
  <Line number="2869">  return SQLITE_OK;</Line>
  <Line number="2870">}</Line>
  <Line number="2871"></Line>
  <Line number="2872">/*</Line>
  <Line number="2873">** Return values of columns for the row at which the series_cursor</Line>
  <Line number="2874">** is currently pointing.</Line>
  <Line number="2875">*/</Line>
  <Line number="2876">static int fsdirColumn(</Line>
  <Line number="2877">  sqlite3_vtab_cursor *cur,   /* The cursor */</Line>
  <Line number="2878">  sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */</Line>
  <Line number="2879">  int i                       /* Which column to return */</Line>
  <Line number="2880">){</Line>
  <Line number="2881">  fsdir_cursor *pCur = (fsdir_cursor*)cur;</Line>
  <Line number="2882">  switch( i ){</Line>
  <Line number="2883">    case FSDIR_COLUMN_NAME: {</Line>
  <Line number="2884">      sqlite3_result_text(ctx, &amp;pCur-&gt;zPath[pCur-&gt;nBase], <CheckRefs ids="1240">-</CheckRefs>1, <CheckRefs ids="1241">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="2885">      break;</Line>
  <Line number="2886">    }</Line>
  <Line number="2887"></Line>
  <Line number="2888">    case FSDIR_COLUMN_MODE:</Line>
  <Line number="2889">      sqlite3_result_int64(ctx, <CheckRefs ids="1242">pCur</CheckRefs>-&gt;sStat.st_mode);</Line>
  <Line number="2890">      break;</Line>
  <Line number="2891"></Line>
  <Line number="2892">    case FSDIR_COLUMN_MTIME:</Line>
  <Line number="2893">      sqlite3_result_int64(ctx, <CheckRefs ids="1243">pCur</CheckRefs>-&gt;sStat.st_mtime);</Line>
  <Line number="2894">      break;</Line>
  <Line number="2895"></Line>
  <Line number="2896">    case FSDIR_COLUMN_DATA: {</Line>
  <Line number="2897">      mode_t m = pCur-&gt;sStat.st_mode;</Line>
  <Line number="2898">      if( <CheckRefs ids="1244,1245">S_ISDIR</CheckRefs>(m) ){</Line>
  <Line number="2899">        sqlite3_result_null(ctx);</Line>
  <Line number="2900">#if !defined(_WIN32) &amp;&amp; !defined(WIN32)</Line>
  <Line number="2901">      }else if( <CheckRefs ids="1246,1247">S_ISLNK</CheckRefs>(m) ){</Line>
  <Line number="2902">        char aStatic[64];</Line>
  <Line number="2903">        char *aBuf = aStatic;</Line>
  <Line number="2904">        sqlite3_int64 nBuf = <CheckRefs ids="1248">64</CheckRefs>;</Line>
  <Line number="2905">        int n;</Line>
  <Line number="2906"></Line>
  <Line number="2907">        while( 1 ){</Line>
  <Line number="2908">          n = <CheckRefs ids="1249">readlink</CheckRefs>(pCur-&gt;zPath, aBuf, <CheckRefs ids="1250">nBuf</CheckRefs>);</Line>
  <Line number="2909">          if( <CheckRefs ids="1251">n</CheckRefs>&lt;nBuf ) break;</Line>
  <Line number="2910">          if( aBuf!=aStatic ) sqlite3_free(aBuf);</Line>
  <Line number="2911">          nBuf = nBuf<CheckRefs ids="1252">*</CheckRefs><CheckRefs ids="1253">2</CheckRefs>;</Line>
  <Line number="2912">          aBuf = sqlite3_malloc64(<CheckRefs ids="1254">nBuf</CheckRefs>);</Line>
  <Line number="2913">          if( aBuf==0 ){</Line>
  <Line number="2914">            sqlite3_result_error_nomem(ctx);</Line>
  <Line number="2915">            return SQLITE_NOMEM;</Line>
  <Line number="2916">          }</Line>
  <Line number="2917">        }</Line>
  <Line number="2918"></Line>
  <Line number="2919">        sqlite3_result_text(ctx, aBuf, n, <CheckRefs ids="1255">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="2920">        if( aBuf!=aStatic ) sqlite3_free(aBuf);</Line>
  <Line number="2921">#endif</Line>
  <Line number="2922">      }else{</Line>
  <Line number="2923">        readFileContents(ctx, pCur-&gt;zPath);</Line>
  <Line number="2924">      }</Line>
  <Line number="2925">    }</Line>
  <Line number="2926">    case FSDIR_COLUMN_PATH:</Line>
  <Line number="2927">    default: {</Line>
  <Line number="2928">      /* The FSDIR_COLUMN_PATH and FSDIR_COLUMN_DIR are input parameters.</Line>
  <Line number="2929">      ** always return their values as NULL */</Line>
  <Line number="2930">      break;</Line>
  <Line number="2931">    }</Line>
  <Line number="2932">  }</Line>
  <Line number="2933">  return SQLITE_OK;</Line>
  <Line number="2934">}</Line>
  <Line number="2935"></Line>
  <Line number="2936">/*</Line>
  <Line number="2937">** Return the rowid for the current row. In this implementation, the</Line>
  <Line number="2938">** first row returned is assigned rowid value 1, and each subsequent</Line>
  <Line number="2939">** row a value 1 more than that of the previous.</Line>
  <Line number="2940">*/</Line>
  <Line number="2941">static int fsdirRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){</Line>
  <Line number="2942">  fsdir_cursor *pCur = (fsdir_cursor*)cur;</Line>
  <Line number="2943">  *pRowid = pCur-&gt;iRowid;</Line>
  <Line number="2944">  return SQLITE_OK;</Line>
  <Line number="2945">}</Line>
  <Line number="2946"></Line>
  <Line number="2947">/*</Line>
  <Line number="2948">** Return TRUE if the cursor has been moved off of the last</Line>
  <Line number="2949">** row of output.</Line>
  <Line number="2950">*/</Line>
  <Line number="2951">static int fsdirEof(sqlite3_vtab_cursor *cur){</Line>
  <Line number="2952">  fsdir_cursor *pCur = (fsdir_cursor*)cur;</Line>
  <Line number="2953">  return (pCur-&gt;zPath==0);</Line>
  <Line number="2954">}</Line>
  <Line number="2955"></Line>
  <Line number="2956">/*</Line>
  <Line number="2957">** xFilter callback.</Line>
  <Line number="2958">**</Line>
  <Line number="2959">** idxNum==1   PATH parameter only</Line>
  <Line number="2960">** idxNum==2   Both PATH and DIR supplied</Line>
  <Line number="2961">*/</Line>
  <Line number="2962">static int fsdirFilter(</Line>
  <Line number="2963">  sqlite3_vtab_cursor *cur, </Line>
  <Line number="2964">  int idxNum, const char *idxStr,</Line>
  <Line number="2965">  int argc, sqlite3_value **argv</Line>
  <Line number="2966">){</Line>
  <Line number="2967">  const char *zDir = 0;</Line>
  <Line number="2968">  fsdir_cursor *pCur = (fsdir_cursor*)cur;</Line>
  <Line number="2969">  (void)idxStr;</Line>
  <Line number="2970">  fsdirResetCursor(pCur);</Line>
  <Line number="2971"></Line>
  <Line number="2972">  if( idxNum==0 ){</Line>
  <Line number="2973">    fsdirSetErrmsg(pCur, &quot;table function fsdir requires an argument&quot;);</Line>
  <Line number="2974">    return SQLITE_ERROR;</Line>
  <Line number="2975">  }</Line>
  <Line number="2976"></Line>
  <Line number="2977">  <CheckRefs ids="1256">assert</CheckRefs>( argc==idxNum &amp;&amp; (argc==1 || argc==2) );</Line>
  <Line number="2978">  zDir = (const char*)sqlite3_value_text(argv[0]);</Line>
  <Line number="2979">  if( zDir==0 ){</Line>
  <Line number="2980">    fsdirSetErrmsg(pCur, &quot;table function fsdir requires a non-NULL argument&quot;);</Line>
  <Line number="2981">    return SQLITE_ERROR;</Line>
  <Line number="2982">  }</Line>
  <Line number="2983">  if( argc==2 ){</Line>
  <Line number="2984">    pCur-&gt;zBase = (const char*)sqlite3_value_text(argv[1]);</Line>
  <Line number="2985">  }</Line>
  <Line number="2986">  if( pCur-&gt;zBase ){</Line>
  <Line number="2987">    pCur-&gt;nBase = <CheckRefs ids="1258">(</CheckRefs>int)strlen(pCur-&gt;zBase)<CheckRefs ids="1257">+</CheckRefs>1;</Line>
  <Line number="2988">    pCur-&gt;zPath = sqlite3_mprintf(&quot;%s/%s&quot;, pCur-&gt;zBase, zDir);</Line>
  <Line number="2989">  }else{</Line>
  <Line number="2990">    pCur-&gt;zPath = sqlite3_mprintf(&quot;%s&quot;, zDir);</Line>
  <Line number="2991">  }</Line>
  <Line number="2992"></Line>
  <Line number="2993">  if( pCur-&gt;zPath==0 ){</Line>
  <Line number="2994">    return SQLITE_NOMEM;</Line>
  <Line number="2995">  }</Line>
  <Line number="2996">  if( fileLinkStat(pCur-&gt;zPath, &amp;pCur-&gt;sStat) ){</Line>
  <Line number="2997">    fsdirSetErrmsg(pCur, &quot;cannot stat file: %s&quot;, pCur-&gt;zPath);</Line>
  <Line number="2998">    return SQLITE_ERROR;</Line>
  <Line number="2999">  }</Line>
  <Line number="3000"></Line>
  <Line number="3001">  return SQLITE_OK;</Line>
  <Line number="3002">}</Line>
  <Line number="3003"></Line>
  <Line number="3004">/*</Line>
  <Line number="3005">** SQLite will invoke this method one or more times while planning a query</Line>
  <Line number="3006">** that uses the generate_series virtual table.  This routine needs to create</Line>
  <Line number="3007">** a query plan for each invocation and compute an estimated cost for that</Line>
  <Line number="3008">** plan.</Line>
  <Line number="3009">**</Line>
  <Line number="3010">** In this implementation idxNum is used to represent the</Line>
  <Line number="3011">** query plan.  idxStr is unused.</Line>
  <Line number="3012">**</Line>
  <Line number="3013">** The query plan is represented by values of idxNum:</Line>
  <Line number="3014">**</Line>
  <Line number="3015">**  (1)  The path value is supplied by argv[0]</Line>
  <Line number="3016">**  (2)  Path is in argv[0] and dir is in argv[1]</Line>
  <Line number="3017">*/</Line>
  <Line number="3018">static int fsdirBestIndex(</Line>
  <Line number="3019">  sqlite3_vtab *tab,</Line>
  <Line number="3020">  sqlite3_index_info *pIdxInfo</Line>
  <Line number="3021">){</Line>
  <Line number="3022">  int i;                 /* Loop over constraints */</Line>
  <Line number="3023">  int idxPath = <CheckRefs ids="1259">-</CheckRefs>1;      /* Index in pIdxInfo-&gt;aConstraint of PATH= */</Line>
  <Line number="3024">  int idxDir = <CheckRefs ids="1260">-</CheckRefs>1;       /* Index in pIdxInfo-&gt;aConstraint of DIR= */</Line>
  <Line number="3025">  int seenPath = 0;      /* True if an unusable PATH= constraint is seen */</Line>
  <Line number="3026">  int seenDir = 0;       /* True if an unusable DIR= constraint is seen */</Line>
  <Line number="3027">  const struct sqlite3_index_constraint *pConstraint;</Line>
  <Line number="3028"></Line>
  <Line number="3029">  (void)tab;</Line>
  <Line number="3030">  pConstraint = pIdxInfo-&gt;aConstraint;</Line>
  <Line number="3031">  for(i=0; i&lt;pIdxInfo-&gt;nConstraint; i<CheckRefs ids="1261">++</CheckRefs>, pConstraint++){</Line>
  <Line number="3032">    if( <CheckRefs ids="1262">pConstraint</CheckRefs>-&gt;op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;</Line>
  <Line number="3033">    switch( pConstraint-&gt;iColumn ){</Line>
  <Line number="3034">      case FSDIR_COLUMN_PATH: {</Line>
  <Line number="3035">        if( pConstraint-&gt;usable ){</Line>
  <Line number="3036">          idxPath = i;</Line>
  <Line number="3037">          seenPath = 0;</Line>
  <Line number="3038">        }else if( idxPath&lt;0 ){</Line>
  <Line number="3039">          seenPath = 1;</Line>
  <Line number="3040">        }</Line>
  <Line number="3041">        break;</Line>
  <Line number="3042">      }</Line>
  <Line number="3043">      case FSDIR_COLUMN_DIR: {</Line>
  <Line number="3044">        if( pConstraint-&gt;usable ){</Line>
  <Line number="3045">          idxDir = i;</Line>
  <Line number="3046">          seenDir = 0;</Line>
  <Line number="3047">        }else if( idxDir&lt;0 ){</Line>
  <Line number="3048">          seenDir = 1;</Line>
  <Line number="3049">        }</Line>
  <Line number="3050">        break;</Line>
  <Line number="3051">      }</Line>
  <Line number="3052">    } </Line>
  <Line number="3053">  }</Line>
  <Line number="3054">  if( seenPath || seenDir ){</Line>
  <Line number="3055">    /* If input parameters are unusable, disallow this plan */</Line>
  <Line number="3056">    return SQLITE_CONSTRAINT;</Line>
  <Line number="3057">  }</Line>
  <Line number="3058"></Line>
  <Line number="3059">  if( idxPath&lt;0 ){</Line>
  <Line number="3060">    pIdxInfo-&gt;idxNum = 0;</Line>
  <Line number="3061">    /* The pIdxInfo-&gt;estimatedCost should have been initialized to a huge</Line>
  <Line number="3062">    ** number.  Leave it unchanged. */</Line>
  <Line number="3063">    pIdxInfo-&gt;estimatedRows = <CheckRefs ids="1263">0x7fffffff</CheckRefs>;</Line>
  <Line number="3064">  }else{</Line>
  <Line number="3065">    pIdxInfo-&gt;aConstraintUsage[idxPath].omit = <CheckRefs ids="1264">1</CheckRefs>;</Line>
  <Line number="3066">    pIdxInfo-&gt;aConstraintUsage[idxPath].argvIndex = 1;</Line>
  <Line number="3067">    if( idxDir&gt;=0 ){</Line>
  <Line number="3068">      pIdxInfo-&gt;aConstraintUsage[idxDir].omit = <CheckRefs ids="1265">1</CheckRefs>;</Line>
  <Line number="3069">      pIdxInfo-&gt;aConstraintUsage[idxDir].argvIndex = 2;</Line>
  <Line number="3070">      pIdxInfo-&gt;idxNum = 2;</Line>
  <Line number="3071">      pIdxInfo-&gt;estimatedCost <CheckRefs ids="1266">=</CheckRefs> 10.0;</Line>
  <Line number="3072">    }else{</Line>
  <Line number="3073">      pIdxInfo-&gt;idxNum = 1;</Line>
  <Line number="3074">      pIdxInfo-&gt;estimatedCost <CheckRefs ids="1267">=</CheckRefs> 100.0;</Line>
  <Line number="3075">    }</Line>
  <Line number="3076">  }</Line>
  <Line number="3077"></Line>
  <Line number="3078">  return SQLITE_OK;</Line>
  <Line number="3079">}</Line>
  <Line number="3080"></Line>
  <Line number="3081">/*</Line>
  <Line number="3082">** Register the &quot;fsdir&quot; virtual table.</Line>
  <Line number="3083">*/</Line>
  <Line number="3084">static int fsdirRegister(sqlite3 *db){</Line>
  <Line number="3085">  static sqlite3_module fsdirModule = {</Line>
  <Line number="3086">    0,                         /* iVersion */</Line>
  <Line number="3087">    0,                         /* xCreate */</Line>
  <Line number="3088">    fsdirConnect,              /* xConnect */</Line>
  <Line number="3089">    fsdirBestIndex,            /* xBestIndex */</Line>
  <Line number="3090">    fsdirDisconnect,           /* xDisconnect */</Line>
  <Line number="3091">    0,                         /* xDestroy */</Line>
  <Line number="3092">    fsdirOpen,                 /* xOpen - open a cursor */</Line>
  <Line number="3093">    fsdirClose,                /* xClose - close a cursor */</Line>
  <Line number="3094">    fsdirFilter,               /* xFilter - configure scan constraints */</Line>
  <Line number="3095">    fsdirNext,                 /* xNext - advance a cursor */</Line>
  <Line number="3096">    fsdirEof,                  /* xEof - check for end of scan */</Line>
  <Line number="3097">    fsdirColumn,               /* xColumn - read data */</Line>
  <Line number="3098">    fsdirRowid,                /* xRowid - read data */</Line>
  <Line number="3099">    0,                         /* xUpdate */</Line>
  <Line number="3100">    0,                         /* xBegin */</Line>
  <Line number="3101">    0,                         /* xSync */</Line>
  <Line number="3102">    0,                         /* xCommit */</Line>
  <Line number="3103">    0,                         /* xRollback */</Line>
  <Line number="3104">    0,                         /* xFindMethod */</Line>
  <Line number="3105">    0,                         /* xRename */</Line>
  <Line number="3106">    0,                         /* xSavepoint */</Line>
  <Line number="3107">    0,                         /* xRelease */</Line>
  <Line number="3108">    0,                         /* xRollbackTo */</Line>
  <Line number="3109">    0,                         /* xShadowName */</Line>
  <Line number="3110">  };</Line>
  <Line number="3111"></Line>
  <Line number="3112">  int rc = sqlite3_create_module(db, &quot;fsdir&quot;, &amp;fsdirModule, 0);</Line>
  <Line number="3113">  return rc;</Line>
  <Line number="3114">}</Line>
  <Line number="3115">#else         /* SQLITE_OMIT_VIRTUALTABLE */</Line>
  <Line number="3116"># define fsdirRegister(x) SQLITE_OK</Line>
  <Line number="3117">#endif</Line>
  <Line number="3118"></Line>
  <Line number="3119">#ifdef _WIN32</Line>
  <Line number="3120"></Line>
  <Line number="3121">#endif</Line>
  <Line number="3122">int sqlite3_fileio_init(</Line>
  <Line number="3123">  sqlite3 *db, </Line>
  <Line number="3124">  char **pzErrMsg, </Line>
  <Line number="3125">  const sqlite3_api_routines *pApi</Line>
  <Line number="3126">){</Line>
  <Line number="3127">  int rc = SQLITE_OK;</Line>
  <Line number="3128">  SQLITE_EXTENSION_INIT2(pApi);</Line>
  <Line number="3129">  (void)pzErrMsg;  /* Unused parameter */</Line>
  <Line number="3130">  rc = sqlite3_create_function(db, &quot;readfile&quot;, 1, </Line>
  <Line number="3131">                               SQLITE_UTF8|SQLITE_DIRECTONLY, 0,</Line>
  <Line number="3132">                               readfileFunc, 0, 0);</Line>
  <Line number="3133">  if( rc==SQLITE_OK ){</Line>
  <Line number="3134">    rc = sqlite3_create_function(db, &quot;writefile&quot;, <CheckRefs ids="1268">-</CheckRefs>1,</Line>
  <Line number="3135">                                 SQLITE_UTF8|SQLITE_DIRECTONLY, 0,</Line>
  <Line number="3136">                                 writefileFunc, 0, 0);</Line>
  <Line number="3137">  }</Line>
  <Line number="3138">  if( rc==SQLITE_OK ){</Line>
  <Line number="3139">    rc = sqlite3_create_function(db, &quot;lsmode&quot;, 1, SQLITE_UTF8, 0,</Line>
  <Line number="3140">                                 lsModeFunc, 0, 0);</Line>
  <Line number="3141">  }</Line>
  <Line number="3142">  if( rc==SQLITE_OK ){</Line>
  <Line number="3143">    rc = fsdirRegister(db);</Line>
  <Line number="3144">  }</Line>
  <Line number="3145">  return rc;</Line>
  <Line number="3146">}</Line>
  <Line number="3147"></Line>
  <Line number="3148">/************************* End ../ext/misc/fileio.c ********************/</Line>
  <Line number="3149">/************************* Begin ../ext/misc/completion.c ******************/</Line>
  <Line number="3150">/*</Line>
  <Line number="3151">** 2017-07-10</Line>
  <Line number="3152">**</Line>
  <Line number="3153">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="3154">** a legal notice, here is a blessing:</Line>
  <Line number="3155">**</Line>
  <Line number="3156">**    May you do good and not evil.</Line>
  <Line number="3157">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="3158">**    May you share freely, never taking more than you give.</Line>
  <Line number="3159">**</Line>
  <Line number="3160">*************************************************************************</Line>
  <Line number="3161">**</Line>
  <Line number="3162">** This file implements an eponymous virtual table that returns suggested</Line>
  <Line number="3163">** completions for a partial SQL input.</Line>
  <Line number="3164">**</Line>
  <Line number="3165">** Suggested usage:</Line>
  <Line number="3166">**</Line>
  <Line number="3167">**     SELECT DISTINCT candidate COLLATE nocase</Line>
  <Line number="3168">**       FROM completion($prefix,$wholeline)</Line>
  <Line number="3169">**      ORDER BY 1;</Line>
  <Line number="3170">**</Line>
  <Line number="3171">** The two query parameters are optional.  $prefix is the text of the</Line>
  <Line number="3172">** current word being typed and that is to be completed.  $wholeline is</Line>
  <Line number="3173">** the complete input line, used for context.</Line>
  <Line number="3174">**</Line>
  <Line number="3175">** The raw completion() table might return the same candidate multiple</Line>
  <Line number="3176">** times, for example if the same column name is used to two or more</Line>
  <Line number="3177">** tables.  And the candidates are returned in an arbitrary order.  Hence,</Line>
  <Line number="3178">** the DISTINCT and ORDER BY are recommended.</Line>
  <Line number="3179">**</Line>
  <Line number="3180">** This virtual table operates at the speed of human typing, and so there</Line>
  <Line number="3181">** is no attempt to make it fast.  Even a slow implementation will be much</Line>
  <Line number="3182">** faster than any human can type.</Line>
  <Line number="3183">**</Line>
  <Line number="3184">*/</Line>
  <Line number="3185">/* #include &quot;sqlite3ext.h&quot; */</Line>
  <Line number="3186">SQLITE_EXTENSION_INIT1</Line>
  <Line number="3187">#include &lt;assert.h&gt;</Line>
  <Line number="3188">#include &lt;string.h&gt;</Line>
  <Line number="3189">#include &lt;ctype.h&gt;</Line>
  <Line number="3190"></Line>
  <Line number="3191">#ifndef SQLITE_OMIT_VIRTUALTABLE</Line>
  <Line number="3192"></Line>
  <Line number="3193">/* completion_vtab is a subclass of sqlite3_vtab which will</Line>
  <Line number="3194">** serve as the underlying representation of a completion virtual table</Line>
  <Line number="3195">*/</Line>
  <Line number="3196">typedef struct completion_vtab completion_vtab;</Line>
  <Line number="3197">struct completion_vtab {</Line>
  <Line number="3198">  sqlite3_vtab base;  /* Base class - must be first */</Line>
  <Line number="3199">  sqlite3 *db;        /* Database connection for this completion vtab */</Line>
  <Line number="3200">};</Line>
  <Line number="3201"></Line>
  <Line number="3202">/* completion_cursor is a subclass of sqlite3_vtab_cursor which will</Line>
  <Line number="3203">** serve as the underlying representation of a cursor that scans</Line>
  <Line number="3204">** over rows of the result</Line>
  <Line number="3205">*/</Line>
  <Line number="3206">typedef struct completion_cursor completion_cursor;</Line>
  <Line number="3207">struct completion_cursor {</Line>
  <Line number="3208">  sqlite3_vtab_cursor base;  /* Base class - must be first */</Line>
  <Line number="3209">  sqlite3 *db;               /* Database connection for this cursor */</Line>
  <Line number="3210">  int nPrefix, nLine;        /* Number of bytes in zPrefix and zLine */</Line>
  <Line number="3211">  char *zPrefix;             /* The prefix for the word we want to complete */</Line>
  <Line number="3212">  char *zLine;               /* The whole that we want to complete */</Line>
  <Line number="3213">  const char *zCurrentRow;   /* Current output row */</Line>
  <Line number="3214">  int szRow;                 /* Length of the zCurrentRow string */</Line>
  <Line number="3215">  sqlite3_stmt *pStmt;       /* Current statement */</Line>
  <Line number="3216">  sqlite3_int64 iRowid;      /* The rowid */</Line>
  <Line number="3217">  int ePhase;                /* Current phase */</Line>
  <Line number="3218">  int j;                     /* inter-phase counter */</Line>
  <Line number="3219">};</Line>
  <Line number="3220"></Line>
  <Line number="3221">/* Values for ePhase:</Line>
  <Line number="3222">*/</Line>
  <Line number="3223">#define COMPLETION_FIRST_PHASE   1</Line>
  <Line number="3224">#define COMPLETION_KEYWORDS      1</Line>
  <Line number="3225">#define COMPLETION_PRAGMAS       2</Line>
  <Line number="3226">#define COMPLETION_FUNCTIONS     3</Line>
  <Line number="3227">#define COMPLETION_COLLATIONS    4</Line>
  <Line number="3228">#define COMPLETION_INDEXES       5</Line>
  <Line number="3229">#define COMPLETION_TRIGGERS      6</Line>
  <Line number="3230">#define COMPLETION_DATABASES     7</Line>
  <Line number="3231">#define COMPLETION_TABLES        8    /* Also VIEWs and TRIGGERs */</Line>
  <Line number="3232">#define COMPLETION_COLUMNS       9</Line>
  <Line number="3233">#define COMPLETION_MODULES       10</Line>
  <Line number="3234">#define COMPLETION_EOF           11</Line>
  <Line number="3235"></Line>
  <Line number="3236">/*</Line>
  <Line number="3237">** The completionConnect() method is invoked to create a new</Line>
  <Line number="3238">** completion_vtab that describes the completion virtual table.</Line>
  <Line number="3239">**</Line>
  <Line number="3240">** Think of this routine as the constructor for completion_vtab objects.</Line>
  <Line number="3241">**</Line>
  <Line number="3242">** All this routine needs to do is:</Line>
  <Line number="3243">**</Line>
  <Line number="3244">**    (1) Allocate the completion_vtab object and initialize all fields.</Line>
  <Line number="3245">**</Line>
  <Line number="3246">**    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the</Line>
  <Line number="3247">**        result set of queries against completion will look like.</Line>
  <Line number="3248">*/</Line>
  <Line number="3249">static int completionConnect(</Line>
  <Line number="3250">  sqlite3 *db,</Line>
  <Line number="3251">  void *pAux,</Line>
  <Line number="3252">  int argc, const char *const*argv,</Line>
  <Line number="3253">  sqlite3_vtab **ppVtab,</Line>
  <Line number="3254">  char **pzErr</Line>
  <Line number="3255">){</Line>
  <Line number="3256">  completion_vtab *pNew;</Line>
  <Line number="3257">  int rc;</Line>
  <Line number="3258"></Line>
  <Line number="3259">  (void)(pAux);    /* Unused parameter */</Line>
  <Line number="3260">  (void)(argc);    /* Unused parameter */</Line>
  <Line number="3261">  (void)(argv);    /* Unused parameter */</Line>
  <Line number="3262">  (void)(pzErr);   /* Unused parameter */</Line>
  <Line number="3263"></Line>
  <Line number="3264">/* Column numbers */</Line>
  <Line number="3265">#define COMPLETION_COLUMN_CANDIDATE 0  /* Suggested completion of the input */</Line>
  <Line number="3266">#define COMPLETION_COLUMN_PREFIX    1  /* Prefix of the word to be completed */</Line>
  <Line number="3267">#define COMPLETION_COLUMN_WHOLELINE 2  /* Entire line seen so far */</Line>
  <Line number="3268">#define COMPLETION_COLUMN_PHASE     3  /* ePhase - used for debugging only */</Line>
  <Line number="3269"></Line>
  <Line number="3270">  sqlite3_vtab_config(db, SQLITE_VTAB_INNOCUOUS);</Line>
  <Line number="3271">  rc = sqlite3_declare_vtab(db,</Line>
  <Line number="3272">      &quot;CREATE TABLE x(&quot;</Line>
  <Line number="3273">      &quot;  candidate TEXT,&quot;</Line>
  <Line number="3274">      &quot;  prefix TEXT HIDDEN,&quot;</Line>
  <Line number="3275">      &quot;  wholeline TEXT HIDDEN,&quot;</Line>
  <Line number="3276">      &quot;  phase INT HIDDEN&quot;        /* Used for debugging only */</Line>
  <Line number="3277">      &quot;)&quot;);</Line>
  <Line number="3278">  if( rc==SQLITE_OK ){</Line>
  <Line number="3279">    pNew = sqlite3_malloc( <CheckRefs ids="1269">sizeof</CheckRefs>(*pNew) );</Line>
  <Line number="3280">    *ppVtab = (sqlite3_vtab*)pNew;</Line>
  <Line number="3281">    if( pNew==0 ) return SQLITE_NOMEM;</Line>
  <Line number="3282">    memset(pNew, 0, sizeof(*pNew));</Line>
  <Line number="3283">    pNew-&gt;db = db;</Line>
  <Line number="3284">  }</Line>
  <Line number="3285">  return rc;</Line>
  <Line number="3286">}</Line>
  <Line number="3287"></Line>
  <Line number="3288">/*</Line>
  <Line number="3289">** This method is the destructor for completion_cursor objects.</Line>
  <Line number="3290">*/</Line>
  <Line number="3291">static int completionDisconnect(sqlite3_vtab *pVtab){</Line>
  <Line number="3292">  sqlite3_free(pVtab);</Line>
  <Line number="3293">  return SQLITE_OK;</Line>
  <Line number="3294">}</Line>
  <Line number="3295"></Line>
  <Line number="3296">/*</Line>
  <Line number="3297">** Constructor for a new completion_cursor object.</Line>
  <Line number="3298">*/</Line>
  <Line number="3299">static int completionOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){</Line>
  <Line number="3300">  completion_cursor *pCur;</Line>
  <Line number="3301">  pCur = sqlite3_malloc( <CheckRefs ids="1270">sizeof</CheckRefs>(*pCur) );</Line>
  <Line number="3302">  if( pCur==0 ) return SQLITE_NOMEM;</Line>
  <Line number="3303">  memset(pCur, 0, sizeof(*pCur));</Line>
  <Line number="3304">  pCur-&gt;db = ((completion_vtab*)p)-&gt;db;</Line>
  <Line number="3305">  *ppCursor = &amp;pCur-&gt;base;</Line>
  <Line number="3306">  return SQLITE_OK;</Line>
  <Line number="3307">}</Line>
  <Line number="3308"></Line>
  <Line number="3309">/*</Line>
  <Line number="3310">** Reset the completion_cursor.</Line>
  <Line number="3311">*/</Line>
  <Line number="3312">static void completionCursorReset(completion_cursor *pCur){</Line>
  <Line number="3313">  sqlite3_free(pCur-&gt;zPrefix);   pCur-&gt;zPrefix = 0;  pCur-&gt;nPrefix = 0;</Line>
  <Line number="3314">  sqlite3_free(pCur-&gt;zLine);     pCur-&gt;zLine = 0;    pCur-&gt;nLine = 0;</Line>
  <Line number="3315">  sqlite3_finalize(pCur-&gt;pStmt); pCur-&gt;pStmt = 0;</Line>
  <Line number="3316">  pCur-&gt;j = 0;</Line>
  <Line number="3317">}</Line>
  <Line number="3318"></Line>
  <Line number="3319">/*</Line>
  <Line number="3320">** Destructor for a completion_cursor.</Line>
  <Line number="3321">*/</Line>
  <Line number="3322">static int completionClose(sqlite3_vtab_cursor *cur){</Line>
  <Line number="3323">  completionCursorReset((completion_cursor*)cur);</Line>
  <Line number="3324">  sqlite3_free(cur);</Line>
  <Line number="3325">  return SQLITE_OK;</Line>
  <Line number="3326">}</Line>
  <Line number="3327"></Line>
  <Line number="3328">/*</Line>
  <Line number="3329">** Advance a completion_cursor to its next row of output.</Line>
  <Line number="3330">**</Line>
  <Line number="3331">** The -&gt;ePhase, -&gt;j, and -&gt;pStmt fields of the completion_cursor object</Line>
  <Line number="3332">** record the current state of the scan.  This routine sets -&gt;zCurrentRow</Line>
  <Line number="3333">** to the current row of output and then returns.  If no more rows remain,</Line>
  <Line number="3334">** then -&gt;ePhase is set to COMPLETION_EOF which will signal the virtual</Line>
  <Line number="3335">** table that has reached the end of its scan.</Line>
  <Line number="3336">**</Line>
  <Line number="3337">** The current implementation just lists potential identifiers and</Line>
  <Line number="3338">** keywords and filters them by zPrefix.  Future enhancements should</Line>
  <Line number="3339">** take zLine into account to try to restrict the set of identifiers and</Line>
  <Line number="3340">** keywords based on what would be legal at the current point of input.</Line>
  <Line number="3341">*/</Line>
  <Line number="3342">static int completionNext(sqlite3_vtab_cursor *cur){</Line>
  <Line number="3343">  completion_cursor *pCur = (completion_cursor*)cur;</Line>
  <Line number="3344">  int eNextPhase = 0;  /* Next phase to try if current phase reaches end */</Line>
  <Line number="3345">  int iCol = <CheckRefs ids="1271">-</CheckRefs>1;       /* If &gt;=0, step pCur-&gt;pStmt and use the i-th column */</Line>
  <Line number="3346">  pCur-&gt;iRowid<CheckRefs ids="1272">++</CheckRefs>;</Line>
  <Line number="3347">  while( pCur-&gt;ePhase!=COMPLETION_EOF ){</Line>
  <Line number="3348">    switch( pCur-&gt;ePhase ){</Line>
  <Line number="3349">      case COMPLETION_KEYWORDS: {</Line>
  <Line number="3350">        if( pCur-&gt;j &gt;= sqlite3_keyword_count() ){</Line>
  <Line number="3351">          pCur-&gt;zCurrentRow = 0;</Line>
  <Line number="3352">          pCur-&gt;ePhase = COMPLETION_DATABASES;</Line>
  <Line number="3353">        }else{</Line>
  <Line number="3354">          sqlite3_keyword_name(pCur-&gt;j<CheckRefs ids="1273">++</CheckRefs>, &amp;pCur-&gt;zCurrentRow, &amp;pCur-&gt;szRow);</Line>
  <Line number="3355">        }</Line>
  <Line number="3356">        iCol = <CheckRefs ids="1274">-</CheckRefs>1;</Line>
  <Line number="3357">        break;</Line>
  <Line number="3358">      }</Line>
  <Line number="3359">      case COMPLETION_DATABASES: {</Line>
  <Line number="3360">        if( pCur-&gt;pStmt==0 ){</Line>
  <Line number="3361">          sqlite3_prepare_v2(pCur-&gt;db, &quot;PRAGMA database_list&quot;, <CheckRefs ids="1275">-</CheckRefs>1,</Line>
  <Line number="3362">                             &amp;pCur-&gt;pStmt, 0);</Line>
  <Line number="3363">        }</Line>
  <Line number="3364">        iCol = 1;</Line>
  <Line number="3365">        eNextPhase = COMPLETION_TABLES;</Line>
  <Line number="3366">        break;</Line>
  <Line number="3367">      }</Line>
  <Line number="3368">      case COMPLETION_TABLES: {</Line>
  <Line number="3369">        if( pCur-&gt;pStmt==0 ){</Line>
  <Line number="3370">          sqlite3_stmt *pS2;</Line>
  <Line number="3371">          char *zSql = 0;</Line>
  <Line number="3372">          const char *zSep = &quot;&quot;;</Line>
  <Line number="3373">          sqlite3_prepare_v2(pCur-&gt;db, &quot;PRAGMA database_list&quot;, <CheckRefs ids="1276">-</CheckRefs>1, &amp;pS2, 0);</Line>
  <Line number="3374">          while( sqlite3_step(pS2)==SQLITE_ROW ){</Line>
  <Line number="3375">            const char *zDb = (const char*)sqlite3_column_text(pS2, 1);</Line>
  <Line number="3376">            zSql = sqlite3_mprintf(</Line>
  <Line number="3377">               &quot;%z%s&quot;</Line>
  <Line number="3378">               &quot;SELECT name FROM \&quot;%w\&quot;.sqlite_schema&quot;,</Line>
  <Line number="3379">               zSql, zSep, zDb</Line>
  <Line number="3380">            );</Line>
  <Line number="3381">            if( zSql==0 ) return SQLITE_NOMEM;</Line>
  <Line number="3382">            zSep = &quot; UNION &quot;;</Line>
  <Line number="3383">          }</Line>
  <Line number="3384">          sqlite3_finalize(pS2);</Line>
  <Line number="3385">          sqlite3_prepare_v2(pCur-&gt;db, zSql, <CheckRefs ids="1277">-</CheckRefs>1, &amp;pCur-&gt;pStmt, 0);</Line>
  <Line number="3386">          sqlite3_free(zSql);</Line>
  <Line number="3387">        }</Line>
  <Line number="3388">        iCol = 0;</Line>
  <Line number="3389">        eNextPhase = COMPLETION_COLUMNS;</Line>
  <Line number="3390">        break;</Line>
  <Line number="3391">      }</Line>
  <Line number="3392">      case COMPLETION_COLUMNS: {</Line>
  <Line number="3393">        if( pCur-&gt;pStmt==0 ){</Line>
  <Line number="3394">          sqlite3_stmt *pS2;</Line>
  <Line number="3395">          char *zSql = 0;</Line>
  <Line number="3396">          const char *zSep = &quot;&quot;;</Line>
  <Line number="3397">          sqlite3_prepare_v2(pCur-&gt;db, &quot;PRAGMA database_list&quot;, <CheckRefs ids="1278">-</CheckRefs>1, &amp;pS2, 0);</Line>
  <Line number="3398">          while( sqlite3_step(pS2)==SQLITE_ROW ){</Line>
  <Line number="3399">            const char *zDb = (const char*)sqlite3_column_text(pS2, 1);</Line>
  <Line number="3400">            zSql = sqlite3_mprintf(</Line>
  <Line number="3401">               &quot;%z%s&quot;</Line>
  <Line number="3402">               &quot;SELECT pti.name FROM \&quot;%w\&quot;.sqlite_schema AS sm&quot;</Line>
  <Line number="3403">                       &quot; JOIN pragma_table_info(sm.name,%Q) AS pti&quot;</Line>
  <Line number="3404">               &quot; WHERE sm.type=&apos;table&apos;&quot;,</Line>
  <Line number="3405">               zSql, zSep, zDb, zDb</Line>
  <Line number="3406">            );</Line>
  <Line number="3407">            if( zSql==0 ) return SQLITE_NOMEM;</Line>
  <Line number="3408">            zSep = &quot; UNION &quot;;</Line>
  <Line number="3409">          }</Line>
  <Line number="3410">          sqlite3_finalize(pS2);</Line>
  <Line number="3411">          sqlite3_prepare_v2(pCur-&gt;db, zSql, <CheckRefs ids="1279">-</CheckRefs>1, &amp;pCur-&gt;pStmt, 0);</Line>
  <Line number="3412">          sqlite3_free(zSql);</Line>
  <Line number="3413">        }</Line>
  <Line number="3414">        iCol = 0;</Line>
  <Line number="3415">        eNextPhase = COMPLETION_EOF;</Line>
  <Line number="3416">        break;</Line>
  <Line number="3417">      }</Line>
  <Line number="3418">    }</Line>
  <Line number="3419">    if( iCol&lt;0 ){</Line>
  <Line number="3420">      /* This case is when the phase presets zCurrentRow */</Line>
  <Line number="3421">      if( pCur-&gt;zCurrentRow==0 ) continue;</Line>
  <Line number="3422">    }else{</Line>
  <Line number="3423">      if( sqlite3_step(pCur-&gt;pStmt)==SQLITE_ROW ){</Line>
  <Line number="3424">        /* Extract the next row of content */</Line>
  <Line number="3425">        pCur-&gt;zCurrentRow = (const char*)sqlite3_column_text(pCur-&gt;pStmt, iCol);</Line>
  <Line number="3426">        pCur-&gt;szRow = sqlite3_column_bytes(pCur-&gt;pStmt, iCol);</Line>
  <Line number="3427">      }else{</Line>
  <Line number="3428">        /* When all rows are finished, advance to the next phase */</Line>
  <Line number="3429">        sqlite3_finalize(pCur-&gt;pStmt);</Line>
  <Line number="3430">        pCur-&gt;pStmt = 0;</Line>
  <Line number="3431">        pCur-&gt;ePhase = eNextPhase;</Line>
  <Line number="3432">        continue;</Line>
  <Line number="3433">      }</Line>
  <Line number="3434">    }</Line>
  <Line number="3435">    if( pCur-&gt;nPrefix==0 ) break;</Line>
  <Line number="3436">    if( pCur-&gt;nPrefix&lt;=pCur-&gt;szRow</Line>
  <Line number="3437">     &amp;&amp; sqlite3_strnicmp(pCur-&gt;zPrefix, pCur-&gt;zCurrentRow, pCur-&gt;nPrefix)==0</Line>
  <Line number="3438">    ){</Line>
  <Line number="3439">      break;</Line>
  <Line number="3440">    }</Line>
  <Line number="3441">  }</Line>
  <Line number="3442"></Line>
  <Line number="3443">  return SQLITE_OK;</Line>
  <Line number="3444">}</Line>
  <Line number="3445"></Line>
  <Line number="3446">/*</Line>
  <Line number="3447">** Return values of columns for the row at which the completion_cursor</Line>
  <Line number="3448">** is currently pointing.</Line>
  <Line number="3449">*/</Line>
  <Line number="3450">static int completionColumn(</Line>
  <Line number="3451">  sqlite3_vtab_cursor *cur,   /* The cursor */</Line>
  <Line number="3452">  sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */</Line>
  <Line number="3453">  int i                       /* Which column to return */</Line>
  <Line number="3454">){</Line>
  <Line number="3455">  completion_cursor *pCur = (completion_cursor*)cur;</Line>
  <Line number="3456">  switch( i ){</Line>
  <Line number="3457">    case COMPLETION_COLUMN_CANDIDATE: {</Line>
  <Line number="3458">      sqlite3_result_text(ctx, pCur-&gt;zCurrentRow, pCur-&gt;szRow,<CheckRefs ids="1280">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="3459">      break;</Line>
  <Line number="3460">    }</Line>
  <Line number="3461">    case COMPLETION_COLUMN_PREFIX: {</Line>
  <Line number="3462">      sqlite3_result_text(ctx, pCur-&gt;zPrefix, <CheckRefs ids="1281">-</CheckRefs>1, <CheckRefs ids="1282">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="3463">      break;</Line>
  <Line number="3464">    }</Line>
  <Line number="3465">    case COMPLETION_COLUMN_WHOLELINE: {</Line>
  <Line number="3466">      sqlite3_result_text(ctx, pCur-&gt;zLine, <CheckRefs ids="1283">-</CheckRefs>1, <CheckRefs ids="1284">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="3467">      break;</Line>
  <Line number="3468">    }</Line>
  <Line number="3469">    case COMPLETION_COLUMN_PHASE: {</Line>
  <Line number="3470">      sqlite3_result_int(ctx, pCur-&gt;ePhase);</Line>
  <Line number="3471">      break;</Line>
  <Line number="3472">    }</Line>
  <Line number="3473">  }</Line>
  <Line number="3474">  return SQLITE_OK;</Line>
  <Line number="3475">}</Line>
  <Line number="3476"></Line>
  <Line number="3477">/*</Line>
  <Line number="3478">** Return the rowid for the current row.  In this implementation, the</Line>
  <Line number="3479">** rowid is the same as the output value.</Line>
  <Line number="3480">*/</Line>
  <Line number="3481">static int completionRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){</Line>
  <Line number="3482">  completion_cursor *pCur = (completion_cursor*)cur;</Line>
  <Line number="3483">  *pRowid = pCur-&gt;iRowid;</Line>
  <Line number="3484">  return SQLITE_OK;</Line>
  <Line number="3485">}</Line>
  <Line number="3486"></Line>
  <Line number="3487">/*</Line>
  <Line number="3488">** Return TRUE if the cursor has been moved off of the last</Line>
  <Line number="3489">** row of output.</Line>
  <Line number="3490">*/</Line>
  <Line number="3491">static int completionEof(sqlite3_vtab_cursor *cur){</Line>
  <Line number="3492">  completion_cursor *pCur = (completion_cursor*)cur;</Line>
  <Line number="3493">  return pCur-&gt;ePhase &gt;= COMPLETION_EOF;</Line>
  <Line number="3494">}</Line>
  <Line number="3495"></Line>
  <Line number="3496">/*</Line>
  <Line number="3497">** This method is called to &quot;rewind&quot; the completion_cursor object back</Line>
  <Line number="3498">** to the first row of output.  This method is always called at least</Line>
  <Line number="3499">** once prior to any call to completionColumn() or completionRowid() or </Line>
  <Line number="3500">** completionEof().</Line>
  <Line number="3501">*/</Line>
  <Line number="3502">static int completionFilter(</Line>
  <Line number="3503">  sqlite3_vtab_cursor *pVtabCursor, </Line>
  <Line number="3504">  int idxNum, const char *idxStr,</Line>
  <Line number="3505">  int argc, sqlite3_value **argv</Line>
  <Line number="3506">){</Line>
  <Line number="3507">  completion_cursor *pCur = (completion_cursor *)pVtabCursor;</Line>
  <Line number="3508">  int iArg = 0;</Line>
  <Line number="3509">  (void)(idxStr);   /* Unused parameter */</Line>
  <Line number="3510">  (void)(argc);     /* Unused parameter */</Line>
  <Line number="3511">  completionCursorReset(pCur);</Line>
  <Line number="3512">  if( idxNum &amp; 1 ){</Line>
  <Line number="3513">    pCur-&gt;nPrefix = sqlite3_value_bytes(argv[iArg]);</Line>
  <Line number="3514">    if( pCur-&gt;nPrefix&gt;0 ){</Line>
  <Line number="3515">      pCur-&gt;zPrefix = sqlite3_mprintf(&quot;%s&quot;, sqlite3_value_text(argv[iArg]));</Line>
  <Line number="3516">      if( pCur-&gt;zPrefix==0 ) return SQLITE_NOMEM;</Line>
  <Line number="3517">    }</Line>
  <Line number="3518">    iArg = 1;</Line>
  <Line number="3519">  }</Line>
  <Line number="3520">  if( idxNum &amp; 2 ){</Line>
  <Line number="3521">    pCur-&gt;nLine = sqlite3_value_bytes(argv[iArg]);</Line>
  <Line number="3522">    if( pCur-&gt;nLine&gt;0 ){</Line>
  <Line number="3523">      pCur-&gt;zLine = sqlite3_mprintf(&quot;%s&quot;, sqlite3_value_text(argv[iArg]));</Line>
  <Line number="3524">      if( pCur-&gt;zLine==0 ) return SQLITE_NOMEM;</Line>
  <Line number="3525">    }</Line>
  <Line number="3526">  }</Line>
  <Line number="3527">  if( pCur-&gt;zLine!=0 &amp;&amp; pCur-&gt;zPrefix==0 ){</Line>
  <Line number="3528">    int i = pCur-&gt;nLine;</Line>
  <Line number="3529">    while( i&gt;0 &amp;&amp; (<CheckRefs ids="1285,1286,1288,1289,1287">isalnum</CheckRefs>(pCur-&gt;zLine[i-1]) || <CheckRefs ids="1290">pCur</CheckRefs>-&gt;zLine[i<CheckRefs ids="1291">-</CheckRefs>1]==&apos;_&apos;) ){</Line>
  <Line number="3530">      i<CheckRefs ids="1292">--</CheckRefs>;</Line>
  <Line number="3531">    }</Line>
  <Line number="3532">    pCur-&gt;nPrefix = pCur-&gt;nLine <CheckRefs ids="1293">-</CheckRefs> i;</Line>
  <Line number="3533">    if( pCur-&gt;nPrefix&gt;0 ){</Line>
  <Line number="3534">      pCur-&gt;zPrefix = sqlite3_mprintf(&quot;%.*s&quot;, pCur-&gt;nPrefix, pCur-&gt;zLine + i);</Line>
  <Line number="3535">      if( pCur-&gt;zPrefix==0 ) return SQLITE_NOMEM;</Line>
  <Line number="3536">    }</Line>
  <Line number="3537">  }</Line>
  <Line number="3538">  pCur-&gt;iRowid = <CheckRefs ids="1294">0</CheckRefs>;</Line>
  <Line number="3539">  pCur-&gt;ePhase = COMPLETION_FIRST_PHASE;</Line>
  <Line number="3540">  return completionNext(pVtabCursor);</Line>
  <Line number="3541">}</Line>
  <Line number="3542"></Line>
  <Line number="3543">/*</Line>
  <Line number="3544">** SQLite will invoke this method one or more times while planning a query</Line>
  <Line number="3545">** that uses the completion virtual table.  This routine needs to create</Line>
  <Line number="3546">** a query plan for each invocation and compute an estimated cost for that</Line>
  <Line number="3547">** plan.</Line>
  <Line number="3548">**</Line>
  <Line number="3549">** There are two hidden parameters that act as arguments to the table-valued</Line>
  <Line number="3550">** function:  &quot;prefix&quot; and &quot;wholeline&quot;.  Bit 0 of idxNum is set if &quot;prefix&quot;</Line>
  <Line number="3551">** is available and bit 1 is set if &quot;wholeline&quot; is available.</Line>
  <Line number="3552">*/</Line>
  <Line number="3553">static int completionBestIndex(</Line>
  <Line number="3554">  sqlite3_vtab *tab,</Line>
  <Line number="3555">  sqlite3_index_info *pIdxInfo</Line>
  <Line number="3556">){</Line>
  <Line number="3557">  int i;                 /* Loop over constraints */</Line>
  <Line number="3558">  int idxNum = 0;        /* The query plan bitmask */</Line>
  <Line number="3559">  int prefixIdx = <CheckRefs ids="1295">-</CheckRefs>1;    /* Index of the start= constraint, or -1 if none */</Line>
  <Line number="3560">  int wholelineIdx = <CheckRefs ids="1296">-</CheckRefs>1; /* Index of the stop= constraint, or -1 if none */</Line>
  <Line number="3561">  int nArg = 0;          /* Number of arguments that completeFilter() expects */</Line>
  <Line number="3562">  const struct sqlite3_index_constraint *pConstraint;</Line>
  <Line number="3563"></Line>
  <Line number="3564">  (void)(tab);    /* Unused parameter */</Line>
  <Line number="3565">  pConstraint = pIdxInfo-&gt;aConstraint;</Line>
  <Line number="3566">  for(i=0; i&lt;pIdxInfo-&gt;nConstraint; i<CheckRefs ids="1297">++</CheckRefs>, pConstraint++){</Line>
  <Line number="3567">    if( <CheckRefs ids="1298">pConstraint</CheckRefs>-&gt;usable==0 ) continue;</Line>
  <Line number="3568">    if( <CheckRefs ids="1299">pConstraint</CheckRefs>-&gt;op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;</Line>
  <Line number="3569">    switch( pConstraint-&gt;iColumn ){</Line>
  <Line number="3570">      case COMPLETION_COLUMN_PREFIX:</Line>
  <Line number="3571">        prefixIdx = i;</Line>
  <Line number="3572">        idxNum |= 1;</Line>
  <Line number="3573">        break;</Line>
  <Line number="3574">      case COMPLETION_COLUMN_WHOLELINE:</Line>
  <Line number="3575">        wholelineIdx = i;</Line>
  <Line number="3576">        idxNum |= 2;</Line>
  <Line number="3577">        break;</Line>
  <Line number="3578">    }</Line>
  <Line number="3579">  }</Line>
  <Line number="3580">  if( prefixIdx&gt;=0 ){</Line>
  <Line number="3581">    pIdxInfo-&gt;aConstraintUsage[prefixIdx].argvIndex = <CheckRefs ids="1300">++</CheckRefs>nArg;</Line>
  <Line number="3582">    pIdxInfo-&gt;aConstraintUsage[prefixIdx].omit = <CheckRefs ids="1301">1</CheckRefs>;</Line>
  <Line number="3583">  }</Line>
  <Line number="3584">  if( wholelineIdx&gt;=0 ){</Line>
  <Line number="3585">    pIdxInfo-&gt;aConstraintUsage[wholelineIdx].argvIndex = <CheckRefs ids="1302">++</CheckRefs>nArg;</Line>
  <Line number="3586">    pIdxInfo-&gt;aConstraintUsage[wholelineIdx].omit = <CheckRefs ids="1303">1</CheckRefs>;</Line>
  <Line number="3587">  }</Line>
  <Line number="3588">  pIdxInfo-&gt;idxNum = idxNum;</Line>
  <Line number="3589">  pIdxInfo-&gt;estimatedCost <CheckRefs ids="1304">=</CheckRefs> <CheckRefs ids="1306">(</CheckRefs>double)5000 <CheckRefs ids="1305">-</CheckRefs> 1000<CheckRefs ids="1307,1308">*</CheckRefs>nArg;</Line>
  <Line number="3590">  pIdxInfo-&gt;estimatedRows = 500 <CheckRefs ids="1309,1310">-</CheckRefs> 100<CheckRefs ids="1311">*</CheckRefs>nArg;</Line>
  <Line number="3591">  return SQLITE_OK;</Line>
  <Line number="3592">}</Line>
  <Line number="3593"></Line>
  <Line number="3594">/*</Line>
  <Line number="3595">** This following structure defines all the methods for the </Line>
  <Line number="3596">** completion virtual table.</Line>
  <Line number="3597">*/</Line>
  <Line number="3598">static sqlite3_module completionModule = {</Line>
  <Line number="3599">  0,                         /* iVersion */</Line>
  <Line number="3600">  0,                         /* xCreate */</Line>
  <Line number="3601">  completionConnect,         /* xConnect */</Line>
  <Line number="3602">  completionBestIndex,       /* xBestIndex */</Line>
  <Line number="3603">  completionDisconnect,      /* xDisconnect */</Line>
  <Line number="3604">  0,                         /* xDestroy */</Line>
  <Line number="3605">  completionOpen,            /* xOpen - open a cursor */</Line>
  <Line number="3606">  completionClose,           /* xClose - close a cursor */</Line>
  <Line number="3607">  completionFilter,          /* xFilter - configure scan constraints */</Line>
  <Line number="3608">  completionNext,            /* xNext - advance a cursor */</Line>
  <Line number="3609">  completionEof,             /* xEof - check for end of scan */</Line>
  <Line number="3610">  completionColumn,          /* xColumn - read data */</Line>
  <Line number="3611">  completionRowid,           /* xRowid - read data */</Line>
  <Line number="3612">  0,                         /* xUpdate */</Line>
  <Line number="3613">  0,                         /* xBegin */</Line>
  <Line number="3614">  0,                         /* xSync */</Line>
  <Line number="3615">  0,                         /* xCommit */</Line>
  <Line number="3616">  0,                         /* xRollback */</Line>
  <Line number="3617">  0,                         /* xFindMethod */</Line>
  <Line number="3618">  0,                         /* xRename */</Line>
  <Line number="3619">  0,                         /* xSavepoint */</Line>
  <Line number="3620">  0,                         /* xRelease */</Line>
  <Line number="3621">  0,                         /* xRollbackTo */</Line>
  <Line number="3622">  0                          /* xShadowName */</Line>
  <Line number="3623">};</Line>
  <Line number="3624"></Line>
  <Line number="3625">#endif /* SQLITE_OMIT_VIRTUALTABLE */</Line>
  <Line number="3626"></Line>
  <Line number="3627">int sqlite3CompletionVtabInit(sqlite3 *db){</Line>
  <Line number="3628">  int rc = SQLITE_OK;</Line>
  <Line number="3629">#ifndef SQLITE_OMIT_VIRTUALTABLE</Line>
  <Line number="3630">  rc = sqlite3_create_module(db, &quot;completion&quot;, &amp;completionModule, 0);</Line>
  <Line number="3631">#endif</Line>
  <Line number="3632">  return rc;</Line>
  <Line number="3633">}</Line>
  <Line number="3634"></Line>
  <Line number="3635">#ifdef _WIN32</Line>
  <Line number="3636"></Line>
  <Line number="3637">#endif</Line>
  <Line number="3638">int sqlite3_completion_init(</Line>
  <Line number="3639">  sqlite3 *db, </Line>
  <Line number="3640">  char **pzErrMsg, </Line>
  <Line number="3641">  const sqlite3_api_routines *pApi</Line>
  <Line number="3642">){</Line>
  <Line number="3643">  int rc = SQLITE_OK;</Line>
  <Line number="3644">  SQLITE_EXTENSION_INIT2(pApi);</Line>
  <Line number="3645">  (void)(pzErrMsg);  /* Unused parameter */</Line>
  <Line number="3646">#ifndef SQLITE_OMIT_VIRTUALTABLE</Line>
  <Line number="3647">  rc = sqlite3CompletionVtabInit(db);</Line>
  <Line number="3648">#endif</Line>
  <Line number="3649">  return rc;</Line>
  <Line number="3650">}</Line>
  <Line number="3651"></Line>
  <Line number="3652">/************************* End ../ext/misc/completion.c ********************/</Line>
  <Line number="3653">/************************* Begin ../ext/misc/appendvfs.c ******************/</Line>
  <Line number="3654">/*</Line>
  <Line number="3655">** 2017-10-20</Line>
  <Line number="3656">**</Line>
  <Line number="3657">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="3658">** a legal notice, here is a blessing:</Line>
  <Line number="3659">**</Line>
  <Line number="3660">**    May you do good and not evil.</Line>
  <Line number="3661">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="3662">**    May you share freely, never taking more than you give.</Line>
  <Line number="3663">**</Line>
  <Line number="3664">******************************************************************************</Line>
  <Line number="3665">**</Line>
  <Line number="3666">** This file implements a VFS shim that allows an SQLite database to be</Line>
  <Line number="3667">** appended onto the end of some other file, such as an executable.</Line>
  <Line number="3668">**</Line>
  <Line number="3669">** A special record must appear at the end of the file that identifies the</Line>
  <Line number="3670">** file as an appended database and provides the offset to the first page</Line>
  <Line number="3671">** of the exposed content. (Or, it is the length of the content prefix.)</Line>
  <Line number="3672">** For best performance page 1 should be located at a disk page boundary,</Line>
  <Line number="3673">** though that is not required.</Line>
  <Line number="3674">**</Line>
  <Line number="3675">** When opening a database using this VFS, the connection might treat</Line>
  <Line number="3676">** the file as an ordinary SQLite database, or it might treat it as a</Line>
  <Line number="3677">** database appended onto some other file.  The decision is made by</Line>
  <Line number="3678">** applying the following rules in order:</Line>
  <Line number="3679">**</Line>
  <Line number="3680">**  (1)  An empty file is an ordinary database.</Line>
  <Line number="3681">**</Line>
  <Line number="3682">**  (2)  If the file ends with the appendvfs trailer string</Line>
  <Line number="3683">**       &quot;Start-Of-SQLite3-NNNNNNNN&quot; that file is an appended database.</Line>
  <Line number="3684">**</Line>
  <Line number="3685">**  (3)  If the file begins with the standard SQLite prefix string</Line>
  <Line number="3686">**       &quot;SQLite format 3&quot;, that file is an ordinary database.</Line>
  <Line number="3687">**</Line>
  <Line number="3688">**  (4)  If none of the above apply and the SQLITE_OPEN_CREATE flag is</Line>
  <Line number="3689">**       set, then a new database is appended to the already existing file.</Line>
  <Line number="3690">**</Line>
  <Line number="3691">**  (5)  Otherwise, SQLITE_CANTOPEN is returned.</Line>
  <Line number="3692">**</Line>
  <Line number="3693">** To avoid unnecessary complications with the PENDING_BYTE, the size of</Line>
  <Line number="3694">** the file containing the database is limited to 1GiB. (1073741824 bytes)</Line>
  <Line number="3695">** This VFS will not read or write past the 1GiB mark.  This restriction</Line>
  <Line number="3696">** might be lifted in future versions.  For now, if you need a larger</Line>
  <Line number="3697">** database, then keep it in a separate file.</Line>
  <Line number="3698">**</Line>
  <Line number="3699">** If the file being opened is a plain database (not an appended one), then</Line>
  <Line number="3700">** this shim is a pass-through into the default underlying VFS. (rule 3)</Line>
  <Line number="3701">**/</Line>
  <Line number="3702">/* #include &quot;sqlite3ext.h&quot; */</Line>
  <Line number="3703">SQLITE_EXTENSION_INIT1</Line>
  <Line number="3704">#include &lt;string.h&gt;</Line>
  <Line number="3705">#include &lt;assert.h&gt;</Line>
  <Line number="3706"></Line>
  <Line number="3707">/* The append mark at the end of the database is:</Line>
  <Line number="3708">**</Line>
  <Line number="3709">**     Start-Of-SQLite3-NNNNNNNN</Line>
  <Line number="3710">**     123456789 123456789 12345</Line>
  <Line number="3711">**</Line>
  <Line number="3712">** The NNNNNNNN represents a 64-bit big-endian unsigned integer which is</Line>
  <Line number="3713">** the offset to page 1, and also the length of the prefix content.</Line>
  <Line number="3714">*/</Line>
  <Line number="3715">#define APND_MARK_PREFIX     &quot;Start-Of-SQLite3-&quot;</Line>
  <Line number="3716">#define APND_MARK_PREFIX_SZ  17</Line>
  <Line number="3717">#define APND_MARK_FOS_SZ      8</Line>
  <Line number="3718">#define APND_MARK_SIZE       (APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ)</Line>
  <Line number="3719"></Line>
  <Line number="3720">/*</Line>
  <Line number="3721">** Maximum size of the combined prefix + database + append-mark.  This</Line>
  <Line number="3722">** must be less than 0x40000000 to avoid locking issues on Windows.</Line>
  <Line number="3723">*/</Line>
  <Line number="3724">#define APND_MAX_SIZE  (0x40000000)</Line>
  <Line number="3725"></Line>
  <Line number="3726">/*</Line>
  <Line number="3727">** Try to align the database to an even multiple of APND_ROUNDUP bytes.</Line>
  <Line number="3728">*/</Line>
  <Line number="3729">#ifndef APND_ROUNDUP</Line>
  <Line number="3730">#define APND_ROUNDUP 4096</Line>
  <Line number="3731">#endif</Line>
  <Line number="3732">#define APND_ALIGN_MASK         ((sqlite3_int64)(APND_ROUNDUP-1))</Line>
  <Line number="3733">#define APND_START_ROUNDUP(fsz) (((fsz)+APND_ALIGN_MASK) &amp; ~APND_ALIGN_MASK)</Line>
  <Line number="3734"></Line>
  <Line number="3735">/*</Line>
  <Line number="3736">** Forward declaration of objects used by this utility</Line>
  <Line number="3737">*/</Line>
  <Line number="3738">typedef struct sqlite3_vfs ApndVfs;</Line>
  <Line number="3739">typedef struct ApndFile ApndFile;</Line>
  <Line number="3740"></Line>
  <Line number="3741">/* Access to a lower-level VFS that (might) implement dynamic loading,</Line>
  <Line number="3742">** access to randomness, etc.</Line>
  <Line number="3743">*/</Line>
  <Line number="3744">#define ORIGVFS(p)  ((sqlite3_vfs*)((p)-&gt;pAppData))</Line>
  <Line number="3745">#define ORIGFILE(p) ((sqlite3_file*)(((ApndFile*)(p))+1))</Line>
  <Line number="3746"></Line>
  <Line number="3747">/* An open appendvfs file</Line>
  <Line number="3748">**</Line>
  <Line number="3749">** An instance of this structure describes the appended database file.</Line>
  <Line number="3750">** A separate sqlite3_file object is always appended. The appended</Line>
  <Line number="3751">** sqlite3_file object (which can be accessed using ORIGFILE()) describes</Line>
  <Line number="3752">** the entire file, including the prefix, the database, and the</Line>
  <Line number="3753">** append-mark.</Line>
  <Line number="3754">**</Line>
  <Line number="3755">** The structure of an AppendVFS database is like this:</Line>
  <Line number="3756">**</Line>
  <Line number="3757">**   +-------------+---------+----------+-------------+</Line>
  <Line number="3758">**   | prefix-file | padding | database | append-mark |</Line>
  <Line number="3759">**   +-------------+---------+----------+-------------+</Line>
  <Line number="3760">**                           ^          ^</Line>
  <Line number="3761">**                           |          |</Line>
  <Line number="3762">**                         iPgOne      iMark</Line>
  <Line number="3763">**</Line>
  <Line number="3764">**</Line>
  <Line number="3765">** &quot;prefix file&quot; -  file onto which the database has been appended.</Line>
  <Line number="3766">** &quot;padding&quot;     -  zero or more bytes inserted so that &quot;database&quot;</Line>
  <Line number="3767">**                  starts on an APND_ROUNDUP boundary</Line>
  <Line number="3768">** &quot;database&quot;    -  The SQLite database file</Line>
  <Line number="3769">** &quot;append-mark&quot; -  The 25-byte &quot;Start-Of-SQLite3-NNNNNNNN&quot; that indicates</Line>
  <Line number="3770">**                  the offset from the start of prefix-file to the start</Line>
  <Line number="3771">**                  of &quot;database&quot;.</Line>
  <Line number="3772">**</Line>
  <Line number="3773">** The size of the database is iMark - iPgOne.</Line>
  <Line number="3774">**</Line>
  <Line number="3775">** The NNNNNNNN in the &quot;Start-Of-SQLite3-NNNNNNNN&quot; suffix is the value</Line>
  <Line number="3776">** of iPgOne stored as a big-ending 64-bit integer.</Line>
  <Line number="3777">**</Line>
  <Line number="3778">** iMark will be the size of the underlying file minus 25 (APND_MARKSIZE).</Line>
  <Line number="3779">** Or, iMark is -1 to indicate that it has not yet been written.</Line>
  <Line number="3780">*/</Line>
  <Line number="3781">struct ApndFile {</Line>
  <Line number="3782">  sqlite3_file base;        /* Subclass.  MUST BE FIRST! */</Line>
  <Line number="3783">  sqlite3_int64 iPgOne;     /* Offset to the start of the database */</Line>
  <Line number="3784">  sqlite3_int64 iMark;      /* Offset of the append mark.  -1 if unwritten */</Line>
  <Line number="3785">  /* Always followed by another sqlite3_file that describes the whole file */</Line>
  <Line number="3786">};</Line>
  <Line number="3787"></Line>
  <Line number="3788">/*</Line>
  <Line number="3789">** Methods for ApndFile</Line>
  <Line number="3790">*/</Line>
  <Line number="3791">static int apndClose(sqlite3_file*);</Line>
  <Line number="3792">static int apndRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);</Line>
  <Line number="3793">static int apndWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64 iOfst);</Line>
  <Line number="3794">static int apndTruncate(sqlite3_file*, sqlite3_int64 size);</Line>
  <Line number="3795">static int apndSync(sqlite3_file*, int flags);</Line>
  <Line number="3796">static int apndFileSize(sqlite3_file*, sqlite3_int64 *pSize);</Line>
  <Line number="3797">static int apndLock(sqlite3_file*, int);</Line>
  <Line number="3798">static int apndUnlock(sqlite3_file*, int);</Line>
  <Line number="3799">static int apndCheckReservedLock(sqlite3_file*, int *pResOut);</Line>
  <Line number="3800">static int apndFileControl(sqlite3_file*, int op, void *pArg);</Line>
  <Line number="3801">static int apndSectorSize(sqlite3_file*);</Line>
  <Line number="3802">static int apndDeviceCharacteristics(sqlite3_file*);</Line>
  <Line number="3803">static int apndShmMap(sqlite3_file*, int iPg, int pgsz, int, void volatile**);</Line>
  <Line number="3804">static int apndShmLock(sqlite3_file*, int offset, int n, int flags);</Line>
  <Line number="3805">static void apndShmBarrier(sqlite3_file*);</Line>
  <Line number="3806">static int apndShmUnmap(sqlite3_file*, int deleteFlag);</Line>
  <Line number="3807">static int apndFetch(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);</Line>
  <Line number="3808">static int apndUnfetch(sqlite3_file*, sqlite3_int64 iOfst, void *p);</Line>
  <Line number="3809"></Line>
  <Line number="3810">/*</Line>
  <Line number="3811">** Methods for ApndVfs</Line>
  <Line number="3812">*/</Line>
  <Line number="3813">static int apndOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);</Line>
  <Line number="3814">static int apndDelete(sqlite3_vfs*, const char *zName, int syncDir);</Line>
  <Line number="3815">static int apndAccess(sqlite3_vfs*, const char *zName, int flags, int *);</Line>
  <Line number="3816">static int apndFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);</Line>
  <Line number="3817">static void *apndDlOpen(sqlite3_vfs*, const char *zFilename);</Line>
  <Line number="3818">static void apndDlError(sqlite3_vfs*, int nByte, char *zErrMsg);</Line>
  <Line number="3819">static void (*apndDlSym(sqlite3_vfs *pVfs, void *p, const char*zSym))(void);</Line>
  <Line number="3820">static void apndDlClose(sqlite3_vfs*, void*);</Line>
  <Line number="3821">static int apndRandomness(sqlite3_vfs*, int nByte, char *zOut);</Line>
  <Line number="3822">static int apndSleep(sqlite3_vfs*, int microseconds);</Line>
  <Line number="3823">static int apndCurrentTime(sqlite3_vfs*, double*);</Line>
  <Line number="3824">static int apndGetLastError(sqlite3_vfs*, int, char *);</Line>
  <Line number="3825">static int apndCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*);</Line>
  <Line number="3826">static int apndSetSystemCall(sqlite3_vfs*, const char*,sqlite3_syscall_ptr);</Line>
  <Line number="3827">static sqlite3_syscall_ptr apndGetSystemCall(sqlite3_vfs*, const char *z);</Line>
  <Line number="3828">static const char *apndNextSystemCall(sqlite3_vfs*, const char *zName);</Line>
  <Line number="3829"></Line>
  <Line number="3830">static sqlite3_vfs apnd_vfs = {</Line>
  <Line number="3831">  3,                            /* iVersion (set when registered) */</Line>
  <Line number="3832">  0,                            /* szOsFile (set when registered) */</Line>
  <Line number="3833">  1024,                         /* mxPathname */</Line>
  <Line number="3834">  0,                            /* pNext */</Line>
  <Line number="3835">  &quot;apndvfs&quot;,                    /* zName */</Line>
  <Line number="3836">  0,                            /* pAppData (set when registered) */ </Line>
  <Line number="3837">  apndOpen,                     /* xOpen */</Line>
  <Line number="3838">  apndDelete,                   /* xDelete */</Line>
  <Line number="3839">  apndAccess,                   /* xAccess */</Line>
  <Line number="3840">  apndFullPathname,             /* xFullPathname */</Line>
  <Line number="3841">  apndDlOpen,                   /* xDlOpen */</Line>
  <Line number="3842">  apndDlError,                  /* xDlError */</Line>
  <Line number="3843">  apndDlSym,                    /* xDlSym */</Line>
  <Line number="3844">  apndDlClose,                  /* xDlClose */</Line>
  <Line number="3845">  apndRandomness,               /* xRandomness */</Line>
  <Line number="3846">  apndSleep,                    /* xSleep */</Line>
  <Line number="3847">  apndCurrentTime,              /* xCurrentTime */</Line>
  <Line number="3848">  apndGetLastError,             /* xGetLastError */</Line>
  <Line number="3849">  apndCurrentTimeInt64,         /* xCurrentTimeInt64 */</Line>
  <Line number="3850">  apndSetSystemCall,            /* xSetSystemCall */</Line>
  <Line number="3851">  apndGetSystemCall,            /* xGetSystemCall */</Line>
  <Line number="3852">  apndNextSystemCall            /* xNextSystemCall */</Line>
  <Line number="3853">};</Line>
  <Line number="3854"></Line>
  <Line number="3855">static const sqlite3_io_methods apnd_io_methods = {</Line>
  <Line number="3856">  3,                              /* iVersion */</Line>
  <Line number="3857">  apndClose,                      /* xClose */</Line>
  <Line number="3858">  apndRead,                       /* xRead */</Line>
  <Line number="3859">  apndWrite,                      /* xWrite */</Line>
  <Line number="3860">  apndTruncate,                   /* xTruncate */</Line>
  <Line number="3861">  apndSync,                       /* xSync */</Line>
  <Line number="3862">  apndFileSize,                   /* xFileSize */</Line>
  <Line number="3863">  apndLock,                       /* xLock */</Line>
  <Line number="3864">  apndUnlock,                     /* xUnlock */</Line>
  <Line number="3865">  apndCheckReservedLock,          /* xCheckReservedLock */</Line>
  <Line number="3866">  apndFileControl,                /* xFileControl */</Line>
  <Line number="3867">  apndSectorSize,                 /* xSectorSize */</Line>
  <Line number="3868">  apndDeviceCharacteristics,      /* xDeviceCharacteristics */</Line>
  <Line number="3869">  apndShmMap,                     /* xShmMap */</Line>
  <Line number="3870">  apndShmLock,                    /* xShmLock */</Line>
  <Line number="3871">  apndShmBarrier,                 /* xShmBarrier */</Line>
  <Line number="3872">  apndShmUnmap,                   /* xShmUnmap */</Line>
  <Line number="3873">  apndFetch,                      /* xFetch */</Line>
  <Line number="3874">  apndUnfetch                     /* xUnfetch */</Line>
  <Line number="3875">};</Line>
  <Line number="3876"></Line>
  <Line number="3877">/*</Line>
  <Line number="3878">** Close an apnd-file.</Line>
  <Line number="3879">*/</Line>
  <Line number="3880">static int apndClose(sqlite3_file *pFile){</Line>
  <Line number="3881">  pFile = ORIGFILE(pFile);</Line>
  <Line number="3882">  return pFile-&gt;pMethods-&gt;xClose(pFile);</Line>
  <Line number="3883">}</Line>
  <Line number="3884"></Line>
  <Line number="3885">/*</Line>
  <Line number="3886">** Read data from an apnd-file.</Line>
  <Line number="3887">*/</Line>
  <Line number="3888">static int apndRead(</Line>
  <Line number="3889">  sqlite3_file *pFile, </Line>
  <Line number="3890">  void *zBuf, </Line>
  <Line number="3891">  int iAmt, </Line>
  <Line number="3892">  sqlite_int64 iOfst</Line>
  <Line number="3893">){</Line>
  <Line number="3894">  ApndFile *paf = (ApndFile *)pFile;</Line>
  <Line number="3895">  pFile = ORIGFILE(pFile);</Line>
  <Line number="3896">  return pFile-&gt;pMethods-&gt;xRead(pFile, zBuf, iAmt, paf-&gt;iPgOne<CheckRefs ids="1312">+</CheckRefs>iOfst);</Line>
  <Line number="3897">}</Line>
  <Line number="3898"></Line>
  <Line number="3899">/*</Line>
  <Line number="3900">** Add the append-mark onto what should become the end of the file.</Line>
  <Line number="3901">*  If and only if this succeeds, internal ApndFile.iMark is updated.</Line>
  <Line number="3902">*  Parameter iWriteEnd is the appendvfs-relative offset of the new mark.</Line>
  <Line number="3903">*/</Line>
  <Line number="3904">static int apndWriteMark(</Line>
  <Line number="3905">  ApndFile *paf,</Line>
  <Line number="3906">  sqlite3_file *pFile,</Line>
  <Line number="3907">  sqlite_int64 iWriteEnd</Line>
  <Line number="3908">){</Line>
  <Line number="3909">  sqlite_int64 iPgOne = paf-&gt;iPgOne;</Line>
  <Line number="3910">  unsigned char a[<CheckRefs ids="1313">APND_MARK_SIZE</CheckRefs>];</Line>
  <Line number="3911">  int i = APND_MARK_FOS_SZ;</Line>
  <Line number="3912">  int rc;</Line>
  <Line number="3913">  <CheckRefs ids="1314">assert</CheckRefs>(pFile == ORIGFILE(paf));</Line>
  <Line number="3914">  memcpy(a, APND_MARK_PREFIX, <CheckRefs ids="1315">APND_MARK_PREFIX_SZ</CheckRefs>);</Line>
  <Line number="3915">  while( <CheckRefs ids="1316">--</CheckRefs>i &gt;= 0 ){</Line>
  <Line number="3916">    a[APND_MARK_PREFIX_SZ<CheckRefs ids="1318">+</CheckRefs>i<CheckRefs ids="1317">]</CheckRefs> = <CheckRefs ids="1319">(</CheckRefs>unsigned char)(iPgOne &amp; <CheckRefs ids="1320">0xff</CheckRefs>);</Line>
  <Line number="3917">    iPgOne <CheckRefs ids="1321,1322,1323">&gt;&gt;=</CheckRefs> 8;</Line>
  <Line number="3918">  }</Line>
  <Line number="3919">  iWriteEnd <CheckRefs ids="1324">+=</CheckRefs> paf-&gt;iPgOne;</Line>
  <Line number="3920">  if( SQLITE_OK==(rc = pFile-&gt;pMethods-&gt;xWrite</Line>
  <Line number="3921">                  (pFile, a, <CheckRefs ids="1325">APND_MARK_SIZE</CheckRefs>, iWriteEnd)) ){</Line>
  <Line number="3922">    paf-&gt;iMark = iWriteEnd;</Line>
  <Line number="3923">  }</Line>
  <Line number="3924">  return rc;</Line>
  <Line number="3925">}</Line>
  <Line number="3926"></Line>
  <Line number="3927">/*</Line>
  <Line number="3928">** Write data to an apnd-file.</Line>
  <Line number="3929">*/</Line>
  <Line number="3930">static int apndWrite(</Line>
  <Line number="3931">  sqlite3_file *pFile,</Line>
  <Line number="3932">  const void *zBuf,</Line>
  <Line number="3933">  int iAmt,</Line>
  <Line number="3934">  sqlite_int64 iOfst</Line>
  <Line number="3935">){</Line>
  <Line number="3936">  ApndFile *paf = (ApndFile *)pFile;</Line>
  <Line number="3937">  sqlite_int64 iWriteEnd = iOfst <CheckRefs ids="1326">+</CheckRefs> <CheckRefs ids="1327">iAmt</CheckRefs>;</Line>
  <Line number="3938">  if( iWriteEnd&gt;=<CheckRefs ids="1328">APND_MAX_SIZE</CheckRefs> ) return SQLITE_FULL;</Line>
  <Line number="3939">  pFile = ORIGFILE(pFile);</Line>
  <Line number="3940">  /* If append-mark is absent or will be overwritten, write it. */</Line>
  <Line number="3941">  if( paf-&gt;iMark &lt; <CheckRefs ids="1329">0</CheckRefs> || paf-&gt;iPgOne <CheckRefs ids="1330">+</CheckRefs> iWriteEnd &gt; paf-&gt;iMark ){</Line>
  <Line number="3942">    int rc = apndWriteMark(paf, pFile, iWriteEnd);</Line>
  <Line number="3943">    if( SQLITE_OK!=rc ) return rc;</Line>
  <Line number="3944">  }</Line>
  <Line number="3945">  return pFile-&gt;pMethods-&gt;xWrite(pFile, zBuf, iAmt, paf-&gt;iPgOne<CheckRefs ids="1331">+</CheckRefs>iOfst);</Line>
  <Line number="3946">}</Line>
  <Line number="3947"></Line>
  <Line number="3948">/*</Line>
  <Line number="3949">** Truncate an apnd-file.</Line>
  <Line number="3950">*/</Line>
  <Line number="3951">static int apndTruncate(sqlite3_file *pFile, sqlite_int64 size){</Line>
  <Line number="3952">  ApndFile *paf = (ApndFile *)pFile;</Line>
  <Line number="3953">  pFile = ORIGFILE(pFile);</Line>
  <Line number="3954">  /* The append mark goes out first so truncate failure does not lose it. */</Line>
  <Line number="3955">  if( SQLITE_OK!=apndWriteMark(paf, pFile, size) ) return SQLITE_IOERR;</Line>
  <Line number="3956">  /* Truncate underlying file just past append mark */</Line>
  <Line number="3957">  return pFile-&gt;pMethods-&gt;xTruncate(pFile, paf-&gt;iMark<CheckRefs ids="1332">+</CheckRefs><CheckRefs ids="1333,1334">APND_MARK_SIZE</CheckRefs>);</Line>
  <Line number="3958">}</Line>
  <Line number="3959"></Line>
  <Line number="3960">/*</Line>
  <Line number="3961">** Sync an apnd-file.</Line>
  <Line number="3962">*/</Line>
  <Line number="3963">static int apndSync(sqlite3_file *pFile, int flags){</Line>
  <Line number="3964">  pFile = ORIGFILE(pFile);</Line>
  <Line number="3965">  return pFile-&gt;pMethods-&gt;xSync(pFile, flags);</Line>
  <Line number="3966">}</Line>
  <Line number="3967"></Line>
  <Line number="3968">/*</Line>
  <Line number="3969">** Return the current file-size of an apnd-file.</Line>
  <Line number="3970">** If the append mark is not yet there, the file-size is 0.</Line>
  <Line number="3971">*/</Line>
  <Line number="3972">static int apndFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){</Line>
  <Line number="3973">  ApndFile *paf = (ApndFile *)pFile;</Line>
  <Line number="3974">  *pSize = ( paf-&gt;iMark &gt;= <CheckRefs ids="1335">0</CheckRefs> )? (paf-&gt;iMark <CheckRefs ids="1336">-</CheckRefs> paf-&gt;iPgOne) : <CheckRefs ids="1337">0</CheckRefs>;</Line>
  <Line number="3975">  return SQLITE_OK;</Line>
  <Line number="3976">}</Line>
  <Line number="3977"></Line>
  <Line number="3978">/*</Line>
  <Line number="3979">** Lock an apnd-file.</Line>
  <Line number="3980">*/</Line>
  <Line number="3981">static int apndLock(sqlite3_file *pFile, int eLock){</Line>
  <Line number="3982">  pFile = ORIGFILE(pFile);</Line>
  <Line number="3983">  return pFile-&gt;pMethods-&gt;xLock(pFile, eLock);</Line>
  <Line number="3984">}</Line>
  <Line number="3985"></Line>
  <Line number="3986">/*</Line>
  <Line number="3987">** Unlock an apnd-file.</Line>
  <Line number="3988">*/</Line>
  <Line number="3989">static int apndUnlock(sqlite3_file *pFile, int eLock){</Line>
  <Line number="3990">  pFile = ORIGFILE(pFile);</Line>
  <Line number="3991">  return pFile-&gt;pMethods-&gt;xUnlock(pFile, eLock);</Line>
  <Line number="3992">}</Line>
  <Line number="3993"></Line>
  <Line number="3994">/*</Line>
  <Line number="3995">** Check if another file-handle holds a RESERVED lock on an apnd-file.</Line>
  <Line number="3996">*/</Line>
  <Line number="3997">static int apndCheckReservedLock(sqlite3_file *pFile, int *pResOut){</Line>
  <Line number="3998">  pFile = ORIGFILE(pFile);</Line>
  <Line number="3999">  return pFile-&gt;pMethods-&gt;xCheckReservedLock(pFile, pResOut);</Line>
  <Line number="4000">}</Line>
  <Line number="4001"></Line>
  <Line number="4002">/*</Line>
  <Line number="4003">** File control method. For custom operations on an apnd-file.</Line>
  <Line number="4004">*/</Line>
  <Line number="4005">static int apndFileControl(sqlite3_file *pFile, int op, void *pArg){</Line>
  <Line number="4006">  ApndFile *paf = (ApndFile *)pFile;</Line>
  <Line number="4007">  int rc;</Line>
  <Line number="4008">  pFile = ORIGFILE(pFile);</Line>
  <Line number="4009">  if( op==SQLITE_FCNTL_SIZE_HINT ) *(sqlite3_int64*)pArg <CheckRefs ids="1338">+=</CheckRefs> paf-&gt;iPgOne;</Line>
  <Line number="4010">  rc = pFile-&gt;pMethods-&gt;xFileControl(pFile, op, pArg);</Line>
  <Line number="4011">  if( rc==SQLITE_OK &amp;&amp; op==SQLITE_FCNTL_VFSNAME ){</Line>
  <Line number="4012">    *(char**)pArg = sqlite3_mprintf(&quot;apnd(%lld)/%z&quot;, paf-&gt;iPgOne,*(char**)pArg);</Line>
  <Line number="4013">  }</Line>
  <Line number="4014">  return rc;</Line>
  <Line number="4015">}</Line>
  <Line number="4016"></Line>
  <Line number="4017">/*</Line>
  <Line number="4018">** Return the sector-size in bytes for an apnd-file.</Line>
  <Line number="4019">*/</Line>
  <Line number="4020">static int apndSectorSize(sqlite3_file *pFile){</Line>
  <Line number="4021">  pFile = ORIGFILE(pFile);</Line>
  <Line number="4022">  return pFile-&gt;pMethods-&gt;xSectorSize(pFile);</Line>
  <Line number="4023">}</Line>
  <Line number="4024"></Line>
  <Line number="4025">/*</Line>
  <Line number="4026">** Return the device characteristic flags supported by an apnd-file.</Line>
  <Line number="4027">*/</Line>
  <Line number="4028">static int apndDeviceCharacteristics(sqlite3_file *pFile){</Line>
  <Line number="4029">  pFile = ORIGFILE(pFile);</Line>
  <Line number="4030">  return pFile-&gt;pMethods-&gt;xDeviceCharacteristics(pFile);</Line>
  <Line number="4031">}</Line>
  <Line number="4032"></Line>
  <Line number="4033">/* Create a shared memory file mapping */</Line>
  <Line number="4034">static int apndShmMap(</Line>
  <Line number="4035">  sqlite3_file *pFile,</Line>
  <Line number="4036">  int iPg,</Line>
  <Line number="4037">  int pgsz,</Line>
  <Line number="4038">  int bExtend,</Line>
  <Line number="4039">  void volatile **pp</Line>
  <Line number="4040">){</Line>
  <Line number="4041">  pFile = ORIGFILE(pFile);</Line>
  <Line number="4042">  return pFile-&gt;pMethods-&gt;xShmMap(pFile,iPg,pgsz,bExtend,pp);</Line>
  <Line number="4043">}</Line>
  <Line number="4044"></Line>
  <Line number="4045">/* Perform locking on a shared-memory segment */</Line>
  <Line number="4046">static int apndShmLock(sqlite3_file *pFile, int offset, int n, int flags){</Line>
  <Line number="4047">  pFile = ORIGFILE(pFile);</Line>
  <Line number="4048">  return pFile-&gt;pMethods-&gt;xShmLock(pFile,offset,n,flags);</Line>
  <Line number="4049">}</Line>
  <Line number="4050"></Line>
  <Line number="4051">/* Memory barrier operation on shared memory */</Line>
  <Line number="4052">static void apndShmBarrier(sqlite3_file *pFile){</Line>
  <Line number="4053">  pFile = ORIGFILE(pFile);</Line>
  <Line number="4054">  pFile-&gt;pMethods-&gt;xShmBarrier(pFile);</Line>
  <Line number="4055">}</Line>
  <Line number="4056"></Line>
  <Line number="4057">/* Unmap a shared memory segment */</Line>
  <Line number="4058">static int apndShmUnmap(sqlite3_file *pFile, int deleteFlag){</Line>
  <Line number="4059">  pFile = ORIGFILE(pFile);</Line>
  <Line number="4060">  return pFile-&gt;pMethods-&gt;xShmUnmap(pFile,deleteFlag);</Line>
  <Line number="4061">}</Line>
  <Line number="4062"></Line>
  <Line number="4063">/* Fetch a page of a memory-mapped file */</Line>
  <Line number="4064">static int apndFetch(</Line>
  <Line number="4065">  sqlite3_file *pFile,</Line>
  <Line number="4066">  sqlite3_int64 iOfst,</Line>
  <Line number="4067">  int iAmt,</Line>
  <Line number="4068">  void **pp</Line>
  <Line number="4069">){</Line>
  <Line number="4070">  ApndFile *p = (ApndFile *)pFile;</Line>
  <Line number="4071">  if( p-&gt;iMark &lt; <CheckRefs ids="1339">0</CheckRefs> || iOfst<CheckRefs ids="1340">+</CheckRefs><CheckRefs ids="1341">iAmt</CheckRefs> &gt; p-&gt;iMark ){</Line>
  <Line number="4072">    return SQLITE_IOERR; /* Cannot read what is not yet there. */</Line>
  <Line number="4073">  }</Line>
  <Line number="4074">  pFile = ORIGFILE(pFile);</Line>
  <Line number="4075">  return pFile-&gt;pMethods-&gt;xFetch(pFile, iOfst<CheckRefs ids="1342">+</CheckRefs>p-&gt;iPgOne, iAmt, pp);</Line>
  <Line number="4076">}</Line>
  <Line number="4077"></Line>
  <Line number="4078">/* Release a memory-mapped page */</Line>
  <Line number="4079">static int apndUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *pPage){</Line>
  <Line number="4080">  ApndFile *p = (ApndFile *)pFile;</Line>
  <Line number="4081">  pFile = ORIGFILE(pFile);</Line>
  <Line number="4082">  return pFile-&gt;pMethods-&gt;xUnfetch(pFile, iOfst<CheckRefs ids="1343">+</CheckRefs>p-&gt;iPgOne, pPage);</Line>
  <Line number="4083">}</Line>
  <Line number="4084"></Line>
  <Line number="4085">/*</Line>
  <Line number="4086">** Try to read the append-mark off the end of a file.  Return the</Line>
  <Line number="4087">** start of the appended database if the append-mark is present.</Line>
  <Line number="4088">** If there is no valid append-mark, return -1;</Line>
  <Line number="4089">**</Line>
  <Line number="4090">** An append-mark is only valid if the NNNNNNNN start-of-database offset</Line>
  <Line number="4091">** indicates that the appended database contains at least one page.  The</Line>
  <Line number="4092">** start-of-database value must be a multiple of 512.</Line>
  <Line number="4093">*/</Line>
  <Line number="4094">static sqlite3_int64 apndReadMark(sqlite3_int64 sz, sqlite3_file *pFile){</Line>
  <Line number="4095">  int rc, i;</Line>
  <Line number="4096">  sqlite3_int64 iMark;</Line>
  <Line number="4097">  int msbs = 8 <CheckRefs ids="1344">*</CheckRefs> (APND_MARK_FOS_SZ<CheckRefs ids="1345">-</CheckRefs>1);</Line>
  <Line number="4098">  unsigned char a[<CheckRefs ids="1346">APND_MARK_SIZE</CheckRefs>];</Line>
  <Line number="4099"></Line>
  <Line number="4100">  if( <CheckRefs ids="1347,1348">APND_MARK_SIZE</CheckRefs>!=(sz &amp; <CheckRefs ids="1349">0x1ff</CheckRefs>) ) return <CheckRefs ids="1350,1351">-</CheckRefs>1;</Line>
  <Line number="4101">  rc = pFile-&gt;pMethods-&gt;xRead(pFile, a, <CheckRefs ids="1352">APND_MARK_SIZE</CheckRefs>, sz<CheckRefs ids="1353">-</CheckRefs><CheckRefs ids="1354,1355">APND_MARK_SIZE</CheckRefs>);</Line>
  <Line number="4102">  if( rc ) return <CheckRefs ids="1356,1357">-</CheckRefs>1;</Line>
  <Line number="4103">  if( memcmp(a, APND_MARK_PREFIX, <CheckRefs ids="1358">APND_MARK_PREFIX_SZ</CheckRefs>)!=0 ) return <CheckRefs ids="1359,1360">-</CheckRefs>1;</Line>
  <Line number="4104">  iMark = (<CheckRefs ids="1364">(</CheckRefs>sqlite3_int64)(<CheckRefs ids="1365">a</CheckRefs>[APND_MARK_PREFIX_SZ<CheckRefs ids="1366">]</CheckRefs> &amp; 0x7f)) <CheckRefs ids="1361,1362,1363">&lt;&lt;</CheckRefs> msbs;</Line>
  <Line number="4105">  for(i=1; i&lt;8; i<CheckRefs ids="1367">++</CheckRefs>){</Line>
  <Line number="4106">    msbs <CheckRefs ids="1368">-=</CheckRefs> 8;</Line>
  <Line number="4107">    iMark |= <CheckRefs ids="1372">(</CheckRefs>sqlite3_int64)a[APND_MARK_PREFIX_SZ<CheckRefs ids="1374">+</CheckRefs>i<CheckRefs ids="1373">]</CheckRefs><CheckRefs ids="1370,1371,1369">&lt;&lt;</CheckRefs>msbs;</Line>
  <Line number="4108">  }</Line>
  <Line number="4109">  if( iMark &gt; (sz <CheckRefs ids="1376">-</CheckRefs> <CheckRefs ids="1377,1378">APND_MARK_SIZE</CheckRefs> <CheckRefs ids="1375">-</CheckRefs> <CheckRefs ids="1379">512</CheckRefs>) ) return <CheckRefs ids="1380,1381">-</CheckRefs>1;</Line>
  <Line number="4110">  if( iMark &amp; <CheckRefs ids="1382">0x1ff</CheckRefs> ) return <CheckRefs ids="1383,1384">-</CheckRefs>1;</Line>
  <Line number="4111">  return iMark;</Line>
  <Line number="4112">}</Line>
  <Line number="4113"></Line>
  <Line number="4114">static const char apvfsSqliteHdr[] = &quot;SQLite format 3&quot;;</Line>
  <Line number="4115">/*</Line>
  <Line number="4116">** Check to see if the file is an appendvfs SQLite database file.</Line>
  <Line number="4117">** Return true iff it is such. Parameter sz is the file&apos;s size.</Line>
  <Line number="4118">*/</Line>
  <Line number="4119">static int apndIsAppendvfsDatabase(sqlite3_int64 sz, sqlite3_file *pFile){</Line>
  <Line number="4120">  int rc;</Line>
  <Line number="4121">  char zHdr[16];</Line>
  <Line number="4122">  sqlite3_int64 iMark = apndReadMark(sz, pFile);</Line>
  <Line number="4123">  if( iMark&gt;=<CheckRefs ids="1385">0</CheckRefs> ){</Line>
  <Line number="4124">    /* If file has the correct end-marker, the expected odd size, and the</Line>
  <Line number="4125">    ** SQLite DB type marker where the end-marker puts it, then it</Line>
  <Line number="4126">    ** is an appendvfs database.</Line>
  <Line number="4127">    */</Line>
  <Line number="4128">    rc = pFile-&gt;pMethods-&gt;xRead(pFile, zHdr, <CheckRefs ids="1386">sizeof</CheckRefs>(zHdr), iMark);</Line>
  <Line number="4129">    if( SQLITE_OK==rc</Line>
  <Line number="4130">     &amp;&amp; memcmp(zHdr, apvfsSqliteHdr, sizeof(zHdr))==0</Line>
  <Line number="4131">     &amp;&amp; (sz &amp; <CheckRefs ids="1387">0x1ff</CheckRefs>) == <CheckRefs ids="1389,1388">APND_MARK_SIZE</CheckRefs></Line>
  <Line number="4132">     &amp;&amp; sz&gt;=512<CheckRefs ids="1390,1391">+</CheckRefs><CheckRefs ids="1392">APND_MARK_SIZE</CheckRefs></Line>
  <Line number="4133">    ){</Line>
  <Line number="4134">      return 1; /* It&apos;s an appendvfs database */</Line>
  <Line number="4135">    }</Line>
  <Line number="4136">  }</Line>
  <Line number="4137">  return 0;</Line>
  <Line number="4138">}</Line>
  <Line number="4139"></Line>
  <Line number="4140">/*</Line>
  <Line number="4141">** Check to see if the file is an ordinary SQLite database file.</Line>
  <Line number="4142">** Return true iff so. Parameter sz is the file&apos;s size.</Line>
  <Line number="4143">*/</Line>
  <Line number="4144">static int apndIsOrdinaryDatabaseFile(sqlite3_int64 sz, sqlite3_file *pFile){</Line>
  <Line number="4145">  char zHdr[16];</Line>
  <Line number="4146">  if( apndIsAppendvfsDatabase(sz, pFile) /* rule 2 */</Line>
  <Line number="4147">   || (sz &amp; <CheckRefs ids="1393">0x1ff</CheckRefs>) != <CheckRefs ids="1394">0</CheckRefs></Line>
  <Line number="4148">   || SQLITE_OK!=pFile-&gt;pMethods-&gt;xRead(pFile, zHdr, <CheckRefs ids="1395">sizeof</CheckRefs>(zHdr), <CheckRefs ids="1396">0</CheckRefs>)</Line>
  <Line number="4149">   || memcmp(zHdr, apvfsSqliteHdr, sizeof(zHdr))!=0</Line>
  <Line number="4150">  ){</Line>
  <Line number="4151">    return 0;</Line>
  <Line number="4152">  }else{</Line>
  <Line number="4153">    return 1;</Line>
  <Line number="4154">  }</Line>
  <Line number="4155">}</Line>
  <Line number="4156"></Line>
  <Line number="4157">/*</Line>
  <Line number="4158">** Open an apnd file handle.</Line>
  <Line number="4159">*/</Line>
  <Line number="4160">static int apndOpen(</Line>
  <Line number="4161">  sqlite3_vfs *pApndVfs,</Line>
  <Line number="4162">  const char *zName,</Line>
  <Line number="4163">  sqlite3_file *pFile,</Line>
  <Line number="4164">  int flags,</Line>
  <Line number="4165">  int *pOutFlags</Line>
  <Line number="4166">){</Line>
  <Line number="4167">  ApndFile *pApndFile = (ApndFile*)pFile;</Line>
  <Line number="4168">  sqlite3_file *pBaseFile = ORIGFILE(pFile);</Line>
  <Line number="4169">  sqlite3_vfs *pBaseVfs = ORIGVFS(pApndVfs);</Line>
  <Line number="4170">  int rc;</Line>
  <Line number="4171">  sqlite3_int64 sz = <CheckRefs ids="1397">0</CheckRefs>;</Line>
  <Line number="4172">  if( (flags &amp; SQLITE_OPEN_MAIN_DB)==0 ){</Line>
  <Line number="4173">    /* The appendvfs is not to be used for transient or temporary databases.</Line>
  <Line number="4174">    ** Just use the base VFS open to initialize the given file object and</Line>
  <Line number="4175">    ** open the underlying file. (Appendvfs is then unused for this file.)</Line>
  <Line number="4176">    */</Line>
  <Line number="4177">    return pBaseVfs-&gt;xOpen(pBaseVfs, zName, pFile, flags, pOutFlags);</Line>
  <Line number="4178">  }</Line>
  <Line number="4179">  memset(pApndFile, 0, sizeof(ApndFile));</Line>
  <Line number="4180">  pFile-&gt;pMethods = &amp;apnd_io_methods;</Line>
  <Line number="4181">  pApndFile-&gt;iMark = <CheckRefs ids="1398,1399">-</CheckRefs>1;    /* Append mark not yet written */</Line>
  <Line number="4182"></Line>
  <Line number="4183">  rc = pBaseVfs-&gt;xOpen(pBaseVfs, zName, pBaseFile, flags, pOutFlags);</Line>
  <Line number="4184">  if( rc==SQLITE_OK ){</Line>
  <Line number="4185">    rc = pBaseFile-&gt;pMethods-&gt;xFileSize(pBaseFile, &amp;sz);</Line>
  <Line number="4186">    if( rc ){</Line>
  <Line number="4187">      pBaseFile-&gt;pMethods-&gt;xClose(pBaseFile);</Line>
  <Line number="4188">    }</Line>
  <Line number="4189">  }</Line>
  <Line number="4190">  if( rc ){</Line>
  <Line number="4191">    pFile-&gt;pMethods = 0;</Line>
  <Line number="4192">    return rc;</Line>
  <Line number="4193">  }</Line>
  <Line number="4194">  if( apndIsOrdinaryDatabaseFile(sz, pBaseFile) ){</Line>
  <Line number="4195">    /* The file being opened appears to be just an ordinary DB. Copy</Line>
  <Line number="4196">    ** the base dispatch-table so this instance mimics the base VFS. </Line>
  <Line number="4197">    */</Line>
  <Line number="4198">    memmove(pApndFile, pBaseFile, <CheckRefs ids="1400">pBaseVfs</CheckRefs>-&gt;szOsFile);</Line>
  <Line number="4199">    return SQLITE_OK;</Line>
  <Line number="4200">  }</Line>
  <Line number="4201">  pApndFile-&gt;iPgOne = apndReadMark(sz, pFile);</Line>
  <Line number="4202">  if( pApndFile-&gt;iPgOne&gt;=<CheckRefs ids="1401">0</CheckRefs> ){</Line>
  <Line number="4203">    pApndFile-&gt;iMark = sz <CheckRefs ids="1402">-</CheckRefs> <CheckRefs ids="1403,1404">APND_MARK_SIZE</CheckRefs>; /* Append mark found */</Line>
  <Line number="4204">    return SQLITE_OK;</Line>
  <Line number="4205">  }</Line>
  <Line number="4206">  if( (flags &amp; SQLITE_OPEN_CREATE)==0 ){</Line>
  <Line number="4207">    pBaseFile-&gt;pMethods-&gt;xClose(pBaseFile);</Line>
  <Line number="4208">    rc = SQLITE_CANTOPEN;</Line>
  <Line number="4209">    pFile-&gt;pMethods = 0;</Line>
  <Line number="4210">  }else{</Line>
  <Line number="4211">    /* Round newly added appendvfs location to #define&apos;d page boundary. </Line>
  <Line number="4212">    ** Note that nothing has yet been written to the underlying file.</Line>
  <Line number="4213">    ** The append mark will be written along with first content write.</Line>
  <Line number="4214">    ** Until then, paf-&gt;iMark value indicates it is not yet written.</Line>
  <Line number="4215">    */</Line>
  <Line number="4216">    pApndFile-&gt;iPgOne = <CheckRefs ids="1406,1407,1405">APND_START_ROUNDUP</CheckRefs>(sz);</Line>
  <Line number="4217">  }</Line>
  <Line number="4218">  return rc;</Line>
  <Line number="4219">}</Line>
  <Line number="4220"></Line>
  <Line number="4221">/*</Line>
  <Line number="4222">** Delete an apnd file.</Line>
  <Line number="4223">** For an appendvfs, this could mean delete the appendvfs portion,</Line>
  <Line number="4224">** leaving the appendee as it was before it gained an appendvfs.</Line>
  <Line number="4225">** For now, this code deletes the underlying file too.</Line>
  <Line number="4226">*/</Line>
  <Line number="4227">static int apndDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){</Line>
  <Line number="4228">  return ORIGVFS(pVfs)-&gt;xDelete(ORIGVFS(pVfs), zPath, dirSync);</Line>
  <Line number="4229">}</Line>
  <Line number="4230"></Line>
  <Line number="4231">/*</Line>
  <Line number="4232">** All other VFS methods are pass-thrus.</Line>
  <Line number="4233">*/</Line>
  <Line number="4234">static int apndAccess(</Line>
  <Line number="4235">  sqlite3_vfs *pVfs, </Line>
  <Line number="4236">  const char *zPath, </Line>
  <Line number="4237">  int flags, </Line>
  <Line number="4238">  int *pResOut</Line>
  <Line number="4239">){</Line>
  <Line number="4240">  return ORIGVFS(pVfs)-&gt;xAccess(ORIGVFS(pVfs), zPath, flags, pResOut);</Line>
  <Line number="4241">}</Line>
  <Line number="4242">static int apndFullPathname(</Line>
  <Line number="4243">  sqlite3_vfs *pVfs, </Line>
  <Line number="4244">  const char *zPath, </Line>
  <Line number="4245">  int nOut, </Line>
  <Line number="4246">  char *zOut</Line>
  <Line number="4247">){</Line>
  <Line number="4248">  return ORIGVFS(pVfs)-&gt;xFullPathname(ORIGVFS(pVfs),zPath,nOut,zOut);</Line>
  <Line number="4249">}</Line>
  <Line number="4250">static void *apndDlOpen(sqlite3_vfs *pVfs, const char *zPath){</Line>
  <Line number="4251">  return ORIGVFS(pVfs)-&gt;xDlOpen(ORIGVFS(pVfs), zPath);</Line>
  <Line number="4252">}</Line>
  <Line number="4253">static void apndDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){</Line>
  <Line number="4254">  ORIGVFS(pVfs)-&gt;xDlError(ORIGVFS(pVfs), nByte, zErrMsg);</Line>
  <Line number="4255">}</Line>
  <Line number="4256">static void (*apndDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){</Line>
  <Line number="4257">  return ORIGVFS(pVfs)-&gt;xDlSym(ORIGVFS(pVfs), p, zSym);</Line>
  <Line number="4258">}</Line>
  <Line number="4259">static void apndDlClose(sqlite3_vfs *pVfs, void *pHandle){</Line>
  <Line number="4260">  ORIGVFS(pVfs)-&gt;xDlClose(ORIGVFS(pVfs), pHandle);</Line>
  <Line number="4261">}</Line>
  <Line number="4262">static int apndRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){</Line>
  <Line number="4263">  return ORIGVFS(pVfs)-&gt;xRandomness(ORIGVFS(pVfs), nByte, zBufOut);</Line>
  <Line number="4264">}</Line>
  <Line number="4265">static int apndSleep(sqlite3_vfs *pVfs, int nMicro){</Line>
  <Line number="4266">  return ORIGVFS(pVfs)-&gt;xSleep(ORIGVFS(pVfs), nMicro);</Line>
  <Line number="4267">}</Line>
  <Line number="4268">static int apndCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){</Line>
  <Line number="4269">  return ORIGVFS(pVfs)-&gt;xCurrentTime(ORIGVFS(pVfs), pTimeOut);</Line>
  <Line number="4270">}</Line>
  <Line number="4271">static int apndGetLastError(sqlite3_vfs *pVfs, int a, char *b){</Line>
  <Line number="4272">  return ORIGVFS(pVfs)-&gt;xGetLastError(ORIGVFS(pVfs), a, b);</Line>
  <Line number="4273">}</Line>
  <Line number="4274">static int apndCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *p){</Line>
  <Line number="4275">  return ORIGVFS(pVfs)-&gt;xCurrentTimeInt64(ORIGVFS(pVfs), p);</Line>
  <Line number="4276">}</Line>
  <Line number="4277">static int apndSetSystemCall(</Line>
  <Line number="4278">  sqlite3_vfs *pVfs,</Line>
  <Line number="4279">  const char *zName,</Line>
  <Line number="4280">  sqlite3_syscall_ptr pCall</Line>
  <Line number="4281">){</Line>
  <Line number="4282">  return ORIGVFS(pVfs)-&gt;xSetSystemCall(ORIGVFS(pVfs),zName,pCall);</Line>
  <Line number="4283">}</Line>
  <Line number="4284">static sqlite3_syscall_ptr apndGetSystemCall(</Line>
  <Line number="4285">  sqlite3_vfs *pVfs,</Line>
  <Line number="4286">  const char *zName</Line>
  <Line number="4287">){</Line>
  <Line number="4288">  return ORIGVFS(pVfs)-&gt;xGetSystemCall(ORIGVFS(pVfs),zName);</Line>
  <Line number="4289">}</Line>
  <Line number="4290">static const char *apndNextSystemCall(sqlite3_vfs *pVfs, const char *zName){</Line>
  <Line number="4291">  return ORIGVFS(pVfs)-&gt;xNextSystemCall(ORIGVFS(pVfs), zName);</Line>
  <Line number="4292">}</Line>
  <Line number="4293"></Line>
  <Line number="4294">  </Line>
  <Line number="4295">#ifdef _WIN32</Line>
  <Line number="4296"></Line>
  <Line number="4297">#endif</Line>
  <Line number="4298">/* </Line>
  <Line number="4299">** This routine is called when the extension is loaded.</Line>
  <Line number="4300">** Register the new VFS.</Line>
  <Line number="4301">*/</Line>
  <Line number="4302">int sqlite3_appendvfs_init(</Line>
  <Line number="4303">  sqlite3 *db, </Line>
  <Line number="4304">  char **pzErrMsg, </Line>
  <Line number="4305">  const sqlite3_api_routines *pApi</Line>
  <Line number="4306">){</Line>
  <Line number="4307">  int rc = SQLITE_OK;</Line>
  <Line number="4308">  sqlite3_vfs *pOrig;</Line>
  <Line number="4309">  SQLITE_EXTENSION_INIT2(pApi);</Line>
  <Line number="4310">  (void)pzErrMsg;</Line>
  <Line number="4311">  (void)db;</Line>
  <Line number="4312">  pOrig = sqlite3_vfs_find(0);</Line>
  <Line number="4313">  if( pOrig==0 ) return SQLITE_ERROR;</Line>
  <Line number="4314">  apnd_vfs.iVersion = pOrig-&gt;iVersion;</Line>
  <Line number="4315">  apnd_vfs.pAppData = pOrig;</Line>
  <Line number="4316">  apnd_vfs.szOsFile = <CheckRefs ids="1410">pOrig</CheckRefs>-&gt;szOsFile <CheckRefs ids="1409,1408">+</CheckRefs> sizeof(ApndFile);</Line>
  <Line number="4317">  rc = sqlite3_vfs_register(&amp;apnd_vfs, 0);</Line>
  <Line number="4318">#ifdef APPENDVFS_TEST</Line>
  <Line number="4319">  if( rc==SQLITE_OK ){</Line>
  <Line number="4320">    rc = sqlite3_auto_extension((void(*)(void))apndvfsRegister);</Line>
  <Line number="4321">  }</Line>
  <Line number="4322">#endif</Line>
  <Line number="4323">  if( rc==SQLITE_OK ) rc = <CheckRefs ids="1412,1411,1413">SQLITE_OK_LOAD_PERMANENTLY</CheckRefs>;</Line>
  <Line number="4324">  return rc;</Line>
  <Line number="4325">}</Line>
  <Line number="4326"></Line>
  <Line number="4327">/************************* End ../ext/misc/appendvfs.c ********************/</Line>
  <Line number="4328">/************************* Begin ../ext/misc/memtrace.c ******************/</Line>
  <Line number="4329">/*</Line>
  <Line number="4330">** 2019-01-21</Line>
  <Line number="4331">**</Line>
  <Line number="4332">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="4333">** a legal notice, here is a blessing:</Line>
  <Line number="4334">**</Line>
  <Line number="4335">**    May you do good and not evil.</Line>
  <Line number="4336">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="4337">**    May you share freely, never taking more than you give.</Line>
  <Line number="4338">**</Line>
  <Line number="4339">*************************************************************************</Line>
  <Line number="4340">**</Line>
  <Line number="4341">** This file implements an extension that uses the SQLITE_CONFIG_MALLOC</Line>
  <Line number="4342">** mechanism to add a tracing layer on top of SQLite.  If this extension</Line>
  <Line number="4343">** is registered prior to sqlite3_initialize(), it will cause all memory</Line>
  <Line number="4344">** allocation activities to be logged on standard output, or to some other</Line>
  <Line number="4345">** FILE specified by the initializer.</Line>
  <Line number="4346">**</Line>
  <Line number="4347">** This file needs to be compiled into the application that uses it.</Line>
  <Line number="4348">**</Line>
  <Line number="4349">** This extension is used to implement the --memtrace option of the</Line>
  <Line number="4350">** command-line shell.</Line>
  <Line number="4351">*/</Line>
  <Line number="4352">#include &lt;assert.h&gt;</Line>
  <Line number="4353">#include &lt;string.h&gt;</Line>
  <Line number="4354">#include &lt;stdio.h&gt;</Line>
  <Line number="4355"></Line>
  <Line number="4356">/* The original memory allocation routines */</Line>
  <Line number="4357">static sqlite3_mem_methods memtraceBase;</Line>
  <Line number="4358">static FILE *memtraceOut;</Line>
  <Line number="4359"></Line>
  <Line number="4360">/* Methods that trace memory allocations */</Line>
  <Line number="4361">static void *memtraceMalloc(int n){</Line>
  <Line number="4362">  if( memtraceOut ){</Line>
  <Line number="4363">    fprintf(memtraceOut, &quot;MEMTRACE: allocate %d bytes\n&quot;, </Line>
  <Line number="4364">            memtraceBase.xRoundup(n));</Line>
  <Line number="4365">  }</Line>
  <Line number="4366">  return memtraceBase.xMalloc(n);</Line>
  <Line number="4367">}</Line>
  <Line number="4368">static void memtraceFree(void *p){</Line>
  <Line number="4369">  if( p==0 ) return;</Line>
  <Line number="4370">  if( memtraceOut ){</Line>
  <Line number="4371">    fprintf(memtraceOut, &quot;MEMTRACE: free %d bytes\n&quot;, memtraceBase.xSize(p));</Line>
  <Line number="4372">  }</Line>
  <Line number="4373">  memtraceBase.xFree(p);</Line>
  <Line number="4374">}</Line>
  <Line number="4375">static void *memtraceRealloc(void *p, int n){</Line>
  <Line number="4376">  if( p==0 ) return memtraceMalloc(n);</Line>
  <Line number="4377">  if( n==0 ){</Line>
  <Line number="4378">    memtraceFree(p);</Line>
  <Line number="4379">    return 0;</Line>
  <Line number="4380">  }</Line>
  <Line number="4381">  if( memtraceOut ){</Line>
  <Line number="4382">    fprintf(memtraceOut, &quot;MEMTRACE: resize %d -&gt; %d bytes\n&quot;,</Line>
  <Line number="4383">            memtraceBase.xSize(p), memtraceBase.xRoundup(n));</Line>
  <Line number="4384">  }</Line>
  <Line number="4385">  return memtraceBase.xRealloc(p, n);</Line>
  <Line number="4386">}</Line>
  <Line number="4387">static int memtraceSize(void *p){</Line>
  <Line number="4388">  return memtraceBase.xSize(p);</Line>
  <Line number="4389">}</Line>
  <Line number="4390">static int memtraceRoundup(int n){</Line>
  <Line number="4391">  return memtraceBase.xRoundup(n);</Line>
  <Line number="4392">}</Line>
  <Line number="4393">static int memtraceInit(void *p){</Line>
  <Line number="4394">  return memtraceBase.xInit(p);</Line>
  <Line number="4395">}</Line>
  <Line number="4396">static void memtraceShutdown(void *p){</Line>
  <Line number="4397">  memtraceBase.xShutdown(p);</Line>
  <Line number="4398">}</Line>
  <Line number="4399"></Line>
  <Line number="4400">/* The substitute memory allocator */</Line>
  <Line number="4401">static sqlite3_mem_methods ersaztMethods = {</Line>
  <Line number="4402">  memtraceMalloc,</Line>
  <Line number="4403">  memtraceFree,</Line>
  <Line number="4404">  memtraceRealloc,</Line>
  <Line number="4405">  memtraceSize,</Line>
  <Line number="4406">  memtraceRoundup,</Line>
  <Line number="4407">  memtraceInit,</Line>
  <Line number="4408">  memtraceShutdown,</Line>
  <Line number="4409">  0</Line>
  <Line number="4410">};</Line>
  <Line number="4411"></Line>
  <Line number="4412">/* Begin tracing memory allocations to out. */</Line>
  <Line number="4413">int sqlite3MemTraceActivate(FILE *out){</Line>
  <Line number="4414">  int rc = SQLITE_OK;</Line>
  <Line number="4415">  if( memtraceBase.xMalloc==0 ){</Line>
  <Line number="4416">    rc = sqlite3_config(SQLITE_CONFIG_GETMALLOC, &amp;memtraceBase);</Line>
  <Line number="4417">    if( rc==SQLITE_OK ){</Line>
  <Line number="4418">      rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &amp;ersaztMethods);</Line>
  <Line number="4419">    }</Line>
  <Line number="4420">  }</Line>
  <Line number="4421">  memtraceOut = out;</Line>
  <Line number="4422">  return rc;</Line>
  <Line number="4423">}</Line>
  <Line number="4424"></Line>
  <Line number="4425">/* Deactivate memory tracing */</Line>
  <Line number="4426">int sqlite3MemTraceDeactivate(void){</Line>
  <Line number="4427">  int rc = SQLITE_OK;</Line>
  <Line number="4428">  if( memtraceBase.xMalloc!=0 ){</Line>
  <Line number="4429">    rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &amp;memtraceBase);</Line>
  <Line number="4430">    if( rc==SQLITE_OK ){</Line>
  <Line number="4431">      memset(&amp;memtraceBase, 0, sizeof(memtraceBase));</Line>
  <Line number="4432">    }</Line>
  <Line number="4433">  }</Line>
  <Line number="4434">  memtraceOut = 0;</Line>
  <Line number="4435">  return rc;</Line>
  <Line number="4436">}</Line>
  <Line number="4437"></Line>
  <Line number="4438">/************************* End ../ext/misc/memtrace.c ********************/</Line>
  <Line number="4439">/************************* Begin ../ext/misc/uint.c ******************/</Line>
  <Line number="4440">/*</Line>
  <Line number="4441">** 2020-04-14</Line>
  <Line number="4442">**</Line>
  <Line number="4443">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="4444">** a legal notice, here is a blessing:</Line>
  <Line number="4445">**</Line>
  <Line number="4446">**    May you do good and not evil.</Line>
  <Line number="4447">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="4448">**    May you share freely, never taking more than you give.</Line>
  <Line number="4449">**</Line>
  <Line number="4450">******************************************************************************</Line>
  <Line number="4451">**</Line>
  <Line number="4452">** This SQLite extension implements the UINT collating sequence.</Line>
  <Line number="4453">**</Line>
  <Line number="4454">** UINT works like BINARY for text, except that embedded strings</Line>
  <Line number="4455">** of digits compare in numeric order.</Line>
  <Line number="4456">**</Line>
  <Line number="4457">**     *   Leading zeros are handled properly, in the sense that</Line>
  <Line number="4458">**         they do not mess of the maginitude comparison of embedded</Line>
  <Line number="4459">**         strings of digits.  &quot;x00123y&quot; is equal to &quot;x123y&quot;.</Line>
  <Line number="4460">**</Line>
  <Line number="4461">**     *   Only unsigned integers are recognized.  Plus and minus</Line>
  <Line number="4462">**         signs are ignored.  Decimal points and exponential notation</Line>
  <Line number="4463">**         are ignored.</Line>
  <Line number="4464">**</Line>
  <Line number="4465">**     *   Embedded integers can be of arbitrary length.  Comparison</Line>
  <Line number="4466">**         is *not* limited integers that can be expressed as a</Line>
  <Line number="4467">**         64-bit machine integer.</Line>
  <Line number="4468">*/</Line>
  <Line number="4469">/* #include &quot;sqlite3ext.h&quot; */</Line>
  <Line number="4470">SQLITE_EXTENSION_INIT1</Line>
  <Line number="4471">#include &lt;assert.h&gt;</Line>
  <Line number="4472">#include &lt;string.h&gt;</Line>
  <Line number="4473">#include &lt;ctype.h&gt;</Line>
  <Line number="4474"></Line>
  <Line number="4475">/*</Line>
  <Line number="4476">** Compare text in lexicographic order, except strings of digits</Line>
  <Line number="4477">** compare in numeric order.</Line>
  <Line number="4478">*/</Line>
  <Line number="4479">static int uintCollFunc(</Line>
  <Line number="4480">  void *notUsed,</Line>
  <Line number="4481">  int nKey1, const void *pKey1,</Line>
  <Line number="4482">  int nKey2, const void *pKey2</Line>
  <Line number="4483">){</Line>
  <Line number="4484">  const unsigned char *zA = (const unsigned char*)pKey1;</Line>
  <Line number="4485">  const unsigned char *zB = (const unsigned char*)pKey2;</Line>
  <Line number="4486">  int i=0, j=0, x;</Line>
  <Line number="4487">  (void)notUsed;</Line>
  <Line number="4488">  while( i&lt;nKey1 &amp;&amp; j&lt;nKey2 ){</Line>
  <Line number="4489">    x = <CheckRefs ids="1415">zA</CheckRefs>[i] <CheckRefs ids="1414">-</CheckRefs> <CheckRefs ids="1416">zB</CheckRefs>[j];</Line>
  <Line number="4490">    if( <CheckRefs ids="1417,1418,1419,1420">isdigit</CheckRefs>(zA[i]) ){</Line>
  <Line number="4491">      int k;</Line>
  <Line number="4492">      if( !<CheckRefs ids="1421,1422,1423,1424">isdigit</CheckRefs>(zB[j]) ) return x;</Line>
  <Line number="4493">      while( i&lt;nKey1 &amp;&amp; <CheckRefs ids="1425">zA</CheckRefs>[i]==&apos;0&apos; ){ i<CheckRefs ids="1426">++</CheckRefs>; }</Line>
  <Line number="4494">      while( j&lt;nKey2 &amp;&amp; <CheckRefs ids="1427">zB</CheckRefs>[j]==&apos;0&apos; ){ j<CheckRefs ids="1428">++</CheckRefs>; }</Line>
  <Line number="4495">      k = 0;</Line>
  <Line number="4496">      while( i<CheckRefs ids="1429">+</CheckRefs>k&lt;nKey1 &amp;&amp; <CheckRefs ids="1430,1431,1433,1434,1432">isdigit</CheckRefs>(zA[i+k])</Line>
  <Line number="4497">             &amp;&amp; j<CheckRefs ids="1435">+</CheckRefs>k&lt;nKey2 &amp;&amp; <CheckRefs ids="1436,1437,1439,1440,1438">isdigit</CheckRefs>(zB[j+k]) ){</Line>
  <Line number="4498">        k<CheckRefs ids="1441">++</CheckRefs>;</Line>
  <Line number="4499">      }</Line>
  <Line number="4500">      if( i<CheckRefs ids="1442">+</CheckRefs>k&lt;nKey1 &amp;&amp; <CheckRefs ids="1444,1446,1447,1443,1445">isdigit</CheckRefs>(zA[i+k]) ){</Line>
  <Line number="4501">        return +1;</Line>
  <Line number="4502">      }else if( j<CheckRefs ids="1448">+</CheckRefs>k&lt;nKey2 &amp;&amp; <CheckRefs ids="1449,1450,1452,1453,1451">isdigit</CheckRefs>(zB[j+k]) ){</Line>
  <Line number="4503">        return <CheckRefs ids="1454">-</CheckRefs>1;</Line>
  <Line number="4504">      }else{</Line>
  <Line number="4505">        x = memcmp(zA+i, zB+j, <CheckRefs ids="1455">k</CheckRefs>);</Line>
  <Line number="4506">        if( x ) return x;</Line>
  <Line number="4507">        i <CheckRefs ids="1456">+=</CheckRefs> k;</Line>
  <Line number="4508">        j <CheckRefs ids="1457">+=</CheckRefs> k;</Line>
  <Line number="4509">      }</Line>
  <Line number="4510">    }else if( x ){</Line>
  <Line number="4511">      return x;</Line>
  <Line number="4512">    }else{</Line>
  <Line number="4513">      i<CheckRefs ids="1458">++</CheckRefs>;</Line>
  <Line number="4514">      j<CheckRefs ids="1459">++</CheckRefs>;</Line>
  <Line number="4515">    }</Line>
  <Line number="4516">  }</Line>
  <Line number="4517">  return (nKey1 <CheckRefs ids="1461">-</CheckRefs> i) <CheckRefs ids="1460">-</CheckRefs> (nKey2 <CheckRefs ids="1462">-</CheckRefs> j);</Line>
  <Line number="4518">}</Line>
  <Line number="4519"></Line>
  <Line number="4520">#ifdef _WIN32</Line>
  <Line number="4521"></Line>
  <Line number="4522">#endif</Line>
  <Line number="4523">int sqlite3_uint_init(</Line>
  <Line number="4524">  sqlite3 *db, </Line>
  <Line number="4525">  char **pzErrMsg, </Line>
  <Line number="4526">  const sqlite3_api_routines *pApi</Line>
  <Line number="4527">){</Line>
  <Line number="4528">  SQLITE_EXTENSION_INIT2(pApi);</Line>
  <Line number="4529">  (void)pzErrMsg;  /* Unused parameter */</Line>
  <Line number="4530">  return sqlite3_create_collation(db, &quot;uint&quot;, SQLITE_UTF8, 0, uintCollFunc);</Line>
  <Line number="4531">}</Line>
  <Line number="4532"></Line>
  <Line number="4533">/************************* End ../ext/misc/uint.c ********************/</Line>
  <Line number="4534">/************************* Begin ../ext/misc/decimal.c ******************/</Line>
  <Line number="4535">/*</Line>
  <Line number="4536">** 2020-06-22</Line>
  <Line number="4537">**</Line>
  <Line number="4538">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="4539">** a legal notice, here is a blessing:</Line>
  <Line number="4540">**</Line>
  <Line number="4541">**    May you do good and not evil.</Line>
  <Line number="4542">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="4543">**    May you share freely, never taking more than you give.</Line>
  <Line number="4544">**</Line>
  <Line number="4545">******************************************************************************</Line>
  <Line number="4546">**</Line>
  <Line number="4547">** Routines to implement arbitrary-precision decimal math.</Line>
  <Line number="4548">**</Line>
  <Line number="4549">** The focus here is on simplicity and correctness, not performance.</Line>
  <Line number="4550">*/</Line>
  <Line number="4551">/* #include &quot;sqlite3ext.h&quot; */</Line>
  <Line number="4552">SQLITE_EXTENSION_INIT1</Line>
  <Line number="4553">#include &lt;assert.h&gt;</Line>
  <Line number="4554">#include &lt;string.h&gt;</Line>
  <Line number="4555">#include &lt;ctype.h&gt;</Line>
  <Line number="4556">#include &lt;stdlib.h&gt;</Line>
  <Line number="4557"></Line>
  <Line number="4558">/* Mark a function parameter as unused, to suppress nuisance compiler</Line>
  <Line number="4559">** warnings. */</Line>
  <Line number="4560">#ifndef UNUSED_PARAMETER</Line>
  <Line number="4561"># define UNUSED_PARAMETER(X)  (void)(X)</Line>
  <Line number="4562">#endif</Line>
  <Line number="4563"></Line>
  <Line number="4564"></Line>
  <Line number="4565">/* A decimal object */</Line>
  <Line number="4566">typedef struct Decimal Decimal;</Line>
  <Line number="4567">struct Decimal {</Line>
  <Line number="4568">  char sign;        /* 0 for positive, 1 for negative */</Line>
  <Line number="4569">  char oom;         /* True if an OOM is encountered */</Line>
  <Line number="4570">  char isNull;      /* True if holds a NULL rather than a number */</Line>
  <Line number="4571">  char isInit;      /* True upon initialization */</Line>
  <Line number="4572">  int nDigit;       /* Total number of digits */</Line>
  <Line number="4573">  int nFrac;        /* Number of digits to the right of the decimal point */</Line>
  <Line number="4574">  signed char *a;   /* Array of digits.  Most significant first. */</Line>
  <Line number="4575">};</Line>
  <Line number="4576"></Line>
  <Line number="4577">/*</Line>
  <Line number="4578">** Release memory held by a Decimal, but do not free the object itself.</Line>
  <Line number="4579">*/</Line>
  <Line number="4580">static void decimal_clear(Decimal *p){</Line>
  <Line number="4581">  sqlite3_free(p-&gt;a);</Line>
  <Line number="4582">}</Line>
  <Line number="4583"></Line>
  <Line number="4584">/*</Line>
  <Line number="4585">** Destroy a Decimal object</Line>
  <Line number="4586">*/</Line>
  <Line number="4587">static void decimal_free(Decimal *p){</Line>
  <Line number="4588">  if( p ){</Line>
  <Line number="4589">    decimal_clear(p);</Line>
  <Line number="4590">    sqlite3_free(p);</Line>
  <Line number="4591">  }</Line>
  <Line number="4592">}</Line>
  <Line number="4593"></Line>
  <Line number="4594">/*</Line>
  <Line number="4595">** Allocate a new Decimal object.  Initialize it to the number given</Line>
  <Line number="4596">** by the input string.</Line>
  <Line number="4597">*/</Line>
  <Line number="4598">static Decimal *decimal_new(</Line>
  <Line number="4599">  sqlite3_context *pCtx,</Line>
  <Line number="4600">  sqlite3_value *pIn,</Line>
  <Line number="4601">  int nAlt,</Line>
  <Line number="4602">  const unsigned char *zAlt</Line>
  <Line number="4603">){</Line>
  <Line number="4604">  Decimal *p;</Line>
  <Line number="4605">  int n, i;</Line>
  <Line number="4606">  const unsigned char *zIn;</Line>
  <Line number="4607">  int iExp = 0;</Line>
  <Line number="4608">  p = sqlite3_malloc( <CheckRefs ids="1463">sizeof</CheckRefs>(*p) );</Line>
  <Line number="4609">  if( p==0 ) goto new_no_mem;</Line>
  <Line number="4610">  p-&gt;sign = <CheckRefs ids="1464">0</CheckRefs>;</Line>
  <Line number="4611">  p-&gt;oom = <CheckRefs ids="1465">0</CheckRefs>;</Line>
  <Line number="4612">  p-&gt;isInit = <CheckRefs ids="1466">1</CheckRefs>;</Line>
  <Line number="4613">  p-&gt;isNull = <CheckRefs ids="1467">0</CheckRefs>;</Line>
  <Line number="4614">  p-&gt;nDigit = 0;</Line>
  <Line number="4615">  p-&gt;nFrac = 0;</Line>
  <Line number="4616">  if( zAlt ){</Line>
  <Line number="4617">    n = nAlt,</Line>
  <Line number="4618">    zIn = zAlt;</Line>
  <Line number="4619">  }else{</Line>
  <Line number="4620">    if( sqlite3_value_type(pIn)==SQLITE_NULL ){</Line>
  <Line number="4621">      p-&gt;a = 0;</Line>
  <Line number="4622">      p-&gt;isNull = <CheckRefs ids="1468">1</CheckRefs>;</Line>
  <Line number="4623">      return p;</Line>
  <Line number="4624">    }</Line>
  <Line number="4625">    n = sqlite3_value_bytes(pIn);</Line>
  <Line number="4626">    zIn = sqlite3_value_text(pIn);</Line>
  <Line number="4627">  }</Line>
  <Line number="4628">  p-&gt;a = sqlite3_malloc64( n<CheckRefs ids="1469,1470">+</CheckRefs>1 );</Line>
  <Line number="4629">  if( p-&gt;a==0 ) goto new_no_mem;</Line>
  <Line number="4630">  for(i=0; <CheckRefs ids="1474,1473,1471,1472">isspace</CheckRefs>(zIn[i]); i<CheckRefs ids="1475">++</CheckRefs>){}</Line>
  <Line number="4631">  if( <CheckRefs ids="1476">zIn</CheckRefs>[i]==&apos;-&apos; ){</Line>
  <Line number="4632">    p-&gt;sign = <CheckRefs ids="1477">1</CheckRefs>;</Line>
  <Line number="4633">    i<CheckRefs ids="1478">++</CheckRefs>;</Line>
  <Line number="4634">  }else if( <CheckRefs ids="1479">zIn</CheckRefs>[i]==&apos;+&apos; ){</Line>
  <Line number="4635">    i<CheckRefs ids="1480">++</CheckRefs>;</Line>
  <Line number="4636">  }</Line>
  <Line number="4637">  while( i&lt;n &amp;&amp; <CheckRefs ids="1481">zIn</CheckRefs>[i]==&apos;0&apos; ) i<CheckRefs ids="1482">++</CheckRefs>;</Line>
  <Line number="4638">  while( i&lt;n ){</Line>
  <Line number="4639">    char c = <CheckRefs ids="1483">zIn</CheckRefs>[i];</Line>
  <Line number="4640">    if( <CheckRefs ids="1484">c</CheckRefs>&gt;=&apos;0&apos; &amp;&amp; <CheckRefs ids="1485">c</CheckRefs>&lt;=&apos;9&apos; ){</Line>
  <Line number="4641">      p-&gt;a[p-&gt;nDigit<CheckRefs ids="1486">++</CheckRefs>] = <CheckRefs ids="1489">c</CheckRefs> <CheckRefs ids="1487,1488">-</CheckRefs> &apos;0&apos;;</Line>
  <Line number="4642">    }else if( <CheckRefs ids="1490">c</CheckRefs>==&apos;.&apos; ){</Line>
  <Line number="4643">      p-&gt;nFrac = p-&gt;nDigit <CheckRefs ids="1491">+</CheckRefs> 1;</Line>
  <Line number="4644">    }else if( <CheckRefs ids="1492">c</CheckRefs>==&apos;e&apos; || <CheckRefs ids="1493">c</CheckRefs>==&apos;E&apos; ){</Line>
  <Line number="4645">      int j = i<CheckRefs ids="1494">+</CheckRefs>1;</Line>
  <Line number="4646">      int neg = 0;</Line>
  <Line number="4647">      if( j&gt;=n ) break;</Line>
  <Line number="4648">      if( <CheckRefs ids="1495">zIn</CheckRefs>[j]==&apos;-&apos; ){</Line>
  <Line number="4649">        neg = 1;</Line>
  <Line number="4650">        j<CheckRefs ids="1496">++</CheckRefs>;</Line>
  <Line number="4651">      }else if( <CheckRefs ids="1497">zIn</CheckRefs>[j]==&apos;+&apos; ){</Line>
  <Line number="4652">        j<CheckRefs ids="1498">++</CheckRefs>;</Line>
  <Line number="4653">      }</Line>
  <Line number="4654">      while( j&lt;n &amp;&amp; iExp&lt;1000000 ){</Line>
  <Line number="4655">        if( <CheckRefs ids="1499">zIn</CheckRefs>[j]&gt;=&apos;0&apos; &amp;&amp; <CheckRefs ids="1500">zIn</CheckRefs>[j]&lt;=&apos;9&apos; ){</Line>
  <Line number="4656">          iExp = iExp<CheckRefs ids="1503">*</CheckRefs>10 <CheckRefs ids="1502">+</CheckRefs> <CheckRefs ids="1504">zIn</CheckRefs>[j] <CheckRefs ids="1501">-</CheckRefs> &apos;0&apos;;</Line>
  <Line number="4657">        }</Line>
  <Line number="4658">        j<CheckRefs ids="1505">++</CheckRefs>;</Line>
  <Line number="4659">      }</Line>
  <Line number="4660">      if( neg ) iExp = <CheckRefs ids="1506">-</CheckRefs>iExp;</Line>
  <Line number="4661">      break;</Line>
  <Line number="4662">    }</Line>
  <Line number="4663">    i<CheckRefs ids="1507">++</CheckRefs>;</Line>
  <Line number="4664">  }</Line>
  <Line number="4665">  if( p-&gt;nFrac ){</Line>
  <Line number="4666">    p-&gt;nFrac = p-&gt;nDigit <CheckRefs ids="1508">-</CheckRefs> (p-&gt;nFrac <CheckRefs ids="1509">-</CheckRefs> 1);</Line>
  <Line number="4667">  }</Line>
  <Line number="4668">  if( iExp&gt;0 ){</Line>
  <Line number="4669">    if( p-&gt;nFrac&gt;0 ){</Line>
  <Line number="4670">      if( iExp&lt;=p-&gt;nFrac ){</Line>
  <Line number="4671">        p-&gt;nFrac <CheckRefs ids="1510">-=</CheckRefs> iExp;</Line>
  <Line number="4672">        iExp = 0;</Line>
  <Line number="4673">      }else{</Line>
  <Line number="4674">        iExp <CheckRefs ids="1511">-=</CheckRefs> p-&gt;nFrac;</Line>
  <Line number="4675">        p-&gt;nFrac = 0;</Line>
  <Line number="4676">      }</Line>
  <Line number="4677">    }</Line>
  <Line number="4678">    if( iExp&gt;0 ){   </Line>
  <Line number="4679">      p-&gt;a = sqlite3_realloc64(p-&gt;a, p-&gt;nDigit <CheckRefs ids="1514">+</CheckRefs> iExp <CheckRefs ids="1512,1513">+</CheckRefs> 1 );</Line>
  <Line number="4680">      if( p-&gt;a==0 ) goto new_no_mem;</Line>
  <Line number="4681">      memset(p-&gt;a+p-&gt;nDigit, 0, <CheckRefs ids="1515">iExp</CheckRefs>);</Line>
  <Line number="4682">      p-&gt;nDigit <CheckRefs ids="1516">+=</CheckRefs> iExp;</Line>
  <Line number="4683">    }</Line>
  <Line number="4684">  }else if( iExp&lt;0 ){</Line>
  <Line number="4685">    int nExtra;</Line>
  <Line number="4686">    iExp = <CheckRefs ids="1517">-</CheckRefs>iExp;</Line>
  <Line number="4687">    nExtra = p-&gt;nDigit <CheckRefs ids="1519">-</CheckRefs> p-&gt;nFrac <CheckRefs ids="1518">-</CheckRefs> 1;</Line>
  <Line number="4688">    if( nExtra ){</Line>
  <Line number="4689">      if( nExtra&gt;=iExp ){</Line>
  <Line number="4690">        p-&gt;nFrac <CheckRefs ids="1520">+=</CheckRefs> iExp;</Line>
  <Line number="4691">        iExp  = 0;</Line>
  <Line number="4692">      }else{</Line>
  <Line number="4693">        iExp <CheckRefs ids="1521">-=</CheckRefs> nExtra;</Line>
  <Line number="4694">        p-&gt;nFrac = p-&gt;nDigit <CheckRefs ids="1522">-</CheckRefs> 1;</Line>
  <Line number="4695">      }</Line>
  <Line number="4696">    }</Line>
  <Line number="4697">    if( iExp&gt;0 ){</Line>
  <Line number="4698">      p-&gt;a = sqlite3_realloc64(p-&gt;a, p-&gt;nDigit <CheckRefs ids="1525">+</CheckRefs> iExp <CheckRefs ids="1523,1524">+</CheckRefs> 1 );</Line>
  <Line number="4699">      if( p-&gt;a==0 ) goto new_no_mem;</Line>
  <Line number="4700">      memmove(p-&gt;a+iExp, p-&gt;a, <CheckRefs ids="1526">p</CheckRefs>-&gt;nDigit);</Line>
  <Line number="4701">      memset(p-&gt;a, 0, <CheckRefs ids="1527">iExp</CheckRefs>);</Line>
  <Line number="4702">      p-&gt;nDigit <CheckRefs ids="1528">+=</CheckRefs> iExp;</Line>
  <Line number="4703">      p-&gt;nFrac <CheckRefs ids="1529">+=</CheckRefs> iExp;</Line>
  <Line number="4704">    }</Line>
  <Line number="4705">  }</Line>
  <Line number="4706">  return p;</Line>
  <Line number="4707"></Line>
  <Line number="4708">new_no_mem:</Line>
  <Line number="4709">  if( pCtx ) sqlite3_result_error_nomem(pCtx);</Line>
  <Line number="4710">  sqlite3_free(p);</Line>
  <Line number="4711">  return 0;</Line>
  <Line number="4712">}</Line>
  <Line number="4713"></Line>
  <Line number="4714">/*</Line>
  <Line number="4715">** Make the given Decimal the result.</Line>
  <Line number="4716">*/</Line>
  <Line number="4717">static void decimal_result(sqlite3_context *pCtx, Decimal *p){</Line>
  <Line number="4718">  char *z;</Line>
  <Line number="4719">  int i, j;</Line>
  <Line number="4720">  int n;</Line>
  <Line number="4721">  if( p==0 || <CheckRefs ids="1530">p</CheckRefs>-&gt;oom ){</Line>
  <Line number="4722">    sqlite3_result_error_nomem(pCtx);</Line>
  <Line number="4723">    return;</Line>
  <Line number="4724">  }</Line>
  <Line number="4725">  if( p-&gt;isNull ){</Line>
  <Line number="4726">    sqlite3_result_null(pCtx);</Line>
  <Line number="4727">    return;</Line>
  <Line number="4728">  }</Line>
  <Line number="4729">  z = sqlite3_malloc( p-&gt;nDigit<CheckRefs ids="1531">+</CheckRefs>4 );</Line>
  <Line number="4730">  if( z==0 ){</Line>
  <Line number="4731">    sqlite3_result_error_nomem(pCtx);</Line>
  <Line number="4732">    return;</Line>
  <Line number="4733">  }</Line>
  <Line number="4734">  i = 0;</Line>
  <Line number="4735">  if( p-&gt;nDigit==0 || (p-&gt;nDigit==1 &amp;&amp; <CheckRefs ids="1532">p</CheckRefs>-&gt;a[0]==0) ){</Line>
  <Line number="4736">    p-&gt;sign = <CheckRefs ids="1533">0</CheckRefs>;</Line>
  <Line number="4737">  }</Line>
  <Line number="4738">  if( p-&gt;sign ){</Line>
  <Line number="4739">    z[0] = <CheckRefs ids="1534">&apos;-&apos;</CheckRefs>;</Line>
  <Line number="4740">    i = 1;</Line>
  <Line number="4741">  }</Line>
  <Line number="4742">  n = p-&gt;nDigit <CheckRefs ids="1535">-</CheckRefs> p-&gt;nFrac;</Line>
  <Line number="4743">  if( n&lt;=0 ){</Line>
  <Line number="4744">    z[i<CheckRefs ids="1536">++</CheckRefs>] = <CheckRefs ids="1537">&apos;0&apos;</CheckRefs>;</Line>
  <Line number="4745">  }</Line>
  <Line number="4746">  j = 0;</Line>
  <Line number="4747">  while( n&gt;1 &amp;&amp; <CheckRefs ids="1538">p</CheckRefs>-&gt;a[j]==0 ){</Line>
  <Line number="4748">    j<CheckRefs ids="1539">++</CheckRefs>;</Line>
  <Line number="4749">    n<CheckRefs ids="1540">--</CheckRefs>;</Line>
  <Line number="4750">  }</Line>
  <Line number="4751">  while( n&gt;0  ){</Line>
  <Line number="4752">    z[i<CheckRefs ids="1541">++</CheckRefs>] = <CheckRefs ids="1544">p</CheckRefs>-&gt;a[j] <CheckRefs ids="1543,1542">+</CheckRefs> &apos;0&apos;;</Line>
  <Line number="4753">    j<CheckRefs ids="1545">++</CheckRefs>;</Line>
  <Line number="4754">    n<CheckRefs ids="1546">--</CheckRefs>;</Line>
  <Line number="4755">  }</Line>
  <Line number="4756">  if( p-&gt;nFrac ){</Line>
  <Line number="4757">    z[i<CheckRefs ids="1547">++</CheckRefs>] = <CheckRefs ids="1548">&apos;.&apos;</CheckRefs>;</Line>
  <Line number="4758">    do{</Line>
  <Line number="4759">      z[i<CheckRefs ids="1549">++</CheckRefs>] = <CheckRefs ids="1552">p</CheckRefs>-&gt;a[j] <CheckRefs ids="1550,1551">+</CheckRefs> &apos;0&apos;;</Line>
  <Line number="4760">      j<CheckRefs ids="1553">++</CheckRefs>;</Line>
  <Line number="4761">    }while( j&lt;p-&gt;nDigit );</Line>
  <Line number="4762">  }</Line>
  <Line number="4763">  z[i] = <CheckRefs ids="1554">0</CheckRefs>;</Line>
  <Line number="4764">  sqlite3_result_text(pCtx, z, i, sqlite3_free);</Line>
  <Line number="4765">}</Line>
  <Line number="4766"></Line>
  <Line number="4767">/*</Line>
  <Line number="4768">** SQL Function:   decimal(X)</Line>
  <Line number="4769">**</Line>
  <Line number="4770">** Convert input X into decimal and then back into text</Line>
  <Line number="4771">*/</Line>
  <Line number="4772">static void decimalFunc(</Line>
  <Line number="4773">  sqlite3_context *context,</Line>
  <Line number="4774">  int argc,</Line>
  <Line number="4775">  sqlite3_value **argv</Line>
  <Line number="4776">){</Line>
  <Line number="4777">  Decimal *p = decimal_new(context, argv[0], 0, 0);</Line>
  <Line number="4778">  UNUSED_PARAMETER(argc);</Line>
  <Line number="4779">  decimal_result(context, p);</Line>
  <Line number="4780">  decimal_free(p);</Line>
  <Line number="4781">}</Line>
  <Line number="4782"></Line>
  <Line number="4783">/*</Line>
  <Line number="4784">** Compare to Decimal objects.  Return negative, 0, or positive if the</Line>
  <Line number="4785">** first object is less than, equal to, or greater than the second.</Line>
  <Line number="4786">**</Line>
  <Line number="4787">** Preconditions for this routine:</Line>
  <Line number="4788">**</Line>
  <Line number="4789">**    pA!=0</Line>
  <Line number="4790">**    pA-&gt;isNull==0</Line>
  <Line number="4791">**    pB!=0</Line>
  <Line number="4792">**    pB-&gt;isNull==0</Line>
  <Line number="4793">*/</Line>
  <Line number="4794">static int decimal_cmp(const Decimal *pA, const Decimal *pB){</Line>
  <Line number="4795">  int nASig, nBSig, rc, n;</Line>
  <Line number="4796">  if( <CheckRefs ids="1555">pA</CheckRefs>-&gt;sign!=<CheckRefs ids="1556">pB</CheckRefs>-&gt;sign ){</Line>
  <Line number="4797">    return <CheckRefs ids="1557">pA</CheckRefs>-&gt;sign ? <CheckRefs ids="1558">-</CheckRefs>1 : +1;</Line>
  <Line number="4798">  }</Line>
  <Line number="4799">  if( pA-&gt;sign ){</Line>
  <Line number="4800">    const Decimal *pTemp = pA;</Line>
  <Line number="4801">    pA = pB;</Line>
  <Line number="4802">    pB = pTemp;</Line>
  <Line number="4803">  }</Line>
  <Line number="4804">  nASig = pA-&gt;nDigit <CheckRefs ids="1559">-</CheckRefs> pA-&gt;nFrac;</Line>
  <Line number="4805">  nBSig = pB-&gt;nDigit <CheckRefs ids="1560">-</CheckRefs> pB-&gt;nFrac;</Line>
  <Line number="4806">  if( nASig!=nBSig ){</Line>
  <Line number="4807">    return nASig <CheckRefs ids="1561">-</CheckRefs> nBSig;</Line>
  <Line number="4808">  }</Line>
  <Line number="4809">  n = pA-&gt;nDigit;</Line>
  <Line number="4810">  if( n&gt;pB-&gt;nDigit ) n = pB-&gt;nDigit;</Line>
  <Line number="4811">  rc = memcmp(pA-&gt;a, pB-&gt;a, <CheckRefs ids="1562">n</CheckRefs>);</Line>
  <Line number="4812">  if( rc==0 ){</Line>
  <Line number="4813">    rc = pA-&gt;nDigit <CheckRefs ids="1563">-</CheckRefs> pB-&gt;nDigit;</Line>
  <Line number="4814">  }</Line>
  <Line number="4815">  return rc;</Line>
  <Line number="4816">}</Line>
  <Line number="4817"></Line>
  <Line number="4818">/*</Line>
  <Line number="4819">** SQL Function:   decimal_cmp(X, Y)</Line>
  <Line number="4820">**</Line>
  <Line number="4821">** Return negative, zero, or positive if X is less then, equal to, or</Line>
  <Line number="4822">** greater than Y.</Line>
  <Line number="4823">*/</Line>
  <Line number="4824">static void decimalCmpFunc(</Line>
  <Line number="4825">  sqlite3_context *context,</Line>
  <Line number="4826">  int argc,</Line>
  <Line number="4827">  sqlite3_value **argv</Line>
  <Line number="4828">){</Line>
  <Line number="4829">  Decimal *pA = 0, *pB = 0;</Line>
  <Line number="4830">  int rc;</Line>
  <Line number="4831"></Line>
  <Line number="4832">  UNUSED_PARAMETER(argc);</Line>
  <Line number="4833">  pA = decimal_new(context, argv[0], 0, 0);</Line>
  <Line number="4834">  if( pA==0 || <CheckRefs ids="1564">pA</CheckRefs>-&gt;isNull ) goto cmp_done;</Line>
  <Line number="4835">  pB = decimal_new(context, argv[1], 0, 0);</Line>
  <Line number="4836">  if( pB==0 || <CheckRefs ids="1565">pB</CheckRefs>-&gt;isNull ) goto cmp_done;</Line>
  <Line number="4837">  rc = decimal_cmp(pA, pB);</Line>
  <Line number="4838">  if( rc&lt;0 ) rc = <CheckRefs ids="1566">-</CheckRefs>1;</Line>
  <Line number="4839">  else if( rc&gt;0 ) rc = +1;</Line>
  <Line number="4840">  sqlite3_result_int(context, rc);</Line>
  <Line number="4841">cmp_done:</Line>
  <Line number="4842">  decimal_free(pA);</Line>
  <Line number="4843">  decimal_free(pB);</Line>
  <Line number="4844">}</Line>
  <Line number="4845"></Line>
  <Line number="4846">/*</Line>
  <Line number="4847">** Expand the Decimal so that it has a least nDigit digits and nFrac</Line>
  <Line number="4848">** digits to the right of the decimal point.</Line>
  <Line number="4849">*/</Line>
  <Line number="4850">static void decimal_expand(Decimal *p, int nDigit, int nFrac){</Line>
  <Line number="4851">  int nAddSig;</Line>
  <Line number="4852">  int nAddFrac;</Line>
  <Line number="4853">  if( p==0 ) return;</Line>
  <Line number="4854">  nAddFrac = nFrac <CheckRefs ids="1567">-</CheckRefs> p-&gt;nFrac;</Line>
  <Line number="4855">  nAddSig = (nDigit <CheckRefs ids="1569">-</CheckRefs> p-&gt;nDigit) <CheckRefs ids="1568">-</CheckRefs> nAddFrac;</Line>
  <Line number="4856">  if( nAddFrac==0 &amp;&amp; nAddSig==0 ) return;</Line>
  <Line number="4857">  p-&gt;a = sqlite3_realloc64(p-&gt;a, nDigit<CheckRefs ids="1570,1571">+</CheckRefs>1);</Line>
  <Line number="4858">  if( p-&gt;a==0 ){</Line>
  <Line number="4859">    p-&gt;oom = <CheckRefs ids="1572">1</CheckRefs>;</Line>
  <Line number="4860">    return;</Line>
  <Line number="4861">  }</Line>
  <Line number="4862">  if( nAddSig ){</Line>
  <Line number="4863">    memmove(p-&gt;a+nAddSig, p-&gt;a, <CheckRefs ids="1573">p</CheckRefs>-&gt;nDigit);</Line>
  <Line number="4864">    memset(p-&gt;a, 0, <CheckRefs ids="1574">nAddSig</CheckRefs>);</Line>
  <Line number="4865">    p-&gt;nDigit <CheckRefs ids="1575">+=</CheckRefs> nAddSig;</Line>
  <Line number="4866">  }</Line>
  <Line number="4867">  if( nAddFrac ){</Line>
  <Line number="4868">    memset(p-&gt;a+p-&gt;nDigit, 0, <CheckRefs ids="1576">nAddFrac</CheckRefs>);</Line>
  <Line number="4869">    p-&gt;nDigit <CheckRefs ids="1577">+=</CheckRefs> nAddFrac;</Line>
  <Line number="4870">    p-&gt;nFrac <CheckRefs ids="1578">+=</CheckRefs> nAddFrac;</Line>
  <Line number="4871">  }</Line>
  <Line number="4872">}</Line>
  <Line number="4873"></Line>
  <Line number="4874">/*</Line>
  <Line number="4875">** Add the value pB into pA.</Line>
  <Line number="4876">**</Line>
  <Line number="4877">** Both pA and pB might become denormalized by this routine.</Line>
  <Line number="4878">*/</Line>
  <Line number="4879">static void decimal_add(Decimal *pA, Decimal *pB){</Line>
  <Line number="4880">  int nSig, nFrac, nDigit;</Line>
  <Line number="4881">  int i, rc;</Line>
  <Line number="4882">  if( pA==0 ){</Line>
  <Line number="4883">    return;</Line>
  <Line number="4884">  }</Line>
  <Line number="4885">  if( <CheckRefs ids="1579">pA</CheckRefs>-&gt;oom || pB==0 || <CheckRefs ids="1580">pB</CheckRefs>-&gt;oom ){</Line>
  <Line number="4886">    pA-&gt;oom = <CheckRefs ids="1581">1</CheckRefs>;</Line>
  <Line number="4887">    return;</Line>
  <Line number="4888">  }</Line>
  <Line number="4889">  if( <CheckRefs ids="1582">pA</CheckRefs>-&gt;isNull || <CheckRefs ids="1583">pB</CheckRefs>-&gt;isNull ){</Line>
  <Line number="4890">    pA-&gt;isNull = <CheckRefs ids="1584">1</CheckRefs>;</Line>
  <Line number="4891">    return;</Line>
  <Line number="4892">  }</Line>
  <Line number="4893">  nSig = pA-&gt;nDigit <CheckRefs ids="1585">-</CheckRefs> pA-&gt;nFrac;</Line>
  <Line number="4894">  if( nSig &amp;&amp; <CheckRefs ids="1586">pA</CheckRefs>-&gt;a[0]==0 ) nSig<CheckRefs ids="1587">--</CheckRefs>;</Line>
  <Line number="4895">  if( nSig&lt;pB-&gt;nDigit<CheckRefs ids="1588">-</CheckRefs>pB-&gt;nFrac ){</Line>
  <Line number="4896">    nSig = pB-&gt;nDigit <CheckRefs ids="1589">-</CheckRefs> pB-&gt;nFrac;</Line>
  <Line number="4897">  }</Line>
  <Line number="4898">  nFrac = pA-&gt;nFrac;</Line>
  <Line number="4899">  if( nFrac&lt;pB-&gt;nFrac ) nFrac = pB-&gt;nFrac;</Line>
  <Line number="4900">  nDigit = nSig <CheckRefs ids="1591">+</CheckRefs> nFrac <CheckRefs ids="1590">+</CheckRefs> 1;</Line>
  <Line number="4901">  decimal_expand(pA, nDigit, nFrac);</Line>
  <Line number="4902">  decimal_expand(pB, nDigit, nFrac);</Line>
  <Line number="4903">  if( <CheckRefs ids="1592">pA</CheckRefs>-&gt;oom || <CheckRefs ids="1593">pB</CheckRefs>-&gt;oom ){</Line>
  <Line number="4904">    pA-&gt;oom = <CheckRefs ids="1594">1</CheckRefs>;</Line>
  <Line number="4905">  }else{</Line>
  <Line number="4906">    if( <CheckRefs ids="1595">pA</CheckRefs>-&gt;sign==<CheckRefs ids="1596">pB</CheckRefs>-&gt;sign ){</Line>
  <Line number="4907">      int carry = 0;</Line>
  <Line number="4908">      for(i=nDigit<CheckRefs ids="1597">-</CheckRefs>1; i&gt;=0; i<CheckRefs ids="1598">--</CheckRefs>){</Line>
  <Line number="4909">        int x = <CheckRefs ids="1601">pA</CheckRefs>-&gt;a[i] <CheckRefs ids="1600">+</CheckRefs> <CheckRefs ids="1602">pB</CheckRefs>-&gt;a[i] <CheckRefs ids="1599">+</CheckRefs> carry;</Line>
  <Line number="4910">        if( x&gt;=10 ){</Line>
  <Line number="4911">          carry = 1;</Line>
  <Line number="4912">          pA-&gt;a[i] = x <CheckRefs ids="1603,1604">-</CheckRefs> 10;</Line>
  <Line number="4913">        }else{</Line>
  <Line number="4914">          carry = 0;</Line>
  <Line number="4915">          pA-&gt;a[i] = <CheckRefs ids="1605">x</CheckRefs>;</Line>
  <Line number="4916">        }</Line>
  <Line number="4917">      }</Line>
  <Line number="4918">    }else{</Line>
  <Line number="4919">      signed char *aA, *aB;</Line>
  <Line number="4920">      int borrow = 0;</Line>
  <Line number="4921">      rc = memcmp(pA-&gt;a, pB-&gt;a, <CheckRefs ids="1606">nDigit</CheckRefs>);</Line>
  <Line number="4922">      if( rc&lt;0 ){</Line>
  <Line number="4923">        aA = pB-&gt;a;</Line>
  <Line number="4924">        aB = pA-&gt;a;</Line>
  <Line number="4925">        pA-&gt;sign = <CheckRefs ids="1607">!</CheckRefs>pA-&gt;sign;</Line>
  <Line number="4926">      }else{</Line>
  <Line number="4927">        aA = pA-&gt;a;</Line>
  <Line number="4928">        aB = pB-&gt;a;</Line>
  <Line number="4929">      }</Line>
  <Line number="4930">      for(i=nDigit<CheckRefs ids="1608">-</CheckRefs>1; i&gt;=0; i<CheckRefs ids="1609">--</CheckRefs>){</Line>
  <Line number="4931">        int x = <CheckRefs ids="1612">aA</CheckRefs>[i] <CheckRefs ids="1611">-</CheckRefs> <CheckRefs ids="1613">aB</CheckRefs>[i] <CheckRefs ids="1610">-</CheckRefs> borrow;</Line>
  <Line number="4932">        if( x&lt;0 ){</Line>
  <Line number="4933">          pA-&gt;a[i] = x<CheckRefs ids="1614,1615">+</CheckRefs>10;</Line>
  <Line number="4934">          borrow = 1;</Line>
  <Line number="4935">        }else{</Line>
  <Line number="4936">          pA-&gt;a[i] = <CheckRefs ids="1616">x</CheckRefs>;</Line>
  <Line number="4937">          borrow = 0;</Line>
  <Line number="4938">        }</Line>
  <Line number="4939">      }</Line>
  <Line number="4940">    }</Line>
  <Line number="4941">  }</Line>
  <Line number="4942">}</Line>
  <Line number="4943"></Line>
  <Line number="4944">/*</Line>
  <Line number="4945">** Compare text in decimal order.</Line>
  <Line number="4946">*/</Line>
  <Line number="4947">static int decimalCollFunc(</Line>
  <Line number="4948">  void *notUsed,</Line>
  <Line number="4949">  int nKey1, const void *pKey1,</Line>
  <Line number="4950">  int nKey2, const void *pKey2</Line>
  <Line number="4951">){</Line>
  <Line number="4952">  const unsigned char *zA = (const unsigned char*)pKey1;</Line>
  <Line number="4953">  const unsigned char *zB = (const unsigned char*)pKey2;</Line>
  <Line number="4954">  Decimal *pA = decimal_new(0, 0, nKey1, zA);</Line>
  <Line number="4955">  Decimal *pB = decimal_new(0, 0, nKey2, zB);</Line>
  <Line number="4956">  int rc;</Line>
  <Line number="4957">  UNUSED_PARAMETER(notUsed);</Line>
  <Line number="4958">  if( pA==0 || pB==0 ){</Line>
  <Line number="4959">    rc = 0;</Line>
  <Line number="4960">  }else{</Line>
  <Line number="4961">    rc = decimal_cmp(pA, pB);</Line>
  <Line number="4962">  }</Line>
  <Line number="4963">  decimal_free(pA);</Line>
  <Line number="4964">  decimal_free(pB);</Line>
  <Line number="4965">  return rc;</Line>
  <Line number="4966">}</Line>
  <Line number="4967"></Line>
  <Line number="4968"></Line>
  <Line number="4969">/*</Line>
  <Line number="4970">** SQL Function:   decimal_add(X, Y)</Line>
  <Line number="4971">**                 decimal_sub(X, Y)</Line>
  <Line number="4972">**</Line>
  <Line number="4973">** Return the sum or difference of X and Y.</Line>
  <Line number="4974">*/</Line>
  <Line number="4975">static void decimalAddFunc(</Line>
  <Line number="4976">  sqlite3_context *context,</Line>
  <Line number="4977">  int argc,</Line>
  <Line number="4978">  sqlite3_value **argv</Line>
  <Line number="4979">){</Line>
  <Line number="4980">  Decimal *pA = decimal_new(context, argv[0], 0, 0);</Line>
  <Line number="4981">  Decimal *pB = decimal_new(context, argv[1], 0, 0);</Line>
  <Line number="4982">  UNUSED_PARAMETER(argc);</Line>
  <Line number="4983">  decimal_add(pA, pB);</Line>
  <Line number="4984">  decimal_result(context, pA);</Line>
  <Line number="4985">  decimal_free(pA);</Line>
  <Line number="4986">  decimal_free(pB);</Line>
  <Line number="4987">}</Line>
  <Line number="4988">static void decimalSubFunc(</Line>
  <Line number="4989">  sqlite3_context *context,</Line>
  <Line number="4990">  int argc,</Line>
  <Line number="4991">  sqlite3_value **argv</Line>
  <Line number="4992">){</Line>
  <Line number="4993">  Decimal *pA = decimal_new(context, argv[0], 0, 0);</Line>
  <Line number="4994">  Decimal *pB = decimal_new(context, argv[1], 0, 0);</Line>
  <Line number="4995">  UNUSED_PARAMETER(argc);</Line>
  <Line number="4996">  if( pB ){</Line>
  <Line number="4997">    pB-&gt;sign = <CheckRefs ids="1617">!</CheckRefs>pB-&gt;sign;</Line>
  <Line number="4998">    decimal_add(pA, pB);</Line>
  <Line number="4999">    decimal_result(context, pA);</Line>
  <Line number="5000">  }</Line>
  <Line number="5001">  decimal_free(pA);</Line>
  <Line number="5002">  decimal_free(pB);</Line>
  <Line number="5003">}</Line>
  <Line number="5004"></Line>
  <Line number="5005">/* Aggregate funcion:   decimal_sum(X)</Line>
  <Line number="5006">**</Line>
  <Line number="5007">** Works like sum() except that it uses decimal arithmetic for unlimited</Line>
  <Line number="5008">** precision.</Line>
  <Line number="5009">*/</Line>
  <Line number="5010">static void decimalSumStep(</Line>
  <Line number="5011">  sqlite3_context *context,</Line>
  <Line number="5012">  int argc,</Line>
  <Line number="5013">  sqlite3_value **argv</Line>
  <Line number="5014">){</Line>
  <Line number="5015">  Decimal *p;</Line>
  <Line number="5016">  Decimal *pArg;</Line>
  <Line number="5017">  UNUSED_PARAMETER(argc);</Line>
  <Line number="5018">  p = sqlite3_aggregate_context(context, <CheckRefs ids="1618">sizeof</CheckRefs>(*p));</Line>
  <Line number="5019">  if( p==0 ) return;</Line>
  <Line number="5020">  if( !p-&gt;isInit ){</Line>
  <Line number="5021">    p-&gt;isInit = <CheckRefs ids="1619">1</CheckRefs>;</Line>
  <Line number="5022">    p-&gt;a = sqlite3_malloc(2);</Line>
  <Line number="5023">    if( p-&gt;a==0 ){</Line>
  <Line number="5024">      p-&gt;oom = <CheckRefs ids="1620">1</CheckRefs>;</Line>
  <Line number="5025">    }else{</Line>
  <Line number="5026">      p-&gt;a[0] = <CheckRefs ids="1621">0</CheckRefs>;</Line>
  <Line number="5027">    }</Line>
  <Line number="5028">    p-&gt;nDigit = 1;</Line>
  <Line number="5029">    p-&gt;nFrac = 0;</Line>
  <Line number="5030">  }</Line>
  <Line number="5031">  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;</Line>
  <Line number="5032">  pArg = decimal_new(context, argv[0], 0, 0);</Line>
  <Line number="5033">  decimal_add(p, pArg);</Line>
  <Line number="5034">  decimal_free(pArg);</Line>
  <Line number="5035">}</Line>
  <Line number="5036">static void decimalSumInverse(</Line>
  <Line number="5037">  sqlite3_context *context,</Line>
  <Line number="5038">  int argc,</Line>
  <Line number="5039">  sqlite3_value **argv</Line>
  <Line number="5040">){</Line>
  <Line number="5041">  Decimal *p;</Line>
  <Line number="5042">  Decimal *pArg;</Line>
  <Line number="5043">  UNUSED_PARAMETER(argc);</Line>
  <Line number="5044">  p = sqlite3_aggregate_context(context, <CheckRefs ids="1622">sizeof</CheckRefs>(*p));</Line>
  <Line number="5045">  if( p==0 ) return;</Line>
  <Line number="5046">  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;</Line>
  <Line number="5047">  pArg = decimal_new(context, argv[0], 0, 0);</Line>
  <Line number="5048">  if( pArg ) pArg-&gt;sign = <CheckRefs ids="1623">!</CheckRefs>pArg-&gt;sign;</Line>
  <Line number="5049">  decimal_add(p, pArg);</Line>
  <Line number="5050">  decimal_free(pArg);</Line>
  <Line number="5051">}</Line>
  <Line number="5052">static void decimalSumValue(sqlite3_context *context){</Line>
  <Line number="5053">  Decimal *p = sqlite3_aggregate_context(context, 0);</Line>
  <Line number="5054">  if( p==0 ) return;</Line>
  <Line number="5055">  decimal_result(context, p);</Line>
  <Line number="5056">}</Line>
  <Line number="5057">static void decimalSumFinalize(sqlite3_context *context){</Line>
  <Line number="5058">  Decimal *p = sqlite3_aggregate_context(context, 0);</Line>
  <Line number="5059">  if( p==0 ) return;</Line>
  <Line number="5060">  decimal_result(context, p);</Line>
  <Line number="5061">  decimal_clear(p);</Line>
  <Line number="5062">}</Line>
  <Line number="5063"></Line>
  <Line number="5064">/*</Line>
  <Line number="5065">** SQL Function:   decimal_mul(X, Y)</Line>
  <Line number="5066">**</Line>
  <Line number="5067">** Return the product of X and Y.</Line>
  <Line number="5068">**</Line>
  <Line number="5069">** All significant digits after the decimal point are retained.</Line>
  <Line number="5070">** Trailing zeros after the decimal point are omitted as long as</Line>
  <Line number="5071">** the number of digits after the decimal point is no less than</Line>
  <Line number="5072">** either the number of digits in either input.</Line>
  <Line number="5073">*/</Line>
  <Line number="5074">static void decimalMulFunc(</Line>
  <Line number="5075">  sqlite3_context *context,</Line>
  <Line number="5076">  int argc,</Line>
  <Line number="5077">  sqlite3_value **argv</Line>
  <Line number="5078">){</Line>
  <Line number="5079">  Decimal *pA = decimal_new(context, argv[0], 0, 0);</Line>
  <Line number="5080">  Decimal *pB = decimal_new(context, argv[1], 0, 0);</Line>
  <Line number="5081">  signed char *acc = 0;</Line>
  <Line number="5082">  int i, j, k;</Line>
  <Line number="5083">  int minFrac;</Line>
  <Line number="5084">  UNUSED_PARAMETER(argc);</Line>
  <Line number="5085">  if( pA==0 || <CheckRefs ids="1624">pA</CheckRefs>-&gt;oom || <CheckRefs ids="1625">pA</CheckRefs>-&gt;isNull</Line>
  <Line number="5086">   || pB==0 || <CheckRefs ids="1626">pB</CheckRefs>-&gt;oom || <CheckRefs ids="1627">pB</CheckRefs>-&gt;isNull </Line>
  <Line number="5087">  ){</Line>
  <Line number="5088">    goto mul_end;</Line>
  <Line number="5089">  }</Line>
  <Line number="5090">  acc = sqlite3_malloc64( pA-&gt;nDigit <CheckRefs ids="1630">+</CheckRefs> pB-&gt;nDigit <CheckRefs ids="1628,1629">+</CheckRefs> 2 );</Line>
  <Line number="5091">  if( acc==0 ){</Line>
  <Line number="5092">    sqlite3_result_error_nomem(context);</Line>
  <Line number="5093">    goto mul_end;</Line>
  <Line number="5094">  }</Line>
  <Line number="5095">  memset(acc, 0, pA-&gt;nDigit <CheckRefs ids="1633">+</CheckRefs> pB-&gt;nDigit <CheckRefs ids="1631,1632">+</CheckRefs> 2);</Line>
  <Line number="5096">  minFrac = pA-&gt;nFrac;</Line>
  <Line number="5097">  if( pB-&gt;nFrac&lt;minFrac ) minFrac = pB-&gt;nFrac;</Line>
  <Line number="5098">  for(i=pA-&gt;nDigit<CheckRefs ids="1634">-</CheckRefs>1; i&gt;=0; i<CheckRefs ids="1635">--</CheckRefs>){</Line>
  <Line number="5099">    signed char f = pA-&gt;a[i];</Line>
  <Line number="5100">    int carry = 0, x;</Line>
  <Line number="5101">    for(j=pB-&gt;nDigit<CheckRefs ids="1636">-</CheckRefs>1, k=i<CheckRefs ids="1638">+</CheckRefs>j<CheckRefs ids="1637">+</CheckRefs>3; j&gt;=0; j<CheckRefs ids="1639">--</CheckRefs>, k<CheckRefs ids="1640">--</CheckRefs>){</Line>
  <Line number="5102">      x = <CheckRefs ids="1643">acc</CheckRefs>[k] <CheckRefs ids="1642">+</CheckRefs> <CheckRefs ids="1645">f</CheckRefs><CheckRefs ids="1644">*</CheckRefs><CheckRefs ids="1646">pB</CheckRefs>-&gt;a[j] <CheckRefs ids="1641">+</CheckRefs> carry;</Line>
  <Line number="5103">      acc[k] = x<CheckRefs ids="1647,1648">%</CheckRefs>10;</Line>
  <Line number="5104">      carry = x<CheckRefs ids="1649,1650">/</CheckRefs>10;</Line>
  <Line number="5105">    }</Line>
  <Line number="5106">    x = <CheckRefs ids="1652">acc</CheckRefs>[k] <CheckRefs ids="1651">+</CheckRefs> carry;</Line>
  <Line number="5107">    acc[k] = x<CheckRefs ids="1654,1653">%</CheckRefs>10;</Line>
  <Line number="5108">    acc[k<CheckRefs ids="1656">-</CheckRefs>1] <CheckRefs ids="1655">+=</CheckRefs> x<CheckRefs ids="1657,1658">/</CheckRefs>10;</Line>
  <Line number="5109">  }</Line>
  <Line number="5110">  sqlite3_free(pA-&gt;a);</Line>
  <Line number="5111">  pA-&gt;a = acc;</Line>
  <Line number="5112">  acc = 0;</Line>
  <Line number="5113">  pA-&gt;nDigit <CheckRefs ids="1659">+=</CheckRefs> pB-&gt;nDigit <CheckRefs ids="1660">+</CheckRefs> 2;</Line>
  <Line number="5114">  pA-&gt;nFrac <CheckRefs ids="1661">+=</CheckRefs> pB-&gt;nFrac;</Line>
  <Line number="5115">  pA-&gt;sign ^= <CheckRefs ids="1662">pB</CheckRefs>-&gt;sign;</Line>
  <Line number="5116">  while( pA-&gt;nFrac&gt;minFrac &amp;&amp; <CheckRefs ids="1663">pA</CheckRefs>-&gt;a[pA-&gt;nDigit<CheckRefs ids="1664">-</CheckRefs>1]==0 ){</Line>
  <Line number="5117">    pA-&gt;nFrac<CheckRefs ids="1665">--</CheckRefs>;</Line>
  <Line number="5118">    pA-&gt;nDigit<CheckRefs ids="1666">--</CheckRefs>;</Line>
  <Line number="5119">  }</Line>
  <Line number="5120">  decimal_result(context, pA);</Line>
  <Line number="5121"></Line>
  <Line number="5122">mul_end:</Line>
  <Line number="5123">  sqlite3_free(acc);</Line>
  <Line number="5124">  decimal_free(pA);</Line>
  <Line number="5125">  decimal_free(pB);</Line>
  <Line number="5126">}</Line>
  <Line number="5127"></Line>
  <Line number="5128">#ifdef _WIN32</Line>
  <Line number="5129"></Line>
  <Line number="5130">#endif</Line>
  <Line number="5131">int sqlite3_decimal_init(</Line>
  <Line number="5132">  sqlite3 *db, </Line>
  <Line number="5133">  char **pzErrMsg, </Line>
  <Line number="5134">  const sqlite3_api_routines *pApi</Line>
  <Line number="5135">){</Line>
  <Line number="5136">  int rc = SQLITE_OK;</Line>
  <Line number="5137">  static const struct {</Line>
  <Line number="5138">    const char *zFuncName;</Line>
  <Line number="5139">    int nArg;</Line>
  <Line number="5140">    void (*xFunc)(sqlite3_context*,int,sqlite3_value**);</Line>
  <Line number="5141">  } aFunc[] = {</Line>
  <Line number="5142">    { &quot;decimal&quot;,       1,   decimalFunc        },</Line>
  <Line number="5143">    { &quot;decimal_cmp&quot;,   2,   decimalCmpFunc     },</Line>
  <Line number="5144">    { &quot;decimal_add&quot;,   2,   decimalAddFunc     },</Line>
  <Line number="5145">    { &quot;decimal_sub&quot;,   2,   decimalSubFunc     },</Line>
  <Line number="5146">    { &quot;decimal_mul&quot;,   2,   decimalMulFunc     },</Line>
  <Line number="5147">  };</Line>
  <Line number="5148">  unsigned int i;</Line>
  <Line number="5149">  (void)pzErrMsg;  /* Unused parameter */</Line>
  <Line number="5150"></Line>
  <Line number="5151">  SQLITE_EXTENSION_INIT2(pApi);</Line>
  <Line number="5152"></Line>
  <Line number="5153">  for(i=<CheckRefs ids="1667">0</CheckRefs>; <CheckRefs ids="1668">i</CheckRefs>&lt;sizeof(aFunc)<CheckRefs ids="1669">/</CheckRefs>sizeof(aFunc[0<CheckRefs ids="1670">]</CheckRefs>) &amp;&amp; rc==SQLITE_OK; i<CheckRefs ids="1671">++</CheckRefs>){</Line>
  <Line number="5154">    rc = sqlite3_create_function(db, aFunc[i<CheckRefs ids="1672">]</CheckRefs>.zFuncName, aFunc[i<CheckRefs ids="1673">]</CheckRefs>.nArg,</Line>
  <Line number="5155">                   SQLITE_UTF8|SQLITE_INNOCUOUS|SQLITE_DETERMINISTIC,</Line>
  <Line number="5156">                   0, aFunc[i<CheckRefs ids="1674">]</CheckRefs>.xFunc, 0, 0);</Line>
  <Line number="5157">  }</Line>
  <Line number="5158">  if( rc==SQLITE_OK ){</Line>
  <Line number="5159">    rc = sqlite3_create_window_function(db, &quot;decimal_sum&quot;, 1,</Line>
  <Line number="5160">                   SQLITE_UTF8|SQLITE_INNOCUOUS|SQLITE_DETERMINISTIC, 0,</Line>
  <Line number="5161">                   decimalSumStep, decimalSumFinalize,</Line>
  <Line number="5162">                   decimalSumValue, decimalSumInverse, 0);</Line>
  <Line number="5163">  }</Line>
  <Line number="5164">  if( rc==SQLITE_OK ){</Line>
  <Line number="5165">    rc = sqlite3_create_collation(db, &quot;decimal&quot;, SQLITE_UTF8,</Line>
  <Line number="5166">                                  0, decimalCollFunc);</Line>
  <Line number="5167">  }</Line>
  <Line number="5168">  return rc;</Line>
  <Line number="5169">}</Line>
  <Line number="5170"></Line>
  <Line number="5171">/************************* End ../ext/misc/decimal.c ********************/</Line>
  <Line number="5172">/************************* Begin ../ext/misc/ieee754.c ******************/</Line>
  <Line number="5173">/*</Line>
  <Line number="5174">** 2013-04-17</Line>
  <Line number="5175">**</Line>
  <Line number="5176">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="5177">** a legal notice, here is a blessing:</Line>
  <Line number="5178">**</Line>
  <Line number="5179">**    May you do good and not evil.</Line>
  <Line number="5180">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="5181">**    May you share freely, never taking more than you give.</Line>
  <Line number="5182">**</Line>
  <Line number="5183">******************************************************************************</Line>
  <Line number="5184">**</Line>
  <Line number="5185">** This SQLite extension implements functions for the exact display</Line>
  <Line number="5186">** and input of IEEE754 Binary64 floating-point numbers.</Line>
  <Line number="5187">**</Line>
  <Line number="5188">**   ieee754(X)</Line>
  <Line number="5189">**   ieee754(Y,Z)</Line>
  <Line number="5190">**</Line>
  <Line number="5191">** In the first form, the value X should be a floating-point number.</Line>
  <Line number="5192">** The function will return a string of the form &apos;ieee754(Y,Z)&apos; where</Line>
  <Line number="5193">** Y and Z are integers such that X==Y*pow(2,Z).</Line>
  <Line number="5194">**</Line>
  <Line number="5195">** In the second form, Y and Z are integers which are the mantissa and</Line>
  <Line number="5196">** base-2 exponent of a new floating point number.  The function returns</Line>
  <Line number="5197">** a floating-point value equal to Y*pow(2,Z).</Line>
  <Line number="5198">**</Line>
  <Line number="5199">** Examples:</Line>
  <Line number="5200">**</Line>
  <Line number="5201">**     ieee754(2.0)             -&gt;     &apos;ieee754(2,0)&apos;</Line>
  <Line number="5202">**     ieee754(45.25)           -&gt;     &apos;ieee754(181,-2)&apos;</Line>
  <Line number="5203">**     ieee754(2, 0)            -&gt;     2.0</Line>
  <Line number="5204">**     ieee754(181, -2)         -&gt;     45.25</Line>
  <Line number="5205">**</Line>
  <Line number="5206">** Two additional functions break apart the one-argument ieee754()</Line>
  <Line number="5207">** result into separate integer values:</Line>
  <Line number="5208">**</Line>
  <Line number="5209">**     ieee754_mantissa(45.25)  -&gt;     181</Line>
  <Line number="5210">**     ieee754_exponent(45.25)  -&gt;     -2</Line>
  <Line number="5211">**</Line>
  <Line number="5212">** These functions convert binary64 numbers into blobs and back again.</Line>
  <Line number="5213">**</Line>
  <Line number="5214">**     ieee754_from_blob(x&apos;3ff0000000000000&apos;)  -&gt;  1.0</Line>
  <Line number="5215">**     ieee754_to_blob(1.0)                    -&gt;  x&apos;3ff0000000000000&apos;</Line>
  <Line number="5216">**</Line>
  <Line number="5217">** In all single-argument functions, if the argument is an 8-byte blob</Line>
  <Line number="5218">** then that blob is interpreted as a big-endian binary64 value.</Line>
  <Line number="5219">**</Line>
  <Line number="5220">**</Line>
  <Line number="5221">** EXACT DECIMAL REPRESENTATION OF BINARY64 VALUES</Line>
  <Line number="5222">** -----------------------------------------------</Line>
  <Line number="5223">**</Line>
  <Line number="5224">** This extension in combination with the separate &apos;decimal&apos; extension</Line>
  <Line number="5225">** can be used to compute the exact decimal representation of binary64</Line>
  <Line number="5226">** values.  To begin, first compute a table of exponent values:</Line>
  <Line number="5227">**</Line>
  <Line number="5228">**    CREATE TABLE pow2(x INTEGER PRIMARY KEY, v TEXT);</Line>
  <Line number="5229">**    WITH RECURSIVE c(x,v) AS (</Line>
  <Line number="5230">**      VALUES(0,&apos;1&apos;)</Line>
  <Line number="5231">**      UNION ALL</Line>
  <Line number="5232">**      SELECT x+1, decimal_mul(v,&apos;2&apos;) FROM c WHERE x+1&lt;=971</Line>
  <Line number="5233">**    ) INSERT INTO pow2(x,v) SELECT x, v FROM c;</Line>
  <Line number="5234">**    WITH RECURSIVE c(x,v) AS (</Line>
  <Line number="5235">**      VALUES(-1,&apos;0.5&apos;)</Line>
  <Line number="5236">**      UNION ALL</Line>
  <Line number="5237">**      SELECT x-1, decimal_mul(v,&apos;0.5&apos;) FROM c WHERE x-1&gt;=-1075</Line>
  <Line number="5238">**    ) INSERT INTO pow2(x,v) SELECT x, v FROM c;</Line>
  <Line number="5239">**</Line>
  <Line number="5240">** Then, to compute the exact decimal representation of a floating</Line>
  <Line number="5241">** point value (the value 47.49 is used in the example) do:</Line>
  <Line number="5242">**</Line>
  <Line number="5243">**    WITH c(n) AS (VALUES(47.49))</Line>
  <Line number="5244">**          ---------------^^^^^---- Replace with whatever you want</Line>
  <Line number="5245">**    SELECT decimal_mul(ieee754_mantissa(c.n),pow2.v)</Line>
  <Line number="5246">**      FROM pow2, c WHERE pow2.x=ieee754_exponent(c.n);</Line>
  <Line number="5247">**</Line>
  <Line number="5248">** Here is a query to show various boundry values for the binary64</Line>
  <Line number="5249">** number format:</Line>
  <Line number="5250">**</Line>
  <Line number="5251">**    WITH c(name,bin) AS (VALUES</Line>
  <Line number="5252">**       (&apos;minimum positive value&apos;,        x&apos;0000000000000001&apos;),</Line>
  <Line number="5253">**       (&apos;maximum subnormal value&apos;,       x&apos;000fffffffffffff&apos;),</Line>
  <Line number="5254">**       (&apos;mininum positive nornal value&apos;, x&apos;0010000000000000&apos;),</Line>
  <Line number="5255">**       (&apos;maximum value&apos;,                 x&apos;7fefffffffffffff&apos;))</Line>
  <Line number="5256">**    SELECT c.name, decimal_mul(ieee754_mantissa(c.bin),pow2.v)</Line>
  <Line number="5257">**      FROM pow2, c WHERE pow2.x=ieee754_exponent(c.bin);</Line>
  <Line number="5258">**</Line>
  <Line number="5259">*/</Line>
  <Line number="5260">/* #include &quot;sqlite3ext.h&quot; */</Line>
  <Line number="5261">SQLITE_EXTENSION_INIT1</Line>
  <Line number="5262">#include &lt;assert.h&gt;</Line>
  <Line number="5263">#include &lt;string.h&gt;</Line>
  <Line number="5264"></Line>
  <Line number="5265">/* Mark a function parameter as unused, to suppress nuisance compiler</Line>
  <Line number="5266">** warnings. */</Line>
  <Line number="5267">#ifndef UNUSED_PARAMETER</Line>
  <Line number="5268"># define UNUSED_PARAMETER(X)  (void)(X)</Line>
  <Line number="5269">#endif</Line>
  <Line number="5270"></Line>
  <Line number="5271">/*</Line>
  <Line number="5272">** Implementation of the ieee754() function</Line>
  <Line number="5273">*/</Line>
  <Line number="5274">static void ieee754func(</Line>
  <Line number="5275">  sqlite3_context *context,</Line>
  <Line number="5276">  int argc,</Line>
  <Line number="5277">  sqlite3_value **argv</Line>
  <Line number="5278">){</Line>
  <Line number="5279">  if( argc==1 ){</Line>
  <Line number="5280">    sqlite3_int64 m, a;</Line>
  <Line number="5281">    double r;</Line>
  <Line number="5282">    int e;</Line>
  <Line number="5283">    int isNeg;</Line>
  <Line number="5284">    char zResult[100];</Line>
  <Line number="5285">    <CheckRefs ids="1675">assert</CheckRefs>( sizeof(m)==sizeof(r) );</Line>
  <Line number="5286">    if( sqlite3_value_type(argv[0])==SQLITE_BLOB</Line>
  <Line number="5287">     &amp;&amp; <CheckRefs ids="1676">sqlite3_value_bytes</CheckRefs>(argv[0])==sizeof(r)</Line>
  <Line number="5288">    ){</Line>
  <Line number="5289">      const unsigned char *x = sqlite3_value_blob(argv[0]);</Line>
  <Line number="5290">      unsigned int i;</Line>
  <Line number="5291">      sqlite3_uint64 v = <CheckRefs ids="1677">0</CheckRefs>;</Line>
  <Line number="5292">      for(i=<CheckRefs ids="1678">0</CheckRefs>; <CheckRefs ids="1679">i</CheckRefs>&lt;sizeof(r); i<CheckRefs ids="1680">++</CheckRefs>){</Line>
  <Line number="5293">        v = (v<CheckRefs ids="1681">&lt;&lt;</CheckRefs>8) | <CheckRefs ids="1682">x</CheckRefs>[i];</Line>
  <Line number="5294">      }</Line>
  <Line number="5295">      memcpy(&amp;r, &amp;v, sizeof(r));</Line>
  <Line number="5296">    }else{</Line>
  <Line number="5297">      r <CheckRefs ids="1683">=</CheckRefs> sqlite3_value_double(argv[0]);</Line>
  <Line number="5298">    }</Line>
  <Line number="5299">    if( r&lt;0.0 ){</Line>
  <Line number="5300">      isNeg = 1;</Line>
  <Line number="5301">      r <CheckRefs ids="1684">=</CheckRefs> <CheckRefs ids="1685">-</CheckRefs>r;</Line>
  <Line number="5302">    }else{</Line>
  <Line number="5303">      isNeg = 0;</Line>
  <Line number="5304">    }</Line>
  <Line number="5305">    memcpy(&amp;a,&amp;r,sizeof(a));</Line>
  <Line number="5306">    if( a==<CheckRefs ids="1686">0</CheckRefs> ){</Line>
  <Line number="5307">      e = 0;</Line>
  <Line number="5308">      m = <CheckRefs ids="1687">0</CheckRefs>;</Line>
  <Line number="5309">    }else{</Line>
  <Line number="5310">      e = a<CheckRefs ids="1690,1689,1688,1691">&gt;&gt;</CheckRefs>52;</Line>
  <Line number="5311">      m = a &amp; (((<CheckRefs ids="1696">(</CheckRefs>sqlite3_int64)1)<CheckRefs ids="1693,1694,1695">&lt;&lt;</CheckRefs>52)<CheckRefs ids="1692">-</CheckRefs><CheckRefs ids="1697">1</CheckRefs>);</Line>
  <Line number="5312">      if( e==0 ){</Line>
  <Line number="5313">        m <CheckRefs ids="1698,1699,1700">&lt;&lt;=</CheckRefs> 1;</Line>
  <Line number="5314">      }else{</Line>
  <Line number="5315">        m |= (<CheckRefs ids="1704">(</CheckRefs>sqlite3_int64)1)<CheckRefs ids="1701,1702,1703">&lt;&lt;</CheckRefs>52;</Line>
  <Line number="5316">      }</Line>
  <Line number="5317">      while( e&lt;1075 &amp;&amp; m&gt;<CheckRefs ids="1705">0</CheckRefs> &amp;&amp; (m&amp;<CheckRefs ids="1706">1</CheckRefs>)==<CheckRefs ids="1707">0</CheckRefs> ){</Line>
  <Line number="5318">        m <CheckRefs ids="1708,1709,1710">&gt;&gt;=</CheckRefs> 1;</Line>
  <Line number="5319">        e<CheckRefs ids="1711">++</CheckRefs>;</Line>
  <Line number="5320">      }</Line>
  <Line number="5321">      if( isNeg ) m = <CheckRefs ids="1712">-</CheckRefs>m;</Line>
  <Line number="5322">    }</Line>
  <Line number="5323">    switch( *(int*)sqlite3_user_data(context) ){</Line>
  <Line number="5324">      case 0:</Line>
  <Line number="5325">        sqlite3_snprintf(<CheckRefs ids="1713">sizeof</CheckRefs>(zResult), zResult, &quot;ieee754(%lld,%d)&quot;,</Line>
  <Line number="5326">                         m, e<CheckRefs ids="1714">-</CheckRefs>1075);</Line>
  <Line number="5327">        sqlite3_result_text(context, zResult, <CheckRefs ids="1715">-</CheckRefs>1, <CheckRefs ids="1716">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="5328">        break;</Line>
  <Line number="5329">      case 1:</Line>
  <Line number="5330">        sqlite3_result_int64(context, m);</Line>
  <Line number="5331">        break;</Line>
  <Line number="5332">      case 2:</Line>
  <Line number="5333">        sqlite3_result_int(context, e<CheckRefs ids="1717">-</CheckRefs>1075);</Line>
  <Line number="5334">        break;</Line>
  <Line number="5335">    }</Line>
  <Line number="5336">  }else{</Line>
  <Line number="5337">    sqlite3_int64 m, e, a;</Line>
  <Line number="5338">    double r;</Line>
  <Line number="5339">    int isNeg = 0;</Line>
  <Line number="5340">    m = sqlite3_value_int64(argv[0]);</Line>
  <Line number="5341">    e = sqlite3_value_int64(argv[1]);</Line>
  <Line number="5342"></Line>
  <Line number="5343">    /* Limit the range of e.  Ticket 22dea1cfdb9151e4 2021-03-02 */</Line>
  <Line number="5344">    if( e&gt;<CheckRefs ids="1718">10000</CheckRefs> ){</Line>
  <Line number="5345">      e = <CheckRefs ids="1719">10000</CheckRefs>;</Line>
  <Line number="5346">    }else if( e&lt;<CheckRefs ids="1720,1721">-</CheckRefs>10000 ){</Line>
  <Line number="5347">      e = <CheckRefs ids="1722,1723">-</CheckRefs>10000;</Line>
  <Line number="5348">    }</Line>
  <Line number="5349"></Line>
  <Line number="5350">    if( m&lt;<CheckRefs ids="1724">0</CheckRefs> ){</Line>
  <Line number="5351">      isNeg = 1;</Line>
  <Line number="5352">      m = <CheckRefs ids="1725">-</CheckRefs>m;</Line>
  <Line number="5353">      if( m&lt;<CheckRefs ids="1726">0</CheckRefs> ) return;</Line>
  <Line number="5354">    }else if( m==<CheckRefs ids="1727">0</CheckRefs> &amp;&amp; e&gt;<CheckRefs ids="1728,1729">-</CheckRefs>1000 &amp;&amp; e&lt;<CheckRefs ids="1730">1000</CheckRefs> ){</Line>
  <Line number="5355">      sqlite3_result_double(context, 0.0);</Line>
  <Line number="5356">      return;</Line>
  <Line number="5357">    }</Line>
  <Line number="5358">    while( (m<CheckRefs ids="1731,1732,1733">&gt;&gt;</CheckRefs>32)&amp;<CheckRefs ids="1734">0xffe00000</CheckRefs> ){</Line>
  <Line number="5359">      m <CheckRefs ids="1735,1736,1737">&gt;&gt;=</CheckRefs> 1;</Line>
  <Line number="5360">      e<CheckRefs ids="1738">++</CheckRefs>;</Line>
  <Line number="5361">    }</Line>
  <Line number="5362">    while( m!=<CheckRefs ids="1739">0</CheckRefs> &amp;&amp; ((m<CheckRefs ids="1741,1740,1742">&gt;&gt;</CheckRefs>32)&amp;<CheckRefs ids="1743">0xfff00000</CheckRefs>)==<CheckRefs ids="1744">0</CheckRefs> ){</Line>
  <Line number="5363">      m <CheckRefs ids="1745,1746,1747">&lt;&lt;=</CheckRefs> 1;</Line>
  <Line number="5364">      e<CheckRefs ids="1748">--</CheckRefs>;</Line>
  <Line number="5365">    }</Line>
  <Line number="5366">    e <CheckRefs ids="1749">+=</CheckRefs> <CheckRefs ids="1750">1075</CheckRefs>;</Line>
  <Line number="5367">    if( e&lt;=<CheckRefs ids="1751">0</CheckRefs> ){</Line>
  <Line number="5368">      /* Subnormal */</Line>
  <Line number="5369">      m <CheckRefs ids="1752,1753,1754">&gt;&gt;=</CheckRefs> <CheckRefs ids="1756">1</CheckRefs><CheckRefs ids="1755">-</CheckRefs>e;</Line>
  <Line number="5370">      e = <CheckRefs ids="1757">0</CheckRefs>;</Line>
  <Line number="5371">    }else if( e&gt;<CheckRefs ids="1758">0x7ff</CheckRefs> ){</Line>
  <Line number="5372">      e = <CheckRefs ids="1759">0x7ff</CheckRefs>;</Line>
  <Line number="5373">    }</Line>
  <Line number="5374">    a = m &amp; (((<CheckRefs ids="1764">(</CheckRefs>sqlite3_int64)1)<CheckRefs ids="1761,1762,1763">&lt;&lt;</CheckRefs>52)<CheckRefs ids="1760">-</CheckRefs><CheckRefs ids="1765">1</CheckRefs>);</Line>
  <Line number="5375">    a |= e<CheckRefs ids="1766,1767,1768">&lt;&lt;</CheckRefs>52;</Line>
  <Line number="5376">    if( isNeg ) a |= (<CheckRefs ids="1770">(</CheckRefs>sqlite3_uint64)1)<CheckRefs ids="1769">&lt;&lt;</CheckRefs>63;</Line>
  <Line number="5377">    memcpy(&amp;r, &amp;a, sizeof(r));</Line>
  <Line number="5378">    sqlite3_result_double(context, r);</Line>
  <Line number="5379">  }</Line>
  <Line number="5380">}</Line>
  <Line number="5381"></Line>
  <Line number="5382">/*</Line>
  <Line number="5383">** Functions to convert between blobs and floats.</Line>
  <Line number="5384">*/</Line>
  <Line number="5385">static void ieee754func_from_blob(</Line>
  <Line number="5386">  sqlite3_context *context,</Line>
  <Line number="5387">  int argc,</Line>
  <Line number="5388">  sqlite3_value **argv</Line>
  <Line number="5389">){</Line>
  <Line number="5390">  UNUSED_PARAMETER(argc);</Line>
  <Line number="5391">  if( sqlite3_value_type(argv[0])==SQLITE_BLOB</Line>
  <Line number="5392">   &amp;&amp; <CheckRefs ids="1771">sqlite3_value_bytes</CheckRefs>(argv[0])==sizeof(double)</Line>
  <Line number="5393">  ){</Line>
  <Line number="5394">    double r;</Line>
  <Line number="5395">    const unsigned char *x = sqlite3_value_blob(argv[0]);</Line>
  <Line number="5396">    unsigned int i;</Line>
  <Line number="5397">    sqlite3_uint64 v = <CheckRefs ids="1772">0</CheckRefs>;</Line>
  <Line number="5398">    for(i=<CheckRefs ids="1773">0</CheckRefs>; <CheckRefs ids="1774">i</CheckRefs>&lt;sizeof(r); i<CheckRefs ids="1775">++</CheckRefs>){</Line>
  <Line number="5399">      v = (v<CheckRefs ids="1776">&lt;&lt;</CheckRefs>8) | <CheckRefs ids="1777">x</CheckRefs>[i];</Line>
  <Line number="5400">    }</Line>
  <Line number="5401">    memcpy(&amp;r, &amp;v, sizeof(r));</Line>
  <Line number="5402">    sqlite3_result_double(context, r);</Line>
  <Line number="5403">  }</Line>
  <Line number="5404">}</Line>
  <Line number="5405">static void ieee754func_to_blob(</Line>
  <Line number="5406">  sqlite3_context *context,</Line>
  <Line number="5407">  int argc,</Line>
  <Line number="5408">  sqlite3_value **argv</Line>
  <Line number="5409">){</Line>
  <Line number="5410">  UNUSED_PARAMETER(argc);</Line>
  <Line number="5411">  if( sqlite3_value_type(argv[0])==SQLITE_FLOAT</Line>
  <Line number="5412">   || sqlite3_value_type(argv[0])==SQLITE_INTEGER</Line>
  <Line number="5413">  ){</Line>
  <Line number="5414">    double r = sqlite3_value_double(argv[0]);</Line>
  <Line number="5415">    sqlite3_uint64 v;</Line>
  <Line number="5416">    unsigned char a[sizeof(r)];</Line>
  <Line number="5417">    unsigned int i;</Line>
  <Line number="5418">    memcpy(&amp;v, &amp;r, sizeof(r));</Line>
  <Line number="5419">    for(i=<CheckRefs ids="1778">1</CheckRefs>; <CheckRefs ids="1779">i</CheckRefs>&lt;=sizeof(r); i<CheckRefs ids="1780">++</CheckRefs>){</Line>
  <Line number="5420">      a[sizeof(r)<CheckRefs ids="1782">-</CheckRefs><CheckRefs ids="1783">i</CheckRefs><CheckRefs ids="1781">]</CheckRefs> = v<CheckRefs ids="1784">&amp;</CheckRefs><CheckRefs ids="1785">0xff</CheckRefs>;</Line>
  <Line number="5421">      v <CheckRefs ids="1786">&gt;&gt;=</CheckRefs> 8;</Line>
  <Line number="5422">    }</Line>
  <Line number="5423">    sqlite3_result_blob(context, a, <CheckRefs ids="1787">sizeof</CheckRefs>(r), <CheckRefs ids="1788">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="5424">  }</Line>
  <Line number="5425">}</Line>
  <Line number="5426"></Line>
  <Line number="5427"></Line>
  <Line number="5428">#ifdef _WIN32</Line>
  <Line number="5429"></Line>
  <Line number="5430">#endif</Line>
  <Line number="5431">int sqlite3_ieee_init(</Line>
  <Line number="5432">  sqlite3 *db, </Line>
  <Line number="5433">  char **pzErrMsg, </Line>
  <Line number="5434">  const sqlite3_api_routines *pApi</Line>
  <Line number="5435">){</Line>
  <Line number="5436">  static const struct {</Line>
  <Line number="5437">    char *zFName;</Line>
  <Line number="5438">    int nArg;</Line>
  <Line number="5439">    int iAux;</Line>
  <Line number="5440">    void (*xFunc)(sqlite3_context*,int,sqlite3_value**);</Line>
  <Line number="5441">  } aFunc[] = {</Line>
  <Line number="5442">    { &quot;ieee754&quot;,           1,   0, ieee754func },</Line>
  <Line number="5443">    { &quot;ieee754&quot;,           2,   0, ieee754func },</Line>
  <Line number="5444">    { &quot;ieee754_mantissa&quot;,  1,   1, ieee754func },</Line>
  <Line number="5445">    { &quot;ieee754_exponent&quot;,  1,   2, ieee754func },</Line>
  <Line number="5446">    { &quot;ieee754_to_blob&quot;,   1,   0, ieee754func_to_blob },</Line>
  <Line number="5447">    { &quot;ieee754_from_blob&quot;, 1,   0, ieee754func_from_blob },</Line>
  <Line number="5448"></Line>
  <Line number="5449">  };</Line>
  <Line number="5450">  unsigned int i;</Line>
  <Line number="5451">  int rc = SQLITE_OK;</Line>
  <Line number="5452">  SQLITE_EXTENSION_INIT2(pApi);</Line>
  <Line number="5453">  (void)pzErrMsg;  /* Unused parameter */</Line>
  <Line number="5454">  for(i=<CheckRefs ids="1789">0</CheckRefs>; <CheckRefs ids="1790">i</CheckRefs>&lt;sizeof(aFunc)<CheckRefs ids="1791">/</CheckRefs>sizeof(aFunc[0<CheckRefs ids="1792">]</CheckRefs>) &amp;&amp; rc==SQLITE_OK; i<CheckRefs ids="1793">++</CheckRefs>){</Line>
  <Line number="5455">    rc = sqlite3_create_function(db, aFunc[i<CheckRefs ids="1794">]</CheckRefs>.zFName, aFunc[i<CheckRefs ids="1795">]</CheckRefs>.nArg,	</Line>
  <Line number="5456">                               SQLITE_UTF8|SQLITE_INNOCUOUS,</Line>
  <Line number="5457">                               (void*)&amp;aFunc[i<CheckRefs ids="1796">]</CheckRefs>.iAux,</Line>
  <Line number="5458">                               aFunc[i<CheckRefs ids="1797">]</CheckRefs>.xFunc, 0, 0);</Line>
  <Line number="5459">  }</Line>
  <Line number="5460">  return rc;</Line>
  <Line number="5461">}</Line>
  <Line number="5462"></Line>
  <Line number="5463">/************************* End ../ext/misc/ieee754.c ********************/</Line>
  <Line number="5464">/************************* Begin ../ext/misc/series.c ******************/</Line>
  <Line number="5465">/*</Line>
  <Line number="5466">** 2015-08-18</Line>
  <Line number="5467">**</Line>
  <Line number="5468">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="5469">** a legal notice, here is a blessing:</Line>
  <Line number="5470">**</Line>
  <Line number="5471">**    May you do good and not evil.</Line>
  <Line number="5472">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="5473">**    May you share freely, never taking more than you give.</Line>
  <Line number="5474">**</Line>
  <Line number="5475">*************************************************************************</Line>
  <Line number="5476">**</Line>
  <Line number="5477">** This file demonstrates how to create a table-valued-function using</Line>
  <Line number="5478">** a virtual table.  This demo implements the generate_series() function</Line>
  <Line number="5479">** which gives similar results to the eponymous function in PostgreSQL.</Line>
  <Line number="5480">** Examples:</Line>
  <Line number="5481">**</Line>
  <Line number="5482">**      SELECT * FROM generate_series(0,100,5);</Line>
  <Line number="5483">**</Line>
  <Line number="5484">** The query above returns integers from 0 through 100 counting by steps</Line>
  <Line number="5485">** of 5.</Line>
  <Line number="5486">**</Line>
  <Line number="5487">**      SELECT * FROM generate_series(0,100);</Line>
  <Line number="5488">**</Line>
  <Line number="5489">** Integers from 0 through 100 with a step size of 1.</Line>
  <Line number="5490">**</Line>
  <Line number="5491">**      SELECT * FROM generate_series(20) LIMIT 10;</Line>
  <Line number="5492">**</Line>
  <Line number="5493">** Integers 20 through 29.</Line>
  <Line number="5494">**</Line>
  <Line number="5495">** HOW IT WORKS</Line>
  <Line number="5496">**</Line>
  <Line number="5497">** The generate_series &quot;function&quot; is really a virtual table with the</Line>
  <Line number="5498">** following schema:</Line>
  <Line number="5499">**</Line>
  <Line number="5500">**     CREATE TABLE generate_series(</Line>
  <Line number="5501">**       value,</Line>
  <Line number="5502">**       start HIDDEN,</Line>
  <Line number="5503">**       stop HIDDEN,</Line>
  <Line number="5504">**       step HIDDEN</Line>
  <Line number="5505">**     );</Line>
  <Line number="5506">**</Line>
  <Line number="5507">** Function arguments in queries against this virtual table are translated</Line>
  <Line number="5508">** into equality constraints against successive hidden columns.  In other</Line>
  <Line number="5509">** words, the following pairs of queries are equivalent to each other:</Line>
  <Line number="5510">**</Line>
  <Line number="5511">**    SELECT * FROM generate_series(0,100,5);</Line>
  <Line number="5512">**    SELECT * FROM generate_series WHERE start=0 AND stop=100 AND step=5;</Line>
  <Line number="5513">**</Line>
  <Line number="5514">**    SELECT * FROM generate_series(0,100);</Line>
  <Line number="5515">**    SELECT * FROM generate_series WHERE start=0 AND stop=100;</Line>
  <Line number="5516">**</Line>
  <Line number="5517">**    SELECT * FROM generate_series(20) LIMIT 10;</Line>
  <Line number="5518">**    SELECT * FROM generate_series WHERE start=20 LIMIT 10;</Line>
  <Line number="5519">**</Line>
  <Line number="5520">** The generate_series virtual table implementation leaves the xCreate method</Line>
  <Line number="5521">** set to NULL.  This means that it is not possible to do a CREATE VIRTUAL</Line>
  <Line number="5522">** TABLE command with &quot;generate_series&quot; as the USING argument.  Instead, there</Line>
  <Line number="5523">** is a single generate_series virtual table that is always available without</Line>
  <Line number="5524">** having to be created first.</Line>
  <Line number="5525">**</Line>
  <Line number="5526">** The xBestIndex method looks for equality constraints against the hidden</Line>
  <Line number="5527">** start, stop, and step columns, and if present, it uses those constraints</Line>
  <Line number="5528">** to bound the sequence of generated values.  If the equality constraints</Line>
  <Line number="5529">** are missing, it uses 0 for start, 4294967295 for stop, and 1 for step.</Line>
  <Line number="5530">** xBestIndex returns a small cost when both start and stop are available,</Line>
  <Line number="5531">** and a very large cost if either start or stop are unavailable.  This</Line>
  <Line number="5532">** encourages the query planner to order joins such that the bounds of the</Line>
  <Line number="5533">** series are well-defined.</Line>
  <Line number="5534">*/</Line>
  <Line number="5535">/* #include &quot;sqlite3ext.h&quot; */</Line>
  <Line number="5536">SQLITE_EXTENSION_INIT1</Line>
  <Line number="5537">#include &lt;assert.h&gt;</Line>
  <Line number="5538">#include &lt;string.h&gt;</Line>
  <Line number="5539"></Line>
  <Line number="5540">#ifndef SQLITE_OMIT_VIRTUALTABLE</Line>
  <Line number="5541"></Line>
  <Line number="5542"></Line>
  <Line number="5543">/* series_cursor is a subclass of sqlite3_vtab_cursor which will</Line>
  <Line number="5544">** serve as the underlying representation of a cursor that scans</Line>
  <Line number="5545">** over rows of the result</Line>
  <Line number="5546">*/</Line>
  <Line number="5547">typedef struct series_cursor series_cursor;</Line>
  <Line number="5548">struct series_cursor {</Line>
  <Line number="5549">  sqlite3_vtab_cursor base;  /* Base class - must be first */</Line>
  <Line number="5550">  int isDesc;                /* True to count down rather than up */</Line>
  <Line number="5551">  sqlite3_int64 iRowid;      /* The rowid */</Line>
  <Line number="5552">  sqlite3_int64 iValue;      /* Current value (&quot;value&quot;) */</Line>
  <Line number="5553">  sqlite3_int64 mnValue;     /* Mimimum value (&quot;start&quot;) */</Line>
  <Line number="5554">  sqlite3_int64 mxValue;     /* Maximum value (&quot;stop&quot;) */</Line>
  <Line number="5555">  sqlite3_int64 iStep;       /* Increment (&quot;step&quot;) */</Line>
  <Line number="5556">};</Line>
  <Line number="5557"></Line>
  <Line number="5558">/*</Line>
  <Line number="5559">** The seriesConnect() method is invoked to create a new</Line>
  <Line number="5560">** series_vtab that describes the generate_series virtual table.</Line>
  <Line number="5561">**</Line>
  <Line number="5562">** Think of this routine as the constructor for series_vtab objects.</Line>
  <Line number="5563">**</Line>
  <Line number="5564">** All this routine needs to do is:</Line>
  <Line number="5565">**</Line>
  <Line number="5566">**    (1) Allocate the series_vtab object and initialize all fields.</Line>
  <Line number="5567">**</Line>
  <Line number="5568">**    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the</Line>
  <Line number="5569">**        result set of queries against generate_series will look like.</Line>
  <Line number="5570">*/</Line>
  <Line number="5571">static int seriesConnect(</Line>
  <Line number="5572">  sqlite3 *db,</Line>
  <Line number="5573">  void *pUnused,</Line>
  <Line number="5574">  int argcUnused, const char *const*argvUnused,</Line>
  <Line number="5575">  sqlite3_vtab **ppVtab,</Line>
  <Line number="5576">  char **pzErrUnused</Line>
  <Line number="5577">){</Line>
  <Line number="5578">  sqlite3_vtab *pNew;</Line>
  <Line number="5579">  int rc;</Line>
  <Line number="5580"></Line>
  <Line number="5581">/* Column numbers */</Line>
  <Line number="5582">#define SERIES_COLUMN_VALUE 0</Line>
  <Line number="5583">#define SERIES_COLUMN_START 1</Line>
  <Line number="5584">#define SERIES_COLUMN_STOP  2</Line>
  <Line number="5585">#define SERIES_COLUMN_STEP  3</Line>
  <Line number="5586"></Line>
  <Line number="5587">  (void)pUnused;</Line>
  <Line number="5588">  (void)argcUnused;</Line>
  <Line number="5589">  (void)argvUnused;</Line>
  <Line number="5590">  (void)pzErrUnused;</Line>
  <Line number="5591">  rc = sqlite3_declare_vtab(db,</Line>
  <Line number="5592">     &quot;CREATE TABLE x(value,start hidden,stop hidden,step hidden)&quot;);</Line>
  <Line number="5593">  if( rc==SQLITE_OK ){</Line>
  <Line number="5594">    pNew = *ppVtab = sqlite3_malloc( <CheckRefs ids="1798">sizeof</CheckRefs>(*pNew) );</Line>
  <Line number="5595">    if( pNew==0 ) return SQLITE_NOMEM;</Line>
  <Line number="5596">    memset(pNew, 0, sizeof(*pNew));</Line>
  <Line number="5597">    sqlite3_vtab_config(db, SQLITE_VTAB_INNOCUOUS);</Line>
  <Line number="5598">  }</Line>
  <Line number="5599">  return rc;</Line>
  <Line number="5600">}</Line>
  <Line number="5601"></Line>
  <Line number="5602">/*</Line>
  <Line number="5603">** This method is the destructor for series_cursor objects.</Line>
  <Line number="5604">*/</Line>
  <Line number="5605">static int seriesDisconnect(sqlite3_vtab *pVtab){</Line>
  <Line number="5606">  sqlite3_free(pVtab);</Line>
  <Line number="5607">  return SQLITE_OK;</Line>
  <Line number="5608">}</Line>
  <Line number="5609"></Line>
  <Line number="5610">/*</Line>
  <Line number="5611">** Constructor for a new series_cursor object.</Line>
  <Line number="5612">*/</Line>
  <Line number="5613">static int seriesOpen(sqlite3_vtab *pUnused, sqlite3_vtab_cursor **ppCursor){</Line>
  <Line number="5614">  series_cursor *pCur;</Line>
  <Line number="5615">  (void)pUnused;</Line>
  <Line number="5616">  pCur = sqlite3_malloc( <CheckRefs ids="1799">sizeof</CheckRefs>(*pCur) );</Line>
  <Line number="5617">  if( pCur==0 ) return SQLITE_NOMEM;</Line>
  <Line number="5618">  memset(pCur, 0, sizeof(*pCur));</Line>
  <Line number="5619">  *ppCursor = &amp;pCur-&gt;base;</Line>
  <Line number="5620">  return SQLITE_OK;</Line>
  <Line number="5621">}</Line>
  <Line number="5622"></Line>
  <Line number="5623">/*</Line>
  <Line number="5624">** Destructor for a series_cursor.</Line>
  <Line number="5625">*/</Line>
  <Line number="5626">static int seriesClose(sqlite3_vtab_cursor *cur){</Line>
  <Line number="5627">  sqlite3_free(cur);</Line>
  <Line number="5628">  return SQLITE_OK;</Line>
  <Line number="5629">}</Line>
  <Line number="5630"></Line>
  <Line number="5631"></Line>
  <Line number="5632">/*</Line>
  <Line number="5633">** Advance a series_cursor to its next row of output.</Line>
  <Line number="5634">*/</Line>
  <Line number="5635">static int seriesNext(sqlite3_vtab_cursor *cur){</Line>
  <Line number="5636">  series_cursor *pCur = (series_cursor*)cur;</Line>
  <Line number="5637">  if( pCur-&gt;isDesc ){</Line>
  <Line number="5638">    pCur-&gt;iValue <CheckRefs ids="1800">-=</CheckRefs> pCur-&gt;iStep;</Line>
  <Line number="5639">  }else{</Line>
  <Line number="5640">    pCur-&gt;iValue <CheckRefs ids="1801">+=</CheckRefs> pCur-&gt;iStep;</Line>
  <Line number="5641">  }</Line>
  <Line number="5642">  pCur-&gt;iRowid<CheckRefs ids="1802">++</CheckRefs>;</Line>
  <Line number="5643">  return SQLITE_OK;</Line>
  <Line number="5644">}</Line>
  <Line number="5645"></Line>
  <Line number="5646">/*</Line>
  <Line number="5647">** Return values of columns for the row at which the series_cursor</Line>
  <Line number="5648">** is currently pointing.</Line>
  <Line number="5649">*/</Line>
  <Line number="5650">static int seriesColumn(</Line>
  <Line number="5651">  sqlite3_vtab_cursor *cur,   /* The cursor */</Line>
  <Line number="5652">  sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */</Line>
  <Line number="5653">  int i                       /* Which column to return */</Line>
  <Line number="5654">){</Line>
  <Line number="5655">  series_cursor *pCur = (series_cursor*)cur;</Line>
  <Line number="5656">  sqlite3_int64 x = <CheckRefs ids="1803">0</CheckRefs>;</Line>
  <Line number="5657">  switch( i ){</Line>
  <Line number="5658">    case SERIES_COLUMN_START:  x = pCur-&gt;mnValue; break;</Line>
  <Line number="5659">    case SERIES_COLUMN_STOP:   x = pCur-&gt;mxValue; break;</Line>
  <Line number="5660">    case SERIES_COLUMN_STEP:   x = pCur-&gt;iStep;   break;</Line>
  <Line number="5661">    default:                   x = pCur-&gt;iValue;  break;</Line>
  <Line number="5662">  }</Line>
  <Line number="5663">  sqlite3_result_int64(ctx, x);</Line>
  <Line number="5664">  return SQLITE_OK;</Line>
  <Line number="5665">}</Line>
  <Line number="5666"></Line>
  <Line number="5667">/*</Line>
  <Line number="5668">** Return the rowid for the current row. In this implementation, the</Line>
  <Line number="5669">** first row returned is assigned rowid value 1, and each subsequent</Line>
  <Line number="5670">** row a value 1 more than that of the previous.</Line>
  <Line number="5671">*/</Line>
  <Line number="5672">static int seriesRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){</Line>
  <Line number="5673">  series_cursor *pCur = (series_cursor*)cur;</Line>
  <Line number="5674">  *pRowid = pCur-&gt;iRowid;</Line>
  <Line number="5675">  return SQLITE_OK;</Line>
  <Line number="5676">}</Line>
  <Line number="5677"></Line>
  <Line number="5678">/*</Line>
  <Line number="5679">** Return TRUE if the cursor has been moved off of the last</Line>
  <Line number="5680">** row of output.</Line>
  <Line number="5681">*/</Line>
  <Line number="5682">static int seriesEof(sqlite3_vtab_cursor *cur){</Line>
  <Line number="5683">  series_cursor *pCur = (series_cursor*)cur;</Line>
  <Line number="5684">  if( pCur-&gt;isDesc ){</Line>
  <Line number="5685">    return pCur-&gt;iValue &lt; pCur-&gt;mnValue;</Line>
  <Line number="5686">  }else{</Line>
  <Line number="5687">    return pCur-&gt;iValue &gt; pCur-&gt;mxValue;</Line>
  <Line number="5688">  }</Line>
  <Line number="5689">}</Line>
  <Line number="5690"></Line>
  <Line number="5691">/* True to cause run-time checking of the start=, stop=, and/or step= </Line>
  <Line number="5692">** parameters.  The only reason to do this is for testing the</Line>
  <Line number="5693">** constraint checking logic for virtual tables in the SQLite core.</Line>
  <Line number="5694">*/</Line>
  <Line number="5695">#ifndef SQLITE_SERIES_CONSTRAINT_VERIFY</Line>
  <Line number="5696"># define SQLITE_SERIES_CONSTRAINT_VERIFY 0</Line>
  <Line number="5697">#endif</Line>
  <Line number="5698"></Line>
  <Line number="5699">/*</Line>
  <Line number="5700">** This method is called to &quot;rewind&quot; the series_cursor object back</Line>
  <Line number="5701">** to the first row of output.  This method is always called at least</Line>
  <Line number="5702">** once prior to any call to seriesColumn() or seriesRowid() or </Line>
  <Line number="5703">** seriesEof().</Line>
  <Line number="5704">**</Line>
  <Line number="5705">** The query plan selected by seriesBestIndex is passed in the idxNum</Line>
  <Line number="5706">** parameter.  (idxStr is not used in this implementation.)  idxNum</Line>
  <Line number="5707">** is a bitmask showing which constraints are available:</Line>
  <Line number="5708">**</Line>
  <Line number="5709">**    1:    start=VALUE</Line>
  <Line number="5710">**    2:    stop=VALUE</Line>
  <Line number="5711">**    4:    step=VALUE</Line>
  <Line number="5712">**</Line>
  <Line number="5713">** Also, if bit 8 is set, that means that the series should be output</Line>
  <Line number="5714">** in descending order rather than in ascending order.  If bit 16 is</Line>
  <Line number="5715">** set, then output must appear in ascending order.</Line>
  <Line number="5716">**</Line>
  <Line number="5717">** This routine should initialize the cursor and position it so that it</Line>
  <Line number="5718">** is pointing at the first row, or pointing off the end of the table</Line>
  <Line number="5719">** (so that seriesEof() will return true) if the table is empty.</Line>
  <Line number="5720">*/</Line>
  <Line number="5721">static int seriesFilter(</Line>
  <Line number="5722">  sqlite3_vtab_cursor *pVtabCursor, </Line>
  <Line number="5723">  int idxNum, const char *idxStrUnused,</Line>
  <Line number="5724">  int argc, sqlite3_value **argv</Line>
  <Line number="5725">){</Line>
  <Line number="5726">  series_cursor *pCur = (series_cursor *)pVtabCursor;</Line>
  <Line number="5727">  int i = 0;</Line>
  <Line number="5728">  (void)idxStrUnused;</Line>
  <Line number="5729">  if( idxNum &amp; 1 ){</Line>
  <Line number="5730">    pCur-&gt;mnValue = sqlite3_value_int64(argv[i<CheckRefs ids="1804">++</CheckRefs>]);</Line>
  <Line number="5731">  }else{</Line>
  <Line number="5732">    pCur-&gt;mnValue = <CheckRefs ids="1805">0</CheckRefs>;</Line>
  <Line number="5733">  }</Line>
  <Line number="5734">  if( idxNum &amp; 2 ){</Line>
  <Line number="5735">    pCur-&gt;mxValue = sqlite3_value_int64(argv[i<CheckRefs ids="1806">++</CheckRefs>]);</Line>
  <Line number="5736">  }else{</Line>
  <Line number="5737">    pCur-&gt;mxValue = <CheckRefs ids="1807">0xffffffff</CheckRefs>;</Line>
  <Line number="5738">  }</Line>
  <Line number="5739">  if( idxNum &amp; 4 ){</Line>
  <Line number="5740">    pCur-&gt;iStep = sqlite3_value_int64(argv[i<CheckRefs ids="1808">++</CheckRefs>]);</Line>
  <Line number="5741">    if( pCur-&gt;iStep==<CheckRefs ids="1809">0</CheckRefs> ){</Line>
  <Line number="5742">      pCur-&gt;iStep = <CheckRefs ids="1810">1</CheckRefs>;</Line>
  <Line number="5743">    }else if( pCur-&gt;iStep&lt;<CheckRefs ids="1811">0</CheckRefs> ){</Line>
  <Line number="5744">      pCur-&gt;iStep = <CheckRefs ids="1812">-</CheckRefs>pCur-&gt;iStep;</Line>
  <Line number="5745">      if( (idxNum &amp; 16)==0 ) idxNum |= 8;</Line>
  <Line number="5746">    }</Line>
  <Line number="5747">  }else{</Line>
  <Line number="5748">    pCur-&gt;iStep = <CheckRefs ids="1813">1</CheckRefs>;</Line>
  <Line number="5749">  }</Line>
  <Line number="5750">  for(i=0; i&lt;argc; i<CheckRefs ids="1814">++</CheckRefs>){</Line>
  <Line number="5751">    if( sqlite3_value_type(argv[i])==SQLITE_NULL ){</Line>
  <Line number="5752">      /* If any of the constraints have a NULL value, then return no rows.</Line>
  <Line number="5753">      ** See ticket https://www.sqlite.org/src/info/fac496b61722daf2 */</Line>
  <Line number="5754">      pCur-&gt;mnValue = <CheckRefs ids="1815">1</CheckRefs>;</Line>
  <Line number="5755">      pCur-&gt;mxValue = <CheckRefs ids="1816">0</CheckRefs>;</Line>
  <Line number="5756">      break;</Line>
  <Line number="5757">    }</Line>
  <Line number="5758">  }</Line>
  <Line number="5759">  if( idxNum &amp; 8 ){</Line>
  <Line number="5760">    pCur-&gt;isDesc = 1;</Line>
  <Line number="5761">    pCur-&gt;iValue = pCur-&gt;mxValue;</Line>
  <Line number="5762">    if( pCur-&gt;iStep&gt;<CheckRefs ids="1817">0</CheckRefs> ){</Line>
  <Line number="5763">      pCur-&gt;iValue <CheckRefs ids="1818">-=</CheckRefs> (pCur-&gt;mxValue <CheckRefs ids="1820">-</CheckRefs> pCur-&gt;mnValue)<CheckRefs ids="1819">%</CheckRefs>pCur-&gt;iStep;</Line>
  <Line number="5764">    }</Line>
  <Line number="5765">  }else{</Line>
  <Line number="5766">    pCur-&gt;isDesc = 0;</Line>
  <Line number="5767">    pCur-&gt;iValue = pCur-&gt;mnValue;</Line>
  <Line number="5768">  }</Line>
  <Line number="5769">  pCur-&gt;iRowid = <CheckRefs ids="1821">1</CheckRefs>;</Line>
  <Line number="5770">  return SQLITE_OK;</Line>
  <Line number="5771">}</Line>
  <Line number="5772"></Line>
  <Line number="5773">/*</Line>
  <Line number="5774">** SQLite will invoke this method one or more times while planning a query</Line>
  <Line number="5775">** that uses the generate_series virtual table.  This routine needs to create</Line>
  <Line number="5776">** a query plan for each invocation and compute an estimated cost for that</Line>
  <Line number="5777">** plan.</Line>
  <Line number="5778">**</Line>
  <Line number="5779">** In this implementation idxNum is used to represent the</Line>
  <Line number="5780">** query plan.  idxStr is unused.</Line>
  <Line number="5781">**</Line>
  <Line number="5782">** The query plan is represented by bits in idxNum:</Line>
  <Line number="5783">**</Line>
  <Line number="5784">**  (1)  start = $value  -- constraint exists</Line>
  <Line number="5785">**  (2)  stop = $value   -- constraint exists</Line>
  <Line number="5786">**  (4)  step = $value   -- constraint exists</Line>
  <Line number="5787">**  (8)  output in descending order</Line>
  <Line number="5788">*/</Line>
  <Line number="5789">static int seriesBestIndex(</Line>
  <Line number="5790">  sqlite3_vtab *tabUnused,</Line>
  <Line number="5791">  sqlite3_index_info *pIdxInfo</Line>
  <Line number="5792">){</Line>
  <Line number="5793">  int i, j;              /* Loop over constraints */</Line>
  <Line number="5794">  int idxNum = 0;        /* The query plan bitmask */</Line>
  <Line number="5795">  int unusableMask = 0;  /* Mask of unusable constraints */</Line>
  <Line number="5796">  int nArg = 0;          /* Number of arguments that seriesFilter() expects */</Line>
  <Line number="5797">  int aIdx[3];           /* Constraints on start, stop, and step */</Line>
  <Line number="5798">  const struct sqlite3_index_constraint *pConstraint;</Line>
  <Line number="5799"></Line>
  <Line number="5800">  /* This implementation assumes that the start, stop, and step columns</Line>
  <Line number="5801">  ** are the last three columns in the virtual table. */</Line>
  <Line number="5802">  <CheckRefs ids="1822,1823">assert</CheckRefs>( SERIES_COLUMN_STOP == SERIES_COLUMN_START+1 );</Line>
  <Line number="5803">  <CheckRefs ids="1824,1825">assert</CheckRefs>( SERIES_COLUMN_STEP == SERIES_COLUMN_START+2 );</Line>
  <Line number="5804">  (void)tabUnused;</Line>
  <Line number="5805">  aIdx[0<CheckRefs ids="1826">]</CheckRefs> = aIdx[1<CheckRefs ids="1827">]</CheckRefs> = aIdx[2<CheckRefs ids="1828">]</CheckRefs> = <CheckRefs ids="1829">-</CheckRefs>1;</Line>
  <Line number="5806">  pConstraint = pIdxInfo-&gt;aConstraint;</Line>
  <Line number="5807">  for(i=0; i&lt;pIdxInfo-&gt;nConstraint; i<CheckRefs ids="1830">++</CheckRefs>, pConstraint++){</Line>
  <Line number="5808">    int iCol;    /* 0 for start, 1 for stop, 2 for step */</Line>
  <Line number="5809">    int iMask;   /* bitmask for those column */</Line>
  <Line number="5810">    if( pConstraint-&gt;iColumn&lt;SERIES_COLUMN_START ) continue;</Line>
  <Line number="5811">    iCol = pConstraint-&gt;iColumn <CheckRefs ids="1831">-</CheckRefs> SERIES_COLUMN_START;</Line>
  <Line number="5812">    <CheckRefs ids="1832">assert</CheckRefs>( iCol&gt;=0 &amp;&amp; iCol&lt;=2 );</Line>
  <Line number="5813">    iMask = 1 <CheckRefs ids="1835,1833,1834">&lt;&lt;</CheckRefs> iCol;</Line>
  <Line number="5814">    if( <CheckRefs ids="1836">pConstraint</CheckRefs>-&gt;usable==0 ){</Line>
  <Line number="5815">      unusableMask |=  iMask;</Line>
  <Line number="5816">      continue;</Line>
  <Line number="5817">    }else if( <CheckRefs ids="1837">pConstraint</CheckRefs>-&gt;op==SQLITE_INDEX_CONSTRAINT_EQ ){</Line>
  <Line number="5818">      idxNum |= iMask;</Line>
  <Line number="5819">      aIdx[iCol<CheckRefs ids="1838">]</CheckRefs> = i;</Line>
  <Line number="5820">    }</Line>
  <Line number="5821">  }</Line>
  <Line number="5822">  for(i=0; i&lt;3; i<CheckRefs ids="1839">++</CheckRefs>){</Line>
  <Line number="5823">    if( (j = aIdx[i<CheckRefs ids="1840">]</CheckRefs>)&gt;=0 ){</Line>
  <Line number="5824">      pIdxInfo-&gt;aConstraintUsage[j].argvIndex = <CheckRefs ids="1841">++</CheckRefs>nArg;</Line>
  <Line number="5825">      pIdxInfo-&gt;aConstraintUsage[j].omit = <CheckRefs ids="1842">!</CheckRefs>SQLITE_SERIES_CONSTRAINT_VERIFY;</Line>
  <Line number="5826">    }</Line>
  <Line number="5827">  }</Line>
  <Line number="5828">  if( (unusableMask &amp; ~idxNum)!=0 ){</Line>
  <Line number="5829">    /* The start, stop, and step columns are inputs.  Therefore if there</Line>
  <Line number="5830">    ** are unusable constraints on any of start, stop, or step then</Line>
  <Line number="5831">    ** this plan is unusable */</Line>
  <Line number="5832">    return SQLITE_CONSTRAINT;</Line>
  <Line number="5833">  }</Line>
  <Line number="5834">  if( (idxNum &amp; 3)==3 ){</Line>
  <Line number="5835">    /* Both start= and stop= boundaries are available.  This is the </Line>
  <Line number="5836">    ** the preferred case */</Line>
  <Line number="5837">    pIdxInfo-&gt;estimatedCost <CheckRefs ids="1843">=</CheckRefs> <CheckRefs ids="1844">(</CheckRefs>double)(2 <CheckRefs ids="1845">-</CheckRefs> ((idxNum&amp;4)!=0));</Line>
  <Line number="5838">    pIdxInfo-&gt;estimatedRows = <CheckRefs ids="1846">1000</CheckRefs>;</Line>
  <Line number="5839">    if( pIdxInfo-&gt;nOrderBy==1 ){</Line>
  <Line number="5840">      if( pIdxInfo-&gt;aOrderBy[0].desc ){</Line>
  <Line number="5841">        idxNum |= 8;</Line>
  <Line number="5842">      }else{</Line>
  <Line number="5843">        idxNum |= 16;</Line>
  <Line number="5844">      }</Line>
  <Line number="5845">      pIdxInfo-&gt;orderByConsumed = 1;</Line>
  <Line number="5846">    }</Line>
  <Line number="5847">  }else{</Line>
  <Line number="5848">    /* If either boundary is missing, we have to generate a huge span</Line>
  <Line number="5849">    ** of numbers.  Make this case very expensive so that the query</Line>
  <Line number="5850">    ** planner will work hard to avoid it. */</Line>
  <Line number="5851">    pIdxInfo-&gt;estimatedRows = <CheckRefs ids="1847">2147483647</CheckRefs>;</Line>
  <Line number="5852">  }</Line>
  <Line number="5853">  pIdxInfo-&gt;idxNum = idxNum;</Line>
  <Line number="5854">  return SQLITE_OK;</Line>
  <Line number="5855">}</Line>
  <Line number="5856"></Line>
  <Line number="5857">/*</Line>
  <Line number="5858">** This following structure defines all the methods for the </Line>
  <Line number="5859">** generate_series virtual table.</Line>
  <Line number="5860">*/</Line>
  <Line number="5861">static sqlite3_module seriesModule = {</Line>
  <Line number="5862">  0,                         /* iVersion */</Line>
  <Line number="5863">  0,                         /* xCreate */</Line>
  <Line number="5864">  seriesConnect,             /* xConnect */</Line>
  <Line number="5865">  seriesBestIndex,           /* xBestIndex */</Line>
  <Line number="5866">  seriesDisconnect,          /* xDisconnect */</Line>
  <Line number="5867">  0,                         /* xDestroy */</Line>
  <Line number="5868">  seriesOpen,                /* xOpen - open a cursor */</Line>
  <Line number="5869">  seriesClose,               /* xClose - close a cursor */</Line>
  <Line number="5870">  seriesFilter,              /* xFilter - configure scan constraints */</Line>
  <Line number="5871">  seriesNext,                /* xNext - advance a cursor */</Line>
  <Line number="5872">  seriesEof,                 /* xEof - check for end of scan */</Line>
  <Line number="5873">  seriesColumn,              /* xColumn - read data */</Line>
  <Line number="5874">  seriesRowid,               /* xRowid - read data */</Line>
  <Line number="5875">  0,                         /* xUpdate */</Line>
  <Line number="5876">  0,                         /* xBegin */</Line>
  <Line number="5877">  0,                         /* xSync */</Line>
  <Line number="5878">  0,                         /* xCommit */</Line>
  <Line number="5879">  0,                         /* xRollback */</Line>
  <Line number="5880">  0,                         /* xFindMethod */</Line>
  <Line number="5881">  0,                         /* xRename */</Line>
  <Line number="5882">  0,                         /* xSavepoint */</Line>
  <Line number="5883">  0,                         /* xRelease */</Line>
  <Line number="5884">  0,                         /* xRollbackTo */</Line>
  <Line number="5885">  0                          /* xShadowName */</Line>
  <Line number="5886">};</Line>
  <Line number="5887"></Line>
  <Line number="5888">#endif /* SQLITE_OMIT_VIRTUALTABLE */</Line>
  <Line number="5889"></Line>
  <Line number="5890">#ifdef _WIN32</Line>
  <Line number="5891"></Line>
  <Line number="5892">#endif</Line>
  <Line number="5893">int sqlite3_series_init(</Line>
  <Line number="5894">  sqlite3 *db, </Line>
  <Line number="5895">  char **pzErrMsg, </Line>
  <Line number="5896">  const sqlite3_api_routines *pApi</Line>
  <Line number="5897">){</Line>
  <Line number="5898">  int rc = SQLITE_OK;</Line>
  <Line number="5899">  SQLITE_EXTENSION_INIT2(pApi);</Line>
  <Line number="5900">#ifndef SQLITE_OMIT_VIRTUALTABLE</Line>
  <Line number="5901">  if( sqlite3_libversion_number()&lt;3008012 ){</Line>
  <Line number="5902">    *pzErrMsg = sqlite3_mprintf(</Line>
  <Line number="5903">        &quot;generate_series() requires SQLite 3.8.12 or later&quot;);</Line>
  <Line number="5904">    return SQLITE_ERROR;</Line>
  <Line number="5905">  }</Line>
  <Line number="5906">  rc = sqlite3_create_module(db, &quot;generate_series&quot;, &amp;seriesModule, 0);</Line>
  <Line number="5907">#endif</Line>
  <Line number="5908">  return rc;</Line>
  <Line number="5909">}</Line>
  <Line number="5910"></Line>
  <Line number="5911">/************************* End ../ext/misc/series.c ********************/</Line>
  <Line number="5912">/************************* Begin ../ext/misc/regexp.c ******************/</Line>
  <Line number="5913">/*</Line>
  <Line number="5914">** 2012-11-13</Line>
  <Line number="5915">**</Line>
  <Line number="5916">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="5917">** a legal notice, here is a blessing:</Line>
  <Line number="5918">**</Line>
  <Line number="5919">**    May you do good and not evil.</Line>
  <Line number="5920">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="5921">**    May you share freely, never taking more than you give.</Line>
  <Line number="5922">**</Line>
  <Line number="5923">******************************************************************************</Line>
  <Line number="5924">**</Line>
  <Line number="5925">** The code in this file implements a compact but reasonably</Line>
  <Line number="5926">** efficient regular-expression matcher for posix extended regular</Line>
  <Line number="5927">** expressions against UTF8 text.</Line>
  <Line number="5928">**</Line>
  <Line number="5929">** This file is an SQLite extension.  It registers a single function</Line>
  <Line number="5930">** named &quot;regexp(A,B)&quot; where A is the regular expression and B is the</Line>
  <Line number="5931">** string to be matched.  By registering this function, SQLite will also</Line>
  <Line number="5932">** then implement the &quot;B regexp A&quot; operator.  Note that with the function</Line>
  <Line number="5933">** the regular expression comes first, but with the operator it comes</Line>
  <Line number="5934">** second.</Line>
  <Line number="5935">**</Line>
  <Line number="5936">**  The following regular expression syntax is supported:</Line>
  <Line number="5937">**</Line>
  <Line number="5938">**     X*      zero or more occurrences of X</Line>
  <Line number="5939">**     X+      one or more occurrences of X</Line>
  <Line number="5940">**     X?      zero or one occurrences of X</Line>
  <Line number="5941">**     X{p,q}  between p and q occurrences of X</Line>
  <Line number="5942">**     (X)     match X</Line>
  <Line number="5943">**     X|Y     X or Y</Line>
  <Line number="5944">**     ^X      X occurring at the beginning of the string</Line>
  <Line number="5945">**     X$      X occurring at the end of the string</Line>
  <Line number="5946">**     .       Match any single character</Line>
  <Line number="5947">**     \c      Character c where c is one of \{}()[]|*+?.</Line>
  <Line number="5948">**     \c      C-language escapes for c in afnrtv.  ex: \t or \n</Line>
  <Line number="5949">**     \uXXXX  Where XXXX is exactly 4 hex digits, unicode value XXXX</Line>
  <Line number="5950">**     \xXX    Where XX is exactly 2 hex digits, unicode value XX</Line>
  <Line number="5951">**     [abc]   Any single character from the set abc</Line>
  <Line number="5952">**     [^abc]  Any single character not in the set abc</Line>
  <Line number="5953">**     [a-z]   Any single character in the range a-z</Line>
  <Line number="5954">**     [^a-z]  Any single character not in the range a-z</Line>
  <Line number="5955">**     \b      Word boundary</Line>
  <Line number="5956">**     \w      Word character.  [A-Za-z0-9_]</Line>
  <Line number="5957">**     \W      Non-word character</Line>
  <Line number="5958">**     \d      Digit</Line>
  <Line number="5959">**     \D      Non-digit</Line>
  <Line number="5960">**     \s      Whitespace character</Line>
  <Line number="5961">**     \S      Non-whitespace character</Line>
  <Line number="5962">**</Line>
  <Line number="5963">** A nondeterministic finite automaton (NFA) is used for matching, so the</Line>
  <Line number="5964">** performance is bounded by O(N*M) where N is the size of the regular</Line>
  <Line number="5965">** expression and M is the size of the input string.  The matcher never</Line>
  <Line number="5966">** exhibits exponential behavior.  Note that the X{p,q} operator expands</Line>
  <Line number="5967">** to p copies of X following by q-p copies of X? and that the size of the</Line>
  <Line number="5968">** regular expression in the O(N*M) performance bound is computed after</Line>
  <Line number="5969">** this expansion.</Line>
  <Line number="5970">*/</Line>
  <Line number="5971">#include &lt;string.h&gt;</Line>
  <Line number="5972">#include &lt;stdlib.h&gt;</Line>
  <Line number="5973">/* #include &quot;sqlite3ext.h&quot; */</Line>
  <Line number="5974">SQLITE_EXTENSION_INIT1</Line>
  <Line number="5975"></Line>
  <Line number="5976">/*</Line>
  <Line number="5977">** The following #defines change the names of some functions implemented in</Line>
  <Line number="5978">** this file to prevent name collisions with C-library functions of the</Line>
  <Line number="5979">** same name.</Line>
  <Line number="5980">*/</Line>
  <Line number="5981">#define re_match   sqlite3re_match</Line>
  <Line number="5982">#define re_compile sqlite3re_compile</Line>
  <Line number="5983">#define re_free    sqlite3re_free</Line>
  <Line number="5984"></Line>
  <Line number="5985">/* The end-of-input character */</Line>
  <Line number="5986">#define RE_EOF            0    /* End of input */</Line>
  <Line number="5987"></Line>
  <Line number="5988">/* The NFA is implemented as sequence of opcodes taken from the following</Line>
  <Line number="5989">** set.  Each opcode has a single integer argument.</Line>
  <Line number="5990">*/</Line>
  <Line number="5991">#define RE_OP_MATCH       1    /* Match the one character in the argument */</Line>
  <Line number="5992">#define RE_OP_ANY         2    /* Match any one character.  (Implements &quot;.&quot;) */</Line>
  <Line number="5993">#define RE_OP_ANYSTAR     3    /* Special optimized version of .* */</Line>
  <Line number="5994">#define RE_OP_FORK        4    /* Continue to both next and opcode at iArg */</Line>
  <Line number="5995">#define RE_OP_GOTO        5    /* Jump to opcode at iArg */</Line>
  <Line number="5996">#define RE_OP_ACCEPT      6    /* Halt and indicate a successful match */</Line>
  <Line number="5997">#define RE_OP_CC_INC      7    /* Beginning of a [...] character class */</Line>
  <Line number="5998">#define RE_OP_CC_EXC      8    /* Beginning of a [^...] character class */</Line>
  <Line number="5999">#define RE_OP_CC_VALUE    9    /* Single value in a character class */</Line>
  <Line number="6000">#define RE_OP_CC_RANGE   10    /* Range of values in a character class */</Line>
  <Line number="6001">#define RE_OP_WORD       11    /* Perl word character [A-Za-z0-9_] */</Line>
  <Line number="6002">#define RE_OP_NOTWORD    12    /* Not a perl word character */</Line>
  <Line number="6003">#define RE_OP_DIGIT      13    /* digit:  [0-9] */</Line>
  <Line number="6004">#define RE_OP_NOTDIGIT   14    /* Not a digit */</Line>
  <Line number="6005">#define RE_OP_SPACE      15    /* space:  [ \t\n\r\v\f] */</Line>
  <Line number="6006">#define RE_OP_NOTSPACE   16    /* Not a digit */</Line>
  <Line number="6007">#define RE_OP_BOUNDARY   17    /* Boundary between word and non-word */</Line>
  <Line number="6008"></Line>
  <Line number="6009">/* Each opcode is a &quot;state&quot; in the NFA */</Line>
  <Line number="6010">typedef unsigned short ReStateNumber;</Line>
  <Line number="6011"></Line>
  <Line number="6012">/* Because this is an NFA and not a DFA, multiple states can be active at</Line>
  <Line number="6013">** once.  An instance of the following object records all active states in</Line>
  <Line number="6014">** the NFA.  The implementation is optimized for the common case where the</Line>
  <Line number="6015">** number of actives states is small.</Line>
  <Line number="6016">*/</Line>
  <Line number="6017">typedef struct ReStateSet {</Line>
  <Line number="6018">  unsigned nState;            /* Number of current states */</Line>
  <Line number="6019">  ReStateNumber *aState;      /* Current states */</Line>
  <Line number="6020">} ReStateSet;</Line>
  <Line number="6021"></Line>
  <Line number="6022">/* An input string read one character at a time.</Line>
  <Line number="6023">*/</Line>
  <Line number="6024">typedef struct ReInput ReInput;</Line>
  <Line number="6025">struct ReInput {</Line>
  <Line number="6026">  const unsigned char *z;  /* All text */</Line>
  <Line number="6027">  int i;                   /* Next byte to read */</Line>
  <Line number="6028">  int mx;                  /* EOF when i&gt;=mx */</Line>
  <Line number="6029">};</Line>
  <Line number="6030"></Line>
  <Line number="6031">/* A compiled NFA (or an NFA that is in the process of being compiled) is</Line>
  <Line number="6032">** an instance of the following object.</Line>
  <Line number="6033">*/</Line>
  <Line number="6034">typedef struct ReCompiled ReCompiled;</Line>
  <Line number="6035">struct ReCompiled {</Line>
  <Line number="6036">  ReInput sIn;                /* Regular expression text */</Line>
  <Line number="6037">  const char *zErr;           /* Error message to return */</Line>
  <Line number="6038">  char *aOp;                  /* Operators for the virtual machine */</Line>
  <Line number="6039">  int *aArg;                  /* Arguments to each operator */</Line>
  <Line number="6040">  unsigned (*xNextChar)(ReInput*);  /* Next character function */</Line>
  <Line number="6041">  unsigned char zInit[12];    /* Initial text to match */</Line>
  <Line number="6042">  int nInit;                  /* Number of characters in zInit */</Line>
  <Line number="6043">  unsigned nState;            /* Number of entries in aOp[] and aArg[] */</Line>
  <Line number="6044">  unsigned nAlloc;            /* Slots allocated for aOp[] and aArg[] */</Line>
  <Line number="6045">};</Line>
  <Line number="6046"></Line>
  <Line number="6047">/* Add a state to the given state set if it is not already there */</Line>
  <Line number="6048">static void re_add_state(ReStateSet *pSet, int newState){</Line>
  <Line number="6049">  unsigned i;</Line>
  <Line number="6050">  for(i=<CheckRefs ids="1848">0</CheckRefs>; i&lt;pSet-&gt;nState; i<CheckRefs ids="1849">++</CheckRefs>) if( <CheckRefs ids="1850">pSet</CheckRefs>-&gt;aState[i]==newState ) return;</Line>
  <Line number="6051">  pSet-&gt;aState[pSet-&gt;nState<CheckRefs ids="1851">++</CheckRefs>] = <CheckRefs ids="1852">(</CheckRefs>ReStateNumber)newState;</Line>
  <Line number="6052">}</Line>
  <Line number="6053"></Line>
  <Line number="6054">/* Extract the next unicode character from *pzIn and return it.  Advance</Line>
  <Line number="6055">** *pzIn to the first byte past the end of the character returned.  To</Line>
  <Line number="6056">** be clear:  this routine converts utf8 to unicode.  This routine is </Line>
  <Line number="6057">** optimized for the common case where the next character is a single byte.</Line>
  <Line number="6058">*/</Line>
  <Line number="6059">static unsigned re_next_char(ReInput *p){</Line>
  <Line number="6060">  unsigned c;</Line>
  <Line number="6061">  if( p-&gt;i&gt;=p-&gt;mx ) return <CheckRefs ids="1853">0</CheckRefs>;</Line>
  <Line number="6062">  c = <CheckRefs ids="1854">p</CheckRefs>-&gt;z[p-&gt;i<CheckRefs ids="1855">++</CheckRefs>];</Line>
  <Line number="6063">  if( c&gt;=<CheckRefs ids="1856">0x80</CheckRefs> ){</Line>
  <Line number="6064">    if( (c&amp;<CheckRefs ids="1857">0xe0</CheckRefs>)==<CheckRefs ids="1858">0xc0</CheckRefs> &amp;&amp; p-&gt;i&lt;p-&gt;mx &amp;&amp; (<CheckRefs ids="1859">p</CheckRefs>-&gt;z[p-&gt;i]&amp;0xc0)==0x80 ){</Line>
  <Line number="6065">      c = (c&amp;<CheckRefs ids="1861">0x1f</CheckRefs>)<CheckRefs ids="1860">&lt;&lt;</CheckRefs>6 | <CheckRefs ids="1862">(</CheckRefs><CheckRefs ids="1863">p</CheckRefs>-&gt;z[p-&gt;i<CheckRefs ids="1864">++</CheckRefs>]&amp;0x3f);</Line>
  <Line number="6066">      if( c&lt;<CheckRefs ids="1865">0x80</CheckRefs> ) c = <CheckRefs ids="1866">0xfffd</CheckRefs>;</Line>
  <Line number="6067">    }else if( (c&amp;<CheckRefs ids="1867">0xf0</CheckRefs>)==<CheckRefs ids="1868">0xe0</CheckRefs> &amp;&amp; p-&gt;i<CheckRefs ids="1869">+</CheckRefs>1&lt;p-&gt;mx &amp;&amp; (<CheckRefs ids="1870">p</CheckRefs>-&gt;z[p-&gt;i]&amp;0xc0)==0x80</Line>
  <Line number="6068">           &amp;&amp; (<CheckRefs ids="1871">p</CheckRefs>-&gt;z[p-&gt;i<CheckRefs ids="1872">+</CheckRefs>1]&amp;0xc0)==0x80 ){</Line>
  <Line number="6069">      c = (c&amp;<CheckRefs ids="1874">0x0f</CheckRefs>)<CheckRefs ids="1873">&lt;&lt;</CheckRefs>12 | <CheckRefs ids="1875">(</CheckRefs>(<CheckRefs ids="1879">p</CheckRefs>-&gt;z[p-&gt;i]&amp;0x3f)<CheckRefs ids="1876,1877,1878">&lt;&lt;</CheckRefs>6) | <CheckRefs ids="1880">(</CheckRefs><CheckRefs ids="1881">p</CheckRefs>-&gt;z[p-&gt;i<CheckRefs ids="1882">+</CheckRefs>1]&amp;0x3f);</Line>
  <Line number="6070">      p-&gt;i <CheckRefs ids="1883">+=</CheckRefs> 2;</Line>
  <Line number="6071">      if( c&lt;=<CheckRefs ids="1884">0x7ff</CheckRefs> || (c&gt;=<CheckRefs ids="1885">0xd800</CheckRefs> &amp;&amp; c&lt;=<CheckRefs ids="1886">0xdfff</CheckRefs>) ) c = <CheckRefs ids="1887">0xfffd</CheckRefs>;</Line>
  <Line number="6072">    }else if( (c&amp;<CheckRefs ids="1888">0xf8</CheckRefs>)==<CheckRefs ids="1889">0xf0</CheckRefs> &amp;&amp; p-&gt;i<CheckRefs ids="1890">+</CheckRefs>3&lt;p-&gt;mx &amp;&amp; (<CheckRefs ids="1891">p</CheckRefs>-&gt;z[p-&gt;i]&amp;0xc0)==0x80</Line>
  <Line number="6073">           &amp;&amp; (<CheckRefs ids="1892">p</CheckRefs>-&gt;z[p-&gt;i<CheckRefs ids="1893">+</CheckRefs>1]&amp;0xc0)==0x80 &amp;&amp; (<CheckRefs ids="1894">p</CheckRefs>-&gt;z[p-&gt;i<CheckRefs ids="1895">+</CheckRefs>2]&amp;0xc0)==0x80 ){</Line>
  <Line number="6074">      c = (c&amp;<CheckRefs ids="1897">0x07</CheckRefs>)<CheckRefs ids="1896">&lt;&lt;</CheckRefs>18 | <CheckRefs ids="1898">(</CheckRefs>(<CheckRefs ids="1902">p</CheckRefs>-&gt;z[p-&gt;i]&amp;0x3f)<CheckRefs ids="1899,1900,1901">&lt;&lt;</CheckRefs>12) | <CheckRefs ids="1903">(</CheckRefs>(<CheckRefs ids="1907">p</CheckRefs>-&gt;z[p-&gt;i<CheckRefs ids="1908">+</CheckRefs>1]&amp;0x3f)<CheckRefs ids="1905,1904,1906">&lt;&lt;</CheckRefs>6)</Line>
  <Line number="6075">                       | <CheckRefs ids="1909">(</CheckRefs><CheckRefs ids="1910">p</CheckRefs>-&gt;z[p-&gt;i<CheckRefs ids="1911">+</CheckRefs>2]&amp;0x3f);</Line>
  <Line number="6076">      p-&gt;i <CheckRefs ids="1912">+=</CheckRefs> 3;</Line>
  <Line number="6077">      if( c&lt;=<CheckRefs ids="1913">0xffff</CheckRefs> || c&gt;<CheckRefs ids="1914">0x10ffff</CheckRefs> ) c = <CheckRefs ids="1915">0xfffd</CheckRefs>;</Line>
  <Line number="6078">    }else{</Line>
  <Line number="6079">      c = <CheckRefs ids="1916">0xfffd</CheckRefs>;</Line>
  <Line number="6080">    }</Line>
  <Line number="6081">  }</Line>
  <Line number="6082">  return c;</Line>
  <Line number="6083">}</Line>
  <Line number="6084">static unsigned re_next_char_nocase(ReInput *p){</Line>
  <Line number="6085">  unsigned c = re_next_char(p);</Line>
  <Line number="6086">  if( c&gt;=<CheckRefs ids="1917">&apos;A&apos;</CheckRefs> &amp;&amp; c&lt;=<CheckRefs ids="1918">&apos;Z&apos;</CheckRefs> ) c <CheckRefs ids="1919">+=</CheckRefs> &apos;a&apos; <CheckRefs ids="1920,1921">-</CheckRefs> &apos;A&apos;;</Line>
  <Line number="6087">  return c;</Line>
  <Line number="6088">}</Line>
  <Line number="6089"></Line>
  <Line number="6090">/* Return true if c is a perl &quot;word&quot; character:  [A-Za-z0-9_] */</Line>
  <Line number="6091">static int re_word_char(int c){</Line>
  <Line number="6092">  return (c&gt;=&apos;0&apos; &amp;&amp; c&lt;=&apos;9&apos;) || (c&gt;=&apos;a&apos; &amp;&amp; c&lt;=&apos;z&apos;)</Line>
  <Line number="6093">      || (c&gt;=&apos;A&apos; &amp;&amp; c&lt;=&apos;Z&apos;) || c==&apos;_&apos;;</Line>
  <Line number="6094">}</Line>
  <Line number="6095"></Line>
  <Line number="6096">/* Return true if c is a &quot;digit&quot; character:  [0-9] */</Line>
  <Line number="6097">static int re_digit_char(int c){</Line>
  <Line number="6098">  return (c&gt;=&apos;0&apos; &amp;&amp; c&lt;=&apos;9&apos;);</Line>
  <Line number="6099">}</Line>
  <Line number="6100"></Line>
  <Line number="6101">/* Return true if c is a perl &quot;space&quot; character:  [ \t\r\n\v\f] */</Line>
  <Line number="6102">static int re_space_char(int c){</Line>
  <Line number="6103">  return c==&apos; &apos; || c==&apos;\t&apos; || c==&apos;\n&apos; || c==&apos;\r&apos; || c==&apos;\v&apos; || c==&apos;\f&apos;;</Line>
  <Line number="6104">}</Line>
  <Line number="6105"></Line>
  <Line number="6106">/* Run a compiled regular expression on the zero-terminated input</Line>
  <Line number="6107">** string zIn[].  Return true on a match and false if there is no match.</Line>
  <Line number="6108">*/</Line>
  <Line number="6109">static int re_match(ReCompiled *pRe, const unsigned char *zIn, int nIn){</Line>
  <Line number="6110">  ReStateSet aStateSet[2], *pThis, *pNext;</Line>
  <Line number="6111">  ReStateNumber aSpace[100];</Line>
  <Line number="6112">  ReStateNumber *pToFree;</Line>
  <Line number="6113">  unsigned int i = <CheckRefs ids="1922">0</CheckRefs>;</Line>
  <Line number="6114">  unsigned int iSwap = <CheckRefs ids="1923">0</CheckRefs>;</Line>
  <Line number="6115">  int c = RE_EOF<CheckRefs ids="1924">+</CheckRefs>1;</Line>
  <Line number="6116">  int cPrev = 0;</Line>
  <Line number="6117">  int rc = 0;</Line>
  <Line number="6118">  ReInput in;</Line>
  <Line number="6119"></Line>
  <Line number="6120">  in.z = zIn;</Line>
  <Line number="6121">  in.i = 0;</Line>
  <Line number="6122">  in.mx = nIn&gt;=0 ? nIn : <CheckRefs ids="1925">(</CheckRefs>int)strlen((char const*)zIn);</Line>
  <Line number="6123"></Line>
  <Line number="6124">  /* Look for the initial prefix match, if there is one. */</Line>
  <Line number="6125">  if( pRe-&gt;nInit ){</Line>
  <Line number="6126">    unsigned char x = pRe-&gt;zInit[0<CheckRefs ids="1926">]</CheckRefs>;</Line>
  <Line number="6127">    while( in.i<CheckRefs ids="1927">+</CheckRefs>pRe-&gt;nInit&lt;=in.mx </Line>
  <Line number="6128">     &amp;&amp; (<CheckRefs ids="1928">zIn</CheckRefs>[in.i]!=<CheckRefs ids="1929">x</CheckRefs> ||</Line>
  <Line number="6129">         strncmp((const char*)zIn+in.i, (const char*)pRe-&gt;zInit, <CheckRefs ids="1930">pRe</CheckRefs>-&gt;nInit)!=0)</Line>
  <Line number="6130">    ){</Line>
  <Line number="6131">      in.i<CheckRefs ids="1931">++</CheckRefs>;</Line>
  <Line number="6132">    }</Line>
  <Line number="6133">    if( in.i<CheckRefs ids="1932">+</CheckRefs>pRe-&gt;nInit&gt;in.mx ) return 0;</Line>
  <Line number="6134">  }</Line>
  <Line number="6135"></Line>
  <Line number="6136">  if( <CheckRefs ids="1933">pRe</CheckRefs>-&gt;nState&lt;=(sizeof(aSpace)<CheckRefs ids="1934">/</CheckRefs>(sizeof(aSpace[0<CheckRefs ids="1936">]</CheckRefs>)<CheckRefs ids="1935">*</CheckRefs><CheckRefs ids="1937">2</CheckRefs>)) ){</Line>
  <Line number="6137">    pToFree = 0;</Line>
  <Line number="6138">    aStateSet[0<CheckRefs ids="1938">]</CheckRefs>.aState = aSpace;</Line>
  <Line number="6139">  }else{</Line>
  <Line number="6140">    pToFree = sqlite3_malloc64( sizeof(ReStateNumber)<CheckRefs ids="1941">*</CheckRefs><CheckRefs ids="1942">2</CheckRefs><CheckRefs ids="1939,1940">*</CheckRefs><CheckRefs ids="1943">pRe</CheckRefs>-&gt;nState );</Line>
  <Line number="6141">    if( pToFree==0 ) return <CheckRefs ids="1944">-</CheckRefs>1;</Line>
  <Line number="6142">    aStateSet[0<CheckRefs ids="1945">]</CheckRefs>.aState = pToFree;</Line>
  <Line number="6143">  }</Line>
  <Line number="6144">  aStateSet[1<CheckRefs ids="1946">]</CheckRefs>.aState = &amp;aStateSet[0<CheckRefs ids="1947">]</CheckRefs>.aState[pRe-&gt;nState];</Line>
  <Line number="6145">  pNext = &amp;aStateSet[1<CheckRefs ids="1948">]</CheckRefs>;</Line>
  <Line number="6146">  pNext-&gt;nState = <CheckRefs ids="1949">0</CheckRefs>;</Line>
  <Line number="6147">  re_add_state(pNext, 0);</Line>
  <Line number="6148">  while( c!=RE_EOF &amp;&amp; pNext-&gt;nState&gt;<CheckRefs ids="1950">0</CheckRefs> ){</Line>
  <Line number="6149">    cPrev = c;</Line>
  <Line number="6150">    c = <CheckRefs ids="1951">pRe</CheckRefs>-&gt;xNextChar(&amp;in);</Line>
  <Line number="6151">    pThis = pNext;</Line>
  <Line number="6152">    pNext = &amp;aStateSet[iSwap<CheckRefs ids="1952">]</CheckRefs>;</Line>
  <Line number="6153">    iSwap = <CheckRefs ids="1954">1</CheckRefs> <CheckRefs ids="1953">-</CheckRefs> iSwap;</Line>
  <Line number="6154">    pNext-&gt;nState = <CheckRefs ids="1955">0</CheckRefs>;</Line>
  <Line number="6155">    for(i=<CheckRefs ids="1956">0</CheckRefs>; i&lt;pThis-&gt;nState; i<CheckRefs ids="1957">++</CheckRefs>){</Line>
  <Line number="6156">      int x = <CheckRefs ids="1958">pThis</CheckRefs>-&gt;aState[i];</Line>
  <Line number="6157">      switch( <CheckRefs ids="1959">pRe</CheckRefs>-&gt;aOp[x] ){</Line>
  <Line number="6158">        case RE_OP_MATCH: {</Line>
  <Line number="6159">          if( pRe-&gt;aArg[x]==c ) re_add_state(pNext, x<CheckRefs ids="1960">+</CheckRefs>1);</Line>
  <Line number="6160">          break;</Line>
  <Line number="6161">        }</Line>
  <Line number="6162">        case RE_OP_ANY: {</Line>
  <Line number="6163">          if( c!=0 ) re_add_state(pNext, x<CheckRefs ids="1961">+</CheckRefs>1);</Line>
  <Line number="6164">          break;</Line>
  <Line number="6165">        }</Line>
  <Line number="6166">        case RE_OP_WORD: {</Line>
  <Line number="6167">          if( re_word_char(c) ) re_add_state(pNext, x<CheckRefs ids="1962">+</CheckRefs>1);</Line>
  <Line number="6168">          break;</Line>
  <Line number="6169">        }</Line>
  <Line number="6170">        case RE_OP_NOTWORD: {</Line>
  <Line number="6171">          if( !re_word_char(c) &amp;&amp; c!=0 ) re_add_state(pNext, x<CheckRefs ids="1963">+</CheckRefs>1);</Line>
  <Line number="6172">          break;</Line>
  <Line number="6173">        }</Line>
  <Line number="6174">        case RE_OP_DIGIT: {</Line>
  <Line number="6175">          if( re_digit_char(c) ) re_add_state(pNext, x<CheckRefs ids="1964">+</CheckRefs>1);</Line>
  <Line number="6176">          break;</Line>
  <Line number="6177">        }</Line>
  <Line number="6178">        case RE_OP_NOTDIGIT: {</Line>
  <Line number="6179">          if( !re_digit_char(c) &amp;&amp; c!=0 ) re_add_state(pNext, x<CheckRefs ids="1965">+</CheckRefs>1);</Line>
  <Line number="6180">          break;</Line>
  <Line number="6181">        }</Line>
  <Line number="6182">        case RE_OP_SPACE: {</Line>
  <Line number="6183">          if( re_space_char(c) ) re_add_state(pNext, x<CheckRefs ids="1966">+</CheckRefs>1);</Line>
  <Line number="6184">          break;</Line>
  <Line number="6185">        }</Line>
  <Line number="6186">        case RE_OP_NOTSPACE: {</Line>
  <Line number="6187">          if( !re_space_char(c) &amp;&amp; c!=0 ) re_add_state(pNext, x<CheckRefs ids="1967">+</CheckRefs>1);</Line>
  <Line number="6188">          break;</Line>
  <Line number="6189">        }</Line>
  <Line number="6190">        case RE_OP_BOUNDARY: {</Line>
  <Line number="6191">          if( re_word_char(c)!=re_word_char(cPrev) ) re_add_state(pThis, x<CheckRefs ids="1968">+</CheckRefs>1);</Line>
  <Line number="6192">          break;</Line>
  <Line number="6193">        }</Line>
  <Line number="6194">        case RE_OP_ANYSTAR: {</Line>
  <Line number="6195">          re_add_state(pNext, x);</Line>
  <Line number="6196">          re_add_state(pThis, x<CheckRefs ids="1969">+</CheckRefs>1);</Line>
  <Line number="6197">          break;</Line>
  <Line number="6198">        }</Line>
  <Line number="6199">        case RE_OP_FORK: {</Line>
  <Line number="6200">          re_add_state(pThis, x<CheckRefs ids="1970">+</CheckRefs>pRe-&gt;aArg[x]);</Line>
  <Line number="6201">          re_add_state(pThis, x<CheckRefs ids="1971">+</CheckRefs>1);</Line>
  <Line number="6202">          break;</Line>
  <Line number="6203">        }</Line>
  <Line number="6204">        case RE_OP_GOTO: {</Line>
  <Line number="6205">          re_add_state(pThis, x<CheckRefs ids="1972">+</CheckRefs>pRe-&gt;aArg[x]);</Line>
  <Line number="6206">          break;</Line>
  <Line number="6207">        }</Line>
  <Line number="6208">        case RE_OP_ACCEPT: {</Line>
  <Line number="6209">          rc = 1;</Line>
  <Line number="6210">          goto re_match_end;</Line>
  <Line number="6211">        }</Line>
  <Line number="6212">        case RE_OP_CC_EXC: {</Line>
  <Line number="6213">          if( c==0 ) break;</Line>
  <Line number="6214">          /* fall-through */</Line>
  <Line number="6215">        }</Line>
  <Line number="6216">        case RE_OP_CC_INC: {</Line>
  <Line number="6217">          int j = 1;</Line>
  <Line number="6218">          int n = pRe-&gt;aArg[x];</Line>
  <Line number="6219">          int hit = 0;</Line>
  <Line number="6220">          for(j=1; j&gt;0 &amp;&amp; j&lt;n; j<CheckRefs ids="1973">++</CheckRefs>){</Line>
  <Line number="6221">            if( <CheckRefs ids="1974">pRe</CheckRefs>-&gt;aOp[x<CheckRefs ids="1975">+</CheckRefs>j]==RE_OP_CC_VALUE ){</Line>
  <Line number="6222">              if( pRe-&gt;aArg[x<CheckRefs ids="1976">+</CheckRefs>j]==c ){</Line>
  <Line number="6223">                hit = 1;</Line>
  <Line number="6224">                j = <CheckRefs ids="1977">-</CheckRefs>1;</Line>
  <Line number="6225">              }</Line>
  <Line number="6226">            }else{</Line>
  <Line number="6227">              if( pRe-&gt;aArg[x<CheckRefs ids="1978">+</CheckRefs>j]&lt;=c &amp;&amp; pRe-&gt;aArg[x<CheckRefs ids="1980">+</CheckRefs>j<CheckRefs ids="1979">+</CheckRefs>1]&gt;=c ){</Line>
  <Line number="6228">                hit = 1;</Line>
  <Line number="6229">                j = <CheckRefs ids="1981">-</CheckRefs>1;</Line>
  <Line number="6230">              }else{</Line>
  <Line number="6231">                j<CheckRefs ids="1982">++</CheckRefs>;</Line>
  <Line number="6232">              }</Line>
  <Line number="6233">            }</Line>
  <Line number="6234">          }</Line>
  <Line number="6235">          if( <CheckRefs ids="1983">pRe</CheckRefs>-&gt;aOp[x]==RE_OP_CC_EXC ) hit = !hit;</Line>
  <Line number="6236">          if( hit ) re_add_state(pNext, x<CheckRefs ids="1984">+</CheckRefs>n);</Line>
  <Line number="6237">          break;</Line>
  <Line number="6238">        }</Line>
  <Line number="6239">      }</Line>
  <Line number="6240">    }</Line>
  <Line number="6241">  }</Line>
  <Line number="6242">  for(i=<CheckRefs ids="1985">0</CheckRefs>; i&lt;pNext-&gt;nState; i<CheckRefs ids="1986">++</CheckRefs>){</Line>
  <Line number="6243">    if( <CheckRefs ids="1987">pRe</CheckRefs>-&gt;aOp[pNext-&gt;aState[i]]==RE_OP_ACCEPT ){ rc = 1; break; }</Line>
  <Line number="6244">  }</Line>
  <Line number="6245">re_match_end:</Line>
  <Line number="6246">  sqlite3_free(pToFree);</Line>
  <Line number="6247">  return rc;</Line>
  <Line number="6248">}</Line>
  <Line number="6249"></Line>
  <Line number="6250">/* Resize the opcode and argument arrays for an RE under construction.</Line>
  <Line number="6251">*/</Line>
  <Line number="6252">static int re_resize(ReCompiled *p, int N){</Line>
  <Line number="6253">  char *aOp;</Line>
  <Line number="6254">  int *aArg;</Line>
  <Line number="6255">  aOp = sqlite3_realloc64(p-&gt;aOp, <CheckRefs ids="1990">N</CheckRefs><CheckRefs ids="1989,1988">*</CheckRefs>sizeof(p-&gt;aOp[0]));</Line>
  <Line number="6256">  if( aOp==0 ) return 1;</Line>
  <Line number="6257">  p-&gt;aOp = aOp;</Line>
  <Line number="6258">  aArg = sqlite3_realloc64(p-&gt;aArg, <CheckRefs ids="1993">N</CheckRefs><CheckRefs ids="1991,1992">*</CheckRefs>sizeof(p-&gt;aArg[0]));</Line>
  <Line number="6259">  if( aArg==0 ) return 1;</Line>
  <Line number="6260">  p-&gt;aArg = aArg;</Line>
  <Line number="6261">  p-&gt;nAlloc = <CheckRefs ids="1994">N</CheckRefs>;</Line>
  <Line number="6262">  return 0;</Line>
  <Line number="6263">}</Line>
  <Line number="6264"></Line>
  <Line number="6265">/* Insert a new opcode and argument into an RE under construction.  The</Line>
  <Line number="6266">** insertion point is just prior to existing opcode iBefore.</Line>
  <Line number="6267">*/</Line>
  <Line number="6268">static int re_insert(ReCompiled *p, int iBefore, int op, int arg){</Line>
  <Line number="6269">  int i;</Line>
  <Line number="6270">  if( p-&gt;nAlloc&lt;=p-&gt;nState &amp;&amp; re_resize(p, p-&gt;nAlloc<CheckRefs ids="1995,1996">*</CheckRefs><CheckRefs ids="1997">2</CheckRefs>) ) return 0;</Line>
  <Line number="6271">  for(i=<CheckRefs ids="1998">p</CheckRefs>-&gt;nState; i&gt;iBefore; i<CheckRefs ids="1999">--</CheckRefs>){</Line>
  <Line number="6272">    p-&gt;aOp[i] = p-&gt;aOp[i<CheckRefs ids="2000">-</CheckRefs>1];</Line>
  <Line number="6273">    p-&gt;aArg[i] = p-&gt;aArg[i<CheckRefs ids="2001">-</CheckRefs>1];</Line>
  <Line number="6274">  }</Line>
  <Line number="6275">  p-&gt;nState<CheckRefs ids="2002">++</CheckRefs>;</Line>
  <Line number="6276">  p-&gt;aOp[iBefore] = <CheckRefs ids="2003">(</CheckRefs>char)op;</Line>
  <Line number="6277">  p-&gt;aArg[iBefore] = arg;</Line>
  <Line number="6278">  return iBefore;</Line>
  <Line number="6279">}</Line>
  <Line number="6280"></Line>
  <Line number="6281">/* Append a new opcode and argument to the end of the RE under construction.</Line>
  <Line number="6282">*/</Line>
  <Line number="6283">static int re_append(ReCompiled *p, int op, int arg){</Line>
  <Line number="6284">  return re_insert(p, <CheckRefs ids="2004">p</CheckRefs>-&gt;nState, op, arg);</Line>
  <Line number="6285">}</Line>
  <Line number="6286"></Line>
  <Line number="6287">/* Make a copy of N opcodes starting at iStart onto the end of the RE</Line>
  <Line number="6288">** under construction.</Line>
  <Line number="6289">*/</Line>
  <Line number="6290">static void re_copy(ReCompiled *p, int iStart, int N){</Line>
  <Line number="6291">  if( p-&gt;nState<CheckRefs ids="2005">+</CheckRefs><CheckRefs ids="2006">N</CheckRefs>&gt;=p-&gt;nAlloc &amp;&amp; re_resize(p, p-&gt;nAlloc<CheckRefs ids="2009">*</CheckRefs><CheckRefs ids="2010">2</CheckRefs><CheckRefs ids="2008,2007">+</CheckRefs><CheckRefs ids="2011">N</CheckRefs>) ) return;</Line>
  <Line number="6292">  memcpy(&amp;p-&gt;aOp[p-&gt;nState], &amp;p-&gt;aOp[iStart], <CheckRefs ids="2013">N</CheckRefs><CheckRefs ids="2012">*</CheckRefs>sizeof(p-&gt;aOp[0]));</Line>
  <Line number="6293">  memcpy(&amp;p-&gt;aArg[p-&gt;nState], &amp;p-&gt;aArg[iStart], <CheckRefs ids="2015">N</CheckRefs><CheckRefs ids="2014">*</CheckRefs>sizeof(p-&gt;aArg[0]));</Line>
  <Line number="6294">  p-&gt;nState <CheckRefs ids="2016">+=</CheckRefs> <CheckRefs ids="2017">N</CheckRefs>;</Line>
  <Line number="6295">}</Line>
  <Line number="6296"></Line>
  <Line number="6297">/* Return true if c is a hexadecimal digit character:  [0-9a-fA-F]</Line>
  <Line number="6298">** If c is a hex digit, also set *pV = (*pV)*16 + valueof(c).  If</Line>
  <Line number="6299">** c is not a hex digit *pV is unchanged.</Line>
  <Line number="6300">*/</Line>
  <Line number="6301">static int re_hex(int c, int *pV){</Line>
  <Line number="6302">  if( c&gt;=&apos;0&apos; &amp;&amp; c&lt;=&apos;9&apos; ){</Line>
  <Line number="6303">    c <CheckRefs ids="2018">-=</CheckRefs> &apos;0&apos;;</Line>
  <Line number="6304">  }else if( c&gt;=&apos;a&apos; &amp;&amp; c&lt;=&apos;f&apos; ){</Line>
  <Line number="6305">    c <CheckRefs ids="2019">-=</CheckRefs> &apos;a&apos; <CheckRefs ids="2020">-</CheckRefs> 10;</Line>
  <Line number="6306">  }else if( c&gt;=&apos;A&apos; &amp;&amp; c&lt;=&apos;F&apos; ){</Line>
  <Line number="6307">    c <CheckRefs ids="2021">-=</CheckRefs> &apos;A&apos; <CheckRefs ids="2022">-</CheckRefs> 10;</Line>
  <Line number="6308">  }else{</Line>
  <Line number="6309">    return 0;</Line>
  <Line number="6310">  }</Line>
  <Line number="6311">  *pV = (*pV)<CheckRefs ids="2024">*</CheckRefs>16 <CheckRefs ids="2023">+</CheckRefs> (c &amp; 0xff);</Line>
  <Line number="6312">  return 1;</Line>
  <Line number="6313">}</Line>
  <Line number="6314"></Line>
  <Line number="6315">/* A backslash character has been seen, read the next character and</Line>
  <Line number="6316">** return its interpretation.</Line>
  <Line number="6317">*/</Line>
  <Line number="6318">static unsigned re_esc_char(ReCompiled *p){</Line>
  <Line number="6319">  static const char zEsc[] = &quot;afnrtv\\()*.+?[$^{|}]&quot;;</Line>
  <Line number="6320">  static const char zTrans[] = &quot;\a\f\n\r\t\v&quot;;</Line>
  <Line number="6321">  int i, v = 0;</Line>
  <Line number="6322">  char c;</Line>
  <Line number="6323">  if( p-&gt;sIn.i&gt;=p-&gt;sIn.mx ) return <CheckRefs ids="2025">0</CheckRefs>;</Line>
  <Line number="6324">  c = <CheckRefs ids="2026">p</CheckRefs>-&gt;sIn.z[p-&gt;sIn.i];</Line>
  <Line number="6325">  if( <CheckRefs ids="2027">c</CheckRefs>==&apos;u&apos; &amp;&amp; p-&gt;sIn.i<CheckRefs ids="2028">+</CheckRefs>4&lt;p-&gt;sIn.mx ){</Line>
  <Line number="6326">    const unsigned char *zIn = p-&gt;sIn.z + p-&gt;sIn.i;</Line>
  <Line number="6327">    if( re_hex(<CheckRefs ids="2029">zIn</CheckRefs>[1],&amp;v)</Line>
  <Line number="6328">     &amp;&amp; re_hex(<CheckRefs ids="2030">zIn</CheckRefs>[2],&amp;v)</Line>
  <Line number="6329">     &amp;&amp; re_hex(<CheckRefs ids="2031">zIn</CheckRefs>[3],&amp;v)</Line>
  <Line number="6330">     &amp;&amp; re_hex(<CheckRefs ids="2032">zIn</CheckRefs>[4],&amp;v)</Line>
  <Line number="6331">    ){</Line>
  <Line number="6332">      p-&gt;sIn.i <CheckRefs ids="2033">+=</CheckRefs> 5;</Line>
  <Line number="6333">      return <CheckRefs ids="2034">v</CheckRefs>;</Line>
  <Line number="6334">    }</Line>
  <Line number="6335">  }</Line>
  <Line number="6336">  if( <CheckRefs ids="2035">c</CheckRefs>==&apos;x&apos; &amp;&amp; p-&gt;sIn.i<CheckRefs ids="2036">+</CheckRefs>2&lt;p-&gt;sIn.mx ){</Line>
  <Line number="6337">    const unsigned char *zIn = p-&gt;sIn.z + p-&gt;sIn.i;</Line>
  <Line number="6338">    if( re_hex(<CheckRefs ids="2037">zIn</CheckRefs>[1],&amp;v)</Line>
  <Line number="6339">     &amp;&amp; re_hex(<CheckRefs ids="2038">zIn</CheckRefs>[2],&amp;v)</Line>
  <Line number="6340">    ){</Line>
  <Line number="6341">      p-&gt;sIn.i <CheckRefs ids="2039">+=</CheckRefs> 3;</Line>
  <Line number="6342">      return <CheckRefs ids="2040">v</CheckRefs>;</Line>
  <Line number="6343">    }</Line>
  <Line number="6344">  }</Line>
  <Line number="6345">  for(i=0; <CheckRefs ids="2041">zEsc</CheckRefs>[i<CheckRefs ids="2042">]</CheckRefs> &amp;&amp; <CheckRefs ids="2043">zEsc</CheckRefs>[i<CheckRefs ids="2044">]</CheckRefs>!=<CheckRefs ids="2045">c</CheckRefs>; i<CheckRefs ids="2046">++</CheckRefs>){}</Line>
  <Line number="6346">  if( zEsc[i<CheckRefs ids="2047">]</CheckRefs> ){</Line>
  <Line number="6347">    if( i&lt;6 ) c = zTrans[i<CheckRefs ids="2048">]</CheckRefs>;</Line>
  <Line number="6348">    p-&gt;sIn.i<CheckRefs ids="2049">++</CheckRefs>;</Line>
  <Line number="6349">  }else{</Line>
  <Line number="6350">    p-&gt;zErr = &quot;unknown \\ escape&quot;;</Line>
  <Line number="6351">  }</Line>
  <Line number="6352">  return <CheckRefs ids="2050">c</CheckRefs>;</Line>
  <Line number="6353">}</Line>
  <Line number="6354"></Line>
  <Line number="6355">/* Forward declaration */</Line>
  <Line number="6356">static const char *re_subcompile_string(ReCompiled*);</Line>
  <Line number="6357"></Line>
  <Line number="6358">/* Peek at the next byte of input */</Line>
  <Line number="6359">static unsigned char rePeek(ReCompiled *p){</Line>
  <Line number="6360">  return <CheckRefs ids="2051">p</CheckRefs>-&gt;sIn.i&lt;p-&gt;sIn.mx ? <CheckRefs ids="2052">p</CheckRefs>-&gt;sIn.z[p-&gt;sIn.i] : 0;</Line>
  <Line number="6361">}</Line>
  <Line number="6362"></Line>
  <Line number="6363">/* Compile RE text into a sequence of opcodes.  Continue up to the</Line>
  <Line number="6364">** first unmatched &quot;)&quot; character, then return.  If an error is found,</Line>
  <Line number="6365">** return a pointer to the error message string.</Line>
  <Line number="6366">*/</Line>
  <Line number="6367">static const char *re_subcompile_re(ReCompiled *p){</Line>
  <Line number="6368">  const char *zErr;</Line>
  <Line number="6369">  int iStart, iEnd, iGoto;</Line>
  <Line number="6370">  iStart = <CheckRefs ids="2053">p</CheckRefs>-&gt;nState;</Line>
  <Line number="6371">  zErr = re_subcompile_string(p);</Line>
  <Line number="6372">  if( zErr ) return zErr;</Line>
  <Line number="6373">  while( <CheckRefs ids="2054">rePeek</CheckRefs>(p)==&apos;|&apos; ){</Line>
  <Line number="6374">    iEnd = <CheckRefs ids="2055">p</CheckRefs>-&gt;nState;</Line>
  <Line number="6375">    re_insert(p, iStart, RE_OP_FORK, iEnd <CheckRefs ids="2057">+</CheckRefs> 2 <CheckRefs ids="2056">-</CheckRefs> iStart);</Line>
  <Line number="6376">    iGoto = re_append(p, RE_OP_GOTO, 0);</Line>
  <Line number="6377">    p-&gt;sIn.i<CheckRefs ids="2058">++</CheckRefs>;</Line>
  <Line number="6378">    zErr = re_subcompile_string(p);</Line>
  <Line number="6379">    if( zErr ) return zErr;</Line>
  <Line number="6380">    p-&gt;aArg[iGoto] = p-&gt;nState <CheckRefs ids="2059,2060">-</CheckRefs> <CheckRefs ids="2061">iGoto</CheckRefs>;</Line>
  <Line number="6381">  }</Line>
  <Line number="6382">  return 0;</Line>
  <Line number="6383">}</Line>
  <Line number="6384"></Line>
  <Line number="6385">/* Compile an element of regular expression text (anything that can be</Line>
  <Line number="6386">** an operand to the &quot;|&quot; operator).  Return NULL on success or a pointer</Line>
  <Line number="6387">** to the error message if there is a problem.</Line>
  <Line number="6388">*/</Line>
  <Line number="6389">static const char *re_subcompile_string(ReCompiled *p){</Line>
  <Line number="6390">  int iPrev = <CheckRefs ids="2062">-</CheckRefs>1;</Line>
  <Line number="6391">  int iStart;</Line>
  <Line number="6392">  unsigned c;</Line>
  <Line number="6393">  const char *zErr;</Line>
  <Line number="6394">  while( (c = p-&gt;xNextChar(&amp;p-&gt;sIn))!=<CheckRefs ids="2063">0</CheckRefs> ){</Line>
  <Line number="6395">    iStart = <CheckRefs ids="2064">p</CheckRefs>-&gt;nState;</Line>
  <Line number="6396">    switch( c ){</Line>
  <Line number="6397">      case <CheckRefs ids="2065">&apos;|&apos;</CheckRefs>:</Line>
  <Line number="6398">      case <CheckRefs ids="2066">&apos;$&apos;</CheckRefs>:</Line>
  <Line number="6399">      case <CheckRefs ids="2067">&apos;)&apos;</CheckRefs>: {</Line>
  <Line number="6400">        p-&gt;sIn.i<CheckRefs ids="2068">--</CheckRefs>;</Line>
  <Line number="6401">        return 0;</Line>
  <Line number="6402">      }</Line>
  <Line number="6403">      case <CheckRefs ids="2069">&apos;(&apos;</CheckRefs>: {</Line>
  <Line number="6404">        zErr = re_subcompile_re(p);</Line>
  <Line number="6405">        if( zErr ) return zErr;</Line>
  <Line number="6406">        if( <CheckRefs ids="2070">rePeek</CheckRefs>(p)!=&apos;)&apos; ) return &quot;unmatched &apos;(&apos;&quot;;</Line>
  <Line number="6407">        p-&gt;sIn.i<CheckRefs ids="2071">++</CheckRefs>;</Line>
  <Line number="6408">        break;</Line>
  <Line number="6409">      }</Line>
  <Line number="6410">      case <CheckRefs ids="2072">&apos;.&apos;</CheckRefs>: {</Line>
  <Line number="6411">        if( <CheckRefs ids="2073">rePeek</CheckRefs>(p)==&apos;*&apos; ){</Line>
  <Line number="6412">          re_append(p, RE_OP_ANYSTAR, 0);</Line>
  <Line number="6413">          p-&gt;sIn.i<CheckRefs ids="2074">++</CheckRefs>;</Line>
  <Line number="6414">        }else{</Line>
  <Line number="6415">          re_append(p, RE_OP_ANY, 0);</Line>
  <Line number="6416">        }</Line>
  <Line number="6417">        break;</Line>
  <Line number="6418">      }</Line>
  <Line number="6419">      case <CheckRefs ids="2075">&apos;*&apos;</CheckRefs>: {</Line>
  <Line number="6420">        if( iPrev&lt;0 ) return &quot;&apos;*&apos; without operand&quot;;</Line>
  <Line number="6421">        re_insert(p, iPrev, RE_OP_GOTO, p-&gt;nState <CheckRefs ids="2078">-</CheckRefs> <CheckRefs ids="2079">iPrev</CheckRefs> <CheckRefs ids="2077,2076">+</CheckRefs> <CheckRefs ids="2080">1</CheckRefs>);</Line>
  <Line number="6422">        re_append(p, RE_OP_FORK, <CheckRefs ids="2084">iPrev</CheckRefs> <CheckRefs ids="2083">-</CheckRefs> p-&gt;nState <CheckRefs ids="2081,2082">+</CheckRefs> <CheckRefs ids="2085">1</CheckRefs>);</Line>
  <Line number="6423">        break;</Line>
  <Line number="6424">      }</Line>
  <Line number="6425">      case <CheckRefs ids="2086">&apos;+&apos;</CheckRefs>: {</Line>
  <Line number="6426">        if( iPrev&lt;0 ) return &quot;&apos;+&apos; without operand&quot;;</Line>
  <Line number="6427">        re_append(p, RE_OP_FORK, <CheckRefs ids="2089">iPrev</CheckRefs> <CheckRefs ids="2087,2088">-</CheckRefs> p-&gt;nState);</Line>
  <Line number="6428">        break;</Line>
  <Line number="6429">      }</Line>
  <Line number="6430">      case <CheckRefs ids="2090">&apos;?&apos;</CheckRefs>: {</Line>
  <Line number="6431">        if( iPrev&lt;0 ) return &quot;&apos;?&apos; without operand&quot;;</Line>
  <Line number="6432">        re_insert(p, iPrev, RE_OP_FORK, p-&gt;nState <CheckRefs ids="2093">-</CheckRefs> <CheckRefs ids="2094">iPrev</CheckRefs><CheckRefs ids="2091,2092">+</CheckRefs><CheckRefs ids="2095">1</CheckRefs>);</Line>
  <Line number="6433">        break;</Line>
  <Line number="6434">      }</Line>
  <Line number="6435">      case <CheckRefs ids="2096">&apos;{&apos;</CheckRefs>: {</Line>
  <Line number="6436">        int m = 0, n = 0;</Line>
  <Line number="6437">        int sz, j;</Line>
  <Line number="6438">        if( iPrev&lt;0 ) return &quot;&apos;{m,n}&apos; without operand&quot;;</Line>
  <Line number="6439">        while( (c=<CheckRefs ids="2097">rePeek</CheckRefs>(p))&gt;=<CheckRefs ids="2098">&apos;0&apos;</CheckRefs> &amp;&amp; c&lt;=<CheckRefs ids="2099">&apos;9&apos;</CheckRefs> ){ m = m<CheckRefs ids="2103,2104">*</CheckRefs>10 <CheckRefs ids="2102">+</CheckRefs> c <CheckRefs ids="2100,2101">-</CheckRefs> <CheckRefs ids="2105">&apos;0&apos;</CheckRefs>; p-&gt;sIn.i<CheckRefs ids="2106">++</CheckRefs>; }</Line>
  <Line number="6440">        n = m;</Line>
  <Line number="6441">        if( c==<CheckRefs ids="2107">&apos;,&apos;</CheckRefs> ){</Line>
  <Line number="6442">          p-&gt;sIn.i<CheckRefs ids="2108">++</CheckRefs>;</Line>
  <Line number="6443">          n = 0;</Line>
  <Line number="6444">          while( (c=<CheckRefs ids="2109">rePeek</CheckRefs>(p))&gt;=<CheckRefs ids="2110">&apos;0&apos;</CheckRefs> &amp;&amp; c&lt;=<CheckRefs ids="2111">&apos;9&apos;</CheckRefs> ){ n = n<CheckRefs ids="2115,2116">*</CheckRefs>10 <CheckRefs ids="2114">+</CheckRefs> c<CheckRefs ids="2112,2113">-</CheckRefs><CheckRefs ids="2117">&apos;0&apos;</CheckRefs>; p-&gt;sIn.i<CheckRefs ids="2118">++</CheckRefs>; }</Line>
  <Line number="6445">        }</Line>
  <Line number="6446">        if( c!=<CheckRefs ids="2119">&apos;}&apos;</CheckRefs> ) return &quot;unmatched &apos;{&apos;&quot;;</Line>
  <Line number="6447">        if( n&gt;0 &amp;&amp; n&lt;m ) return &quot;n less than m in &apos;{m,n}&apos;&quot;;</Line>
  <Line number="6448">        p-&gt;sIn.i<CheckRefs ids="2120">++</CheckRefs>;</Line>
  <Line number="6449">        sz = p-&gt;nState <CheckRefs ids="2121,2122">-</CheckRefs> <CheckRefs ids="2123">iPrev</CheckRefs>;</Line>
  <Line number="6450">        if( m==0 ){</Line>
  <Line number="6451">          if( n==0 ) return &quot;both m and n are zero in &apos;{m,n}&apos;&quot;;</Line>
  <Line number="6452">          re_insert(p, iPrev, RE_OP_FORK, sz<CheckRefs ids="2124">+</CheckRefs>1);</Line>
  <Line number="6453">          n<CheckRefs ids="2125">--</CheckRefs>;</Line>
  <Line number="6454">        }else{</Line>
  <Line number="6455">          for(j=1; j&lt;m; j<CheckRefs ids="2126">++</CheckRefs>) re_copy(p, iPrev, sz);</Line>
  <Line number="6456">        }</Line>
  <Line number="6457">        for(j=m; j&lt;n; j<CheckRefs ids="2127">++</CheckRefs>){</Line>
  <Line number="6458">          re_append(p, RE_OP_FORK, sz<CheckRefs ids="2128">+</CheckRefs>1);</Line>
  <Line number="6459">          re_copy(p, iPrev, sz);</Line>
  <Line number="6460">        }</Line>
  <Line number="6461">        if( n==0 &amp;&amp; m&gt;0 ){</Line>
  <Line number="6462">          re_append(p, RE_OP_FORK, <CheckRefs ids="2129">-</CheckRefs>sz);</Line>
  <Line number="6463">        }</Line>
  <Line number="6464">        break;</Line>
  <Line number="6465">      }</Line>
  <Line number="6466">      case <CheckRefs ids="2130">&apos;[&apos;</CheckRefs>: {</Line>
  <Line number="6467">        int iFirst = <CheckRefs ids="2131">p</CheckRefs>-&gt;nState;</Line>
  <Line number="6468">        if( <CheckRefs ids="2132">rePeek</CheckRefs>(p)==&apos;^&apos; ){</Line>
  <Line number="6469">          re_append(p, RE_OP_CC_EXC, 0);</Line>
  <Line number="6470">          p-&gt;sIn.i<CheckRefs ids="2133">++</CheckRefs>;</Line>
  <Line number="6471">        }else{</Line>
  <Line number="6472">          re_append(p, RE_OP_CC_INC, 0);</Line>
  <Line number="6473">        }</Line>
  <Line number="6474">        while( (c = p-&gt;xNextChar(&amp;p-&gt;sIn))!=<CheckRefs ids="2134">0</CheckRefs> ){</Line>
  <Line number="6475">          if( c==<CheckRefs ids="2135">&apos;[&apos;</CheckRefs> &amp;&amp; <CheckRefs ids="2136">rePeek</CheckRefs>(p)==&apos;:&apos; ){</Line>
  <Line number="6476">            return &quot;POSIX character classes not supported&quot;;</Line>
  <Line number="6477">          }</Line>
  <Line number="6478">          if( c==<CheckRefs ids="2137">&apos;\\&apos;</CheckRefs> ) c = re_esc_char(p);</Line>
  <Line number="6479">          if( <CheckRefs ids="2138">rePeek</CheckRefs>(p)==&apos;-&apos; ){</Line>
  <Line number="6480">            re_append(p, RE_OP_CC_RANGE, <CheckRefs ids="2139">c</CheckRefs>);</Line>
  <Line number="6481">            p-&gt;sIn.i<CheckRefs ids="2140">++</CheckRefs>;</Line>
  <Line number="6482">            c = p-&gt;xNextChar(&amp;p-&gt;sIn);</Line>
  <Line number="6483">            if( c==<CheckRefs ids="2141">&apos;\\&apos;</CheckRefs> ) c = re_esc_char(p);</Line>
  <Line number="6484">            re_append(p, RE_OP_CC_RANGE, <CheckRefs ids="2142">c</CheckRefs>);</Line>
  <Line number="6485">          }else{</Line>
  <Line number="6486">            re_append(p, RE_OP_CC_VALUE, <CheckRefs ids="2143">c</CheckRefs>);</Line>
  <Line number="6487">          }</Line>
  <Line number="6488">          if( <CheckRefs ids="2144">rePeek</CheckRefs>(p)==&apos;]&apos; ){ p-&gt;sIn.i<CheckRefs ids="2145">++</CheckRefs>; break; }</Line>
  <Line number="6489">        }</Line>
  <Line number="6490">        if( c==<CheckRefs ids="2146">0</CheckRefs> ) return &quot;unclosed &apos;[&apos;&quot;;</Line>
  <Line number="6491">        p-&gt;aArg[iFirst] = p-&gt;nState <CheckRefs ids="2147,2148">-</CheckRefs> <CheckRefs ids="2149">iFirst</CheckRefs>;</Line>
  <Line number="6492">        break;</Line>
  <Line number="6493">      }</Line>
  <Line number="6494">      case <CheckRefs ids="2150">&apos;\\&apos;</CheckRefs>: {</Line>
  <Line number="6495">        int specialOp = 0;</Line>
  <Line number="6496">        switch( <CheckRefs ids="2151">rePeek</CheckRefs>(p) ){</Line>
  <Line number="6497">          case &apos;b&apos;: specialOp = RE_OP_BOUNDARY;   break;</Line>
  <Line number="6498">          case &apos;d&apos;: specialOp = RE_OP_DIGIT;      break;</Line>
  <Line number="6499">          case &apos;D&apos;: specialOp = RE_OP_NOTDIGIT;   break;</Line>
  <Line number="6500">          case &apos;s&apos;: specialOp = RE_OP_SPACE;      break;</Line>
  <Line number="6501">          case &apos;S&apos;: specialOp = RE_OP_NOTSPACE;   break;</Line>
  <Line number="6502">          case &apos;w&apos;: specialOp = RE_OP_WORD;       break;</Line>
  <Line number="6503">          case &apos;W&apos;: specialOp = RE_OP_NOTWORD;    break;</Line>
  <Line number="6504">        }</Line>
  <Line number="6505">        if( specialOp ){</Line>
  <Line number="6506">          p-&gt;sIn.i<CheckRefs ids="2152">++</CheckRefs>;</Line>
  <Line number="6507">          re_append(p, specialOp, 0);</Line>
  <Line number="6508">        }else{</Line>
  <Line number="6509">          c = re_esc_char(p);</Line>
  <Line number="6510">          re_append(p, RE_OP_MATCH, <CheckRefs ids="2153">c</CheckRefs>);</Line>
  <Line number="6511">        }</Line>
  <Line number="6512">        break;</Line>
  <Line number="6513">      }</Line>
  <Line number="6514">      default: {</Line>
  <Line number="6515">        re_append(p, RE_OP_MATCH, <CheckRefs ids="2154">c</CheckRefs>);</Line>
  <Line number="6516">        break;</Line>
  <Line number="6517">      }</Line>
  <Line number="6518">    }</Line>
  <Line number="6519">    iPrev = iStart;</Line>
  <Line number="6520">  }</Line>
  <Line number="6521">  return 0;</Line>
  <Line number="6522">}</Line>
  <Line number="6523"></Line>
  <Line number="6524">/* Free and reclaim all the memory used by a previously compiled</Line>
  <Line number="6525">** regular expression.  Applications should invoke this routine once</Line>
  <Line number="6526">** for every call to re_compile() to avoid memory leaks.</Line>
  <Line number="6527">*/</Line>
  <Line number="6528">static void re_free(ReCompiled *pRe){</Line>
  <Line number="6529">  if( pRe ){</Line>
  <Line number="6530">    sqlite3_free(pRe-&gt;aOp);</Line>
  <Line number="6531">    sqlite3_free(pRe-&gt;aArg);</Line>
  <Line number="6532">    sqlite3_free(pRe);</Line>
  <Line number="6533">  }</Line>
  <Line number="6534">}</Line>
  <Line number="6535"></Line>
  <Line number="6536">/*</Line>
  <Line number="6537">** Compile a textual regular expression in zIn[] into a compiled regular</Line>
  <Line number="6538">** expression suitable for us by re_match() and return a pointer to the</Line>
  <Line number="6539">** compiled regular expression in *ppRe.  Return NULL on success or an</Line>
  <Line number="6540">** error message if something goes wrong.</Line>
  <Line number="6541">*/</Line>
  <Line number="6542">static const char *re_compile(ReCompiled **ppRe, const char *zIn, int noCase){</Line>
  <Line number="6543">  ReCompiled *pRe;</Line>
  <Line number="6544">  const char *zErr;</Line>
  <Line number="6545">  int i, j;</Line>
  <Line number="6546"></Line>
  <Line number="6547">  *ppRe = 0;</Line>
  <Line number="6548">  pRe = sqlite3_malloc( <CheckRefs ids="2155">sizeof</CheckRefs>(*pRe) );</Line>
  <Line number="6549">  if( pRe==0 ){</Line>
  <Line number="6550">    return &quot;out of memory&quot;;</Line>
  <Line number="6551">  }</Line>
  <Line number="6552">  memset(pRe, 0, sizeof(*pRe));</Line>
  <Line number="6553">  pRe-&gt;xNextChar = noCase ? re_next_char_nocase : re_next_char;</Line>
  <Line number="6554">  if( re_resize(pRe, 30) ){</Line>
  <Line number="6555">    re_free(pRe);</Line>
  <Line number="6556">    return &quot;out of memory&quot;;</Line>
  <Line number="6557">  }</Line>
  <Line number="6558">  if( <CheckRefs ids="2156">zIn</CheckRefs>[0]==&apos;^&apos; ){</Line>
  <Line number="6559">    zIn++;</Line>
  <Line number="6560">  }else{</Line>
  <Line number="6561">    re_append(pRe, RE_OP_ANYSTAR, 0);</Line>
  <Line number="6562">  }</Line>
  <Line number="6563">  pRe-&gt;sIn.z = (unsigned char*)zIn;</Line>
  <Line number="6564">  pRe-&gt;sIn.i = 0;</Line>
  <Line number="6565">  pRe-&gt;sIn.mx = <CheckRefs ids="2157">(</CheckRefs>int)strlen(zIn);</Line>
  <Line number="6566">  zErr = re_subcompile_re(pRe);</Line>
  <Line number="6567">  if( zErr ){</Line>
  <Line number="6568">    re_free(pRe);</Line>
  <Line number="6569">    return zErr;</Line>
  <Line number="6570">  }</Line>
  <Line number="6571">  if( <CheckRefs ids="2158">rePeek</CheckRefs>(pRe)==&apos;$&apos; &amp;&amp; pRe-&gt;sIn.i<CheckRefs ids="2159">+</CheckRefs>1&gt;=pRe-&gt;sIn.mx ){</Line>
  <Line number="6572">    re_append(pRe, RE_OP_MATCH, RE_EOF);</Line>
  <Line number="6573">    re_append(pRe, RE_OP_ACCEPT, 0);</Line>
  <Line number="6574">    *ppRe = pRe;</Line>
  <Line number="6575">  }else if( pRe-&gt;sIn.i&gt;=pRe-&gt;sIn.mx ){</Line>
  <Line number="6576">    re_append(pRe, RE_OP_ACCEPT, 0);</Line>
  <Line number="6577">    *ppRe = pRe;</Line>
  <Line number="6578">  }else{</Line>
  <Line number="6579">    re_free(pRe);</Line>
  <Line number="6580">    return &quot;unrecognized character&quot;;</Line>
  <Line number="6581">  }</Line>
  <Line number="6582"></Line>
  <Line number="6583">  /* The following is a performance optimization.  If the regex begins with</Line>
  <Line number="6584">  ** &quot;.*&quot; (if the input regex lacks an initial &quot;^&quot;) and afterwards there are</Line>
  <Line number="6585">  ** one or more matching characters, enter those matching characters into</Line>
  <Line number="6586">  ** zInit[].  The re_match() routine can then search ahead in the input </Line>
  <Line number="6587">  ** string looking for the initial match without having to run the whole</Line>
  <Line number="6588">  ** regex engine over the string.  Do not worry able trying to match</Line>
  <Line number="6589">  ** unicode characters beyond plane 0 - those are very rare and this is</Line>
  <Line number="6590">  ** just an optimization. */</Line>
  <Line number="6591">  if( <CheckRefs ids="2160">pRe</CheckRefs>-&gt;aOp[0]==RE_OP_ANYSTAR &amp;&amp; !noCase ){</Line>
  <Line number="6592">    for(j=0, i=1; j&lt;<CheckRefs ids="2162">(</CheckRefs>int)sizeof(pRe-&gt;zInit)<CheckRefs ids="2161">-</CheckRefs>2 &amp;&amp; <CheckRefs ids="2163">pRe</CheckRefs>-&gt;aOp[i]==RE_OP_MATCH; i<CheckRefs ids="2164">++</CheckRefs>){</Line>
  <Line number="6593">      unsigned x = <CheckRefs ids="2165">pRe</CheckRefs>-&gt;aArg[i];</Line>
  <Line number="6594">      if( x&lt;=<CheckRefs ids="2166">127</CheckRefs> ){</Line>
  <Line number="6595">        pRe-&gt;zInit[j<CheckRefs ids="2168">++</CheckRefs><CheckRefs ids="2167">]</CheckRefs> = <CheckRefs ids="2169">(</CheckRefs>unsigned char)x;</Line>
  <Line number="6596">      }else if( x&lt;=<CheckRefs ids="2170">0xfff</CheckRefs> ){</Line>
  <Line number="6597">        pRe-&gt;zInit[j<CheckRefs ids="2172">++</CheckRefs><CheckRefs ids="2171">]</CheckRefs> = <CheckRefs ids="2173">(</CheckRefs>unsigned char)(<CheckRefs ids="2174">0xc0</CheckRefs> | (x<CheckRefs ids="2175">&gt;&gt;</CheckRefs>6));</Line>
  <Line number="6598">        pRe-&gt;zInit[j<CheckRefs ids="2177">++</CheckRefs><CheckRefs ids="2176">]</CheckRefs> = <CheckRefs ids="2179">0x80</CheckRefs> <CheckRefs ids="2178">|</CheckRefs> (x&amp;<CheckRefs ids="2180">0x3f</CheckRefs>);</Line>
  <Line number="6599">      }else if( x&lt;=<CheckRefs ids="2181">0xffff</CheckRefs> ){</Line>
  <Line number="6600">        pRe-&gt;zInit[j<CheckRefs ids="2183">++</CheckRefs><CheckRefs ids="2182">]</CheckRefs> = <CheckRefs ids="2184">(</CheckRefs>unsigned char)(<CheckRefs ids="2185">0xd0</CheckRefs> | (x<CheckRefs ids="2186">&gt;&gt;</CheckRefs>12));</Line>
  <Line number="6601">        pRe-&gt;zInit[j<CheckRefs ids="2188">++</CheckRefs><CheckRefs ids="2187">]</CheckRefs> = <CheckRefs ids="2190">0x80</CheckRefs> <CheckRefs ids="2189">|</CheckRefs> ((x<CheckRefs ids="2191">&gt;&gt;</CheckRefs>6)&amp;<CheckRefs ids="2192">0x3f</CheckRefs>);</Line>
  <Line number="6602">        pRe-&gt;zInit[j<CheckRefs ids="2194">++</CheckRefs><CheckRefs ids="2193">]</CheckRefs> = <CheckRefs ids="2196">0x80</CheckRefs> <CheckRefs ids="2195">|</CheckRefs> (x&amp;<CheckRefs ids="2197">0x3f</CheckRefs>);</Line>
  <Line number="6603">      }else{</Line>
  <Line number="6604">        break;</Line>
  <Line number="6605">      }</Line>
  <Line number="6606">    }</Line>
  <Line number="6607">    if( j&gt;0 &amp;&amp; <CheckRefs ids="2198">pRe</CheckRefs>-&gt;zInit[j<CheckRefs ids="2200">-</CheckRefs>1<CheckRefs ids="2199">]</CheckRefs>==0 ) j<CheckRefs ids="2201">--</CheckRefs>;</Line>
  <Line number="6608">    pRe-&gt;nInit = j;</Line>
  <Line number="6609">  }</Line>
  <Line number="6610">  return pRe-&gt;zErr;</Line>
  <Line number="6611">}</Line>
  <Line number="6612"></Line>
  <Line number="6613">/*</Line>
  <Line number="6614">** Implementation of the regexp() SQL function.  This function implements</Line>
  <Line number="6615">** the build-in REGEXP operator.  The first argument to the function is the</Line>
  <Line number="6616">** pattern and the second argument is the string.  So, the SQL statements:</Line>
  <Line number="6617">**</Line>
  <Line number="6618">**       A REGEXP B</Line>
  <Line number="6619">**</Line>
  <Line number="6620">** is implemented as regexp(B,A).</Line>
  <Line number="6621">*/</Line>
  <Line number="6622">static void re_sql_func(</Line>
  <Line number="6623">  sqlite3_context *context,</Line>
  <Line number="6624">  int argc,</Line>
  <Line number="6625">  sqlite3_value **argv</Line>
  <Line number="6626">){</Line>
  <Line number="6627">  ReCompiled *pRe;          /* Compiled regular expression */</Line>
  <Line number="6628">  const char *zPattern;     /* The regular expression */</Line>
  <Line number="6629">  const unsigned char *zStr;/* String being searched */</Line>
  <Line number="6630">  const char *zErr;         /* Compile error message */</Line>
  <Line number="6631">  int setAux = 0;           /* True to invoke sqlite3_set_auxdata() */</Line>
  <Line number="6632"></Line>
  <Line number="6633">  (void)argc;  /* Unused */</Line>
  <Line number="6634">  pRe = sqlite3_get_auxdata(context, 0);</Line>
  <Line number="6635">  if( pRe==0 ){</Line>
  <Line number="6636">    zPattern = (const char*)sqlite3_value_text(argv[0]);</Line>
  <Line number="6637">    if( zPattern==0 ) return;</Line>
  <Line number="6638">    zErr = re_compile(&amp;pRe, zPattern, sqlite3_user_data(context)!=0);</Line>
  <Line number="6639">    if( zErr ){</Line>
  <Line number="6640">      re_free(pRe);</Line>
  <Line number="6641">      sqlite3_result_error(context, zErr, <CheckRefs ids="2202">-</CheckRefs>1);</Line>
  <Line number="6642">      return;</Line>
  <Line number="6643">    }</Line>
  <Line number="6644">    if( pRe==0 ){</Line>
  <Line number="6645">      sqlite3_result_error_nomem(context);</Line>
  <Line number="6646">      return;</Line>
  <Line number="6647">    }</Line>
  <Line number="6648">    setAux = 1;</Line>
  <Line number="6649">  }</Line>
  <Line number="6650">  zStr = (const unsigned char*)sqlite3_value_text(argv[1]);</Line>
  <Line number="6651">  if( zStr!=0 ){</Line>
  <Line number="6652">    sqlite3_result_int(context, re_match(pRe, zStr, <CheckRefs ids="2203">-</CheckRefs>1));</Line>
  <Line number="6653">  }</Line>
  <Line number="6654">  if( setAux ){</Line>
  <Line number="6655">    sqlite3_set_auxdata(context, 0, pRe, (void(*)(void*))re_free);</Line>
  <Line number="6656">  }</Line>
  <Line number="6657">}</Line>
  <Line number="6658"></Line>
  <Line number="6659">/*</Line>
  <Line number="6660">** Invoke this routine to register the regexp() function with the</Line>
  <Line number="6661">** SQLite database connection.</Line>
  <Line number="6662">*/</Line>
  <Line number="6663">#ifdef _WIN32</Line>
  <Line number="6664"></Line>
  <Line number="6665">#endif</Line>
  <Line number="6666">int sqlite3_regexp_init(</Line>
  <Line number="6667">  sqlite3 *db, </Line>
  <Line number="6668">  char **pzErrMsg, </Line>
  <Line number="6669">  const sqlite3_api_routines *pApi</Line>
  <Line number="6670">){</Line>
  <Line number="6671">  int rc = SQLITE_OK;</Line>
  <Line number="6672">  SQLITE_EXTENSION_INIT2(pApi);</Line>
  <Line number="6673">  (void)pzErrMsg;  /* Unused */</Line>
  <Line number="6674">  rc = sqlite3_create_function(db, &quot;regexp&quot;, 2, SQLITE_UTF8|SQLITE_INNOCUOUS,</Line>
  <Line number="6675">                               0, re_sql_func, 0, 0);</Line>
  <Line number="6676">  if( rc==SQLITE_OK ){</Line>
  <Line number="6677">    /* The regexpi(PATTERN,STRING) function is a case-insensitive version</Line>
  <Line number="6678">    ** of regexp(PATTERN,STRING). */</Line>
  <Line number="6679">    rc = sqlite3_create_function(db, &quot;regexpi&quot;, 2, SQLITE_UTF8|SQLITE_INNOCUOUS,</Line>
  <Line number="6680">                                 (void*)db, re_sql_func, 0, 0);</Line>
  <Line number="6681">  }</Line>
  <Line number="6682">  return rc;</Line>
  <Line number="6683">}</Line>
  <Line number="6684"></Line>
  <Line number="6685">/************************* End ../ext/misc/regexp.c ********************/</Line>
  <Line number="6686">#ifdef SQLITE_HAVE_ZLIB</Line>
  <Line number="6687">/************************* Begin ../ext/misc/zipfile.c ******************/</Line>
  <Line number="6688">/*</Line>
  <Line number="6689">** 2017-12-26</Line>
  <Line number="6690">**</Line>
  <Line number="6691">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="6692">** a legal notice, here is a blessing:</Line>
  <Line number="6693">**</Line>
  <Line number="6694">**    May you do good and not evil.</Line>
  <Line number="6695">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="6696">**    May you share freely, never taking more than you give.</Line>
  <Line number="6697">**</Line>
  <Line number="6698">******************************************************************************</Line>
  <Line number="6699">**</Line>
  <Line number="6700">** This file implements a virtual table for reading and writing ZIP archive</Line>
  <Line number="6701">** files.</Line>
  <Line number="6702">**</Line>
  <Line number="6703">** Usage example:</Line>
  <Line number="6704">**</Line>
  <Line number="6705">**     SELECT name, sz, datetime(mtime,&apos;unixepoch&apos;) FROM zipfile($filename);</Line>
  <Line number="6706">**</Line>
  <Line number="6707">** Current limitations:</Line>
  <Line number="6708">**</Line>
  <Line number="6709">**    *  No support for encryption</Line>
  <Line number="6710">**    *  No support for ZIP archives spanning multiple files</Line>
  <Line number="6711">**    *  No support for zip64 extensions</Line>
  <Line number="6712">**    *  Only the &quot;inflate/deflate&quot; (zlib) compression method is supported</Line>
  <Line number="6713">*/</Line>
  <Line number="6714">/* #include &quot;sqlite3ext.h&quot; */</Line>
  <Line number="6715">SQLITE_EXTENSION_INIT1</Line>
  <Line number="6716">#include &lt;stdio.h&gt;</Line>
  <Line number="6717">#include &lt;string.h&gt;</Line>
  <Line number="6718">#include &lt;assert.h&gt;</Line>
  <Line number="6719"></Line>
  <Line number="6720">#include &lt;zlib.h&gt;</Line>
  <Line number="6721"></Line>
  <Line number="6722">#ifndef SQLITE_OMIT_VIRTUALTABLE</Line>
  <Line number="6723"></Line>
  <Line number="6724">#ifndef SQLITE_AMALGAMATION</Line>
  <Line number="6725"></Line>
  <Line number="6726">#ifndef UINT32_TYPE</Line>
  <Line number="6727"># ifdef HAVE_UINT32_T</Line>
  <Line number="6728">#  define UINT32_TYPE uint32_t</Line>
  <Line number="6729"># else</Line>
  <Line number="6730">#  define UINT32_TYPE unsigned int</Line>
  <Line number="6731"># endif</Line>
  <Line number="6732">#endif</Line>
  <Line number="6733">#ifndef UINT16_TYPE</Line>
  <Line number="6734"># ifdef HAVE_UINT16_T</Line>
  <Line number="6735">#  define UINT16_TYPE uint16_t</Line>
  <Line number="6736"># else</Line>
  <Line number="6737">#  define UINT16_TYPE unsigned short int</Line>
  <Line number="6738"># endif</Line>
  <Line number="6739">#endif</Line>
  <Line number="6740">/* typedef sqlite3_int64 i64; */</Line>
  <Line number="6741">/* typedef unsigned char u8; */</Line>
  <Line number="6742">typedef UINT32_TYPE u32;           /* 4-byte unsigned integer */</Line>
  <Line number="6743">typedef UINT16_TYPE u16;           /* 2-byte unsigned integer */</Line>
  <Line number="6744">#define MIN(a,b) ((a)&lt;(b) ? (a) : (b))</Line>
  <Line number="6745"></Line>
  <Line number="6746">#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)</Line>
  <Line number="6747"># define ALWAYS(X)      (1)</Line>
  <Line number="6748"># define NEVER(X)       (0)</Line>
  <Line number="6749">#elif !defined(NDEBUG)</Line>
  <Line number="6750"># define ALWAYS(X)      ((X)?1:(assert(0),0))</Line>
  <Line number="6751"># define NEVER(X)       ((X)?(assert(0),1):0)</Line>
  <Line number="6752">#else</Line>
  <Line number="6753"># define ALWAYS(X)      (X)</Line>
  <Line number="6754"># define NEVER(X)       (X)</Line>
  <Line number="6755">#endif</Line>
  <Line number="6756"></Line>
  <Line number="6757">#endif   /* SQLITE_AMALGAMATION */</Line>
  <Line number="6758"></Line>
  <Line number="6759">/*</Line>
  <Line number="6760">** Definitions for mode bitmasks S_IFDIR, S_IFREG and S_IFLNK.</Line>
  <Line number="6761">**</Line>
  <Line number="6762">** In some ways it would be better to obtain these values from system </Line>
  <Line number="6763">** header files. But, the dependency is undesirable and (a) these</Line>
  <Line number="6764">** have been stable for decades, (b) the values are part of POSIX and</Line>
  <Line number="6765">** are also made explicit in [man stat], and (c) are part of the </Line>
  <Line number="6766">** file format for zip archives.</Line>
  <Line number="6767">*/</Line>
  <Line number="6768">#ifndef S_IFDIR</Line>
  <Line number="6769"># define S_IFDIR 0040000</Line>
  <Line number="6770">#endif</Line>
  <Line number="6771">#ifndef S_IFREG</Line>
  <Line number="6772"># define S_IFREG 0100000</Line>
  <Line number="6773">#endif</Line>
  <Line number="6774">#ifndef S_IFLNK</Line>
  <Line number="6775"># define S_IFLNK 0120000</Line>
  <Line number="6776">#endif</Line>
  <Line number="6777"></Line>
  <Line number="6778">static const char ZIPFILE_SCHEMA[] = </Line>
  <Line number="6779">  &quot;CREATE TABLE y(&quot;</Line>
  <Line number="6780">    &quot;name PRIMARY KEY,&quot;  /* 0: Name of file in zip archive */</Line>
  <Line number="6781">    &quot;mode,&quot;              /* 1: POSIX mode for file */</Line>
  <Line number="6782">    &quot;mtime,&quot;             /* 2: Last modification time (secs since 1970)*/</Line>
  <Line number="6783">    &quot;sz,&quot;                /* 3: Size of object */</Line>
  <Line number="6784">    &quot;rawdata,&quot;           /* 4: Raw data */</Line>
  <Line number="6785">    &quot;data,&quot;              /* 5: Uncompressed data */</Line>
  <Line number="6786">    &quot;method,&quot;            /* 6: Compression method (integer) */</Line>
  <Line number="6787">    &quot;z HIDDEN&quot;           /* 7: Name of zip file */</Line>
  <Line number="6788">  &quot;) WITHOUT ROWID;&quot;;</Line>
  <Line number="6789"></Line>
  <Line number="6790">#define ZIPFILE_F_COLUMN_IDX 7    /* Index of column &quot;file&quot; in the above */</Line>
  <Line number="6791">#define ZIPFILE_BUFFER_SIZE (64*1024)</Line>
  <Line number="6792"></Line>
  <Line number="6793"></Line>
  <Line number="6794">/*</Line>
  <Line number="6795">** Magic numbers used to read and write zip files.</Line>
  <Line number="6796">**</Line>
  <Line number="6797">** ZIPFILE_NEWENTRY_MADEBY:</Line>
  <Line number="6798">**   Use this value for the &quot;version-made-by&quot; field in new zip file</Line>
  <Line number="6799">**   entries. The upper byte indicates &quot;unix&quot;, and the lower byte </Line>
  <Line number="6800">**   indicates that the zip file matches pkzip specification 3.0. </Line>
  <Line number="6801">**   This is what info-zip seems to do.</Line>
  <Line number="6802">**</Line>
  <Line number="6803">** ZIPFILE_NEWENTRY_REQUIRED:</Line>
  <Line number="6804">**   Value for &quot;version-required-to-extract&quot; field of new entries.</Line>
  <Line number="6805">**   Version 2.0 is required to support folders and deflate compression.</Line>
  <Line number="6806">**</Line>
  <Line number="6807">** ZIPFILE_NEWENTRY_FLAGS:</Line>
  <Line number="6808">**   Value for &quot;general-purpose-bit-flags&quot; field of new entries. Bit</Line>
  <Line number="6809">**   11 means &quot;utf-8 filename and comment&quot;.</Line>
  <Line number="6810">**</Line>
  <Line number="6811">** ZIPFILE_SIGNATURE_CDS:</Line>
  <Line number="6812">**   First 4 bytes of a valid CDS record.</Line>
  <Line number="6813">**</Line>
  <Line number="6814">** ZIPFILE_SIGNATURE_LFH:</Line>
  <Line number="6815">**   First 4 bytes of a valid LFH record.</Line>
  <Line number="6816">**</Line>
  <Line number="6817">** ZIPFILE_SIGNATURE_EOCD</Line>
  <Line number="6818">**   First 4 bytes of a valid EOCD record.</Line>
  <Line number="6819">*/</Line>
  <Line number="6820">#define ZIPFILE_EXTRA_TIMESTAMP   0x5455</Line>
  <Line number="6821">#define ZIPFILE_NEWENTRY_MADEBY   ((3&lt;&lt;8) + 30)</Line>
  <Line number="6822">#define ZIPFILE_NEWENTRY_REQUIRED 20</Line>
  <Line number="6823">#define ZIPFILE_NEWENTRY_FLAGS    0x800</Line>
  <Line number="6824">#define ZIPFILE_SIGNATURE_CDS     0x02014b50</Line>
  <Line number="6825">#define ZIPFILE_SIGNATURE_LFH     0x04034b50</Line>
  <Line number="6826">#define ZIPFILE_SIGNATURE_EOCD    0x06054b50</Line>
  <Line number="6827"></Line>
  <Line number="6828">/*</Line>
  <Line number="6829">** The sizes of the fixed-size part of each of the three main data </Line>
  <Line number="6830">** structures in a zip archive.</Line>
  <Line number="6831">*/</Line>
  <Line number="6832">#define ZIPFILE_LFH_FIXED_SZ      30</Line>
  <Line number="6833">#define ZIPFILE_EOCD_FIXED_SZ     22</Line>
  <Line number="6834">#define ZIPFILE_CDS_FIXED_SZ      46</Line>
  <Line number="6835"></Line>
  <Line number="6836">/*</Line>
  <Line number="6837">*** 4.3.16  End of central directory record:</Line>
  <Line number="6838">***</Line>
  <Line number="6839">***   end of central dir signature    4 bytes  (0x06054b50)</Line>
  <Line number="6840">***   number of this disk             2 bytes</Line>
  <Line number="6841">***   number of the disk with the</Line>
  <Line number="6842">***   start of the central directory  2 bytes</Line>
  <Line number="6843">***   total number of entries in the</Line>
  <Line number="6844">***   central directory on this disk  2 bytes</Line>
  <Line number="6845">***   total number of entries in</Line>
  <Line number="6846">***   the central directory           2 bytes</Line>
  <Line number="6847">***   size of the central directory   4 bytes</Line>
  <Line number="6848">***   offset of start of central</Line>
  <Line number="6849">***   directory with respect to</Line>
  <Line number="6850">***   the starting disk number        4 bytes</Line>
  <Line number="6851">***   .ZIP file comment length        2 bytes</Line>
  <Line number="6852">***   .ZIP file comment       (variable size)</Line>
  <Line number="6853">*/</Line>
  <Line number="6854">typedef struct ZipfileEOCD ZipfileEOCD;</Line>
  <Line number="6855">struct ZipfileEOCD {</Line>
  <Line number="6856">  u16 iDisk;</Line>
  <Line number="6857">  u16 iFirstDisk;</Line>
  <Line number="6858">  u16 nEntry;</Line>
  <Line number="6859">  u16 nEntryTotal;</Line>
  <Line number="6860">  u32 nSize;</Line>
  <Line number="6861">  u32 iOffset;</Line>
  <Line number="6862">};</Line>
  <Line number="6863"></Line>
  <Line number="6864">/*</Line>
  <Line number="6865">*** 4.3.12  Central directory structure:</Line>
  <Line number="6866">***</Line>
  <Line number="6867">*** ...</Line>
  <Line number="6868">***</Line>
  <Line number="6869">***   central file header signature   4 bytes  (0x02014b50)</Line>
  <Line number="6870">***   version made by                 2 bytes</Line>
  <Line number="6871">***   version needed to extract       2 bytes</Line>
  <Line number="6872">***   general purpose bit flag        2 bytes</Line>
  <Line number="6873">***   compression method              2 bytes</Line>
  <Line number="6874">***   last mod file time              2 bytes</Line>
  <Line number="6875">***   last mod file date              2 bytes</Line>
  <Line number="6876">***   crc-32                          4 bytes</Line>
  <Line number="6877">***   compressed size                 4 bytes</Line>
  <Line number="6878">***   uncompressed size               4 bytes</Line>
  <Line number="6879">***   file name length                2 bytes</Line>
  <Line number="6880">***   extra field length              2 bytes</Line>
  <Line number="6881">***   file comment length             2 bytes</Line>
  <Line number="6882">***   disk number start               2 bytes</Line>
  <Line number="6883">***   internal file attributes        2 bytes</Line>
  <Line number="6884">***   external file attributes        4 bytes</Line>
  <Line number="6885">***   relative offset of local header 4 bytes</Line>
  <Line number="6886">*/</Line>
  <Line number="6887">typedef struct ZipfileCDS ZipfileCDS;</Line>
  <Line number="6888">struct ZipfileCDS {</Line>
  <Line number="6889">  u16 iVersionMadeBy;</Line>
  <Line number="6890">  u16 iVersionExtract;</Line>
  <Line number="6891">  u16 flags;</Line>
  <Line number="6892">  u16 iCompression;</Line>
  <Line number="6893">  u16 mTime;</Line>
  <Line number="6894">  u16 mDate;</Line>
  <Line number="6895">  u32 crc32;</Line>
  <Line number="6896">  u32 szCompressed;</Line>
  <Line number="6897">  u32 szUncompressed;</Line>
  <Line number="6898">  u16 nFile;</Line>
  <Line number="6899">  u16 nExtra;</Line>
  <Line number="6900">  u16 nComment;</Line>
  <Line number="6901">  u16 iDiskStart;</Line>
  <Line number="6902">  u16 iInternalAttr;</Line>
  <Line number="6903">  u32 iExternalAttr;</Line>
  <Line number="6904">  u32 iOffset;</Line>
  <Line number="6905">  char *zFile;                    /* Filename (sqlite3_malloc()) */</Line>
  <Line number="6906">};</Line>
  <Line number="6907"></Line>
  <Line number="6908">/*</Line>
  <Line number="6909">*** 4.3.7  Local file header:</Line>
  <Line number="6910">***</Line>
  <Line number="6911">***   local file header signature     4 bytes  (0x04034b50)</Line>
  <Line number="6912">***   version needed to extract       2 bytes</Line>
  <Line number="6913">***   general purpose bit flag        2 bytes</Line>
  <Line number="6914">***   compression method              2 bytes</Line>
  <Line number="6915">***   last mod file time              2 bytes</Line>
  <Line number="6916">***   last mod file date              2 bytes</Line>
  <Line number="6917">***   crc-32                          4 bytes</Line>
  <Line number="6918">***   compressed size                 4 bytes</Line>
  <Line number="6919">***   uncompressed size               4 bytes</Line>
  <Line number="6920">***   file name length                2 bytes</Line>
  <Line number="6921">***   extra field length              2 bytes</Line>
  <Line number="6922">***   </Line>
  <Line number="6923">*/</Line>
  <Line number="6924">typedef struct ZipfileLFH ZipfileLFH;</Line>
  <Line number="6925">struct ZipfileLFH {</Line>
  <Line number="6926">  u16 iVersionExtract;</Line>
  <Line number="6927">  u16 flags;</Line>
  <Line number="6928">  u16 iCompression;</Line>
  <Line number="6929">  u16 mTime;</Line>
  <Line number="6930">  u16 mDate;</Line>
  <Line number="6931">  u32 crc32;</Line>
  <Line number="6932">  u32 szCompressed;</Line>
  <Line number="6933">  u32 szUncompressed;</Line>
  <Line number="6934">  u16 nFile;</Line>
  <Line number="6935">  u16 nExtra;</Line>
  <Line number="6936">};</Line>
  <Line number="6937"></Line>
  <Line number="6938">typedef struct ZipfileEntry ZipfileEntry;</Line>
  <Line number="6939">struct ZipfileEntry {</Line>
  <Line number="6940">  ZipfileCDS cds;            /* Parsed CDS record */</Line>
  <Line number="6941">  u32 mUnixTime;             /* Modification time, in UNIX format */</Line>
  <Line number="6942">  u8 *aExtra;                /* cds.nExtra+cds.nComment bytes of extra data */</Line>
  <Line number="6943">  i64 iDataOff;              /* Offset to data in file (if aData==0) */</Line>
  <Line number="6944">  u8 *aData;                 /* cds.szCompressed bytes of compressed data */</Line>
  <Line number="6945">  ZipfileEntry *pNext;       /* Next element in in-memory CDS */</Line>
  <Line number="6946">};</Line>
  <Line number="6947"></Line>
  <Line number="6948">/* </Line>
  <Line number="6949">** Cursor type for zipfile tables.</Line>
  <Line number="6950">*/</Line>
  <Line number="6951">typedef struct ZipfileCsr ZipfileCsr;</Line>
  <Line number="6952">struct ZipfileCsr {</Line>
  <Line number="6953">  sqlite3_vtab_cursor base;  /* Base class - must be first */</Line>
  <Line number="6954">  i64 iId;                   /* Cursor ID */</Line>
  <Line number="6955">  u8 bEof;                   /* True when at EOF */</Line>
  <Line number="6956">  u8 bNoop;                  /* If next xNext() call is no-op */</Line>
  <Line number="6957"></Line>
  <Line number="6958">  /* Used outside of write transactions */</Line>
  <Line number="6959">  FILE *pFile;               /* Zip file */</Line>
  <Line number="6960">  i64 iNextOff;              /* Offset of next record in central directory */</Line>
  <Line number="6961">  ZipfileEOCD eocd;          /* Parse of central directory record */</Line>
  <Line number="6962"></Line>
  <Line number="6963">  ZipfileEntry *pFreeEntry;  /* Free this list when cursor is closed or reset */</Line>
  <Line number="6964">  ZipfileEntry *pCurrent;    /* Current entry */</Line>
  <Line number="6965">  ZipfileCsr *pCsrNext;      /* Next cursor on same virtual table */</Line>
  <Line number="6966">};</Line>
  <Line number="6967"></Line>
  <Line number="6968">typedef struct ZipfileTab ZipfileTab;</Line>
  <Line number="6969">struct ZipfileTab {</Line>
  <Line number="6970">  sqlite3_vtab base;         /* Base class - must be first */</Line>
  <Line number="6971">  char *zFile;               /* Zip file this table accesses (may be NULL) */</Line>
  <Line number="6972">  sqlite3 *db;               /* Host database connection */</Line>
  <Line number="6973">  u8 *aBuffer;               /* Temporary buffer used for various tasks */</Line>
  <Line number="6974"></Line>
  <Line number="6975">  ZipfileCsr *pCsrList;      /* List of cursors */</Line>
  <Line number="6976">  i64 iNextCsrid;</Line>
  <Line number="6977"></Line>
  <Line number="6978">  /* The following are used by write transactions only */</Line>
  <Line number="6979">  ZipfileEntry *pFirstEntry; /* Linked list of all files (if pWriteFd!=0) */</Line>
  <Line number="6980">  ZipfileEntry *pLastEntry;  /* Last element in pFirstEntry list */</Line>
  <Line number="6981">  FILE *pWriteFd;            /* File handle open on zip archive */</Line>
  <Line number="6982">  i64 szCurrent;             /* Current size of zip archive */</Line>
  <Line number="6983">  i64 szOrig;                /* Size of archive at start of transaction */</Line>
  <Line number="6984">};</Line>
  <Line number="6985"></Line>
  <Line number="6986">/*</Line>
  <Line number="6987">** Set the error message contained in context ctx to the results of</Line>
  <Line number="6988">** vprintf(zFmt, ...).</Line>
  <Line number="6989">*/</Line>
  <Line number="6990">static void zipfileCtxErrorMsg(sqlite3_context *ctx, const char *zFmt, ...){</Line>
  <Line number="6991">  char *zMsg = 0;</Line>
  <Line number="6992">  va_list ap;</Line>
  <Line number="6993">  va_start(ap, zFmt);</Line>
  <Line number="6994">  zMsg = sqlite3_vmprintf(zFmt, ap);</Line>
  <Line number="6995">  sqlite3_result_error(ctx, zMsg, -1);</Line>
  <Line number="6996">  sqlite3_free(zMsg);</Line>
  <Line number="6997">  va_end(ap);</Line>
  <Line number="6998">}</Line>
  <Line number="6999"></Line>
  <Line number="7000">/*</Line>
  <Line number="7001">** If string zIn is quoted, dequote it in place. Otherwise, if the string</Line>
  <Line number="7002">** is not quoted, do nothing.</Line>
  <Line number="7003">*/</Line>
  <Line number="7004">static void zipfileDequote(char *zIn){</Line>
  <Line number="7005">  char q = zIn[0];</Line>
  <Line number="7006">  if( q==&apos;&quot;&apos; || q==&apos;\&apos;&apos; || q==&apos;`&apos; || q==&apos;[&apos; ){</Line>
  <Line number="7007">    int iIn = 1;</Line>
  <Line number="7008">    int iOut = 0;</Line>
  <Line number="7009">    if( q==&apos;[&apos; ) q = &apos;]&apos;;</Line>
  <Line number="7010">    while( ALWAYS(zIn[iIn]) ){</Line>
  <Line number="7011">      char c = zIn[iIn++];</Line>
  <Line number="7012">      if( c==q &amp;&amp; zIn[iIn++]!=q ) break;</Line>
  <Line number="7013">      zIn[iOut++] = c;</Line>
  <Line number="7014">    }</Line>
  <Line number="7015">    zIn[iOut] = &apos;\0&apos;;</Line>
  <Line number="7016">  }</Line>
  <Line number="7017">}</Line>
  <Line number="7018"></Line>
  <Line number="7019">/*</Line>
  <Line number="7020">** Construct a new ZipfileTab virtual table object.</Line>
  <Line number="7021">** </Line>
  <Line number="7022">**   argv[0]   -&gt; module name  (&quot;zipfile&quot;)</Line>
  <Line number="7023">**   argv[1]   -&gt; database name</Line>
  <Line number="7024">**   argv[2]   -&gt; table name</Line>
  <Line number="7025">**   argv[...] -&gt; &quot;column name&quot; and other module argument fields.</Line>
  <Line number="7026">*/</Line>
  <Line number="7027">static int zipfileConnect(</Line>
  <Line number="7028">  sqlite3 *db,</Line>
  <Line number="7029">  void *pAux,</Line>
  <Line number="7030">  int argc, const char *const*argv,</Line>
  <Line number="7031">  sqlite3_vtab **ppVtab,</Line>
  <Line number="7032">  char **pzErr</Line>
  <Line number="7033">){</Line>
  <Line number="7034">  int nByte = sizeof(ZipfileTab) + ZIPFILE_BUFFER_SIZE;</Line>
  <Line number="7035">  int nFile = 0;</Line>
  <Line number="7036">  const char *zFile = 0;</Line>
  <Line number="7037">  ZipfileTab *pNew = 0;</Line>
  <Line number="7038">  int rc;</Line>
  <Line number="7039"></Line>
  <Line number="7040">  /* If the table name is not &quot;zipfile&quot;, require that the argument be</Line>
  <Line number="7041">  ** specified. This stops zipfile tables from being created as:</Line>
  <Line number="7042">  **</Line>
  <Line number="7043">  **   CREATE VIRTUAL TABLE zzz USING zipfile();</Line>
  <Line number="7044">  **</Line>
  <Line number="7045">  ** It does not prevent:</Line>
  <Line number="7046">  **</Line>
  <Line number="7047">  **   CREATE VIRTUAL TABLE zipfile USING zipfile();</Line>
  <Line number="7048">  */</Line>
  <Line number="7049">  assert( 0==sqlite3_stricmp(argv[0], &quot;zipfile&quot;) );</Line>
  <Line number="7050">  if( (0!=sqlite3_stricmp(argv[2], &quot;zipfile&quot;) &amp;&amp; argc&lt;4) || argc&gt;4 ){</Line>
  <Line number="7051">    *pzErr = sqlite3_mprintf(&quot;zipfile constructor requires one argument&quot;);</Line>
  <Line number="7052">    return SQLITE_ERROR;</Line>
  <Line number="7053">  }</Line>
  <Line number="7054"></Line>
  <Line number="7055">  if( argc&gt;3 ){</Line>
  <Line number="7056">    zFile = argv[3];</Line>
  <Line number="7057">    nFile = (int)strlen(zFile)+1;</Line>
  <Line number="7058">  }</Line>
  <Line number="7059"></Line>
  <Line number="7060">  rc = sqlite3_declare_vtab(db, ZIPFILE_SCHEMA);</Line>
  <Line number="7061">  if( rc==SQLITE_OK ){</Line>
  <Line number="7062">    pNew = (ZipfileTab*)sqlite3_malloc64((sqlite3_int64)nByte+nFile);</Line>
  <Line number="7063">    if( pNew==0 ) return SQLITE_NOMEM;</Line>
  <Line number="7064">    memset(pNew, 0, nByte+nFile);</Line>
  <Line number="7065">    pNew-&gt;db = db;</Line>
  <Line number="7066">    pNew-&gt;aBuffer = (u8*)&amp;pNew[1];</Line>
  <Line number="7067">    if( zFile ){</Line>
  <Line number="7068">      pNew-&gt;zFile = (char*)&amp;pNew-&gt;aBuffer[ZIPFILE_BUFFER_SIZE];</Line>
  <Line number="7069">      memcpy(pNew-&gt;zFile, zFile, nFile);</Line>
  <Line number="7070">      zipfileDequote(pNew-&gt;zFile);</Line>
  <Line number="7071">    }</Line>
  <Line number="7072">  }</Line>
  <Line number="7073">  sqlite3_vtab_config(db, SQLITE_VTAB_DIRECTONLY);</Line>
  <Line number="7074">  *ppVtab = (sqlite3_vtab*)pNew;</Line>
  <Line number="7075">  return rc;</Line>
  <Line number="7076">}</Line>
  <Line number="7077"></Line>
  <Line number="7078">/*</Line>
  <Line number="7079">** Free the ZipfileEntry structure indicated by the only argument.</Line>
  <Line number="7080">*/</Line>
  <Line number="7081">static void zipfileEntryFree(ZipfileEntry *p){</Line>
  <Line number="7082">  if( p ){</Line>
  <Line number="7083">    sqlite3_free(p-&gt;cds.zFile);</Line>
  <Line number="7084">    sqlite3_free(p);</Line>
  <Line number="7085">  }</Line>
  <Line number="7086">}</Line>
  <Line number="7087"></Line>
  <Line number="7088">/*</Line>
  <Line number="7089">** Release resources that should be freed at the end of a write </Line>
  <Line number="7090">** transaction.</Line>
  <Line number="7091">*/</Line>
  <Line number="7092">static void zipfileCleanupTransaction(ZipfileTab *pTab){</Line>
  <Line number="7093">  ZipfileEntry *pEntry;</Line>
  <Line number="7094">  ZipfileEntry *pNext;</Line>
  <Line number="7095"></Line>
  <Line number="7096">  if( pTab-&gt;pWriteFd ){</Line>
  <Line number="7097">    fclose(pTab-&gt;pWriteFd);</Line>
  <Line number="7098">    pTab-&gt;pWriteFd = 0;</Line>
  <Line number="7099">  }</Line>
  <Line number="7100">  for(pEntry=pTab-&gt;pFirstEntry; pEntry; pEntry=pNext){</Line>
  <Line number="7101">    pNext = pEntry-&gt;pNext;</Line>
  <Line number="7102">    zipfileEntryFree(pEntry);</Line>
  <Line number="7103">  }</Line>
  <Line number="7104">  pTab-&gt;pFirstEntry = 0;</Line>
  <Line number="7105">  pTab-&gt;pLastEntry = 0;</Line>
  <Line number="7106">  pTab-&gt;szCurrent = 0;</Line>
  <Line number="7107">  pTab-&gt;szOrig = 0;</Line>
  <Line number="7108">}</Line>
  <Line number="7109"></Line>
  <Line number="7110">/*</Line>
  <Line number="7111">** This method is the destructor for zipfile vtab objects.</Line>
  <Line number="7112">*/</Line>
  <Line number="7113">static int zipfileDisconnect(sqlite3_vtab *pVtab){</Line>
  <Line number="7114">  zipfileCleanupTransaction((ZipfileTab*)pVtab);</Line>
  <Line number="7115">  sqlite3_free(pVtab);</Line>
  <Line number="7116">  return SQLITE_OK;</Line>
  <Line number="7117">}</Line>
  <Line number="7118"></Line>
  <Line number="7119">/*</Line>
  <Line number="7120">** Constructor for a new ZipfileCsr object.</Line>
  <Line number="7121">*/</Line>
  <Line number="7122">static int zipfileOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCsr){</Line>
  <Line number="7123">  ZipfileTab *pTab = (ZipfileTab*)p;</Line>
  <Line number="7124">  ZipfileCsr *pCsr;</Line>
  <Line number="7125">  pCsr = sqlite3_malloc(sizeof(*pCsr));</Line>
  <Line number="7126">  *ppCsr = (sqlite3_vtab_cursor*)pCsr;</Line>
  <Line number="7127">  if( pCsr==0 ){</Line>
  <Line number="7128">    return SQLITE_NOMEM;</Line>
  <Line number="7129">  }</Line>
  <Line number="7130">  memset(pCsr, 0, sizeof(*pCsr));</Line>
  <Line number="7131">  pCsr-&gt;iId = ++pTab-&gt;iNextCsrid;</Line>
  <Line number="7132">  pCsr-&gt;pCsrNext = pTab-&gt;pCsrList;</Line>
  <Line number="7133">  pTab-&gt;pCsrList = pCsr;</Line>
  <Line number="7134">  return SQLITE_OK;</Line>
  <Line number="7135">}</Line>
  <Line number="7136"></Line>
  <Line number="7137">/*</Line>
  <Line number="7138">** Reset a cursor back to the state it was in when first returned</Line>
  <Line number="7139">** by zipfileOpen().</Line>
  <Line number="7140">*/</Line>
  <Line number="7141">static void zipfileResetCursor(ZipfileCsr *pCsr){</Line>
  <Line number="7142">  ZipfileEntry *p;</Line>
  <Line number="7143">  ZipfileEntry *pNext;</Line>
  <Line number="7144"></Line>
  <Line number="7145">  pCsr-&gt;bEof = 0;</Line>
  <Line number="7146">  if( pCsr-&gt;pFile ){</Line>
  <Line number="7147">    fclose(pCsr-&gt;pFile);</Line>
  <Line number="7148">    pCsr-&gt;pFile = 0;</Line>
  <Line number="7149">    zipfileEntryFree(pCsr-&gt;pCurrent);</Line>
  <Line number="7150">    pCsr-&gt;pCurrent = 0;</Line>
  <Line number="7151">  }</Line>
  <Line number="7152"></Line>
  <Line number="7153">  for(p=pCsr-&gt;pFreeEntry; p; p=pNext){</Line>
  <Line number="7154">    pNext = p-&gt;pNext;</Line>
  <Line number="7155">    zipfileEntryFree(p);</Line>
  <Line number="7156">  }</Line>
  <Line number="7157">}</Line>
  <Line number="7158"></Line>
  <Line number="7159">/*</Line>
  <Line number="7160">** Destructor for an ZipfileCsr.</Line>
  <Line number="7161">*/</Line>
  <Line number="7162">static int zipfileClose(sqlite3_vtab_cursor *cur){</Line>
  <Line number="7163">  ZipfileCsr *pCsr = (ZipfileCsr*)cur;</Line>
  <Line number="7164">  ZipfileTab *pTab = (ZipfileTab*)(pCsr-&gt;base.pVtab);</Line>
  <Line number="7165">  ZipfileCsr **pp;</Line>
  <Line number="7166">  zipfileResetCursor(pCsr);</Line>
  <Line number="7167"></Line>
  <Line number="7168">  /* Remove this cursor from the ZipfileTab.pCsrList list. */</Line>
  <Line number="7169">  for(pp=&amp;pTab-&gt;pCsrList; *pp!=pCsr; pp=&amp;((*pp)-&gt;pCsrNext));</Line>
  <Line number="7170">  *pp = pCsr-&gt;pCsrNext;</Line>
  <Line number="7171"></Line>
  <Line number="7172">  sqlite3_free(pCsr);</Line>
  <Line number="7173">  return SQLITE_OK;</Line>
  <Line number="7174">}</Line>
  <Line number="7175"></Line>
  <Line number="7176">/*</Line>
  <Line number="7177">** Set the error message for the virtual table associated with cursor</Line>
  <Line number="7178">** pCsr to the results of vprintf(zFmt, ...).</Line>
  <Line number="7179">*/</Line>
  <Line number="7180">static void zipfileTableErr(ZipfileTab *pTab, const char *zFmt, ...){</Line>
  <Line number="7181">  va_list ap;</Line>
  <Line number="7182">  va_start(ap, zFmt);</Line>
  <Line number="7183">  sqlite3_free(pTab-&gt;base.zErrMsg);</Line>
  <Line number="7184">  pTab-&gt;base.zErrMsg = sqlite3_vmprintf(zFmt, ap);</Line>
  <Line number="7185">  va_end(ap);</Line>
  <Line number="7186">}</Line>
  <Line number="7187">static void zipfileCursorErr(ZipfileCsr *pCsr, const char *zFmt, ...){</Line>
  <Line number="7188">  va_list ap;</Line>
  <Line number="7189">  va_start(ap, zFmt);</Line>
  <Line number="7190">  sqlite3_free(pCsr-&gt;base.pVtab-&gt;zErrMsg);</Line>
  <Line number="7191">  pCsr-&gt;base.pVtab-&gt;zErrMsg = sqlite3_vmprintf(zFmt, ap);</Line>
  <Line number="7192">  va_end(ap);</Line>
  <Line number="7193">}</Line>
  <Line number="7194"></Line>
  <Line number="7195">/*</Line>
  <Line number="7196">** Read nRead bytes of data from offset iOff of file pFile into buffer</Line>
  <Line number="7197">** aRead[]. Return SQLITE_OK if successful, or an SQLite error code</Line>
  <Line number="7198">** otherwise. </Line>
  <Line number="7199">**</Line>
  <Line number="7200">** If an error does occur, output variable (*pzErrmsg) may be set to point</Line>
  <Line number="7201">** to an English language error message. It is the responsibility of the</Line>
  <Line number="7202">** caller to eventually free this buffer using</Line>
  <Line number="7203">** sqlite3_free().</Line>
  <Line number="7204">*/</Line>
  <Line number="7205">static int zipfileReadData(</Line>
  <Line number="7206">  FILE *pFile,                    /* Read from this file */</Line>
  <Line number="7207">  u8 *aRead,                      /* Read into this buffer */</Line>
  <Line number="7208">  int nRead,                      /* Number of bytes to read */</Line>
  <Line number="7209">  i64 iOff,                       /* Offset to read from */</Line>
  <Line number="7210">  char **pzErrmsg                 /* OUT: Error message (from sqlite3_malloc) */</Line>
  <Line number="7211">){</Line>
  <Line number="7212">  size_t n;</Line>
  <Line number="7213">  fseek(pFile, (long)iOff, SEEK_SET);</Line>
  <Line number="7214">  n = fread(aRead, 1, nRead, pFile);</Line>
  <Line number="7215">  if( (int)n!=nRead ){</Line>
  <Line number="7216">    *pzErrmsg = sqlite3_mprintf(&quot;error in fread()&quot;);</Line>
  <Line number="7217">    return SQLITE_ERROR;</Line>
  <Line number="7218">  }</Line>
  <Line number="7219">  return SQLITE_OK;</Line>
  <Line number="7220">}</Line>
  <Line number="7221"></Line>
  <Line number="7222">static int zipfileAppendData(</Line>
  <Line number="7223">  ZipfileTab *pTab,</Line>
  <Line number="7224">  const u8 *aWrite,</Line>
  <Line number="7225">  int nWrite</Line>
  <Line number="7226">){</Line>
  <Line number="7227">  if( nWrite&gt;0 ){</Line>
  <Line number="7228">    size_t n = nWrite;</Line>
  <Line number="7229">    fseek(pTab-&gt;pWriteFd, (long)pTab-&gt;szCurrent, SEEK_SET);</Line>
  <Line number="7230">    n = fwrite(aWrite, 1, nWrite, pTab-&gt;pWriteFd);</Line>
  <Line number="7231">    if( (int)n!=nWrite ){</Line>
  <Line number="7232">      pTab-&gt;base.zErrMsg = sqlite3_mprintf(&quot;error in fwrite()&quot;);</Line>
  <Line number="7233">      return SQLITE_ERROR;</Line>
  <Line number="7234">    }</Line>
  <Line number="7235">    pTab-&gt;szCurrent += nWrite;</Line>
  <Line number="7236">  }</Line>
  <Line number="7237">  return SQLITE_OK;</Line>
  <Line number="7238">}</Line>
  <Line number="7239"></Line>
  <Line number="7240">/*</Line>
  <Line number="7241">** Read and return a 16-bit little-endian unsigned integer from buffer aBuf.</Line>
  <Line number="7242">*/</Line>
  <Line number="7243">static u16 zipfileGetU16(const u8 *aBuf){</Line>
  <Line number="7244">  return (aBuf[1] &lt;&lt; 8) + aBuf[0];</Line>
  <Line number="7245">}</Line>
  <Line number="7246"></Line>
  <Line number="7247">/*</Line>
  <Line number="7248">** Read and return a 32-bit little-endian unsigned integer from buffer aBuf.</Line>
  <Line number="7249">*/</Line>
  <Line number="7250">static u32 zipfileGetU32(const u8 *aBuf){</Line>
  <Line number="7251">  return ((u32)(aBuf[3]) &lt;&lt; 24)</Line>
  <Line number="7252">       + ((u32)(aBuf[2]) &lt;&lt; 16)</Line>
  <Line number="7253">       + ((u32)(aBuf[1]) &lt;&lt;  8)</Line>
  <Line number="7254">       + ((u32)(aBuf[0]) &lt;&lt;  0);</Line>
  <Line number="7255">}</Line>
  <Line number="7256"></Line>
  <Line number="7257">/*</Line>
  <Line number="7258">** Write a 16-bit little endiate integer into buffer aBuf.</Line>
  <Line number="7259">*/</Line>
  <Line number="7260">static void zipfilePutU16(u8 *aBuf, u16 val){</Line>
  <Line number="7261">  aBuf[0] = val &amp; 0xFF;</Line>
  <Line number="7262">  aBuf[1] = (val&gt;&gt;8) &amp; 0xFF;</Line>
  <Line number="7263">}</Line>
  <Line number="7264"></Line>
  <Line number="7265">/*</Line>
  <Line number="7266">** Write a 32-bit little endiate integer into buffer aBuf.</Line>
  <Line number="7267">*/</Line>
  <Line number="7268">static void zipfilePutU32(u8 *aBuf, u32 val){</Line>
  <Line number="7269">  aBuf[0] = val &amp; 0xFF;</Line>
  <Line number="7270">  aBuf[1] = (val&gt;&gt;8) &amp; 0xFF;</Line>
  <Line number="7271">  aBuf[2] = (val&gt;&gt;16) &amp; 0xFF;</Line>
  <Line number="7272">  aBuf[3] = (val&gt;&gt;24) &amp; 0xFF;</Line>
  <Line number="7273">}</Line>
  <Line number="7274"></Line>
  <Line number="7275">#define zipfileRead32(aBuf) ( aBuf+=4, zipfileGetU32(aBuf-4) )</Line>
  <Line number="7276">#define zipfileRead16(aBuf) ( aBuf+=2, zipfileGetU16(aBuf-2) )</Line>
  <Line number="7277"></Line>
  <Line number="7278">#define zipfileWrite32(aBuf,val) { zipfilePutU32(aBuf,val); aBuf+=4; }</Line>
  <Line number="7279">#define zipfileWrite16(aBuf,val) { zipfilePutU16(aBuf,val); aBuf+=2; }</Line>
  <Line number="7280"></Line>
  <Line number="7281">/*</Line>
  <Line number="7282">** Magic numbers used to read CDS records.</Line>
  <Line number="7283">*/</Line>
  <Line number="7284">#define ZIPFILE_CDS_NFILE_OFF        28</Line>
  <Line number="7285">#define ZIPFILE_CDS_SZCOMPRESSED_OFF 20</Line>
  <Line number="7286"></Line>
  <Line number="7287">/*</Line>
  <Line number="7288">** Decode the CDS record in buffer aBuf into (*pCDS). Return SQLITE_ERROR</Line>
  <Line number="7289">** if the record is not well-formed, or SQLITE_OK otherwise.</Line>
  <Line number="7290">*/</Line>
  <Line number="7291">static int zipfileReadCDS(u8 *aBuf, ZipfileCDS *pCDS){</Line>
  <Line number="7292">  u8 *aRead = aBuf;</Line>
  <Line number="7293">  u32 sig = zipfileRead32(aRead);</Line>
  <Line number="7294">  int rc = SQLITE_OK;</Line>
  <Line number="7295">  if( sig!=ZIPFILE_SIGNATURE_CDS ){</Line>
  <Line number="7296">    rc = SQLITE_ERROR;</Line>
  <Line number="7297">  }else{</Line>
  <Line number="7298">    pCDS-&gt;iVersionMadeBy = zipfileRead16(aRead);</Line>
  <Line number="7299">    pCDS-&gt;iVersionExtract = zipfileRead16(aRead);</Line>
  <Line number="7300">    pCDS-&gt;flags = zipfileRead16(aRead);</Line>
  <Line number="7301">    pCDS-&gt;iCompression = zipfileRead16(aRead);</Line>
  <Line number="7302">    pCDS-&gt;mTime = zipfileRead16(aRead);</Line>
  <Line number="7303">    pCDS-&gt;mDate = zipfileRead16(aRead);</Line>
  <Line number="7304">    pCDS-&gt;crc32 = zipfileRead32(aRead);</Line>
  <Line number="7305">    pCDS-&gt;szCompressed = zipfileRead32(aRead);</Line>
  <Line number="7306">    pCDS-&gt;szUncompressed = zipfileRead32(aRead);</Line>
  <Line number="7307">    assert( aRead==&amp;aBuf[ZIPFILE_CDS_NFILE_OFF] );</Line>
  <Line number="7308">    pCDS-&gt;nFile = zipfileRead16(aRead);</Line>
  <Line number="7309">    pCDS-&gt;nExtra = zipfileRead16(aRead);</Line>
  <Line number="7310">    pCDS-&gt;nComment = zipfileRead16(aRead);</Line>
  <Line number="7311">    pCDS-&gt;iDiskStart = zipfileRead16(aRead);</Line>
  <Line number="7312">    pCDS-&gt;iInternalAttr = zipfileRead16(aRead);</Line>
  <Line number="7313">    pCDS-&gt;iExternalAttr = zipfileRead32(aRead);</Line>
  <Line number="7314">    pCDS-&gt;iOffset = zipfileRead32(aRead);</Line>
  <Line number="7315">    assert( aRead==&amp;aBuf[ZIPFILE_CDS_FIXED_SZ] );</Line>
  <Line number="7316">  }</Line>
  <Line number="7317"></Line>
  <Line number="7318">  return rc;</Line>
  <Line number="7319">}</Line>
  <Line number="7320"></Line>
  <Line number="7321">/*</Line>
  <Line number="7322">** Decode the LFH record in buffer aBuf into (*pLFH). Return SQLITE_ERROR</Line>
  <Line number="7323">** if the record is not well-formed, or SQLITE_OK otherwise.</Line>
  <Line number="7324">*/</Line>
  <Line number="7325">static int zipfileReadLFH(</Line>
  <Line number="7326">  u8 *aBuffer,</Line>
  <Line number="7327">  ZipfileLFH *pLFH</Line>
  <Line number="7328">){</Line>
  <Line number="7329">  u8 *aRead = aBuffer;</Line>
  <Line number="7330">  int rc = SQLITE_OK;</Line>
  <Line number="7331"></Line>
  <Line number="7332">  u32 sig = zipfileRead32(aRead);</Line>
  <Line number="7333">  if( sig!=ZIPFILE_SIGNATURE_LFH ){</Line>
  <Line number="7334">    rc = SQLITE_ERROR;</Line>
  <Line number="7335">  }else{</Line>
  <Line number="7336">    pLFH-&gt;iVersionExtract = zipfileRead16(aRead);</Line>
  <Line number="7337">    pLFH-&gt;flags = zipfileRead16(aRead);</Line>
  <Line number="7338">    pLFH-&gt;iCompression = zipfileRead16(aRead);</Line>
  <Line number="7339">    pLFH-&gt;mTime = zipfileRead16(aRead);</Line>
  <Line number="7340">    pLFH-&gt;mDate = zipfileRead16(aRead);</Line>
  <Line number="7341">    pLFH-&gt;crc32 = zipfileRead32(aRead);</Line>
  <Line number="7342">    pLFH-&gt;szCompressed = zipfileRead32(aRead);</Line>
  <Line number="7343">    pLFH-&gt;szUncompressed = zipfileRead32(aRead);</Line>
  <Line number="7344">    pLFH-&gt;nFile = zipfileRead16(aRead);</Line>
  <Line number="7345">    pLFH-&gt;nExtra = zipfileRead16(aRead);</Line>
  <Line number="7346">  }</Line>
  <Line number="7347">  return rc;</Line>
  <Line number="7348">}</Line>
  <Line number="7349"></Line>
  <Line number="7350"></Line>
  <Line number="7351">/*</Line>
  <Line number="7352">** Buffer aExtra (size nExtra bytes) contains zip archive &quot;extra&quot; fields.</Line>
  <Line number="7353">** Scan through this buffer to find an &quot;extra-timestamp&quot; field. If one</Line>
  <Line number="7354">** exists, extract the 32-bit modification-timestamp from it and store</Line>
  <Line number="7355">** the value in output parameter *pmTime.</Line>
  <Line number="7356">**</Line>
  <Line number="7357">** Zero is returned if no extra-timestamp record could be found (and so</Line>
  <Line number="7358">** *pmTime is left unchanged), or non-zero otherwise.</Line>
  <Line number="7359">**</Line>
  <Line number="7360">** The general format of an extra field is:</Line>
  <Line number="7361">**</Line>
  <Line number="7362">**   Header ID    2 bytes</Line>
  <Line number="7363">**   Data Size    2 bytes</Line>
  <Line number="7364">**   Data         N bytes</Line>
  <Line number="7365">*/</Line>
  <Line number="7366">static int zipfileScanExtra(u8 *aExtra, int nExtra, u32 *pmTime){</Line>
  <Line number="7367">  int ret = 0;</Line>
  <Line number="7368">  u8 *p = aExtra;</Line>
  <Line number="7369">  u8 *pEnd = &amp;aExtra[nExtra];</Line>
  <Line number="7370"></Line>
  <Line number="7371">  while( p&lt;pEnd ){</Line>
  <Line number="7372">    u16 id = zipfileRead16(p);</Line>
  <Line number="7373">    u16 nByte = zipfileRead16(p);</Line>
  <Line number="7374"></Line>
  <Line number="7375">    switch( id ){</Line>
  <Line number="7376">      case ZIPFILE_EXTRA_TIMESTAMP: {</Line>
  <Line number="7377">        u8 b = p[0];</Line>
  <Line number="7378">        if( b &amp; 0x01 ){     /* 0x01 -&gt; modtime is present */</Line>
  <Line number="7379">          *pmTime = zipfileGetU32(&amp;p[1]);</Line>
  <Line number="7380">          ret = 1;</Line>
  <Line number="7381">        }</Line>
  <Line number="7382">        break;</Line>
  <Line number="7383">      }</Line>
  <Line number="7384">    }</Line>
  <Line number="7385"></Line>
  <Line number="7386">    p += nByte;</Line>
  <Line number="7387">  }</Line>
  <Line number="7388">  return ret;</Line>
  <Line number="7389">}</Line>
  <Line number="7390"></Line>
  <Line number="7391">/*</Line>
  <Line number="7392">** Convert the standard MS-DOS timestamp stored in the mTime and mDate</Line>
  <Line number="7393">** fields of the CDS structure passed as the only argument to a 32-bit</Line>
  <Line number="7394">** UNIX seconds-since-the-epoch timestamp. Return the result.</Line>
  <Line number="7395">**</Line>
  <Line number="7396">** &quot;Standard&quot; MS-DOS time format:</Line>
  <Line number="7397">**</Line>
  <Line number="7398">**   File modification time:</Line>
  <Line number="7399">**     Bits 00-04: seconds divided by 2</Line>
  <Line number="7400">**     Bits 05-10: minute</Line>
  <Line number="7401">**     Bits 11-15: hour</Line>
  <Line number="7402">**   File modification date:</Line>
  <Line number="7403">**     Bits 00-04: day</Line>
  <Line number="7404">**     Bits 05-08: month (1-12)</Line>
  <Line number="7405">**     Bits 09-15: years from 1980 </Line>
  <Line number="7406">**</Line>
  <Line number="7407">** https://msdn.microsoft.com/en-us/library/9kkf9tah.aspx</Line>
  <Line number="7408">*/</Line>
  <Line number="7409">static u32 zipfileMtime(ZipfileCDS *pCDS){</Line>
  <Line number="7410">  int Y,M,D,X1,X2,A,B,sec,min,hr;</Line>
  <Line number="7411">  i64 JDsec;</Line>
  <Line number="7412">  Y = (1980 + ((pCDS-&gt;mDate &gt;&gt; 9) &amp; 0x7F));</Line>
  <Line number="7413">  M = ((pCDS-&gt;mDate &gt;&gt; 5) &amp; 0x0F);</Line>
  <Line number="7414">  D = (pCDS-&gt;mDate &amp; 0x1F);</Line>
  <Line number="7415">  sec = (pCDS-&gt;mTime &amp; 0x1F)*2;</Line>
  <Line number="7416">  min = (pCDS-&gt;mTime &gt;&gt; 5) &amp; 0x3F;</Line>
  <Line number="7417">  hr = (pCDS-&gt;mTime &gt;&gt; 11) &amp; 0x1F;</Line>
  <Line number="7418">  if( M&lt;=2 ){</Line>
  <Line number="7419">    Y--;</Line>
  <Line number="7420">    M += 12;</Line>
  <Line number="7421">  }</Line>
  <Line number="7422">  X1 = 36525*(Y+4716)/100;</Line>
  <Line number="7423">  X2 = 306001*(M+1)/10000;</Line>
  <Line number="7424">  A = Y/100;</Line>
  <Line number="7425">  B = 2 - A + (A/4);</Line>
  <Line number="7426">  JDsec = (i64)((X1 + X2 + D + B - 1524.5)*86400) + hr*3600 + min*60 + sec;</Line>
  <Line number="7427">  return (u32)(JDsec - (i64)24405875*(i64)8640);</Line>
  <Line number="7428">}</Line>
  <Line number="7429"></Line>
  <Line number="7430">/*</Line>
  <Line number="7431">** The opposite of zipfileMtime(). This function populates the mTime and</Line>
  <Line number="7432">** mDate fields of the CDS structure passed as the first argument according</Line>
  <Line number="7433">** to the UNIX timestamp value passed as the second.</Line>
  <Line number="7434">*/</Line>
  <Line number="7435">static void zipfileMtimeToDos(ZipfileCDS *pCds, u32 mUnixTime){</Line>
  <Line number="7436">  /* Convert unix timestamp to JD (2440588 is noon on 1/1/1970) */</Line>
  <Line number="7437">  i64 JD = (i64)2440588 + mUnixTime / (24*60*60);</Line>
  <Line number="7438"></Line>
  <Line number="7439">  int A, B, C, D, E;</Line>
  <Line number="7440">  int yr, mon, day;</Line>
  <Line number="7441">  int hr, min, sec;</Line>
  <Line number="7442"></Line>
  <Line number="7443">  A = (int)((JD - 1867216.25)/36524.25);</Line>
  <Line number="7444">  A = (int)(JD + 1 + A - (A/4));</Line>
  <Line number="7445">  B = A + 1524;</Line>
  <Line number="7446">  C = (int)((B - 122.1)/365.25);</Line>
  <Line number="7447">  D = (36525*(C&amp;32767))/100;</Line>
  <Line number="7448">  E = (int)((B-D)/30.6001);</Line>
  <Line number="7449"></Line>
  <Line number="7450">  day = B - D - (int)(30.6001*E);</Line>
  <Line number="7451">  mon = (E&lt;14 ? E-1 : E-13);</Line>
  <Line number="7452">  yr = mon&gt;2 ? C-4716 : C-4715;</Line>
  <Line number="7453"></Line>
  <Line number="7454">  hr = (mUnixTime % (24*60*60)) / (60*60);</Line>
  <Line number="7455">  min = (mUnixTime % (60*60)) / 60;</Line>
  <Line number="7456">  sec = (mUnixTime % 60);</Line>
  <Line number="7457"></Line>
  <Line number="7458">  if( yr&gt;=1980 ){</Line>
  <Line number="7459">    pCds-&gt;mDate = (u16)(day + (mon &lt;&lt; 5) + ((yr-1980) &lt;&lt; 9));</Line>
  <Line number="7460">    pCds-&gt;mTime = (u16)(sec/2 + (min&lt;&lt;5) + (hr&lt;&lt;11));</Line>
  <Line number="7461">  }else{</Line>
  <Line number="7462">    pCds-&gt;mDate = pCds-&gt;mTime = 0;</Line>
  <Line number="7463">  }</Line>
  <Line number="7464"></Line>
  <Line number="7465">  assert( mUnixTime&lt;315507600 </Line>
  <Line number="7466">       || mUnixTime==zipfileMtime(pCds) </Line>
  <Line number="7467">       || ((mUnixTime % 2) &amp;&amp; mUnixTime-1==zipfileMtime(pCds)) </Line>
  <Line number="7468">       /* || (mUnixTime % 2) */</Line>
  <Line number="7469">  );</Line>
  <Line number="7470">}</Line>
  <Line number="7471"></Line>
  <Line number="7472">/*</Line>
  <Line number="7473">** If aBlob is not NULL, then it is a pointer to a buffer (nBlob bytes in</Line>
  <Line number="7474">** size) containing an entire zip archive image. Or, if aBlob is NULL,</Line>
  <Line number="7475">** then pFile is a file-handle open on a zip file. In either case, this</Line>
  <Line number="7476">** function creates a ZipfileEntry object based on the zip archive entry</Line>
  <Line number="7477">** for which the CDS record is at offset iOff.</Line>
  <Line number="7478">**</Line>
  <Line number="7479">** If successful, SQLITE_OK is returned and (*ppEntry) set to point to</Line>
  <Line number="7480">** the new object. Otherwise, an SQLite error code is returned and the</Line>
  <Line number="7481">** final value of (*ppEntry) undefined.</Line>
  <Line number="7482">*/</Line>
  <Line number="7483">static int zipfileGetEntry(</Line>
  <Line number="7484">  ZipfileTab *pTab,               /* Store any error message here */</Line>
  <Line number="7485">  const u8 *aBlob,                /* Pointer to in-memory file image */</Line>
  <Line number="7486">  int nBlob,                      /* Size of aBlob[] in bytes */</Line>
  <Line number="7487">  FILE *pFile,                    /* If aBlob==0, read from this file */</Line>
  <Line number="7488">  i64 iOff,                       /* Offset of CDS record */</Line>
  <Line number="7489">  ZipfileEntry **ppEntry          /* OUT: Pointer to new object */</Line>
  <Line number="7490">){</Line>
  <Line number="7491">  u8 *aRead;</Line>
  <Line number="7492">  char **pzErr = &amp;pTab-&gt;base.zErrMsg;</Line>
  <Line number="7493">  int rc = SQLITE_OK;</Line>
  <Line number="7494"></Line>
  <Line number="7495">  if( aBlob==0 ){</Line>
  <Line number="7496">    aRead = pTab-&gt;aBuffer;</Line>
  <Line number="7497">    rc = zipfileReadData(pFile, aRead, ZIPFILE_CDS_FIXED_SZ, iOff, pzErr);</Line>
  <Line number="7498">  }else{</Line>
  <Line number="7499">    aRead = (u8*)&amp;aBlob[iOff];</Line>
  <Line number="7500">  }</Line>
  <Line number="7501"></Line>
  <Line number="7502">  if( rc==SQLITE_OK ){</Line>
  <Line number="7503">    sqlite3_int64 nAlloc;</Line>
  <Line number="7504">    ZipfileEntry *pNew;</Line>
  <Line number="7505"></Line>
  <Line number="7506">    int nFile = zipfileGetU16(&amp;aRead[ZIPFILE_CDS_NFILE_OFF]);</Line>
  <Line number="7507">    int nExtra = zipfileGetU16(&amp;aRead[ZIPFILE_CDS_NFILE_OFF+2]);</Line>
  <Line number="7508">    nExtra += zipfileGetU16(&amp;aRead[ZIPFILE_CDS_NFILE_OFF+4]);</Line>
  <Line number="7509"></Line>
  <Line number="7510">    nAlloc = sizeof(ZipfileEntry) + nExtra;</Line>
  <Line number="7511">    if( aBlob ){</Line>
  <Line number="7512">      nAlloc += zipfileGetU32(&amp;aRead[ZIPFILE_CDS_SZCOMPRESSED_OFF]);</Line>
  <Line number="7513">    }</Line>
  <Line number="7514"></Line>
  <Line number="7515">    pNew = (ZipfileEntry*)sqlite3_malloc64(nAlloc);</Line>
  <Line number="7516">    if( pNew==0 ){</Line>
  <Line number="7517">      rc = SQLITE_NOMEM;</Line>
  <Line number="7518">    }else{</Line>
  <Line number="7519">      memset(pNew, 0, sizeof(ZipfileEntry));</Line>
  <Line number="7520">      rc = zipfileReadCDS(aRead, &amp;pNew-&gt;cds);</Line>
  <Line number="7521">      if( rc!=SQLITE_OK ){</Line>
  <Line number="7522">        *pzErr = sqlite3_mprintf(&quot;failed to read CDS at offset %lld&quot;, iOff);</Line>
  <Line number="7523">      }else if( aBlob==0 ){</Line>
  <Line number="7524">        rc = zipfileReadData(</Line>
  <Line number="7525">            pFile, aRead, nExtra+nFile, iOff+ZIPFILE_CDS_FIXED_SZ, pzErr</Line>
  <Line number="7526">        );</Line>
  <Line number="7527">      }else{</Line>
  <Line number="7528">        aRead = (u8*)&amp;aBlob[iOff + ZIPFILE_CDS_FIXED_SZ];</Line>
  <Line number="7529">      }</Line>
  <Line number="7530">    }</Line>
  <Line number="7531"></Line>
  <Line number="7532">    if( rc==SQLITE_OK ){</Line>
  <Line number="7533">      u32 *pt = &amp;pNew-&gt;mUnixTime;</Line>
  <Line number="7534">      pNew-&gt;cds.zFile = sqlite3_mprintf(&quot;%.*s&quot;, nFile, aRead); </Line>
  <Line number="7535">      pNew-&gt;aExtra = (u8*)&amp;pNew[1];</Line>
  <Line number="7536">      memcpy(pNew-&gt;aExtra, &amp;aRead[nFile], nExtra);</Line>
  <Line number="7537">      if( pNew-&gt;cds.zFile==0 ){</Line>
  <Line number="7538">        rc = SQLITE_NOMEM;</Line>
  <Line number="7539">      }else if( 0==zipfileScanExtra(&amp;aRead[nFile], pNew-&gt;cds.nExtra, pt) ){</Line>
  <Line number="7540">        pNew-&gt;mUnixTime = zipfileMtime(&amp;pNew-&gt;cds);</Line>
  <Line number="7541">      }</Line>
  <Line number="7542">    }</Line>
  <Line number="7543"></Line>
  <Line number="7544">    if( rc==SQLITE_OK ){</Line>
  <Line number="7545">      static const int szFix = ZIPFILE_LFH_FIXED_SZ;</Line>
  <Line number="7546">      ZipfileLFH lfh;</Line>
  <Line number="7547">      if( pFile ){</Line>
  <Line number="7548">        rc = zipfileReadData(pFile, aRead, szFix, pNew-&gt;cds.iOffset, pzErr);</Line>
  <Line number="7549">      }else{</Line>
  <Line number="7550">        aRead = (u8*)&amp;aBlob[pNew-&gt;cds.iOffset];</Line>
  <Line number="7551">      }</Line>
  <Line number="7552"></Line>
  <Line number="7553">      rc = zipfileReadLFH(aRead, &amp;lfh);</Line>
  <Line number="7554">      if( rc==SQLITE_OK ){</Line>
  <Line number="7555">        pNew-&gt;iDataOff =  pNew-&gt;cds.iOffset + ZIPFILE_LFH_FIXED_SZ;</Line>
  <Line number="7556">        pNew-&gt;iDataOff += lfh.nFile + lfh.nExtra;</Line>
  <Line number="7557">        if( aBlob &amp;&amp; pNew-&gt;cds.szCompressed ){</Line>
  <Line number="7558">          pNew-&gt;aData = &amp;pNew-&gt;aExtra[nExtra];</Line>
  <Line number="7559">          memcpy(pNew-&gt;aData, &amp;aBlob[pNew-&gt;iDataOff], pNew-&gt;cds.szCompressed);</Line>
  <Line number="7560">        }</Line>
  <Line number="7561">      }else{</Line>
  <Line number="7562">        *pzErr = sqlite3_mprintf(&quot;failed to read LFH at offset %d&quot;, </Line>
  <Line number="7563">            (int)pNew-&gt;cds.iOffset</Line>
  <Line number="7564">        );</Line>
  <Line number="7565">      }</Line>
  <Line number="7566">    }</Line>
  <Line number="7567"></Line>
  <Line number="7568">    if( rc!=SQLITE_OK ){</Line>
  <Line number="7569">      zipfileEntryFree(pNew);</Line>
  <Line number="7570">    }else{</Line>
  <Line number="7571">      *ppEntry = pNew;</Line>
  <Line number="7572">    }</Line>
  <Line number="7573">  }</Line>
  <Line number="7574"></Line>
  <Line number="7575">  return rc;</Line>
  <Line number="7576">}</Line>
  <Line number="7577"></Line>
  <Line number="7578">/*</Line>
  <Line number="7579">** Advance an ZipfileCsr to its next row of output.</Line>
  <Line number="7580">*/</Line>
  <Line number="7581">static int zipfileNext(sqlite3_vtab_cursor *cur){</Line>
  <Line number="7582">  ZipfileCsr *pCsr = (ZipfileCsr*)cur;</Line>
  <Line number="7583">  int rc = SQLITE_OK;</Line>
  <Line number="7584"></Line>
  <Line number="7585">  if( pCsr-&gt;pFile ){</Line>
  <Line number="7586">    i64 iEof = pCsr-&gt;eocd.iOffset + pCsr-&gt;eocd.nSize;</Line>
  <Line number="7587">    zipfileEntryFree(pCsr-&gt;pCurrent);</Line>
  <Line number="7588">    pCsr-&gt;pCurrent = 0;</Line>
  <Line number="7589">    if( pCsr-&gt;iNextOff&gt;=iEof ){</Line>
  <Line number="7590">      pCsr-&gt;bEof = 1;</Line>
  <Line number="7591">    }else{</Line>
  <Line number="7592">      ZipfileEntry *p = 0;</Line>
  <Line number="7593">      ZipfileTab *pTab = (ZipfileTab*)(cur-&gt;pVtab);</Line>
  <Line number="7594">      rc = zipfileGetEntry(pTab, 0, 0, pCsr-&gt;pFile, pCsr-&gt;iNextOff, &amp;p);</Line>
  <Line number="7595">      if( rc==SQLITE_OK ){</Line>
  <Line number="7596">        pCsr-&gt;iNextOff += ZIPFILE_CDS_FIXED_SZ;</Line>
  <Line number="7597">        pCsr-&gt;iNextOff += (int)p-&gt;cds.nExtra + p-&gt;cds.nFile + p-&gt;cds.nComment;</Line>
  <Line number="7598">      }</Line>
  <Line number="7599">      pCsr-&gt;pCurrent = p;</Line>
  <Line number="7600">    }</Line>
  <Line number="7601">  }else{</Line>
  <Line number="7602">    if( !pCsr-&gt;bNoop ){</Line>
  <Line number="7603">      pCsr-&gt;pCurrent = pCsr-&gt;pCurrent-&gt;pNext;</Line>
  <Line number="7604">    }</Line>
  <Line number="7605">    if( pCsr-&gt;pCurrent==0 ){</Line>
  <Line number="7606">      pCsr-&gt;bEof = 1;</Line>
  <Line number="7607">    }</Line>
  <Line number="7608">  }</Line>
  <Line number="7609"></Line>
  <Line number="7610">  pCsr-&gt;bNoop = 0;</Line>
  <Line number="7611">  return rc;</Line>
  <Line number="7612">}</Line>
  <Line number="7613"></Line>
  <Line number="7614">static void zipfileFree(void *p) { </Line>
  <Line number="7615">  sqlite3_free(p); </Line>
  <Line number="7616">}</Line>
  <Line number="7617"></Line>
  <Line number="7618">/*</Line>
  <Line number="7619">** Buffer aIn (size nIn bytes) contains compressed data. Uncompressed, the</Line>
  <Line number="7620">** size is nOut bytes. This function uncompresses the data and sets the</Line>
  <Line number="7621">** return value in context pCtx to the result (a blob).</Line>
  <Line number="7622">**</Line>
  <Line number="7623">** If an error occurs, an error code is left in pCtx instead.</Line>
  <Line number="7624">*/</Line>
  <Line number="7625">static void zipfileInflate(</Line>
  <Line number="7626">  sqlite3_context *pCtx,          /* Store result here */</Line>
  <Line number="7627">  const u8 *aIn,                  /* Compressed data */</Line>
  <Line number="7628">  int nIn,                        /* Size of buffer aIn[] in bytes */</Line>
  <Line number="7629">  int nOut                        /* Expected output size */</Line>
  <Line number="7630">){</Line>
  <Line number="7631">  u8 *aRes = sqlite3_malloc(nOut);</Line>
  <Line number="7632">  if( aRes==0 ){</Line>
  <Line number="7633">    sqlite3_result_error_nomem(pCtx);</Line>
  <Line number="7634">  }else{</Line>
  <Line number="7635">    int err;</Line>
  <Line number="7636">    z_stream str;</Line>
  <Line number="7637">    memset(&amp;str, 0, sizeof(str));</Line>
  <Line number="7638"></Line>
  <Line number="7639">    str.next_in = (Byte*)aIn;</Line>
  <Line number="7640">    str.avail_in = nIn;</Line>
  <Line number="7641">    str.next_out = (Byte*)aRes;</Line>
  <Line number="7642">    str.avail_out = nOut;</Line>
  <Line number="7643"></Line>
  <Line number="7644">    err = inflateInit2(&amp;str, -15);</Line>
  <Line number="7645">    if( err!=Z_OK ){</Line>
  <Line number="7646">      zipfileCtxErrorMsg(pCtx, &quot;inflateInit2() failed (%d)&quot;, err);</Line>
  <Line number="7647">    }else{</Line>
  <Line number="7648">      err = inflate(&amp;str, Z_NO_FLUSH);</Line>
  <Line number="7649">      if( err!=Z_STREAM_END ){</Line>
  <Line number="7650">        zipfileCtxErrorMsg(pCtx, &quot;inflate() failed (%d)&quot;, err);</Line>
  <Line number="7651">      }else{</Line>
  <Line number="7652">        sqlite3_result_blob(pCtx, aRes, nOut, zipfileFree);</Line>
  <Line number="7653">        aRes = 0;</Line>
  <Line number="7654">      }</Line>
  <Line number="7655">    }</Line>
  <Line number="7656">    sqlite3_free(aRes);</Line>
  <Line number="7657">    inflateEnd(&amp;str);</Line>
  <Line number="7658">  }</Line>
  <Line number="7659">}</Line>
  <Line number="7660"></Line>
  <Line number="7661">/*</Line>
  <Line number="7662">** Buffer aIn (size nIn bytes) contains uncompressed data. This function</Line>
  <Line number="7663">** compresses it and sets (*ppOut) to point to a buffer containing the</Line>
  <Line number="7664">** compressed data. The caller is responsible for eventually calling</Line>
  <Line number="7665">** sqlite3_free() to release buffer (*ppOut). Before returning, (*pnOut) </Line>
  <Line number="7666">** is set to the size of buffer (*ppOut) in bytes.</Line>
  <Line number="7667">**</Line>
  <Line number="7668">** If no error occurs, SQLITE_OK is returned. Otherwise, an SQLite error</Line>
  <Line number="7669">** code is returned and an error message left in virtual-table handle</Line>
  <Line number="7670">** pTab. The values of (*ppOut) and (*pnOut) are left unchanged in this</Line>
  <Line number="7671">** case.</Line>
  <Line number="7672">*/</Line>
  <Line number="7673">static int zipfileDeflate(</Line>
  <Line number="7674">  const u8 *aIn, int nIn,         /* Input */</Line>
  <Line number="7675">  u8 **ppOut, int *pnOut,         /* Output */</Line>
  <Line number="7676">  char **pzErr                    /* OUT: Error message */</Line>
  <Line number="7677">){</Line>
  <Line number="7678">  int rc = SQLITE_OK;</Line>
  <Line number="7679">  sqlite3_int64 nAlloc;</Line>
  <Line number="7680">  z_stream str;</Line>
  <Line number="7681">  u8 *aOut;</Line>
  <Line number="7682"></Line>
  <Line number="7683">  memset(&amp;str, 0, sizeof(str));</Line>
  <Line number="7684">  str.next_in = (Bytef*)aIn;</Line>
  <Line number="7685">  str.avail_in = nIn;</Line>
  <Line number="7686">  deflateInit2(&amp;str, 9, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);</Line>
  <Line number="7687"></Line>
  <Line number="7688">  nAlloc = deflateBound(&amp;str, nIn);</Line>
  <Line number="7689">  aOut = (u8*)sqlite3_malloc64(nAlloc);</Line>
  <Line number="7690">  if( aOut==0 ){</Line>
  <Line number="7691">    rc = SQLITE_NOMEM;</Line>
  <Line number="7692">  }else{</Line>
  <Line number="7693">    int res;</Line>
  <Line number="7694">    str.next_out = aOut;</Line>
  <Line number="7695">    str.avail_out = nAlloc;</Line>
  <Line number="7696">    res = deflate(&amp;str, Z_FINISH);</Line>
  <Line number="7697">    if( res==Z_STREAM_END ){</Line>
  <Line number="7698">      *ppOut = aOut;</Line>
  <Line number="7699">      *pnOut = (int)str.total_out;</Line>
  <Line number="7700">    }else{</Line>
  <Line number="7701">      sqlite3_free(aOut);</Line>
  <Line number="7702">      *pzErr = sqlite3_mprintf(&quot;zipfile: deflate() error&quot;);</Line>
  <Line number="7703">      rc = SQLITE_ERROR;</Line>
  <Line number="7704">    }</Line>
  <Line number="7705">    deflateEnd(&amp;str);</Line>
  <Line number="7706">  }</Line>
  <Line number="7707"></Line>
  <Line number="7708">  return rc;</Line>
  <Line number="7709">}</Line>
  <Line number="7710"></Line>
  <Line number="7711"></Line>
  <Line number="7712">/*</Line>
  <Line number="7713">** Return values of columns for the row at which the series_cursor</Line>
  <Line number="7714">** is currently pointing.</Line>
  <Line number="7715">*/</Line>
  <Line number="7716">static int zipfileColumn(</Line>
  <Line number="7717">  sqlite3_vtab_cursor *cur,   /* The cursor */</Line>
  <Line number="7718">  sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */</Line>
  <Line number="7719">  int i                       /* Which column to return */</Line>
  <Line number="7720">){</Line>
  <Line number="7721">  ZipfileCsr *pCsr = (ZipfileCsr*)cur;</Line>
  <Line number="7722">  ZipfileCDS *pCDS = &amp;pCsr-&gt;pCurrent-&gt;cds;</Line>
  <Line number="7723">  int rc = SQLITE_OK;</Line>
  <Line number="7724">  switch( i ){</Line>
  <Line number="7725">    case 0:   /* name */</Line>
  <Line number="7726">      sqlite3_result_text(ctx, pCDS-&gt;zFile, -1, SQLITE_TRANSIENT);</Line>
  <Line number="7727">      break;</Line>
  <Line number="7728">    case 1:   /* mode */</Line>
  <Line number="7729">      /* TODO: Whether or not the following is correct surely depends on</Line>
  <Line number="7730">      ** the platform on which the archive was created.  */</Line>
  <Line number="7731">      sqlite3_result_int(ctx, pCDS-&gt;iExternalAttr &gt;&gt; 16);</Line>
  <Line number="7732">      break;</Line>
  <Line number="7733">    case 2: { /* mtime */</Line>
  <Line number="7734">      sqlite3_result_int64(ctx, pCsr-&gt;pCurrent-&gt;mUnixTime);</Line>
  <Line number="7735">      break;</Line>
  <Line number="7736">    }</Line>
  <Line number="7737">    case 3: { /* sz */</Line>
  <Line number="7738">      if( sqlite3_vtab_nochange(ctx)==0 ){</Line>
  <Line number="7739">        sqlite3_result_int64(ctx, pCDS-&gt;szUncompressed);</Line>
  <Line number="7740">      }</Line>
  <Line number="7741">      break;</Line>
  <Line number="7742">    }</Line>
  <Line number="7743">    case 4:   /* rawdata */</Line>
  <Line number="7744">      if( sqlite3_vtab_nochange(ctx) ) break;</Line>
  <Line number="7745">    case 5: { /* data */</Line>
  <Line number="7746">      if( i==4 || pCDS-&gt;iCompression==0 || pCDS-&gt;iCompression==8 ){</Line>
  <Line number="7747">        int sz = pCDS-&gt;szCompressed;</Line>
  <Line number="7748">        int szFinal = pCDS-&gt;szUncompressed;</Line>
  <Line number="7749">        if( szFinal&gt;0 ){</Line>
  <Line number="7750">          u8 *aBuf;</Line>
  <Line number="7751">          u8 *aFree = 0;</Line>
  <Line number="7752">          if( pCsr-&gt;pCurrent-&gt;aData ){</Line>
  <Line number="7753">            aBuf = pCsr-&gt;pCurrent-&gt;aData;</Line>
  <Line number="7754">          }else{</Line>
  <Line number="7755">            aBuf = aFree = sqlite3_malloc64(sz);</Line>
  <Line number="7756">            if( aBuf==0 ){</Line>
  <Line number="7757">              rc = SQLITE_NOMEM;</Line>
  <Line number="7758">            }else{</Line>
  <Line number="7759">              FILE *pFile = pCsr-&gt;pFile;</Line>
  <Line number="7760">              if( pFile==0 ){</Line>
  <Line number="7761">                pFile = ((ZipfileTab*)(pCsr-&gt;base.pVtab))-&gt;pWriteFd;</Line>
  <Line number="7762">              }</Line>
  <Line number="7763">              rc = zipfileReadData(pFile, aBuf, sz, pCsr-&gt;pCurrent-&gt;iDataOff,</Line>
  <Line number="7764">                  &amp;pCsr-&gt;base.pVtab-&gt;zErrMsg</Line>
  <Line number="7765">              );</Line>
  <Line number="7766">            }</Line>
  <Line number="7767">          }</Line>
  <Line number="7768">          if( rc==SQLITE_OK ){</Line>
  <Line number="7769">            if( i==5 &amp;&amp; pCDS-&gt;iCompression ){</Line>
  <Line number="7770">              zipfileInflate(ctx, aBuf, sz, szFinal);</Line>
  <Line number="7771">            }else{</Line>
  <Line number="7772">              sqlite3_result_blob(ctx, aBuf, sz, SQLITE_TRANSIENT);</Line>
  <Line number="7773">            }</Line>
  <Line number="7774">          }</Line>
  <Line number="7775">          sqlite3_free(aFree);</Line>
  <Line number="7776">        }else{</Line>
  <Line number="7777">          /* Figure out if this is a directory or a zero-sized file. Consider</Line>
  <Line number="7778">          ** it to be a directory either if the mode suggests so, or if</Line>
  <Line number="7779">          ** the final character in the name is &apos;/&apos;.  */</Line>
  <Line number="7780">          u32 mode = pCDS-&gt;iExternalAttr &gt;&gt; 16;</Line>
  <Line number="7781">          if( !(mode &amp; S_IFDIR) &amp;&amp; pCDS-&gt;zFile[pCDS-&gt;nFile-1]!=&apos;/&apos; ){</Line>
  <Line number="7782">            sqlite3_result_blob(ctx, &quot;&quot;, 0, SQLITE_STATIC);</Line>
  <Line number="7783">          }</Line>
  <Line number="7784">        }</Line>
  <Line number="7785">      }</Line>
  <Line number="7786">      break;</Line>
  <Line number="7787">    }</Line>
  <Line number="7788">    case 6:   /* method */</Line>
  <Line number="7789">      sqlite3_result_int(ctx, pCDS-&gt;iCompression);</Line>
  <Line number="7790">      break;</Line>
  <Line number="7791">    default:  /* z */</Line>
  <Line number="7792">      assert( i==7 );</Line>
  <Line number="7793">      sqlite3_result_int64(ctx, pCsr-&gt;iId);</Line>
  <Line number="7794">      break;</Line>
  <Line number="7795">  }</Line>
  <Line number="7796"></Line>
  <Line number="7797">  return rc;</Line>
  <Line number="7798">}</Line>
  <Line number="7799"></Line>
  <Line number="7800">/*</Line>
  <Line number="7801">** Return TRUE if the cursor is at EOF.</Line>
  <Line number="7802">*/</Line>
  <Line number="7803">static int zipfileEof(sqlite3_vtab_cursor *cur){</Line>
  <Line number="7804">  ZipfileCsr *pCsr = (ZipfileCsr*)cur;</Line>
  <Line number="7805">  return pCsr-&gt;bEof;</Line>
  <Line number="7806">}</Line>
  <Line number="7807"></Line>
  <Line number="7808">/*</Line>
  <Line number="7809">** If aBlob is not NULL, then it points to a buffer nBlob bytes in size</Line>
  <Line number="7810">** containing an entire zip archive image. Or, if aBlob is NULL, then pFile</Line>
  <Line number="7811">** is guaranteed to be a file-handle open on a zip file.</Line>
  <Line number="7812">**</Line>
  <Line number="7813">** This function attempts to locate the EOCD record within the zip archive</Line>
  <Line number="7814">** and populate *pEOCD with the results of decoding it. SQLITE_OK is</Line>
  <Line number="7815">** returned if successful. Otherwise, an SQLite error code is returned and</Line>
  <Line number="7816">** an English language error message may be left in virtual-table pTab.</Line>
  <Line number="7817">*/</Line>
  <Line number="7818">static int zipfileReadEOCD(</Line>
  <Line number="7819">  ZipfileTab *pTab,               /* Return errors here */</Line>
  <Line number="7820">  const u8 *aBlob,                /* Pointer to in-memory file image */</Line>
  <Line number="7821">  int nBlob,                      /* Size of aBlob[] in bytes */</Line>
  <Line number="7822">  FILE *pFile,                    /* Read from this file if aBlob==0 */</Line>
  <Line number="7823">  ZipfileEOCD *pEOCD              /* Object to populate */</Line>
  <Line number="7824">){</Line>
  <Line number="7825">  u8 *aRead = pTab-&gt;aBuffer;      /* Temporary buffer */</Line>
  <Line number="7826">  int nRead;                      /* Bytes to read from file */</Line>
  <Line number="7827">  int rc = SQLITE_OK;</Line>
  <Line number="7828"></Line>
  <Line number="7829">  if( aBlob==0 ){</Line>
  <Line number="7830">    i64 iOff;                     /* Offset to read from */</Line>
  <Line number="7831">    i64 szFile;                   /* Total size of file in bytes */</Line>
  <Line number="7832">    fseek(pFile, 0, SEEK_END);</Line>
  <Line number="7833">    szFile = (i64)ftell(pFile);</Line>
  <Line number="7834">    if( szFile==0 ){</Line>
  <Line number="7835">      memset(pEOCD, 0, sizeof(ZipfileEOCD));</Line>
  <Line number="7836">      return SQLITE_OK;</Line>
  <Line number="7837">    }</Line>
  <Line number="7838">    nRead = (int)(MIN(szFile, ZIPFILE_BUFFER_SIZE));</Line>
  <Line number="7839">    iOff = szFile - nRead;</Line>
  <Line number="7840">    rc = zipfileReadData(pFile, aRead, nRead, iOff, &amp;pTab-&gt;base.zErrMsg);</Line>
  <Line number="7841">  }else{</Line>
  <Line number="7842">    nRead = (int)(MIN(nBlob, ZIPFILE_BUFFER_SIZE));</Line>
  <Line number="7843">    aRead = (u8*)&amp;aBlob[nBlob-nRead];</Line>
  <Line number="7844">  }</Line>
  <Line number="7845"></Line>
  <Line number="7846">  if( rc==SQLITE_OK ){</Line>
  <Line number="7847">    int i;</Line>
  <Line number="7848"></Line>
  <Line number="7849">    /* Scan backwards looking for the signature bytes */</Line>
  <Line number="7850">    for(i=nRead-20; i&gt;=0; i--){</Line>
  <Line number="7851">      if( aRead[i]==0x50 &amp;&amp; aRead[i+1]==0x4b </Line>
  <Line number="7852">       &amp;&amp; aRead[i+2]==0x05 &amp;&amp; aRead[i+3]==0x06 </Line>
  <Line number="7853">      ){</Line>
  <Line number="7854">        break;</Line>
  <Line number="7855">      }</Line>
  <Line number="7856">    }</Line>
  <Line number="7857">    if( i&lt;0 ){</Line>
  <Line number="7858">      pTab-&gt;base.zErrMsg = sqlite3_mprintf(</Line>
  <Line number="7859">          &quot;cannot find end of central directory record&quot;</Line>
  <Line number="7860">      );</Line>
  <Line number="7861">      return SQLITE_ERROR;</Line>
  <Line number="7862">    }</Line>
  <Line number="7863"></Line>
  <Line number="7864">    aRead += i+4;</Line>
  <Line number="7865">    pEOCD-&gt;iDisk = zipfileRead16(aRead);</Line>
  <Line number="7866">    pEOCD-&gt;iFirstDisk = zipfileRead16(aRead);</Line>
  <Line number="7867">    pEOCD-&gt;nEntry = zipfileRead16(aRead);</Line>
  <Line number="7868">    pEOCD-&gt;nEntryTotal = zipfileRead16(aRead);</Line>
  <Line number="7869">    pEOCD-&gt;nSize = zipfileRead32(aRead);</Line>
  <Line number="7870">    pEOCD-&gt;iOffset = zipfileRead32(aRead);</Line>
  <Line number="7871">  }</Line>
  <Line number="7872"></Line>
  <Line number="7873">  return rc;</Line>
  <Line number="7874">}</Line>
  <Line number="7875"></Line>
  <Line number="7876">/*</Line>
  <Line number="7877">** Add object pNew to the linked list that begins at ZipfileTab.pFirstEntry </Line>
  <Line number="7878">** and ends with pLastEntry. If argument pBefore is NULL, then pNew is added</Line>
  <Line number="7879">** to the end of the list. Otherwise, it is added to the list immediately</Line>
  <Line number="7880">** before pBefore (which is guaranteed to be a part of said list).</Line>
  <Line number="7881">*/</Line>
  <Line number="7882">static void zipfileAddEntry(</Line>
  <Line number="7883">  ZipfileTab *pTab, </Line>
  <Line number="7884">  ZipfileEntry *pBefore, </Line>
  <Line number="7885">  ZipfileEntry *pNew</Line>
  <Line number="7886">){</Line>
  <Line number="7887">  assert( (pTab-&gt;pFirstEntry==0)==(pTab-&gt;pLastEntry==0) );</Line>
  <Line number="7888">  assert( pNew-&gt;pNext==0 );</Line>
  <Line number="7889">  if( pBefore==0 ){</Line>
  <Line number="7890">    if( pTab-&gt;pFirstEntry==0 ){</Line>
  <Line number="7891">      pTab-&gt;pFirstEntry = pTab-&gt;pLastEntry = pNew;</Line>
  <Line number="7892">    }else{</Line>
  <Line number="7893">      assert( pTab-&gt;pLastEntry-&gt;pNext==0 );</Line>
  <Line number="7894">      pTab-&gt;pLastEntry-&gt;pNext = pNew;</Line>
  <Line number="7895">      pTab-&gt;pLastEntry = pNew;</Line>
  <Line number="7896">    }</Line>
  <Line number="7897">  }else{</Line>
  <Line number="7898">    ZipfileEntry **pp;</Line>
  <Line number="7899">    for(pp=&amp;pTab-&gt;pFirstEntry; *pp!=pBefore; pp=&amp;((*pp)-&gt;pNext));</Line>
  <Line number="7900">    pNew-&gt;pNext = pBefore;</Line>
  <Line number="7901">    *pp = pNew;</Line>
  <Line number="7902">  }</Line>
  <Line number="7903">}</Line>
  <Line number="7904"></Line>
  <Line number="7905">static int zipfileLoadDirectory(ZipfileTab *pTab, const u8 *aBlob, int nBlob){</Line>
  <Line number="7906">  ZipfileEOCD eocd;</Line>
  <Line number="7907">  int rc;</Line>
  <Line number="7908">  int i;</Line>
  <Line number="7909">  i64 iOff;</Line>
  <Line number="7910"></Line>
  <Line number="7911">  rc = zipfileReadEOCD(pTab, aBlob, nBlob, pTab-&gt;pWriteFd, &amp;eocd);</Line>
  <Line number="7912">  iOff = eocd.iOffset;</Line>
  <Line number="7913">  for(i=0; rc==SQLITE_OK &amp;&amp; i&lt;eocd.nEntry; i++){</Line>
  <Line number="7914">    ZipfileEntry *pNew = 0;</Line>
  <Line number="7915">    rc = zipfileGetEntry(pTab, aBlob, nBlob, pTab-&gt;pWriteFd, iOff, &amp;pNew);</Line>
  <Line number="7916"></Line>
  <Line number="7917">    if( rc==SQLITE_OK ){</Line>
  <Line number="7918">      zipfileAddEntry(pTab, 0, pNew);</Line>
  <Line number="7919">      iOff += ZIPFILE_CDS_FIXED_SZ;</Line>
  <Line number="7920">      iOff += (int)pNew-&gt;cds.nExtra + pNew-&gt;cds.nFile + pNew-&gt;cds.nComment;</Line>
  <Line number="7921">    }</Line>
  <Line number="7922">  }</Line>
  <Line number="7923">  return rc;</Line>
  <Line number="7924">}</Line>
  <Line number="7925"></Line>
  <Line number="7926">/*</Line>
  <Line number="7927">** xFilter callback.</Line>
  <Line number="7928">*/</Line>
  <Line number="7929">static int zipfileFilter(</Line>
  <Line number="7930">  sqlite3_vtab_cursor *cur, </Line>
  <Line number="7931">  int idxNum, const char *idxStr,</Line>
  <Line number="7932">  int argc, sqlite3_value **argv</Line>
  <Line number="7933">){</Line>
  <Line number="7934">  ZipfileTab *pTab = (ZipfileTab*)cur-&gt;pVtab;</Line>
  <Line number="7935">  ZipfileCsr *pCsr = (ZipfileCsr*)cur;</Line>
  <Line number="7936">  const char *zFile = 0;          /* Zip file to scan */</Line>
  <Line number="7937">  int rc = SQLITE_OK;             /* Return Code */</Line>
  <Line number="7938">  int bInMemory = 0;              /* True for an in-memory zipfile */</Line>
  <Line number="7939"></Line>
  <Line number="7940">  zipfileResetCursor(pCsr);</Line>
  <Line number="7941"></Line>
  <Line number="7942">  if( pTab-&gt;zFile ){</Line>
  <Line number="7943">    zFile = pTab-&gt;zFile;</Line>
  <Line number="7944">  }else if( idxNum==0 ){</Line>
  <Line number="7945">    zipfileCursorErr(pCsr, &quot;zipfile() function requires an argument&quot;);</Line>
  <Line number="7946">    return SQLITE_ERROR;</Line>
  <Line number="7947">  }else if( sqlite3_value_type(argv[0])==SQLITE_BLOB ){</Line>
  <Line number="7948">    const u8 *aBlob = (const u8*)sqlite3_value_blob(argv[0]);</Line>
  <Line number="7949">    int nBlob = sqlite3_value_bytes(argv[0]);</Line>
  <Line number="7950">    assert( pTab-&gt;pFirstEntry==0 );</Line>
  <Line number="7951">    rc = zipfileLoadDirectory(pTab, aBlob, nBlob);</Line>
  <Line number="7952">    pCsr-&gt;pFreeEntry = pTab-&gt;pFirstEntry;</Line>
  <Line number="7953">    pTab-&gt;pFirstEntry = pTab-&gt;pLastEntry = 0;</Line>
  <Line number="7954">    if( rc!=SQLITE_OK ) return rc;</Line>
  <Line number="7955">    bInMemory = 1;</Line>
  <Line number="7956">  }else{</Line>
  <Line number="7957">    zFile = (const char*)sqlite3_value_text(argv[0]);</Line>
  <Line number="7958">  }</Line>
  <Line number="7959"></Line>
  <Line number="7960">  if( 0==pTab-&gt;pWriteFd &amp;&amp; 0==bInMemory ){</Line>
  <Line number="7961">    pCsr-&gt;pFile = fopen(zFile, &quot;rb&quot;);</Line>
  <Line number="7962">    if( pCsr-&gt;pFile==0 ){</Line>
  <Line number="7963">      zipfileCursorErr(pCsr, &quot;cannot open file: %s&quot;, zFile);</Line>
  <Line number="7964">      rc = SQLITE_ERROR;</Line>
  <Line number="7965">    }else{</Line>
  <Line number="7966">      rc = zipfileReadEOCD(pTab, 0, 0, pCsr-&gt;pFile, &amp;pCsr-&gt;eocd);</Line>
  <Line number="7967">      if( rc==SQLITE_OK ){</Line>
  <Line number="7968">        if( pCsr-&gt;eocd.nEntry==0 ){</Line>
  <Line number="7969">          pCsr-&gt;bEof = 1;</Line>
  <Line number="7970">        }else{</Line>
  <Line number="7971">          pCsr-&gt;iNextOff = pCsr-&gt;eocd.iOffset;</Line>
  <Line number="7972">          rc = zipfileNext(cur);</Line>
  <Line number="7973">        }</Line>
  <Line number="7974">      }</Line>
  <Line number="7975">    }</Line>
  <Line number="7976">  }else{</Line>
  <Line number="7977">    pCsr-&gt;bNoop = 1;</Line>
  <Line number="7978">    pCsr-&gt;pCurrent = pCsr-&gt;pFreeEntry ? pCsr-&gt;pFreeEntry : pTab-&gt;pFirstEntry;</Line>
  <Line number="7979">    rc = zipfileNext(cur);</Line>
  <Line number="7980">  }</Line>
  <Line number="7981"></Line>
  <Line number="7982">  return rc;</Line>
  <Line number="7983">}</Line>
  <Line number="7984"></Line>
  <Line number="7985">/*</Line>
  <Line number="7986">** xBestIndex callback.</Line>
  <Line number="7987">*/</Line>
  <Line number="7988">static int zipfileBestIndex(</Line>
  <Line number="7989">  sqlite3_vtab *tab,</Line>
  <Line number="7990">  sqlite3_index_info *pIdxInfo</Line>
  <Line number="7991">){</Line>
  <Line number="7992">  int i;</Line>
  <Line number="7993">  int idx = -1;</Line>
  <Line number="7994">  int unusable = 0;</Line>
  <Line number="7995"></Line>
  <Line number="7996">  for(i=0; i&lt;pIdxInfo-&gt;nConstraint; i++){</Line>
  <Line number="7997">    const struct sqlite3_index_constraint *pCons = &amp;pIdxInfo-&gt;aConstraint[i];</Line>
  <Line number="7998">    if( pCons-&gt;iColumn!=ZIPFILE_F_COLUMN_IDX ) continue;</Line>
  <Line number="7999">    if( pCons-&gt;usable==0 ){</Line>
  <Line number="8000">      unusable = 1;</Line>
  <Line number="8001">    }else if( pCons-&gt;op==SQLITE_INDEX_CONSTRAINT_EQ ){</Line>
  <Line number="8002">      idx = i;</Line>
  <Line number="8003">    }</Line>
  <Line number="8004">  }</Line>
  <Line number="8005">  pIdxInfo-&gt;estimatedCost = 1000.0;</Line>
  <Line number="8006">  if( idx&gt;=0 ){</Line>
  <Line number="8007">    pIdxInfo-&gt;aConstraintUsage[idx].argvIndex = 1;</Line>
  <Line number="8008">    pIdxInfo-&gt;aConstraintUsage[idx].omit = 1;</Line>
  <Line number="8009">    pIdxInfo-&gt;idxNum = 1;</Line>
  <Line number="8010">  }else if( unusable ){</Line>
  <Line number="8011">    return SQLITE_CONSTRAINT;</Line>
  <Line number="8012">  }</Line>
  <Line number="8013">  return SQLITE_OK;</Line>
  <Line number="8014">}</Line>
  <Line number="8015"></Line>
  <Line number="8016">static ZipfileEntry *zipfileNewEntry(const char *zPath){</Line>
  <Line number="8017">  ZipfileEntry *pNew;</Line>
  <Line number="8018">  pNew = sqlite3_malloc(sizeof(ZipfileEntry));</Line>
  <Line number="8019">  if( pNew ){</Line>
  <Line number="8020">    memset(pNew, 0, sizeof(ZipfileEntry));</Line>
  <Line number="8021">    pNew-&gt;cds.zFile = sqlite3_mprintf(&quot;%s&quot;, zPath);</Line>
  <Line number="8022">    if( pNew-&gt;cds.zFile==0 ){</Line>
  <Line number="8023">      sqlite3_free(pNew);</Line>
  <Line number="8024">      pNew = 0;</Line>
  <Line number="8025">    }</Line>
  <Line number="8026">  }</Line>
  <Line number="8027">  return pNew;</Line>
  <Line number="8028">}</Line>
  <Line number="8029"></Line>
  <Line number="8030">static int zipfileSerializeLFH(ZipfileEntry *pEntry, u8 *aBuf){</Line>
  <Line number="8031">  ZipfileCDS *pCds = &amp;pEntry-&gt;cds;</Line>
  <Line number="8032">  u8 *a = aBuf;</Line>
  <Line number="8033"></Line>
  <Line number="8034">  pCds-&gt;nExtra = 9;</Line>
  <Line number="8035"></Line>
  <Line number="8036">  /* Write the LFH itself */</Line>
  <Line number="8037">  zipfileWrite32(a, ZIPFILE_SIGNATURE_LFH);</Line>
  <Line number="8038">  zipfileWrite16(a, pCds-&gt;iVersionExtract);</Line>
  <Line number="8039">  zipfileWrite16(a, pCds-&gt;flags);</Line>
  <Line number="8040">  zipfileWrite16(a, pCds-&gt;iCompression);</Line>
  <Line number="8041">  zipfileWrite16(a, pCds-&gt;mTime);</Line>
  <Line number="8042">  zipfileWrite16(a, pCds-&gt;mDate);</Line>
  <Line number="8043">  zipfileWrite32(a, pCds-&gt;crc32);</Line>
  <Line number="8044">  zipfileWrite32(a, pCds-&gt;szCompressed);</Line>
  <Line number="8045">  zipfileWrite32(a, pCds-&gt;szUncompressed);</Line>
  <Line number="8046">  zipfileWrite16(a, (u16)pCds-&gt;nFile);</Line>
  <Line number="8047">  zipfileWrite16(a, pCds-&gt;nExtra);</Line>
  <Line number="8048">  assert( a==&amp;aBuf[ZIPFILE_LFH_FIXED_SZ] );</Line>
  <Line number="8049"></Line>
  <Line number="8050">  /* Add the file name */</Line>
  <Line number="8051">  memcpy(a, pCds-&gt;zFile, (int)pCds-&gt;nFile);</Line>
  <Line number="8052">  a += (int)pCds-&gt;nFile;</Line>
  <Line number="8053"></Line>
  <Line number="8054">  /* The &quot;extra&quot; data */</Line>
  <Line number="8055">  zipfileWrite16(a, ZIPFILE_EXTRA_TIMESTAMP);</Line>
  <Line number="8056">  zipfileWrite16(a, 5);</Line>
  <Line number="8057">  *a++ = 0x01;</Line>
  <Line number="8058">  zipfileWrite32(a, pEntry-&gt;mUnixTime);</Line>
  <Line number="8059"></Line>
  <Line number="8060">  return a-aBuf;</Line>
  <Line number="8061">}</Line>
  <Line number="8062"></Line>
  <Line number="8063">static int zipfileAppendEntry(</Line>
  <Line number="8064">  ZipfileTab *pTab,</Line>
  <Line number="8065">  ZipfileEntry *pEntry,</Line>
  <Line number="8066">  const u8 *pData,</Line>
  <Line number="8067">  int nData</Line>
  <Line number="8068">){</Line>
  <Line number="8069">  u8 *aBuf = pTab-&gt;aBuffer;</Line>
  <Line number="8070">  int nBuf;</Line>
  <Line number="8071">  int rc;</Line>
  <Line number="8072"></Line>
  <Line number="8073">  nBuf = zipfileSerializeLFH(pEntry, aBuf);</Line>
  <Line number="8074">  rc = zipfileAppendData(pTab, aBuf, nBuf);</Line>
  <Line number="8075">  if( rc==SQLITE_OK ){</Line>
  <Line number="8076">    pEntry-&gt;iDataOff = pTab-&gt;szCurrent;</Line>
  <Line number="8077">    rc = zipfileAppendData(pTab, pData, nData);</Line>
  <Line number="8078">  }</Line>
  <Line number="8079"></Line>
  <Line number="8080">  return rc;</Line>
  <Line number="8081">}</Line>
  <Line number="8082"></Line>
  <Line number="8083">static int zipfileGetMode(</Line>
  <Line number="8084">  sqlite3_value *pVal, </Line>
  <Line number="8085">  int bIsDir,                     /* If true, default to directory */</Line>
  <Line number="8086">  u32 *pMode,                     /* OUT: Mode value */</Line>
  <Line number="8087">  char **pzErr                    /* OUT: Error message */</Line>
  <Line number="8088">){</Line>
  <Line number="8089">  const char *z = (const char*)sqlite3_value_text(pVal);</Line>
  <Line number="8090">  u32 mode = 0;</Line>
  <Line number="8091">  if( z==0 ){</Line>
  <Line number="8092">    mode = (bIsDir ? (S_IFDIR + 0755) : (S_IFREG + 0644));</Line>
  <Line number="8093">  }else if( z[0]&gt;=&apos;0&apos; &amp;&amp; z[0]&lt;=&apos;9&apos; ){</Line>
  <Line number="8094">    mode = (unsigned int)sqlite3_value_int(pVal);</Line>
  <Line number="8095">  }else{</Line>
  <Line number="8096">    const char zTemplate[11] = &quot;-rwxrwxrwx&quot;;</Line>
  <Line number="8097">    int i;</Line>
  <Line number="8098">    if( strlen(z)!=10 ) goto parse_error;</Line>
  <Line number="8099">    switch( z[0] ){</Line>
  <Line number="8100">      case &apos;-&apos;: mode |= S_IFREG; break;</Line>
  <Line number="8101">      case &apos;d&apos;: mode |= S_IFDIR; break;</Line>
  <Line number="8102">      case &apos;l&apos;: mode |= S_IFLNK; break;</Line>
  <Line number="8103">      default: goto parse_error;</Line>
  <Line number="8104">    }</Line>
  <Line number="8105">    for(i=1; i&lt;10; i++){</Line>
  <Line number="8106">      if( z[i]==zTemplate[i] ) mode |= 1 &lt;&lt; (9-i);</Line>
  <Line number="8107">      else if( z[i]!=&apos;-&apos; ) goto parse_error;</Line>
  <Line number="8108">    }</Line>
  <Line number="8109">  }</Line>
  <Line number="8110">  if( ((mode &amp; S_IFDIR)==0)==bIsDir ){</Line>
  <Line number="8111">    /* The &quot;mode&quot; attribute is a directory, but data has been specified.</Line>
  <Line number="8112">    ** Or vice-versa - no data but &quot;mode&quot; is a file or symlink.  */</Line>
  <Line number="8113">    *pzErr = sqlite3_mprintf(&quot;zipfile: mode does not match data&quot;);</Line>
  <Line number="8114">    return SQLITE_CONSTRAINT;</Line>
  <Line number="8115">  }</Line>
  <Line number="8116">  *pMode = mode;</Line>
  <Line number="8117">  return SQLITE_OK;</Line>
  <Line number="8118"></Line>
  <Line number="8119"> parse_error:</Line>
  <Line number="8120">  *pzErr = sqlite3_mprintf(&quot;zipfile: parse error in mode: %s&quot;, z);</Line>
  <Line number="8121">  return SQLITE_ERROR;</Line>
  <Line number="8122">}</Line>
  <Line number="8123"></Line>
  <Line number="8124">/*</Line>
  <Line number="8125">** Both (const char*) arguments point to nul-terminated strings. Argument</Line>
  <Line number="8126">** nB is the value of strlen(zB). This function returns 0 if the strings are</Line>
  <Line number="8127">** identical, ignoring any trailing &apos;/&apos; character in either path.  */</Line>
  <Line number="8128">static int zipfileComparePath(const char *zA, const char *zB, int nB){</Line>
  <Line number="8129">  int nA = (int)strlen(zA);</Line>
  <Line number="8130">  if( nA&gt;0 &amp;&amp; zA[nA-1]==&apos;/&apos; ) nA--;</Line>
  <Line number="8131">  if( nB&gt;0 &amp;&amp; zB[nB-1]==&apos;/&apos; ) nB--;</Line>
  <Line number="8132">  if( nA==nB &amp;&amp; memcmp(zA, zB, nA)==0 ) return 0;</Line>
  <Line number="8133">  return 1;</Line>
  <Line number="8134">}</Line>
  <Line number="8135"></Line>
  <Line number="8136">static int zipfileBegin(sqlite3_vtab *pVtab){</Line>
  <Line number="8137">  ZipfileTab *pTab = (ZipfileTab*)pVtab;</Line>
  <Line number="8138">  int rc = SQLITE_OK;</Line>
  <Line number="8139"></Line>
  <Line number="8140">  assert( pTab-&gt;pWriteFd==0 );</Line>
  <Line number="8141">  if( pTab-&gt;zFile==0 || pTab-&gt;zFile[0]==0 ){</Line>
  <Line number="8142">    pTab-&gt;base.zErrMsg = sqlite3_mprintf(&quot;zipfile: missing filename&quot;);</Line>
  <Line number="8143">    return SQLITE_ERROR;</Line>
  <Line number="8144">  }</Line>
  <Line number="8145"></Line>
  <Line number="8146">  /* Open a write fd on the file. Also load the entire central directory</Line>
  <Line number="8147">  ** structure into memory. During the transaction any new file data is </Line>
  <Line number="8148">  ** appended to the archive file, but the central directory is accumulated</Line>
  <Line number="8149">  ** in main-memory until the transaction is committed.  */</Line>
  <Line number="8150">  pTab-&gt;pWriteFd = fopen(pTab-&gt;zFile, &quot;ab+&quot;);</Line>
  <Line number="8151">  if( pTab-&gt;pWriteFd==0 ){</Line>
  <Line number="8152">    pTab-&gt;base.zErrMsg = sqlite3_mprintf(</Line>
  <Line number="8153">        &quot;zipfile: failed to open file %s for writing&quot;, pTab-&gt;zFile</Line>
  <Line number="8154">        );</Line>
  <Line number="8155">    rc = SQLITE_ERROR;</Line>
  <Line number="8156">  }else{</Line>
  <Line number="8157">    fseek(pTab-&gt;pWriteFd, 0, SEEK_END);</Line>
  <Line number="8158">    pTab-&gt;szCurrent = pTab-&gt;szOrig = (i64)ftell(pTab-&gt;pWriteFd);</Line>
  <Line number="8159">    rc = zipfileLoadDirectory(pTab, 0, 0);</Line>
  <Line number="8160">  }</Line>
  <Line number="8161"></Line>
  <Line number="8162">  if( rc!=SQLITE_OK ){</Line>
  <Line number="8163">    zipfileCleanupTransaction(pTab);</Line>
  <Line number="8164">  }</Line>
  <Line number="8165"></Line>
  <Line number="8166">  return rc;</Line>
  <Line number="8167">}</Line>
  <Line number="8168"></Line>
  <Line number="8169">/*</Line>
  <Line number="8170">** Return the current time as a 32-bit timestamp in UNIX epoch format (like</Line>
  <Line number="8171">** time(2)).</Line>
  <Line number="8172">*/</Line>
  <Line number="8173">static u32 zipfileTime(void){</Line>
  <Line number="8174">  sqlite3_vfs *pVfs = sqlite3_vfs_find(0);</Line>
  <Line number="8175">  u32 ret;</Line>
  <Line number="8176">  if( pVfs==0 ) return 0;</Line>
  <Line number="8177">  if( pVfs-&gt;iVersion&gt;=2 &amp;&amp; pVfs-&gt;xCurrentTimeInt64 ){</Line>
  <Line number="8178">    i64 ms;</Line>
  <Line number="8179">    pVfs-&gt;xCurrentTimeInt64(pVfs, &amp;ms);</Line>
  <Line number="8180">    ret = (u32)((ms/1000) - ((i64)24405875 * 8640));</Line>
  <Line number="8181">  }else{</Line>
  <Line number="8182">    double day;</Line>
  <Line number="8183">    pVfs-&gt;xCurrentTime(pVfs, &amp;day);</Line>
  <Line number="8184">    ret = (u32)((day - 2440587.5) * 86400);</Line>
  <Line number="8185">  }</Line>
  <Line number="8186">  return ret;</Line>
  <Line number="8187">}</Line>
  <Line number="8188"></Line>
  <Line number="8189">/*</Line>
  <Line number="8190">** Return a 32-bit timestamp in UNIX epoch format.</Line>
  <Line number="8191">**</Line>
  <Line number="8192">** If the value passed as the only argument is either NULL or an SQL NULL,</Line>
  <Line number="8193">** return the current time. Otherwise, return the value stored in (*pVal)</Line>
  <Line number="8194">** cast to a 32-bit unsigned integer.</Line>
  <Line number="8195">*/</Line>
  <Line number="8196">static u32 zipfileGetTime(sqlite3_value *pVal){</Line>
  <Line number="8197">  if( pVal==0 || sqlite3_value_type(pVal)==SQLITE_NULL ){</Line>
  <Line number="8198">    return zipfileTime();</Line>
  <Line number="8199">  }</Line>
  <Line number="8200">  return (u32)sqlite3_value_int64(pVal);</Line>
  <Line number="8201">}</Line>
  <Line number="8202"></Line>
  <Line number="8203">/*</Line>
  <Line number="8204">** Unless it is NULL, entry pOld is currently part of the pTab-&gt;pFirstEntry</Line>
  <Line number="8205">** linked list.  Remove it from the list and free the object.</Line>
  <Line number="8206">*/</Line>
  <Line number="8207">static void zipfileRemoveEntryFromList(ZipfileTab *pTab, ZipfileEntry *pOld){</Line>
  <Line number="8208">  if( pOld ){</Line>
  <Line number="8209">    ZipfileEntry **pp;</Line>
  <Line number="8210">    for(pp=&amp;pTab-&gt;pFirstEntry; (*pp)!=pOld; pp=&amp;((*pp)-&gt;pNext));</Line>
  <Line number="8211">    *pp = (*pp)-&gt;pNext;</Line>
  <Line number="8212">    zipfileEntryFree(pOld);</Line>
  <Line number="8213">  }</Line>
  <Line number="8214">}</Line>
  <Line number="8215"></Line>
  <Line number="8216">/*</Line>
  <Line number="8217">** xUpdate method.</Line>
  <Line number="8218">*/</Line>
  <Line number="8219">static int zipfileUpdate(</Line>
  <Line number="8220">  sqlite3_vtab *pVtab, </Line>
  <Line number="8221">  int nVal, </Line>
  <Line number="8222">  sqlite3_value **apVal, </Line>
  <Line number="8223">  sqlite_int64 *pRowid</Line>
  <Line number="8224">){</Line>
  <Line number="8225">  ZipfileTab *pTab = (ZipfileTab*)pVtab;</Line>
  <Line number="8226">  int rc = SQLITE_OK;             /* Return Code */</Line>
  <Line number="8227">  ZipfileEntry *pNew = 0;         /* New in-memory CDS entry */</Line>
  <Line number="8228"></Line>
  <Line number="8229">  u32 mode = 0;                   /* Mode for new entry */</Line>
  <Line number="8230">  u32 mTime = 0;                  /* Modification time for new entry */</Line>
  <Line number="8231">  i64 sz = 0;                     /* Uncompressed size */</Line>
  <Line number="8232">  const char *zPath = 0;          /* Path for new entry */</Line>
  <Line number="8233">  int nPath = 0;                  /* strlen(zPath) */</Line>
  <Line number="8234">  const u8 *pData = 0;            /* Pointer to buffer containing content */</Line>
  <Line number="8235">  int nData = 0;                  /* Size of pData buffer in bytes */</Line>
  <Line number="8236">  int iMethod = 0;                /* Compression method for new entry */</Line>
  <Line number="8237">  u8 *pFree = 0;                  /* Free this */</Line>
  <Line number="8238">  char *zFree = 0;                /* Also free this */</Line>
  <Line number="8239">  ZipfileEntry *pOld = 0;</Line>
  <Line number="8240">  ZipfileEntry *pOld2 = 0;</Line>
  <Line number="8241">  int bUpdate = 0;                /* True for an update that modifies &quot;name&quot; */</Line>
  <Line number="8242">  int bIsDir = 0;</Line>
  <Line number="8243">  u32 iCrc32 = 0;</Line>
  <Line number="8244"></Line>
  <Line number="8245">  if( pTab-&gt;pWriteFd==0 ){</Line>
  <Line number="8246">    rc = zipfileBegin(pVtab);</Line>
  <Line number="8247">    if( rc!=SQLITE_OK ) return rc;</Line>
  <Line number="8248">  }</Line>
  <Line number="8249"></Line>
  <Line number="8250">  /* If this is a DELETE or UPDATE, find the archive entry to delete. */</Line>
  <Line number="8251">  if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){</Line>
  <Line number="8252">    const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);</Line>
  <Line number="8253">    int nDelete = (int)strlen(zDelete);</Line>
  <Line number="8254">    if( nVal&gt;1 ){</Line>
  <Line number="8255">      const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);</Line>
  <Line number="8256">      if( zUpdate &amp;&amp; zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){</Line>
  <Line number="8257">        bUpdate = 1;</Line>
  <Line number="8258">      }</Line>
  <Line number="8259">    }</Line>
  <Line number="8260">    for(pOld=pTab-&gt;pFirstEntry; 1; pOld=pOld-&gt;pNext){</Line>
  <Line number="8261">      if( zipfileComparePath(pOld-&gt;cds.zFile, zDelete, nDelete)==0 ){</Line>
  <Line number="8262">        break;</Line>
  <Line number="8263">      }</Line>
  <Line number="8264">      assert( pOld-&gt;pNext );</Line>
  <Line number="8265">    }</Line>
  <Line number="8266">  }</Line>
  <Line number="8267"></Line>
  <Line number="8268">  if( nVal&gt;1 ){</Line>
  <Line number="8269">    /* Check that &quot;sz&quot; and &quot;rawdata&quot; are both NULL: */</Line>
  <Line number="8270">    if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){</Line>
  <Line number="8271">      zipfileTableErr(pTab, &quot;sz must be NULL&quot;);</Line>
  <Line number="8272">      rc = SQLITE_CONSTRAINT;</Line>
  <Line number="8273">    }</Line>
  <Line number="8274">    if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){</Line>
  <Line number="8275">      zipfileTableErr(pTab, &quot;rawdata must be NULL&quot;); </Line>
  <Line number="8276">      rc = SQLITE_CONSTRAINT;</Line>
  <Line number="8277">    }</Line>
  <Line number="8278"></Line>
  <Line number="8279">    if( rc==SQLITE_OK ){</Line>
  <Line number="8280">      if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){</Line>
  <Line number="8281">        /* data=NULL. A directory */</Line>
  <Line number="8282">        bIsDir = 1;</Line>
  <Line number="8283">      }else{</Line>
  <Line number="8284">        /* Value specified for &quot;data&quot;, and possibly &quot;method&quot;. This must be</Line>
  <Line number="8285">        ** a regular file or a symlink. */</Line>
  <Line number="8286">        const u8 *aIn = sqlite3_value_blob(apVal[7]);</Line>
  <Line number="8287">        int nIn = sqlite3_value_bytes(apVal[7]);</Line>
  <Line number="8288">        int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;</Line>
  <Line number="8289"></Line>
  <Line number="8290">        iMethod = sqlite3_value_int(apVal[8]);</Line>
  <Line number="8291">        sz = nIn;</Line>
  <Line number="8292">        pData = aIn;</Line>
  <Line number="8293">        nData = nIn;</Line>
  <Line number="8294">        if( iMethod!=0 &amp;&amp; iMethod!=8 ){</Line>
  <Line number="8295">          zipfileTableErr(pTab, &quot;unknown compression method: %d&quot;, iMethod);</Line>
  <Line number="8296">          rc = SQLITE_CONSTRAINT;</Line>
  <Line number="8297">        }else{</Line>
  <Line number="8298">          if( bAuto || iMethod ){</Line>
  <Line number="8299">            int nCmp;</Line>
  <Line number="8300">            rc = zipfileDeflate(aIn, nIn, &amp;pFree, &amp;nCmp, &amp;pTab-&gt;base.zErrMsg);</Line>
  <Line number="8301">            if( rc==SQLITE_OK ){</Line>
  <Line number="8302">              if( iMethod || nCmp&lt;nIn ){</Line>
  <Line number="8303">                iMethod = 8;</Line>
  <Line number="8304">                pData = pFree;</Line>
  <Line number="8305">                nData = nCmp;</Line>
  <Line number="8306">              }</Line>
  <Line number="8307">            }</Line>
  <Line number="8308">          }</Line>
  <Line number="8309">          iCrc32 = crc32(0, aIn, nIn);</Line>
  <Line number="8310">        }</Line>
  <Line number="8311">      }</Line>
  <Line number="8312">    }</Line>
  <Line number="8313"></Line>
  <Line number="8314">    if( rc==SQLITE_OK ){</Line>
  <Line number="8315">      rc = zipfileGetMode(apVal[3], bIsDir, &amp;mode, &amp;pTab-&gt;base.zErrMsg);</Line>
  <Line number="8316">    }</Line>
  <Line number="8317"></Line>
  <Line number="8318">    if( rc==SQLITE_OK ){</Line>
  <Line number="8319">      zPath = (const char*)sqlite3_value_text(apVal[2]);</Line>
  <Line number="8320">      if( zPath==0 ) zPath = &quot;&quot;;</Line>
  <Line number="8321">      nPath = (int)strlen(zPath);</Line>
  <Line number="8322">      mTime = zipfileGetTime(apVal[4]);</Line>
  <Line number="8323">    }</Line>
  <Line number="8324"></Line>
  <Line number="8325">    if( rc==SQLITE_OK &amp;&amp; bIsDir ){</Line>
  <Line number="8326">      /* For a directory, check that the last character in the path is a</Line>
  <Line number="8327">      ** &apos;/&apos;. This appears to be required for compatibility with info-zip</Line>
  <Line number="8328">      ** (the unzip command on unix). It does not create directories</Line>
  <Line number="8329">      ** otherwise.  */</Line>
  <Line number="8330">      if( nPath&lt;=0 || zPath[nPath-1]!=&apos;/&apos; ){</Line>
  <Line number="8331">        zFree = sqlite3_mprintf(&quot;%s/&quot;, zPath);</Line>
  <Line number="8332">        zPath = (const char*)zFree;</Line>
  <Line number="8333">        if( zFree==0 ){</Line>
  <Line number="8334">          rc = SQLITE_NOMEM;</Line>
  <Line number="8335">          nPath = 0;</Line>
  <Line number="8336">        }else{</Line>
  <Line number="8337">          nPath = (int)strlen(zPath);</Line>
  <Line number="8338">        }</Line>
  <Line number="8339">      }</Line>
  <Line number="8340">    }</Line>
  <Line number="8341"></Line>
  <Line number="8342">    /* Check that we&apos;re not inserting a duplicate entry -OR- updating an</Line>
  <Line number="8343">    ** entry with a path, thereby making it into a duplicate. */</Line>
  <Line number="8344">    if( (pOld==0 || bUpdate) &amp;&amp; rc==SQLITE_OK ){</Line>
  <Line number="8345">      ZipfileEntry *p;</Line>
  <Line number="8346">      for(p=pTab-&gt;pFirstEntry; p; p=p-&gt;pNext){</Line>
  <Line number="8347">        if( zipfileComparePath(p-&gt;cds.zFile, zPath, nPath)==0 ){</Line>
  <Line number="8348">          switch( sqlite3_vtab_on_conflict(pTab-&gt;db) ){</Line>
  <Line number="8349">            case SQLITE_IGNORE: {</Line>
  <Line number="8350">              goto zipfile_update_done;</Line>
  <Line number="8351">            }</Line>
  <Line number="8352">            case SQLITE_REPLACE: {</Line>
  <Line number="8353">              pOld2 = p;</Line>
  <Line number="8354">              break;</Line>
  <Line number="8355">            }</Line>
  <Line number="8356">            default: {</Line>
  <Line number="8357">              zipfileTableErr(pTab, &quot;duplicate name: \&quot;%s\&quot;&quot;, zPath);</Line>
  <Line number="8358">              rc = SQLITE_CONSTRAINT;</Line>
  <Line number="8359">              break;</Line>
  <Line number="8360">            }</Line>
  <Line number="8361">          }</Line>
  <Line number="8362">          break;</Line>
  <Line number="8363">        }</Line>
  <Line number="8364">      }</Line>
  <Line number="8365">    }</Line>
  <Line number="8366"></Line>
  <Line number="8367">    if( rc==SQLITE_OK ){</Line>
  <Line number="8368">      /* Create the new CDS record. */</Line>
  <Line number="8369">      pNew = zipfileNewEntry(zPath);</Line>
  <Line number="8370">      if( pNew==0 ){</Line>
  <Line number="8371">        rc = SQLITE_NOMEM;</Line>
  <Line number="8372">      }else{</Line>
  <Line number="8373">        pNew-&gt;cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;</Line>
  <Line number="8374">        pNew-&gt;cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;</Line>
  <Line number="8375">        pNew-&gt;cds.flags = ZIPFILE_NEWENTRY_FLAGS;</Line>
  <Line number="8376">        pNew-&gt;cds.iCompression = (u16)iMethod;</Line>
  <Line number="8377">        zipfileMtimeToDos(&amp;pNew-&gt;cds, mTime);</Line>
  <Line number="8378">        pNew-&gt;cds.crc32 = iCrc32;</Line>
  <Line number="8379">        pNew-&gt;cds.szCompressed = nData;</Line>
  <Line number="8380">        pNew-&gt;cds.szUncompressed = (u32)sz;</Line>
  <Line number="8381">        pNew-&gt;cds.iExternalAttr = (mode&lt;&lt;16);</Line>
  <Line number="8382">        pNew-&gt;cds.iOffset = (u32)pTab-&gt;szCurrent;</Line>
  <Line number="8383">        pNew-&gt;cds.nFile = (u16)nPath;</Line>
  <Line number="8384">        pNew-&gt;mUnixTime = (u32)mTime;</Line>
  <Line number="8385">        rc = zipfileAppendEntry(pTab, pNew, pData, nData);</Line>
  <Line number="8386">        zipfileAddEntry(pTab, pOld, pNew);</Line>
  <Line number="8387">      }</Line>
  <Line number="8388">    }</Line>
  <Line number="8389">  }</Line>
  <Line number="8390"></Line>
  <Line number="8391">  if( rc==SQLITE_OK &amp;&amp; (pOld || pOld2) ){</Line>
  <Line number="8392">    ZipfileCsr *pCsr;</Line>
  <Line number="8393">    for(pCsr=pTab-&gt;pCsrList; pCsr; pCsr=pCsr-&gt;pCsrNext){</Line>
  <Line number="8394">      if( pCsr-&gt;pCurrent &amp;&amp; (pCsr-&gt;pCurrent==pOld || pCsr-&gt;pCurrent==pOld2) ){</Line>
  <Line number="8395">        pCsr-&gt;pCurrent = pCsr-&gt;pCurrent-&gt;pNext;</Line>
  <Line number="8396">        pCsr-&gt;bNoop = 1;</Line>
  <Line number="8397">      }</Line>
  <Line number="8398">    }</Line>
  <Line number="8399"></Line>
  <Line number="8400">    zipfileRemoveEntryFromList(pTab, pOld);</Line>
  <Line number="8401">    zipfileRemoveEntryFromList(pTab, pOld2);</Line>
  <Line number="8402">  }</Line>
  <Line number="8403"></Line>
  <Line number="8404">zipfile_update_done:</Line>
  <Line number="8405">  sqlite3_free(pFree);</Line>
  <Line number="8406">  sqlite3_free(zFree);</Line>
  <Line number="8407">  return rc;</Line>
  <Line number="8408">}</Line>
  <Line number="8409"></Line>
  <Line number="8410">static int zipfileSerializeEOCD(ZipfileEOCD *p, u8 *aBuf){</Line>
  <Line number="8411">  u8 *a = aBuf;</Line>
  <Line number="8412">  zipfileWrite32(a, ZIPFILE_SIGNATURE_EOCD);</Line>
  <Line number="8413">  zipfileWrite16(a, p-&gt;iDisk);</Line>
  <Line number="8414">  zipfileWrite16(a, p-&gt;iFirstDisk);</Line>
  <Line number="8415">  zipfileWrite16(a, p-&gt;nEntry);</Line>
  <Line number="8416">  zipfileWrite16(a, p-&gt;nEntryTotal);</Line>
  <Line number="8417">  zipfileWrite32(a, p-&gt;nSize);</Line>
  <Line number="8418">  zipfileWrite32(a, p-&gt;iOffset);</Line>
  <Line number="8419">  zipfileWrite16(a, 0);        /* Size of trailing comment in bytes*/</Line>
  <Line number="8420"></Line>
  <Line number="8421">  return a-aBuf;</Line>
  <Line number="8422">}</Line>
  <Line number="8423"></Line>
  <Line number="8424">static int zipfileAppendEOCD(ZipfileTab *pTab, ZipfileEOCD *p){</Line>
  <Line number="8425">  int nBuf = zipfileSerializeEOCD(p, pTab-&gt;aBuffer);</Line>
  <Line number="8426">  assert( nBuf==ZIPFILE_EOCD_FIXED_SZ );</Line>
  <Line number="8427">  return zipfileAppendData(pTab, pTab-&gt;aBuffer, nBuf);</Line>
  <Line number="8428">}</Line>
  <Line number="8429"></Line>
  <Line number="8430">/*</Line>
  <Line number="8431">** Serialize the CDS structure into buffer aBuf[]. Return the number</Line>
  <Line number="8432">** of bytes written.</Line>
  <Line number="8433">*/</Line>
  <Line number="8434">static int zipfileSerializeCDS(ZipfileEntry *pEntry, u8 *aBuf){</Line>
  <Line number="8435">  u8 *a = aBuf;</Line>
  <Line number="8436">  ZipfileCDS *pCDS = &amp;pEntry-&gt;cds;</Line>
  <Line number="8437"></Line>
  <Line number="8438">  if( pEntry-&gt;aExtra==0 ){</Line>
  <Line number="8439">    pCDS-&gt;nExtra = 9;</Line>
  <Line number="8440">  }</Line>
  <Line number="8441"></Line>
  <Line number="8442">  zipfileWrite32(a, ZIPFILE_SIGNATURE_CDS);</Line>
  <Line number="8443">  zipfileWrite16(a, pCDS-&gt;iVersionMadeBy);</Line>
  <Line number="8444">  zipfileWrite16(a, pCDS-&gt;iVersionExtract);</Line>
  <Line number="8445">  zipfileWrite16(a, pCDS-&gt;flags);</Line>
  <Line number="8446">  zipfileWrite16(a, pCDS-&gt;iCompression);</Line>
  <Line number="8447">  zipfileWrite16(a, pCDS-&gt;mTime);</Line>
  <Line number="8448">  zipfileWrite16(a, pCDS-&gt;mDate);</Line>
  <Line number="8449">  zipfileWrite32(a, pCDS-&gt;crc32);</Line>
  <Line number="8450">  zipfileWrite32(a, pCDS-&gt;szCompressed);</Line>
  <Line number="8451">  zipfileWrite32(a, pCDS-&gt;szUncompressed);</Line>
  <Line number="8452">  assert( a==&amp;aBuf[ZIPFILE_CDS_NFILE_OFF] );</Line>
  <Line number="8453">  zipfileWrite16(a, pCDS-&gt;nFile);</Line>
  <Line number="8454">  zipfileWrite16(a, pCDS-&gt;nExtra);</Line>
  <Line number="8455">  zipfileWrite16(a, pCDS-&gt;nComment);</Line>
  <Line number="8456">  zipfileWrite16(a, pCDS-&gt;iDiskStart);</Line>
  <Line number="8457">  zipfileWrite16(a, pCDS-&gt;iInternalAttr);</Line>
  <Line number="8458">  zipfileWrite32(a, pCDS-&gt;iExternalAttr);</Line>
  <Line number="8459">  zipfileWrite32(a, pCDS-&gt;iOffset);</Line>
  <Line number="8460"></Line>
  <Line number="8461">  memcpy(a, pCDS-&gt;zFile, pCDS-&gt;nFile);</Line>
  <Line number="8462">  a += pCDS-&gt;nFile;</Line>
  <Line number="8463"></Line>
  <Line number="8464">  if( pEntry-&gt;aExtra ){</Line>
  <Line number="8465">    int n = (int)pCDS-&gt;nExtra + (int)pCDS-&gt;nComment;</Line>
  <Line number="8466">    memcpy(a, pEntry-&gt;aExtra, n);</Line>
  <Line number="8467">    a += n;</Line>
  <Line number="8468">  }else{</Line>
  <Line number="8469">    assert( pCDS-&gt;nExtra==9 );</Line>
  <Line number="8470">    zipfileWrite16(a, ZIPFILE_EXTRA_TIMESTAMP);</Line>
  <Line number="8471">    zipfileWrite16(a, 5);</Line>
  <Line number="8472">    *a++ = 0x01;</Line>
  <Line number="8473">    zipfileWrite32(a, pEntry-&gt;mUnixTime);</Line>
  <Line number="8474">  }</Line>
  <Line number="8475"></Line>
  <Line number="8476">  return a-aBuf;</Line>
  <Line number="8477">}</Line>
  <Line number="8478"></Line>
  <Line number="8479">static int zipfileCommit(sqlite3_vtab *pVtab){</Line>
  <Line number="8480">  ZipfileTab *pTab = (ZipfileTab*)pVtab;</Line>
  <Line number="8481">  int rc = SQLITE_OK;</Line>
  <Line number="8482">  if( pTab-&gt;pWriteFd ){</Line>
  <Line number="8483">    i64 iOffset = pTab-&gt;szCurrent;</Line>
  <Line number="8484">    ZipfileEntry *p;</Line>
  <Line number="8485">    ZipfileEOCD eocd;</Line>
  <Line number="8486">    int nEntry = 0;</Line>
  <Line number="8487"></Line>
  <Line number="8488">    /* Write out all entries */</Line>
  <Line number="8489">    for(p=pTab-&gt;pFirstEntry; rc==SQLITE_OK &amp;&amp; p; p=p-&gt;pNext){</Line>
  <Line number="8490">      int n = zipfileSerializeCDS(p, pTab-&gt;aBuffer);</Line>
  <Line number="8491">      rc = zipfileAppendData(pTab, pTab-&gt;aBuffer, n);</Line>
  <Line number="8492">      nEntry++;</Line>
  <Line number="8493">    }</Line>
  <Line number="8494"></Line>
  <Line number="8495">    /* Write out the EOCD record */</Line>
  <Line number="8496">    eocd.iDisk = 0;</Line>
  <Line number="8497">    eocd.iFirstDisk = 0;</Line>
  <Line number="8498">    eocd.nEntry = (u16)nEntry;</Line>
  <Line number="8499">    eocd.nEntryTotal = (u16)nEntry;</Line>
  <Line number="8500">    eocd.nSize = (u32)(pTab-&gt;szCurrent - iOffset);</Line>
  <Line number="8501">    eocd.iOffset = (u32)iOffset;</Line>
  <Line number="8502">    rc = zipfileAppendEOCD(pTab, &amp;eocd);</Line>
  <Line number="8503"></Line>
  <Line number="8504">    zipfileCleanupTransaction(pTab);</Line>
  <Line number="8505">  }</Line>
  <Line number="8506">  return rc;</Line>
  <Line number="8507">}</Line>
  <Line number="8508"></Line>
  <Line number="8509">static int zipfileRollback(sqlite3_vtab *pVtab){</Line>
  <Line number="8510">  return zipfileCommit(pVtab);</Line>
  <Line number="8511">}</Line>
  <Line number="8512"></Line>
  <Line number="8513">static ZipfileCsr *zipfileFindCursor(ZipfileTab *pTab, i64 iId){</Line>
  <Line number="8514">  ZipfileCsr *pCsr;</Line>
  <Line number="8515">  for(pCsr=pTab-&gt;pCsrList; pCsr; pCsr=pCsr-&gt;pCsrNext){</Line>
  <Line number="8516">    if( iId==pCsr-&gt;iId ) break;</Line>
  <Line number="8517">  }</Line>
  <Line number="8518">  return pCsr;</Line>
  <Line number="8519">}</Line>
  <Line number="8520"></Line>
  <Line number="8521">static void zipfileFunctionCds(</Line>
  <Line number="8522">  sqlite3_context *context,</Line>
  <Line number="8523">  int argc,</Line>
  <Line number="8524">  sqlite3_value **argv</Line>
  <Line number="8525">){</Line>
  <Line number="8526">  ZipfileCsr *pCsr;</Line>
  <Line number="8527">  ZipfileTab *pTab = (ZipfileTab*)sqlite3_user_data(context);</Line>
  <Line number="8528">  assert( argc&gt;0 );</Line>
  <Line number="8529"></Line>
  <Line number="8530">  pCsr = zipfileFindCursor(pTab, sqlite3_value_int64(argv[0]));</Line>
  <Line number="8531">  if( pCsr ){</Line>
  <Line number="8532">    ZipfileCDS *p = &amp;pCsr-&gt;pCurrent-&gt;cds;</Line>
  <Line number="8533">    char *zRes = sqlite3_mprintf(&quot;{&quot;</Line>
  <Line number="8534">        &quot;\&quot;version-made-by\&quot; : %u, &quot;</Line>
  <Line number="8535">        &quot;\&quot;version-to-extract\&quot; : %u, &quot;</Line>
  <Line number="8536">        &quot;\&quot;flags\&quot; : %u, &quot;</Line>
  <Line number="8537">        &quot;\&quot;compression\&quot; : %u, &quot;</Line>
  <Line number="8538">        &quot;\&quot;time\&quot; : %u, &quot;</Line>
  <Line number="8539">        &quot;\&quot;date\&quot; : %u, &quot;</Line>
  <Line number="8540">        &quot;\&quot;crc32\&quot; : %u, &quot;</Line>
  <Line number="8541">        &quot;\&quot;compressed-size\&quot; : %u, &quot;</Line>
  <Line number="8542">        &quot;\&quot;uncompressed-size\&quot; : %u, &quot;</Line>
  <Line number="8543">        &quot;\&quot;file-name-length\&quot; : %u, &quot;</Line>
  <Line number="8544">        &quot;\&quot;extra-field-length\&quot; : %u, &quot;</Line>
  <Line number="8545">        &quot;\&quot;file-comment-length\&quot; : %u, &quot;</Line>
  <Line number="8546">        &quot;\&quot;disk-number-start\&quot; : %u, &quot;</Line>
  <Line number="8547">        &quot;\&quot;internal-attr\&quot; : %u, &quot;</Line>
  <Line number="8548">        &quot;\&quot;external-attr\&quot; : %u, &quot;</Line>
  <Line number="8549">        &quot;\&quot;offset\&quot; : %u }&quot;,</Line>
  <Line number="8550">        (u32)p-&gt;iVersionMadeBy, (u32)p-&gt;iVersionExtract,</Line>
  <Line number="8551">        (u32)p-&gt;flags, (u32)p-&gt;iCompression,</Line>
  <Line number="8552">        (u32)p-&gt;mTime, (u32)p-&gt;mDate,</Line>
  <Line number="8553">        (u32)p-&gt;crc32, (u32)p-&gt;szCompressed,</Line>
  <Line number="8554">        (u32)p-&gt;szUncompressed, (u32)p-&gt;nFile,</Line>
  <Line number="8555">        (u32)p-&gt;nExtra, (u32)p-&gt;nComment,</Line>
  <Line number="8556">        (u32)p-&gt;iDiskStart, (u32)p-&gt;iInternalAttr,</Line>
  <Line number="8557">        (u32)p-&gt;iExternalAttr, (u32)p-&gt;iOffset</Line>
  <Line number="8558">    );</Line>
  <Line number="8559"></Line>
  <Line number="8560">    if( zRes==0 ){</Line>
  <Line number="8561">      sqlite3_result_error_nomem(context);</Line>
  <Line number="8562">    }else{</Line>
  <Line number="8563">      sqlite3_result_text(context, zRes, -1, SQLITE_TRANSIENT);</Line>
  <Line number="8564">      sqlite3_free(zRes);</Line>
  <Line number="8565">    }</Line>
  <Line number="8566">  }</Line>
  <Line number="8567">}</Line>
  <Line number="8568"></Line>
  <Line number="8569">/*</Line>
  <Line number="8570">** xFindFunction method.</Line>
  <Line number="8571">*/</Line>
  <Line number="8572">static int zipfileFindFunction(</Line>
  <Line number="8573">  sqlite3_vtab *pVtab,            /* Virtual table handle */</Line>
  <Line number="8574">  int nArg,                       /* Number of SQL function arguments */</Line>
  <Line number="8575">  const char *zName,              /* Name of SQL function */</Line>
  <Line number="8576">  void (**pxFunc)(sqlite3_context*,int,sqlite3_value**), /* OUT: Result */</Line>
  <Line number="8577">  void **ppArg                    /* OUT: User data for *pxFunc */</Line>
  <Line number="8578">){</Line>
  <Line number="8579">  if( sqlite3_stricmp(&quot;zipfile_cds&quot;, zName)==0 ){</Line>
  <Line number="8580">    *pxFunc = zipfileFunctionCds;</Line>
  <Line number="8581">    *ppArg = (void*)pVtab;</Line>
  <Line number="8582">    return 1;</Line>
  <Line number="8583">  }</Line>
  <Line number="8584">  return 0;</Line>
  <Line number="8585">}</Line>
  <Line number="8586"></Line>
  <Line number="8587">typedef struct ZipfileBuffer ZipfileBuffer;</Line>
  <Line number="8588">struct ZipfileBuffer {</Line>
  <Line number="8589">  u8 *a;                          /* Pointer to buffer */</Line>
  <Line number="8590">  int n;                          /* Size of buffer in bytes */</Line>
  <Line number="8591">  int nAlloc;                     /* Byte allocated at a[] */</Line>
  <Line number="8592">};</Line>
  <Line number="8593"></Line>
  <Line number="8594">typedef struct ZipfileCtx ZipfileCtx;</Line>
  <Line number="8595">struct ZipfileCtx {</Line>
  <Line number="8596">  int nEntry;</Line>
  <Line number="8597">  ZipfileBuffer body;</Line>
  <Line number="8598">  ZipfileBuffer cds;</Line>
  <Line number="8599">};</Line>
  <Line number="8600"></Line>
  <Line number="8601">static int zipfileBufferGrow(ZipfileBuffer *pBuf, int nByte){</Line>
  <Line number="8602">  if( pBuf-&gt;n+nByte&gt;pBuf-&gt;nAlloc ){</Line>
  <Line number="8603">    u8 *aNew;</Line>
  <Line number="8604">    sqlite3_int64 nNew = pBuf-&gt;n ? pBuf-&gt;n*2 : 512;</Line>
  <Line number="8605">    int nReq = pBuf-&gt;n + nByte;</Line>
  <Line number="8606"></Line>
  <Line number="8607">    while( nNew&lt;nReq ) nNew = nNew*2;</Line>
  <Line number="8608">    aNew = sqlite3_realloc64(pBuf-&gt;a, nNew);</Line>
  <Line number="8609">    if( aNew==0 ) return SQLITE_NOMEM;</Line>
  <Line number="8610">    pBuf-&gt;a = aNew;</Line>
  <Line number="8611">    pBuf-&gt;nAlloc = (int)nNew;</Line>
  <Line number="8612">  }</Line>
  <Line number="8613">  return SQLITE_OK;</Line>
  <Line number="8614">}</Line>
  <Line number="8615"></Line>
  <Line number="8616">/*</Line>
  <Line number="8617">** xStep() callback for the zipfile() aggregate. This can be called in</Line>
  <Line number="8618">** any of the following ways:</Line>
  <Line number="8619">**</Line>
  <Line number="8620">**   SELECT zipfile(name,data) ...</Line>
  <Line number="8621">**   SELECT zipfile(name,mode,mtime,data) ...</Line>
  <Line number="8622">**   SELECT zipfile(name,mode,mtime,data,method) ...</Line>
  <Line number="8623">*/</Line>
  <Line number="8624">void zipfileStep(sqlite3_context *pCtx, int nVal, sqlite3_value **apVal){</Line>
  <Line number="8625">  ZipfileCtx *p;                  /* Aggregate function context */</Line>
  <Line number="8626">  ZipfileEntry e;                 /* New entry to add to zip archive */</Line>
  <Line number="8627"></Line>
  <Line number="8628">  sqlite3_value *pName = 0;</Line>
  <Line number="8629">  sqlite3_value *pMode = 0;</Line>
  <Line number="8630">  sqlite3_value *pMtime = 0;</Line>
  <Line number="8631">  sqlite3_value *pData = 0;</Line>
  <Line number="8632">  sqlite3_value *pMethod = 0;</Line>
  <Line number="8633"></Line>
  <Line number="8634">  int bIsDir = 0;</Line>
  <Line number="8635">  u32 mode;</Line>
  <Line number="8636">  int rc = SQLITE_OK;</Line>
  <Line number="8637">  char *zErr = 0;</Line>
  <Line number="8638"></Line>
  <Line number="8639">  int iMethod = -1;               /* Compression method to use (0 or 8) */</Line>
  <Line number="8640"></Line>
  <Line number="8641">  const u8 *aData = 0;            /* Possibly compressed data for new entry */</Line>
  <Line number="8642">  int nData = 0;                  /* Size of aData[] in bytes */</Line>
  <Line number="8643">  int szUncompressed = 0;         /* Size of data before compression */</Line>
  <Line number="8644">  u8 *aFree = 0;                  /* Free this before returning */</Line>
  <Line number="8645">  u32 iCrc32 = 0;                 /* crc32 of uncompressed data */</Line>
  <Line number="8646"></Line>
  <Line number="8647">  char *zName = 0;                /* Path (name) of new entry */</Line>
  <Line number="8648">  int nName = 0;                  /* Size of zName in bytes */</Line>
  <Line number="8649">  char *zFree = 0;                /* Free this before returning */</Line>
  <Line number="8650">  int nByte;</Line>
  <Line number="8651"></Line>
  <Line number="8652">  memset(&amp;e, 0, sizeof(e));</Line>
  <Line number="8653">  p = (ZipfileCtx*)sqlite3_aggregate_context(pCtx, sizeof(ZipfileCtx));</Line>
  <Line number="8654">  if( p==0 ) return;</Line>
  <Line number="8655"></Line>
  <Line number="8656">  /* Martial the arguments into stack variables */</Line>
  <Line number="8657">  if( nVal!=2 &amp;&amp; nVal!=4 &amp;&amp; nVal!=5 ){</Line>
  <Line number="8658">    zErr = sqlite3_mprintf(&quot;wrong number of arguments to function zipfile()&quot;);</Line>
  <Line number="8659">    rc = SQLITE_ERROR;</Line>
  <Line number="8660">    goto zipfile_step_out;</Line>
  <Line number="8661">  }</Line>
  <Line number="8662">  pName = apVal[0];</Line>
  <Line number="8663">  if( nVal==2 ){</Line>
  <Line number="8664">    pData = apVal[1];</Line>
  <Line number="8665">  }else{</Line>
  <Line number="8666">    pMode = apVal[1];</Line>
  <Line number="8667">    pMtime = apVal[2];</Line>
  <Line number="8668">    pData = apVal[3];</Line>
  <Line number="8669">    if( nVal==5 ){</Line>
  <Line number="8670">      pMethod = apVal[4];</Line>
  <Line number="8671">    }</Line>
  <Line number="8672">  }</Line>
  <Line number="8673"></Line>
  <Line number="8674">  /* Check that the &apos;name&apos; parameter looks ok. */</Line>
  <Line number="8675">  zName = (char*)sqlite3_value_text(pName);</Line>
  <Line number="8676">  nName = sqlite3_value_bytes(pName);</Line>
  <Line number="8677">  if( zName==0 ){</Line>
  <Line number="8678">    zErr = sqlite3_mprintf(&quot;first argument to zipfile() must be non-NULL&quot;);</Line>
  <Line number="8679">    rc = SQLITE_ERROR;</Line>
  <Line number="8680">    goto zipfile_step_out;</Line>
  <Line number="8681">  }</Line>
  <Line number="8682"></Line>
  <Line number="8683">  /* Inspect the &apos;method&apos; parameter. This must be either 0 (store), 8 (use</Line>
  <Line number="8684">  ** deflate compression) or NULL (choose automatically).  */</Line>
  <Line number="8685">  if( pMethod &amp;&amp; SQLITE_NULL!=sqlite3_value_type(pMethod) ){</Line>
  <Line number="8686">    iMethod = (int)sqlite3_value_int64(pMethod);</Line>
  <Line number="8687">    if( iMethod!=0 &amp;&amp; iMethod!=8 ){</Line>
  <Line number="8688">      zErr = sqlite3_mprintf(&quot;illegal method value: %d&quot;, iMethod);</Line>
  <Line number="8689">      rc = SQLITE_ERROR;</Line>
  <Line number="8690">      goto zipfile_step_out;</Line>
  <Line number="8691">    }</Line>
  <Line number="8692">  }</Line>
  <Line number="8693"></Line>
  <Line number="8694">  /* Now inspect the data. If this is NULL, then the new entry must be a</Line>
  <Line number="8695">  ** directory.  Otherwise, figure out whether or not the data should</Line>
  <Line number="8696">  ** be deflated or simply stored in the zip archive. */</Line>
  <Line number="8697">  if( sqlite3_value_type(pData)==SQLITE_NULL ){</Line>
  <Line number="8698">    bIsDir = 1;</Line>
  <Line number="8699">    iMethod = 0;</Line>
  <Line number="8700">  }else{</Line>
  <Line number="8701">    aData = sqlite3_value_blob(pData);</Line>
  <Line number="8702">    szUncompressed = nData = sqlite3_value_bytes(pData);</Line>
  <Line number="8703">    iCrc32 = crc32(0, aData, nData);</Line>
  <Line number="8704">    if( iMethod&lt;0 || iMethod==8 ){</Line>
  <Line number="8705">      int nOut = 0;</Line>
  <Line number="8706">      rc = zipfileDeflate(aData, nData, &amp;aFree, &amp;nOut, &amp;zErr);</Line>
  <Line number="8707">      if( rc!=SQLITE_OK ){</Line>
  <Line number="8708">        goto zipfile_step_out;</Line>
  <Line number="8709">      }</Line>
  <Line number="8710">      if( iMethod==8 || nOut&lt;nData ){</Line>
  <Line number="8711">        aData = aFree;</Line>
  <Line number="8712">        nData = nOut;</Line>
  <Line number="8713">        iMethod = 8;</Line>
  <Line number="8714">      }else{</Line>
  <Line number="8715">        iMethod = 0;</Line>
  <Line number="8716">      }</Line>
  <Line number="8717">    }</Line>
  <Line number="8718">  }</Line>
  <Line number="8719"></Line>
  <Line number="8720">  /* Decode the &quot;mode&quot; argument. */</Line>
  <Line number="8721">  rc = zipfileGetMode(pMode, bIsDir, &amp;mode, &amp;zErr);</Line>
  <Line number="8722">  if( rc ) goto zipfile_step_out;</Line>
  <Line number="8723"></Line>
  <Line number="8724">  /* Decode the &quot;mtime&quot; argument. */</Line>
  <Line number="8725">  e.mUnixTime = zipfileGetTime(pMtime);</Line>
  <Line number="8726"></Line>
  <Line number="8727">  /* If this is a directory entry, ensure that there is exactly one &apos;/&apos;</Line>
  <Line number="8728">  ** at the end of the path. Or, if this is not a directory and the path</Line>
  <Line number="8729">  ** ends in &apos;/&apos; it is an error. */</Line>
  <Line number="8730">  if( bIsDir==0 ){</Line>
  <Line number="8731">    if( nName&gt;0 &amp;&amp; zName[nName-1]==&apos;/&apos; ){</Line>
  <Line number="8732">      zErr = sqlite3_mprintf(&quot;non-directory name must not end with /&quot;);</Line>
  <Line number="8733">      rc = SQLITE_ERROR;</Line>
  <Line number="8734">      goto zipfile_step_out;</Line>
  <Line number="8735">    }</Line>
  <Line number="8736">  }else{</Line>
  <Line number="8737">    if( nName==0 || zName[nName-1]!=&apos;/&apos; ){</Line>
  <Line number="8738">      zName = zFree = sqlite3_mprintf(&quot;%s/&quot;, zName);</Line>
  <Line number="8739">      if( zName==0 ){</Line>
  <Line number="8740">        rc = SQLITE_NOMEM;</Line>
  <Line number="8741">        goto zipfile_step_out;</Line>
  <Line number="8742">      }</Line>
  <Line number="8743">      nName = (int)strlen(zName);</Line>
  <Line number="8744">    }else{</Line>
  <Line number="8745">      while( nName&gt;1 &amp;&amp; zName[nName-2]==&apos;/&apos; ) nName--;</Line>
  <Line number="8746">    }</Line>
  <Line number="8747">  }</Line>
  <Line number="8748"></Line>
  <Line number="8749">  /* Assemble the ZipfileEntry object for the new zip archive entry */</Line>
  <Line number="8750">  e.cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;</Line>
  <Line number="8751">  e.cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;</Line>
  <Line number="8752">  e.cds.flags = ZIPFILE_NEWENTRY_FLAGS;</Line>
  <Line number="8753">  e.cds.iCompression = (u16)iMethod;</Line>
  <Line number="8754">  zipfileMtimeToDos(&amp;e.cds, (u32)e.mUnixTime);</Line>
  <Line number="8755">  e.cds.crc32 = iCrc32;</Line>
  <Line number="8756">  e.cds.szCompressed = nData;</Line>
  <Line number="8757">  e.cds.szUncompressed = szUncompressed;</Line>
  <Line number="8758">  e.cds.iExternalAttr = (mode&lt;&lt;16);</Line>
  <Line number="8759">  e.cds.iOffset = p-&gt;body.n;</Line>
  <Line number="8760">  e.cds.nFile = (u16)nName;</Line>
  <Line number="8761">  e.cds.zFile = zName;</Line>
  <Line number="8762"></Line>
  <Line number="8763">  /* Append the LFH to the body of the new archive */</Line>
  <Line number="8764">  nByte = ZIPFILE_LFH_FIXED_SZ + e.cds.nFile + 9;</Line>
  <Line number="8765">  if( (rc = zipfileBufferGrow(&amp;p-&gt;body, nByte)) ) goto zipfile_step_out;</Line>
  <Line number="8766">  p-&gt;body.n += zipfileSerializeLFH(&amp;e, &amp;p-&gt;body.a[p-&gt;body.n]);</Line>
  <Line number="8767"></Line>
  <Line number="8768">  /* Append the data to the body of the new archive */</Line>
  <Line number="8769">  if( nData&gt;0 ){</Line>
  <Line number="8770">    if( (rc = zipfileBufferGrow(&amp;p-&gt;body, nData)) ) goto zipfile_step_out;</Line>
  <Line number="8771">    memcpy(&amp;p-&gt;body.a[p-&gt;body.n], aData, nData);</Line>
  <Line number="8772">    p-&gt;body.n += nData;</Line>
  <Line number="8773">  }</Line>
  <Line number="8774"></Line>
  <Line number="8775">  /* Append the CDS record to the directory of the new archive */</Line>
  <Line number="8776">  nByte = ZIPFILE_CDS_FIXED_SZ + e.cds.nFile + 9;</Line>
  <Line number="8777">  if( (rc = zipfileBufferGrow(&amp;p-&gt;cds, nByte)) ) goto zipfile_step_out;</Line>
  <Line number="8778">  p-&gt;cds.n += zipfileSerializeCDS(&amp;e, &amp;p-&gt;cds.a[p-&gt;cds.n]);</Line>
  <Line number="8779"></Line>
  <Line number="8780">  /* Increment the count of entries in the archive */</Line>
  <Line number="8781">  p-&gt;nEntry++;</Line>
  <Line number="8782"></Line>
  <Line number="8783"> zipfile_step_out:</Line>
  <Line number="8784">  sqlite3_free(aFree);</Line>
  <Line number="8785">  sqlite3_free(zFree);</Line>
  <Line number="8786">  if( rc ){</Line>
  <Line number="8787">    if( zErr ){</Line>
  <Line number="8788">      sqlite3_result_error(pCtx, zErr, -1);</Line>
  <Line number="8789">    }else{</Line>
  <Line number="8790">      sqlite3_result_error_code(pCtx, rc);</Line>
  <Line number="8791">    }</Line>
  <Line number="8792">  }</Line>
  <Line number="8793">  sqlite3_free(zErr);</Line>
  <Line number="8794">}</Line>
  <Line number="8795"></Line>
  <Line number="8796">/*</Line>
  <Line number="8797">** xFinalize() callback for zipfile aggregate function.</Line>
  <Line number="8798">*/</Line>
  <Line number="8799">void zipfileFinal(sqlite3_context *pCtx){</Line>
  <Line number="8800">  ZipfileCtx *p;</Line>
  <Line number="8801">  ZipfileEOCD eocd;</Line>
  <Line number="8802">  sqlite3_int64 nZip;</Line>
  <Line number="8803">  u8 *aZip;</Line>
  <Line number="8804"></Line>
  <Line number="8805">  p = (ZipfileCtx*)sqlite3_aggregate_context(pCtx, sizeof(ZipfileCtx));</Line>
  <Line number="8806">  if( p==0 ) return;</Line>
  <Line number="8807">  if( p-&gt;nEntry&gt;0 ){</Line>
  <Line number="8808">    memset(&amp;eocd, 0, sizeof(eocd));</Line>
  <Line number="8809">    eocd.nEntry = (u16)p-&gt;nEntry;</Line>
  <Line number="8810">    eocd.nEntryTotal = (u16)p-&gt;nEntry;</Line>
  <Line number="8811">    eocd.nSize = p-&gt;cds.n;</Line>
  <Line number="8812">    eocd.iOffset = p-&gt;body.n;</Line>
  <Line number="8813"></Line>
  <Line number="8814">    nZip = p-&gt;body.n + p-&gt;cds.n + ZIPFILE_EOCD_FIXED_SZ;</Line>
  <Line number="8815">    aZip = (u8*)sqlite3_malloc64(nZip);</Line>
  <Line number="8816">    if( aZip==0 ){</Line>
  <Line number="8817">      sqlite3_result_error_nomem(pCtx);</Line>
  <Line number="8818">    }else{</Line>
  <Line number="8819">      memcpy(aZip, p-&gt;body.a, p-&gt;body.n);</Line>
  <Line number="8820">      memcpy(&amp;aZip[p-&gt;body.n], p-&gt;cds.a, p-&gt;cds.n);</Line>
  <Line number="8821">      zipfileSerializeEOCD(&amp;eocd, &amp;aZip[p-&gt;body.n + p-&gt;cds.n]);</Line>
  <Line number="8822">      sqlite3_result_blob(pCtx, aZip, (int)nZip, zipfileFree);</Line>
  <Line number="8823">    }</Line>
  <Line number="8824">  }</Line>
  <Line number="8825"></Line>
  <Line number="8826">  sqlite3_free(p-&gt;body.a);</Line>
  <Line number="8827">  sqlite3_free(p-&gt;cds.a);</Line>
  <Line number="8828">}</Line>
  <Line number="8829"></Line>
  <Line number="8830"></Line>
  <Line number="8831">/*</Line>
  <Line number="8832">** Register the &quot;zipfile&quot; virtual table.</Line>
  <Line number="8833">*/</Line>
  <Line number="8834">static int zipfileRegister(sqlite3 *db){</Line>
  <Line number="8835">  static sqlite3_module zipfileModule = {</Line>
  <Line number="8836">    1,                         /* iVersion */</Line>
  <Line number="8837">    zipfileConnect,            /* xCreate */</Line>
  <Line number="8838">    zipfileConnect,            /* xConnect */</Line>
  <Line number="8839">    zipfileBestIndex,          /* xBestIndex */</Line>
  <Line number="8840">    zipfileDisconnect,         /* xDisconnect */</Line>
  <Line number="8841">    zipfileDisconnect,         /* xDestroy */</Line>
  <Line number="8842">    zipfileOpen,               /* xOpen - open a cursor */</Line>
  <Line number="8843">    zipfileClose,              /* xClose - close a cursor */</Line>
  <Line number="8844">    zipfileFilter,             /* xFilter - configure scan constraints */</Line>
  <Line number="8845">    zipfileNext,               /* xNext - advance a cursor */</Line>
  <Line number="8846">    zipfileEof,                /* xEof - check for end of scan */</Line>
  <Line number="8847">    zipfileColumn,             /* xColumn - read data */</Line>
  <Line number="8848">    0,                         /* xRowid - read data */</Line>
  <Line number="8849">    zipfileUpdate,             /* xUpdate */</Line>
  <Line number="8850">    zipfileBegin,              /* xBegin */</Line>
  <Line number="8851">    0,                         /* xSync */</Line>
  <Line number="8852">    zipfileCommit,             /* xCommit */</Line>
  <Line number="8853">    zipfileRollback,           /* xRollback */</Line>
  <Line number="8854">    zipfileFindFunction,       /* xFindMethod */</Line>
  <Line number="8855">    0,                         /* xRename */</Line>
  <Line number="8856">  };</Line>
  <Line number="8857"></Line>
  <Line number="8858">  int rc = sqlite3_create_module(db, &quot;zipfile&quot;  , &amp;zipfileModule, 0);</Line>
  <Line number="8859">  if( rc==SQLITE_OK ) rc = sqlite3_overload_function(db, &quot;zipfile_cds&quot;, -1);</Line>
  <Line number="8860">  if( rc==SQLITE_OK ){</Line>
  <Line number="8861">    rc = sqlite3_create_function(db, &quot;zipfile&quot;, -1, SQLITE_UTF8, 0, 0, </Line>
  <Line number="8862">        zipfileStep, zipfileFinal</Line>
  <Line number="8863">    );</Line>
  <Line number="8864">  }</Line>
  <Line number="8865">  assert( sizeof(i64)==8 );</Line>
  <Line number="8866">  assert( sizeof(u32)==4 );</Line>
  <Line number="8867">  assert( sizeof(u16)==2 );</Line>
  <Line number="8868">  assert( sizeof(u8)==1 );</Line>
  <Line number="8869">  return rc;</Line>
  <Line number="8870">}</Line>
  <Line number="8871">#else         /* SQLITE_OMIT_VIRTUALTABLE */</Line>
  <Line number="8872"># define zipfileRegister(x) SQLITE_OK</Line>
  <Line number="8873">#endif</Line>
  <Line number="8874"></Line>
  <Line number="8875">#ifdef _WIN32</Line>
  <Line number="8876"></Line>
  <Line number="8877">#endif</Line>
  <Line number="8878">int sqlite3_zipfile_init(</Line>
  <Line number="8879">  sqlite3 *db, </Line>
  <Line number="8880">  char **pzErrMsg, </Line>
  <Line number="8881">  const sqlite3_api_routines *pApi</Line>
  <Line number="8882">){</Line>
  <Line number="8883">  SQLITE_EXTENSION_INIT2(pApi);</Line>
  <Line number="8884">  (void)pzErrMsg;  /* Unused parameter */</Line>
  <Line number="8885">  return zipfileRegister(db);</Line>
  <Line number="8886">}</Line>
  <Line number="8887"></Line>
  <Line number="8888">/************************* End ../ext/misc/zipfile.c ********************/</Line>
  <Line number="8889">/************************* Begin ../ext/misc/sqlar.c ******************/</Line>
  <Line number="8890">/*</Line>
  <Line number="8891">** 2017-12-17</Line>
  <Line number="8892">**</Line>
  <Line number="8893">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="8894">** a legal notice, here is a blessing:</Line>
  <Line number="8895">**</Line>
  <Line number="8896">**    May you do good and not evil.</Line>
  <Line number="8897">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="8898">**    May you share freely, never taking more than you give.</Line>
  <Line number="8899">**</Line>
  <Line number="8900">******************************************************************************</Line>
  <Line number="8901">**</Line>
  <Line number="8902">** Utility functions sqlar_compress() and sqlar_uncompress(). Useful</Line>
  <Line number="8903">** for working with sqlar archives and used by the shell tool&apos;s built-in</Line>
  <Line number="8904">** sqlar support.</Line>
  <Line number="8905">*/</Line>
  <Line number="8906">/* #include &quot;sqlite3ext.h&quot; */</Line>
  <Line number="8907">SQLITE_EXTENSION_INIT1</Line>
  <Line number="8908">#include &lt;zlib.h&gt;</Line>
  <Line number="8909">#include &lt;assert.h&gt;</Line>
  <Line number="8910"></Line>
  <Line number="8911">/*</Line>
  <Line number="8912">** Implementation of the &quot;sqlar_compress(X)&quot; SQL function.</Line>
  <Line number="8913">**</Line>
  <Line number="8914">** If the type of X is SQLITE_BLOB, and compressing that blob using</Line>
  <Line number="8915">** zlib utility function compress() yields a smaller blob, return the</Line>
  <Line number="8916">** compressed blob. Otherwise, return a copy of X.</Line>
  <Line number="8917">**</Line>
  <Line number="8918">** SQLar uses the &quot;zlib format&quot; for compressed content.  The zlib format</Line>
  <Line number="8919">** contains a two-byte identification header and a four-byte checksum at</Line>
  <Line number="8920">** the end.  This is different from ZIP which uses the raw deflate format.</Line>
  <Line number="8921">**</Line>
  <Line number="8922">** Future enhancements to SQLar might add support for new compression formats.</Line>
  <Line number="8923">** If so, those new formats will be identified by alternative headers in the</Line>
  <Line number="8924">** compressed data.</Line>
  <Line number="8925">*/</Line>
  <Line number="8926">static void sqlarCompressFunc(</Line>
  <Line number="8927">  sqlite3_context *context,</Line>
  <Line number="8928">  int argc,</Line>
  <Line number="8929">  sqlite3_value **argv</Line>
  <Line number="8930">){</Line>
  <Line number="8931">  assert( argc==1 );</Line>
  <Line number="8932">  if( sqlite3_value_type(argv[0])==SQLITE_BLOB ){</Line>
  <Line number="8933">    const Bytef *pData = sqlite3_value_blob(argv[0]);</Line>
  <Line number="8934">    uLong nData = sqlite3_value_bytes(argv[0]);</Line>
  <Line number="8935">    uLongf nOut = compressBound(nData);</Line>
  <Line number="8936">    Bytef *pOut;</Line>
  <Line number="8937"></Line>
  <Line number="8938">    pOut = (Bytef*)sqlite3_malloc(nOut);</Line>
  <Line number="8939">    if( pOut==0 ){</Line>
  <Line number="8940">      sqlite3_result_error_nomem(context);</Line>
  <Line number="8941">      return;</Line>
  <Line number="8942">    }else{</Line>
  <Line number="8943">      if( Z_OK!=compress(pOut, &amp;nOut, pData, nData) ){</Line>
  <Line number="8944">        sqlite3_result_error(context, &quot;error in compress()&quot;, -1);</Line>
  <Line number="8945">      }else if( nOut&lt;nData ){</Line>
  <Line number="8946">        sqlite3_result_blob(context, pOut, nOut, SQLITE_TRANSIENT);</Line>
  <Line number="8947">      }else{</Line>
  <Line number="8948">        sqlite3_result_value(context, argv[0]);</Line>
  <Line number="8949">      }</Line>
  <Line number="8950">      sqlite3_free(pOut);</Line>
  <Line number="8951">    }</Line>
  <Line number="8952">  }else{</Line>
  <Line number="8953">    sqlite3_result_value(context, argv[0]);</Line>
  <Line number="8954">  }</Line>
  <Line number="8955">}</Line>
  <Line number="8956"></Line>
  <Line number="8957">/*</Line>
  <Line number="8958">** Implementation of the &quot;sqlar_uncompress(X,SZ)&quot; SQL function</Line>
  <Line number="8959">**</Line>
  <Line number="8960">** Parameter SZ is interpreted as an integer. If it is less than or</Line>
  <Line number="8961">** equal to zero, then this function returns a copy of X. Or, if</Line>
  <Line number="8962">** SZ is equal to the size of X when interpreted as a blob, also</Line>
  <Line number="8963">** return a copy of X. Otherwise, decompress blob X using zlib</Line>
  <Line number="8964">** utility function uncompress() and return the results (another</Line>
  <Line number="8965">** blob).</Line>
  <Line number="8966">*/</Line>
  <Line number="8967">static void sqlarUncompressFunc(</Line>
  <Line number="8968">  sqlite3_context *context,</Line>
  <Line number="8969">  int argc,</Line>
  <Line number="8970">  sqlite3_value **argv</Line>
  <Line number="8971">){</Line>
  <Line number="8972">  uLong nData;</Line>
  <Line number="8973">  uLongf sz;</Line>
  <Line number="8974"></Line>
  <Line number="8975">  assert( argc==2 );</Line>
  <Line number="8976">  sz = sqlite3_value_int(argv[1]);</Line>
  <Line number="8977"></Line>
  <Line number="8978">  if( sz&lt;=0 || sz==(nData = sqlite3_value_bytes(argv[0])) ){</Line>
  <Line number="8979">    sqlite3_result_value(context, argv[0]);</Line>
  <Line number="8980">  }else{</Line>
  <Line number="8981">    const Bytef *pData= sqlite3_value_blob(argv[0]);</Line>
  <Line number="8982">    Bytef *pOut = sqlite3_malloc(sz);</Line>
  <Line number="8983">    if( Z_OK!=uncompress(pOut, &amp;sz, pData, nData) ){</Line>
  <Line number="8984">      sqlite3_result_error(context, &quot;error in uncompress()&quot;, -1);</Line>
  <Line number="8985">    }else{</Line>
  <Line number="8986">      sqlite3_result_blob(context, pOut, sz, SQLITE_TRANSIENT);</Line>
  <Line number="8987">    }</Line>
  <Line number="8988">    sqlite3_free(pOut);</Line>
  <Line number="8989">  }</Line>
  <Line number="8990">}</Line>
  <Line number="8991"></Line>
  <Line number="8992"></Line>
  <Line number="8993">#ifdef _WIN32</Line>
  <Line number="8994"></Line>
  <Line number="8995">#endif</Line>
  <Line number="8996">int sqlite3_sqlar_init(</Line>
  <Line number="8997">  sqlite3 *db, </Line>
  <Line number="8998">  char **pzErrMsg, </Line>
  <Line number="8999">  const sqlite3_api_routines *pApi</Line>
  <Line number="9000">){</Line>
  <Line number="9001">  int rc = SQLITE_OK;</Line>
  <Line number="9002">  SQLITE_EXTENSION_INIT2(pApi);</Line>
  <Line number="9003">  (void)pzErrMsg;  /* Unused parameter */</Line>
  <Line number="9004">  rc = sqlite3_create_function(db, &quot;sqlar_compress&quot;, 1, </Line>
  <Line number="9005">                               SQLITE_UTF8|SQLITE_INNOCUOUS, 0,</Line>
  <Line number="9006">                               sqlarCompressFunc, 0, 0);</Line>
  <Line number="9007">  if( rc==SQLITE_OK ){</Line>
  <Line number="9008">    rc = sqlite3_create_function(db, &quot;sqlar_uncompress&quot;, 2,</Line>
  <Line number="9009">                                 SQLITE_UTF8|SQLITE_INNOCUOUS, 0,</Line>
  <Line number="9010">                                 sqlarUncompressFunc, 0, 0);</Line>
  <Line number="9011">  }</Line>
  <Line number="9012">  return rc;</Line>
  <Line number="9013">}</Line>
  <Line number="9014"></Line>
  <Line number="9015">/************************* End ../ext/misc/sqlar.c ********************/</Line>
  <Line number="9016">#endif</Line>
  <Line number="9017">/************************* Begin ../ext/expert/sqlite3expert.h ******************/</Line>
  <Line number="9018">/*</Line>
  <Line number="9019">** 2017 April 07</Line>
  <Line number="9020">**</Line>
  <Line number="9021">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="9022">** a legal notice, here is a blessing:</Line>
  <Line number="9023">**</Line>
  <Line number="9024">**    May you do good and not evil.</Line>
  <Line number="9025">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="9026">**    May you share freely, never taking more than you give.</Line>
  <Line number="9027">**</Line>
  <Line number="9028">*************************************************************************</Line>
  <Line number="9029">*/</Line>
  <Line number="9030">#if !defined(SQLITEEXPERT_H)</Line>
  <Line number="9031">#define SQLITEEXPERT_H 1</Line>
  <Line number="9032">/* #include &quot;sqlite3.h&quot; */</Line>
  <Line number="9033"></Line>
  <Line number="9034">typedef struct sqlite3expert sqlite3expert;</Line>
  <Line number="9035"></Line>
  <Line number="9036">/*</Line>
  <Line number="9037">** Create a new sqlite3expert object.</Line>
  <Line number="9038">**</Line>
  <Line number="9039">** If successful, a pointer to the new object is returned and (*pzErr) set</Line>
  <Line number="9040">** to NULL. Or, if an error occurs, NULL is returned and (*pzErr) set to</Line>
  <Line number="9041">** an English-language error message. In this case it is the responsibility</Line>
  <Line number="9042">** of the caller to eventually free the error message buffer using</Line>
  <Line number="9043">** sqlite3_free().</Line>
  <Line number="9044">*/</Line>
  <Line number="9045">sqlite3expert *sqlite3_expert_new(sqlite3 *db, char **pzErr);</Line>
  <Line number="9046"></Line>
  <Line number="9047">/*</Line>
  <Line number="9048">** Configure an sqlite3expert object.</Line>
  <Line number="9049">**</Line>
  <Line number="9050">** EXPERT_CONFIG_SAMPLE:</Line>
  <Line number="9051">**   By default, sqlite3_expert_analyze() generates sqlite_stat1 data for</Line>
  <Line number="9052">**   each candidate index. This involves scanning and sorting the entire</Line>
  <Line number="9053">**   contents of each user database table once for each candidate index</Line>
  <Line number="9054">**   associated with the table. For large databases, this can be </Line>
  <Line number="9055">**   prohibitively slow. This option allows the sqlite3expert object to</Line>
  <Line number="9056">**   be configured so that sqlite_stat1 data is instead generated based on a</Line>
  <Line number="9057">**   subset of each table, or so that no sqlite_stat1 data is used at all.</Line>
  <Line number="9058">**</Line>
  <Line number="9059">**   A single integer argument is passed to this option. If the value is less</Line>
  <Line number="9060">**   than or equal to zero, then no sqlite_stat1 data is generated or used by</Line>
  <Line number="9061">**   the analysis - indexes are recommended based on the database schema only.</Line>
  <Line number="9062">**   Or, if the value is 100 or greater, complete sqlite_stat1 data is</Line>
  <Line number="9063">**   generated for each candidate index (this is the default). Finally, if the</Line>
  <Line number="9064">**   value falls between 0 and 100, then it represents the percentage of user</Line>
  <Line number="9065">**   table rows that should be considered when generating sqlite_stat1 data.</Line>
  <Line number="9066">**</Line>
  <Line number="9067">**   Examples:</Line>
  <Line number="9068">**</Line>
  <Line number="9069">**     // Do not generate any sqlite_stat1 data</Line>
  <Line number="9070">**     sqlite3_expert_config(pExpert, EXPERT_CONFIG_SAMPLE, 0);</Line>
  <Line number="9071">**</Line>
  <Line number="9072">**     // Generate sqlite_stat1 data based on 10% of the rows in each table.</Line>
  <Line number="9073">**     sqlite3_expert_config(pExpert, EXPERT_CONFIG_SAMPLE, 10);</Line>
  <Line number="9074">*/</Line>
  <Line number="9075">int sqlite3_expert_config(sqlite3expert *p, int op, ...);</Line>
  <Line number="9076"></Line>
  <Line number="9077">#define EXPERT_CONFIG_SAMPLE 1    /* int */</Line>
  <Line number="9078"></Line>
  <Line number="9079">/*</Line>
  <Line number="9080">** Specify zero or more SQL statements to be included in the analysis.</Line>
  <Line number="9081">**</Line>
  <Line number="9082">** Buffer zSql must contain zero or more complete SQL statements. This</Line>
  <Line number="9083">** function parses all statements contained in the buffer and adds them</Line>
  <Line number="9084">** to the internal list of statements to analyze. If successful, SQLITE_OK</Line>
  <Line number="9085">** is returned and (*pzErr) set to NULL. Or, if an error occurs - for example</Line>
  <Line number="9086">** due to a error in the SQL - an SQLite error code is returned and (*pzErr)</Line>
  <Line number="9087">** may be set to point to an English language error message. In this case</Line>
  <Line number="9088">** the caller is responsible for eventually freeing the error message buffer</Line>
  <Line number="9089">** using sqlite3_free().</Line>
  <Line number="9090">**</Line>
  <Line number="9091">** If an error does occur while processing one of the statements in the</Line>
  <Line number="9092">** buffer passed as the second argument, none of the statements in the</Line>
  <Line number="9093">** buffer are added to the analysis.</Line>
  <Line number="9094">**</Line>
  <Line number="9095">** This function must be called before sqlite3_expert_analyze(). If a call</Line>
  <Line number="9096">** to this function is made on an sqlite3expert object that has already</Line>
  <Line number="9097">** been passed to sqlite3_expert_analyze() SQLITE_MISUSE is returned</Line>
  <Line number="9098">** immediately and no statements are added to the analysis.</Line>
  <Line number="9099">*/</Line>
  <Line number="9100">int sqlite3_expert_sql(</Line>
  <Line number="9101">  sqlite3expert *p,               /* From a successful sqlite3_expert_new() */</Line>
  <Line number="9102">  const char *zSql,               /* SQL statement(s) to add */</Line>
  <Line number="9103">  char **pzErr                    /* OUT: Error message (if any) */</Line>
  <Line number="9104">);</Line>
  <Line number="9105"></Line>
  <Line number="9106"></Line>
  <Line number="9107">/*</Line>
  <Line number="9108">** This function is called after the sqlite3expert object has been configured</Line>
  <Line number="9109">** with all SQL statements using sqlite3_expert_sql() to actually perform</Line>
  <Line number="9110">** the analysis. Once this function has been called, it is not possible to</Line>
  <Line number="9111">** add further SQL statements to the analysis.</Line>
  <Line number="9112">**</Line>
  <Line number="9113">** If successful, SQLITE_OK is returned and (*pzErr) is set to NULL. Or, if</Line>
  <Line number="9114">** an error occurs, an SQLite error code is returned and (*pzErr) set to </Line>
  <Line number="9115">** point to a buffer containing an English language error message. In this</Line>
  <Line number="9116">** case it is the responsibility of the caller to eventually free the buffer</Line>
  <Line number="9117">** using sqlite3_free().</Line>
  <Line number="9118">**</Line>
  <Line number="9119">** If an error does occur within this function, the sqlite3expert object</Line>
  <Line number="9120">** is no longer useful for any purpose. At that point it is no longer</Line>
  <Line number="9121">** possible to add further SQL statements to the object or to re-attempt</Line>
  <Line number="9122">** the analysis. The sqlite3expert object must still be freed using a call</Line>
  <Line number="9123">** sqlite3_expert_destroy().</Line>
  <Line number="9124">*/</Line>
  <Line number="9125">int sqlite3_expert_analyze(sqlite3expert *p, char **pzErr);</Line>
  <Line number="9126"></Line>
  <Line number="9127">/*</Line>
  <Line number="9128">** Return the total number of statements loaded using sqlite3_expert_sql().</Line>
  <Line number="9129">** The total number of SQL statements may be different from the total number</Line>
  <Line number="9130">** to calls to sqlite3_expert_sql().</Line>
  <Line number="9131">*/</Line>
  <Line number="9132">int sqlite3_expert_count(sqlite3expert*);</Line>
  <Line number="9133"></Line>
  <Line number="9134">/*</Line>
  <Line number="9135">** Return a component of the report.</Line>
  <Line number="9136">**</Line>
  <Line number="9137">** This function is called after sqlite3_expert_analyze() to extract the</Line>
  <Line number="9138">** results of the analysis. Each call to this function returns either a</Line>
  <Line number="9139">** NULL pointer or a pointer to a buffer containing a nul-terminated string.</Line>
  <Line number="9140">** The value passed as the third argument must be one of the EXPERT_REPORT_*</Line>
  <Line number="9141">** #define constants defined below.</Line>
  <Line number="9142">**</Line>
  <Line number="9143">** For some EXPERT_REPORT_* parameters, the buffer returned contains </Line>
  <Line number="9144">** information relating to a specific SQL statement. In these cases that</Line>
  <Line number="9145">** SQL statement is identified by the value passed as the second argument.</Line>
  <Line number="9146">** SQL statements are numbered from 0 in the order in which they are parsed.</Line>
  <Line number="9147">** If an out-of-range value (less than zero or equal to or greater than the</Line>
  <Line number="9148">** value returned by sqlite3_expert_count()) is passed as the second argument</Line>
  <Line number="9149">** along with such an EXPERT_REPORT_* parameter, NULL is always returned.</Line>
  <Line number="9150">**</Line>
  <Line number="9151">** EXPERT_REPORT_SQL:</Line>
  <Line number="9152">**   Return the text of SQL statement iStmt.</Line>
  <Line number="9153">**</Line>
  <Line number="9154">** EXPERT_REPORT_INDEXES:</Line>
  <Line number="9155">**   Return a buffer containing the CREATE INDEX statements for all recommended</Line>
  <Line number="9156">**   indexes for statement iStmt. If there are no new recommeded indexes, NULL </Line>
  <Line number="9157">**   is returned.</Line>
  <Line number="9158">**</Line>
  <Line number="9159">** EXPERT_REPORT_PLAN:</Line>
  <Line number="9160">**   Return a buffer containing the EXPLAIN QUERY PLAN output for SQL query</Line>
  <Line number="9161">**   iStmt after the proposed indexes have been added to the database schema.</Line>
  <Line number="9162">**</Line>
  <Line number="9163">** EXPERT_REPORT_CANDIDATES:</Line>
  <Line number="9164">**   Return a pointer to a buffer containing the CREATE INDEX statements </Line>
  <Line number="9165">**   for all indexes that were tested (for all SQL statements). The iStmt</Line>
  <Line number="9166">**   parameter is ignored for EXPERT_REPORT_CANDIDATES calls.</Line>
  <Line number="9167">*/</Line>
  <Line number="9168">const char *sqlite3_expert_report(sqlite3expert*, int iStmt, int eReport);</Line>
  <Line number="9169"></Line>
  <Line number="9170">/*</Line>
  <Line number="9171">** Values for the third argument passed to sqlite3_expert_report().</Line>
  <Line number="9172">*/</Line>
  <Line number="9173">#define EXPERT_REPORT_SQL        1</Line>
  <Line number="9174">#define EXPERT_REPORT_INDEXES    2</Line>
  <Line number="9175">#define EXPERT_REPORT_PLAN       3</Line>
  <Line number="9176">#define EXPERT_REPORT_CANDIDATES 4</Line>
  <Line number="9177"></Line>
  <Line number="9178">/*</Line>
  <Line number="9179">** Free an (sqlite3expert*) handle and all associated resources. There </Line>
  <Line number="9180">** should be one call to this function for each successful call to </Line>
  <Line number="9181">** sqlite3-expert_new().</Line>
  <Line number="9182">*/</Line>
  <Line number="9183">void sqlite3_expert_destroy(sqlite3expert*);</Line>
  <Line number="9184"></Line>
  <Line number="9185">#endif  /* !defined(SQLITEEXPERT_H) */</Line>
  <Line number="9186"></Line>
  <Line number="9187">/************************* End ../ext/expert/sqlite3expert.h ********************/</Line>
  <Line number="9188">/************************* Begin ../ext/expert/sqlite3expert.c ******************/</Line>
  <Line number="9189">/*</Line>
  <Line number="9190">** 2017 April 09</Line>
  <Line number="9191">**</Line>
  <Line number="9192">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="9193">** a legal notice, here is a blessing:</Line>
  <Line number="9194">**</Line>
  <Line number="9195">**    May you do good and not evil.</Line>
  <Line number="9196">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="9197">**    May you share freely, never taking more than you give.</Line>
  <Line number="9198">**</Line>
  <Line number="9199">*************************************************************************</Line>
  <Line number="9200">*/</Line>
  <Line number="9201">/* #include &quot;sqlite3expert.h&quot; */</Line>
  <Line number="9202">#include &lt;assert.h&gt;</Line>
  <Line number="9203">#include &lt;string.h&gt;</Line>
  <Line number="9204">#include &lt;stdio.h&gt;</Line>
  <Line number="9205"></Line>
  <Line number="9206">#ifndef SQLITE_OMIT_VIRTUALTABLE </Line>
  <Line number="9207"></Line>
  <Line number="9208">/* typedef sqlite3_int64 i64; */</Line>
  <Line number="9209">/* typedef sqlite3_uint64 u64; */</Line>
  <Line number="9210"></Line>
  <Line number="9211">typedef struct IdxColumn IdxColumn;</Line>
  <Line number="9212">typedef struct IdxConstraint IdxConstraint;</Line>
  <Line number="9213">typedef struct IdxScan IdxScan;</Line>
  <Line number="9214">typedef struct IdxStatement IdxStatement;</Line>
  <Line number="9215">typedef struct IdxTable IdxTable;</Line>
  <Line number="9216">typedef struct IdxWrite IdxWrite;</Line>
  <Line number="9217"></Line>
  <Line number="9218">#define STRLEN  (int)strlen</Line>
  <Line number="9219"></Line>
  <Line number="9220">/*</Line>
  <Line number="9221">** A temp table name that we assume no user database will actually use.</Line>
  <Line number="9222">** If this assumption proves incorrect triggers on the table with the</Line>
  <Line number="9223">** conflicting name will be ignored.</Line>
  <Line number="9224">*/</Line>
  <Line number="9225">#define UNIQUE_TABLE_NAME &quot;t592690916721053953805701627921227776&quot;</Line>
  <Line number="9226"></Line>
  <Line number="9227">/*</Line>
  <Line number="9228">** A single constraint. Equivalent to either &quot;col = ?&quot; or &quot;col &lt; ?&quot; (or</Line>
  <Line number="9229">** any other type of single-ended range constraint on a column).</Line>
  <Line number="9230">**</Line>
  <Line number="9231">** pLink:</Line>
  <Line number="9232">**   Used to temporarily link IdxConstraint objects into lists while</Line>
  <Line number="9233">**   creating candidate indexes.</Line>
  <Line number="9234">*/</Line>
  <Line number="9235">struct IdxConstraint {</Line>
  <Line number="9236">  char *zColl;                    /* Collation sequence */</Line>
  <Line number="9237">  int bRange;                     /* True for range, false for eq */</Line>
  <Line number="9238">  int iCol;                       /* Constrained table column */</Line>
  <Line number="9239">  int bFlag;                      /* Used by idxFindCompatible() */</Line>
  <Line number="9240">  int bDesc;                      /* True if ORDER BY &lt;expr&gt; DESC */</Line>
  <Line number="9241">  IdxConstraint *pNext;           /* Next constraint in pEq or pRange list */</Line>
  <Line number="9242">  IdxConstraint *pLink;           /* See above */</Line>
  <Line number="9243">};</Line>
  <Line number="9244"></Line>
  <Line number="9245">/*</Line>
  <Line number="9246">** A single scan of a single table.</Line>
  <Line number="9247">*/</Line>
  <Line number="9248">struct IdxScan {</Line>
  <Line number="9249">  IdxTable *pTab;                 /* Associated table object */</Line>
  <Line number="9250">  int iDb;                        /* Database containing table zTable */</Line>
  <Line number="9251">  i64 covering;                   /* Mask of columns required for cov. index */</Line>
  <Line number="9252">  IdxConstraint *pOrder;          /* ORDER BY columns */</Line>
  <Line number="9253">  IdxConstraint *pEq;             /* List of == constraints */</Line>
  <Line number="9254">  IdxConstraint *pRange;          /* List of &lt; constraints */</Line>
  <Line number="9255">  IdxScan *pNextScan;             /* Next IdxScan object for same analysis */</Line>
  <Line number="9256">};</Line>
  <Line number="9257"></Line>
  <Line number="9258">/*</Line>
  <Line number="9259">** Information regarding a single database table. Extracted from </Line>
  <Line number="9260">** &quot;PRAGMA table_info&quot; by function idxGetTableInfo().</Line>
  <Line number="9261">*/</Line>
  <Line number="9262">struct IdxColumn {</Line>
  <Line number="9263">  char *zName;</Line>
  <Line number="9264">  char *zColl;</Line>
  <Line number="9265">  int iPk;</Line>
  <Line number="9266">};</Line>
  <Line number="9267">struct IdxTable {</Line>
  <Line number="9268">  int nCol;</Line>
  <Line number="9269">  char *zName;                    /* Table name */</Line>
  <Line number="9270">  IdxColumn *aCol;</Line>
  <Line number="9271">  IdxTable *pNext;                /* Next table in linked list of all tables */</Line>
  <Line number="9272">};</Line>
  <Line number="9273"></Line>
  <Line number="9274">/*</Line>
  <Line number="9275">** An object of the following type is created for each unique table/write-op</Line>
  <Line number="9276">** seen. The objects are stored in a singly-linked list beginning at</Line>
  <Line number="9277">** sqlite3expert.pWrite.</Line>
  <Line number="9278">*/</Line>
  <Line number="9279">struct IdxWrite {</Line>
  <Line number="9280">  IdxTable *pTab;</Line>
  <Line number="9281">  int eOp;                        /* SQLITE_UPDATE, DELETE or INSERT */</Line>
  <Line number="9282">  IdxWrite *pNext;</Line>
  <Line number="9283">};</Line>
  <Line number="9284"></Line>
  <Line number="9285">/*</Line>
  <Line number="9286">** Each statement being analyzed is represented by an instance of this</Line>
  <Line number="9287">** structure.</Line>
  <Line number="9288">*/</Line>
  <Line number="9289">struct IdxStatement {</Line>
  <Line number="9290">  int iId;                        /* Statement number */</Line>
  <Line number="9291">  char *zSql;                     /* SQL statement */</Line>
  <Line number="9292">  char *zIdx;                     /* Indexes */</Line>
  <Line number="9293">  char *zEQP;                     /* Plan */</Line>
  <Line number="9294">  IdxStatement *pNext;</Line>
  <Line number="9295">};</Line>
  <Line number="9296"></Line>
  <Line number="9297"></Line>
  <Line number="9298">/*</Line>
  <Line number="9299">** A hash table for storing strings. With space for a payload string</Line>
  <Line number="9300">** with each entry. Methods are:</Line>
  <Line number="9301">**</Line>
  <Line number="9302">**   idxHashInit()</Line>
  <Line number="9303">**   idxHashClear()</Line>
  <Line number="9304">**   idxHashAdd()</Line>
  <Line number="9305">**   idxHashSearch()</Line>
  <Line number="9306">*/</Line>
  <Line number="9307">#define IDX_HASH_SIZE 1023</Line>
  <Line number="9308">typedef struct IdxHashEntry IdxHashEntry;</Line>
  <Line number="9309">typedef struct IdxHash IdxHash;</Line>
  <Line number="9310">struct IdxHashEntry {</Line>
  <Line number="9311">  char *zKey;                     /* nul-terminated key */</Line>
  <Line number="9312">  char *zVal;                     /* nul-terminated value string */</Line>
  <Line number="9313">  char *zVal2;                    /* nul-terminated value string 2 */</Line>
  <Line number="9314">  IdxHashEntry *pHashNext;        /* Next entry in same hash bucket */</Line>
  <Line number="9315">  IdxHashEntry *pNext;            /* Next entry in hash */</Line>
  <Line number="9316">};</Line>
  <Line number="9317">struct IdxHash {</Line>
  <Line number="9318">  IdxHashEntry *pFirst;</Line>
  <Line number="9319">  IdxHashEntry *aHash[IDX_HASH_SIZE];</Line>
  <Line number="9320">};</Line>
  <Line number="9321"></Line>
  <Line number="9322">/*</Line>
  <Line number="9323">** sqlite3expert object.</Line>
  <Line number="9324">*/</Line>
  <Line number="9325">struct sqlite3expert {</Line>
  <Line number="9326">  int iSample;                    /* Percentage of tables to sample for stat1 */</Line>
  <Line number="9327">  sqlite3 *db;                    /* User database */</Line>
  <Line number="9328">  sqlite3 *dbm;                   /* In-memory db for this analysis */</Line>
  <Line number="9329">  sqlite3 *dbv;                   /* Vtab schema for this analysis */</Line>
  <Line number="9330">  IdxTable *pTable;               /* List of all IdxTable objects */</Line>
  <Line number="9331">  IdxScan *pScan;                 /* List of scan objects */</Line>
  <Line number="9332">  IdxWrite *pWrite;               /* List of write objects */</Line>
  <Line number="9333">  IdxStatement *pStatement;       /* List of IdxStatement objects */</Line>
  <Line number="9334">  int bRun;                       /* True once analysis has run */</Line>
  <Line number="9335">  char **pzErrmsg;</Line>
  <Line number="9336">  int rc;                         /* Error code from whereinfo hook */</Line>
  <Line number="9337">  IdxHash hIdx;                   /* Hash containing all candidate indexes */</Line>
  <Line number="9338">  char *zCandidates;              /* For EXPERT_REPORT_CANDIDATES */</Line>
  <Line number="9339">};</Line>
  <Line number="9340"></Line>
  <Line number="9341"></Line>
  <Line number="9342">/*</Line>
  <Line number="9343">** Allocate and return nByte bytes of zeroed memory using sqlite3_malloc(). </Line>
  <Line number="9344">** If the allocation fails, set *pRc to SQLITE_NOMEM and return NULL.</Line>
  <Line number="9345">*/</Line>
  <Line number="9346">static void *idxMalloc(int *pRc, int nByte){</Line>
  <Line number="9347">  void *pRet;</Line>
  <Line number="9348">  <CheckRefs ids="2204">assert</CheckRefs>( *pRc==SQLITE_OK );</Line>
  <Line number="9349">  <CheckRefs ids="2205">assert</CheckRefs>( nByte&gt;0 );</Line>
  <Line number="9350">  pRet = sqlite3_malloc(nByte);</Line>
  <Line number="9351">  if( pRet ){</Line>
  <Line number="9352">    memset(pRet, 0, <CheckRefs ids="2206">nByte</CheckRefs>);</Line>
  <Line number="9353">  }else{</Line>
  <Line number="9354">    *pRc = SQLITE_NOMEM;</Line>
  <Line number="9355">  }</Line>
  <Line number="9356">  return pRet;</Line>
  <Line number="9357">}</Line>
  <Line number="9358"></Line>
  <Line number="9359">/*</Line>
  <Line number="9360">** Initialize an IdxHash hash table.</Line>
  <Line number="9361">*/</Line>
  <Line number="9362">static void idxHashInit(IdxHash *pHash){</Line>
  <Line number="9363">  memset(pHash, 0, sizeof(IdxHash));</Line>
  <Line number="9364">}</Line>
  <Line number="9365"></Line>
  <Line number="9366">/*</Line>
  <Line number="9367">** Reset an IdxHash hash table.</Line>
  <Line number="9368">*/</Line>
  <Line number="9369">static void idxHashClear(IdxHash *pHash){</Line>
  <Line number="9370">  int i;</Line>
  <Line number="9371">  for(i=0; i&lt;IDX_HASH_SIZE; i<CheckRefs ids="2207">++</CheckRefs>){</Line>
  <Line number="9372">    IdxHashEntry *pEntry;</Line>
  <Line number="9373">    IdxHashEntry *pNext;</Line>
  <Line number="9374">    for(pEntry=pHash-&gt;aHash[i<CheckRefs ids="2208">]</CheckRefs>; pEntry; pEntry=pNext){</Line>
  <Line number="9375">      pNext = pEntry-&gt;pHashNext;</Line>
  <Line number="9376">      sqlite3_free(pEntry-&gt;zVal2);</Line>
  <Line number="9377">      sqlite3_free(pEntry);</Line>
  <Line number="9378">    }</Line>
  <Line number="9379">  }</Line>
  <Line number="9380">  memset(pHash, 0, sizeof(IdxHash));</Line>
  <Line number="9381">}</Line>
  <Line number="9382"></Line>
  <Line number="9383">/*</Line>
  <Line number="9384">** Return the index of the hash bucket that the string specified by the</Line>
  <Line number="9385">** arguments to this function belongs.</Line>
  <Line number="9386">*/</Line>
  <Line number="9387">static int idxHashString(const char *z, int n){</Line>
  <Line number="9388">  unsigned int ret = <CheckRefs ids="2209">0</CheckRefs>;</Line>
  <Line number="9389">  int i;</Line>
  <Line number="9390">  for(i=0; i&lt;n; i<CheckRefs ids="2210">++</CheckRefs>){</Line>
  <Line number="9391">    ret <CheckRefs ids="2211">+=</CheckRefs> (ret<CheckRefs ids="2213">&lt;&lt;</CheckRefs>3) <CheckRefs ids="2212">+</CheckRefs> <CheckRefs ids="2214,2215">(</CheckRefs>unsigned char)(z[i]);</Line>
  <Line number="9392">  }</Line>
  <Line number="9393">  return <CheckRefs ids="2216">(</CheckRefs>int)(ret <CheckRefs ids="2217">%</CheckRefs> <CheckRefs ids="2218">IDX_HASH_SIZE</CheckRefs>);</Line>
  <Line number="9394">}</Line>
  <Line number="9395"></Line>
  <Line number="9396">/*</Line>
  <Line number="9397">** If zKey is already present in the hash table, return non-zero and do</Line>
  <Line number="9398">** nothing. Otherwise, add an entry with key zKey and payload string zVal to</Line>
  <Line number="9399">** the hash table passed as the second argument. </Line>
  <Line number="9400">*/</Line>
  <Line number="9401">static int idxHashAdd(</Line>
  <Line number="9402">  int *pRc, </Line>
  <Line number="9403">  IdxHash *pHash, </Line>
  <Line number="9404">  const char *zKey,</Line>
  <Line number="9405">  const char *zVal</Line>
  <Line number="9406">){</Line>
  <Line number="9407">  int nKey = <CheckRefs ids="2219">STRLEN</CheckRefs>(zKey);</Line>
  <Line number="9408">  int iHash = idxHashString(zKey, nKey);</Line>
  <Line number="9409">  int nVal = (zVal ? <CheckRefs ids="2220">STRLEN</CheckRefs>(zVal) : 0);</Line>
  <Line number="9410">  IdxHashEntry *pEntry;</Line>
  <Line number="9411">  <CheckRefs ids="2221">assert</CheckRefs>( iHash&gt;=0 );</Line>
  <Line number="9412">  for(pEntry=pHash-&gt;aHash[iHash<CheckRefs ids="2222">]</CheckRefs>; pEntry; pEntry=pEntry-&gt;pHashNext){</Line>
  <Line number="9413">    if( <CheckRefs ids="2223">STRLEN</CheckRefs>(pEntry-&gt;zKey)==nKey &amp;&amp; 0==memcmp(pEntry-&gt;zKey, zKey, <CheckRefs ids="2224">nKey</CheckRefs>) ){</Line>
  <Line number="9414">      return 1;</Line>
  <Line number="9415">    }</Line>
  <Line number="9416">  }</Line>
  <Line number="9417">  pEntry = idxMalloc(pRc, sizeof(IdxHashEntry) <CheckRefs ids="2229">+</CheckRefs> <CheckRefs ids="2230">nKey</CheckRefs><CheckRefs ids="2228">+</CheckRefs><CheckRefs ids="2231">1</CheckRefs> <CheckRefs ids="2227">+</CheckRefs> <CheckRefs ids="2232">nVal</CheckRefs><CheckRefs ids="2225,2226">+</CheckRefs><CheckRefs ids="2233">1</CheckRefs>);</Line>
  <Line number="9418">  if( pEntry ){</Line>
  <Line number="9419">    pEntry-&gt;zKey = (char*)&amp;pEntry[1];</Line>
  <Line number="9420">    memcpy(pEntry-&gt;zKey, zKey, <CheckRefs ids="2234">nKey</CheckRefs>);</Line>
  <Line number="9421">    if( zVal ){</Line>
  <Line number="9422">      pEntry-&gt;zVal = &amp;pEntry-&gt;zKey[nKey<CheckRefs ids="2235">+</CheckRefs>1];</Line>
  <Line number="9423">      memcpy(pEntry-&gt;zVal, zVal, <CheckRefs ids="2236">nVal</CheckRefs>);</Line>
  <Line number="9424">    }</Line>
  <Line number="9425">    pEntry-&gt;pHashNext = pHash-&gt;aHash[iHash<CheckRefs ids="2237">]</CheckRefs>;</Line>
  <Line number="9426">    pHash-&gt;aHash[iHash<CheckRefs ids="2238">]</CheckRefs> = pEntry;</Line>
  <Line number="9427"></Line>
  <Line number="9428">    pEntry-&gt;pNext = pHash-&gt;pFirst;</Line>
  <Line number="9429">    pHash-&gt;pFirst = pEntry;</Line>
  <Line number="9430">  }</Line>
  <Line number="9431">  return 0;</Line>
  <Line number="9432">}</Line>
  <Line number="9433"></Line>
  <Line number="9434">/*</Line>
  <Line number="9435">** If zKey/nKey is present in the hash table, return a pointer to the </Line>
  <Line number="9436">** hash-entry object.</Line>
  <Line number="9437">*/</Line>
  <Line number="9438">static IdxHashEntry *idxHashFind(IdxHash *pHash, const char *zKey, int nKey){</Line>
  <Line number="9439">  int iHash;</Line>
  <Line number="9440">  IdxHashEntry *pEntry;</Line>
  <Line number="9441">  if( nKey&lt;0 ) nKey = <CheckRefs ids="2239">STRLEN</CheckRefs>(zKey);</Line>
  <Line number="9442">  iHash = idxHashString(zKey, nKey);</Line>
  <Line number="9443">  <CheckRefs ids="2240">assert</CheckRefs>( iHash&gt;=0 );</Line>
  <Line number="9444">  for(pEntry=pHash-&gt;aHash[iHash<CheckRefs ids="2241">]</CheckRefs>; pEntry; pEntry=pEntry-&gt;pHashNext){</Line>
  <Line number="9445">    if( <CheckRefs ids="2242">STRLEN</CheckRefs>(pEntry-&gt;zKey)==nKey &amp;&amp; 0==memcmp(pEntry-&gt;zKey, zKey, <CheckRefs ids="2243">nKey</CheckRefs>) ){</Line>
  <Line number="9446">      return pEntry;</Line>
  <Line number="9447">    }</Line>
  <Line number="9448">  }</Line>
  <Line number="9449">  return 0;</Line>
  <Line number="9450">}</Line>
  <Line number="9451"></Line>
  <Line number="9452">/*</Line>
  <Line number="9453">** If the hash table contains an entry with a key equal to the string</Line>
  <Line number="9454">** passed as the final two arguments to this function, return a pointer</Line>
  <Line number="9455">** to the payload string. Otherwise, if zKey/nKey is not present in the</Line>
  <Line number="9456">** hash table, return NULL.</Line>
  <Line number="9457">*/</Line>
  <Line number="9458">static const char *idxHashSearch(IdxHash *pHash, const char *zKey, int nKey){</Line>
  <Line number="9459">  IdxHashEntry *pEntry = idxHashFind(pHash, zKey, nKey);</Line>
  <Line number="9460">  if( pEntry ) return pEntry-&gt;zVal;</Line>
  <Line number="9461">  return 0;</Line>
  <Line number="9462">}</Line>
  <Line number="9463"></Line>
  <Line number="9464">/*</Line>
  <Line number="9465">** Allocate and return a new IdxConstraint object. Set the IdxConstraint.zColl</Line>
  <Line number="9466">** variable to point to a copy of nul-terminated string zColl.</Line>
  <Line number="9467">*/</Line>
  <Line number="9468">static IdxConstraint *idxNewConstraint(int *pRc, const char *zColl){</Line>
  <Line number="9469">  IdxConstraint *pNew;</Line>
  <Line number="9470">  int nColl = <CheckRefs ids="2244">STRLEN</CheckRefs>(zColl);</Line>
  <Line number="9471"></Line>
  <Line number="9472">  <CheckRefs ids="2245">assert</CheckRefs>( *pRc==SQLITE_OK );</Line>
  <Line number="9473">  pNew = (IdxConstraint*)idxMalloc(pRc, sizeof(IdxConstraint) <CheckRefs ids="2248">*</CheckRefs> <CheckRefs ids="2249">nColl</CheckRefs> <CheckRefs ids="2246,2247">+</CheckRefs> <CheckRefs ids="2250">1</CheckRefs>);</Line>
  <Line number="9474">  if( pNew ){</Line>
  <Line number="9475">    pNew-&gt;zColl = (char*)&amp;pNew[1];</Line>
  <Line number="9476">    memcpy(pNew-&gt;zColl, zColl, nColl<CheckRefs ids="2251,2252">+</CheckRefs>1);</Line>
  <Line number="9477">  }</Line>
  <Line number="9478">  return pNew;</Line>
  <Line number="9479">}</Line>
  <Line number="9480"></Line>
  <Line number="9481">/*</Line>
  <Line number="9482">** An error associated with database handle db has just occurred. Pass</Line>
  <Line number="9483">** the error message to callback function xOut.</Line>
  <Line number="9484">*/</Line>
  <Line number="9485">static void idxDatabaseError(</Line>
  <Line number="9486">  sqlite3 *db,                    /* Database handle */</Line>
  <Line number="9487">  char **pzErrmsg                 /* Write error here */</Line>
  <Line number="9488">){</Line>
  <Line number="9489">  *pzErrmsg = sqlite3_mprintf(&quot;%s&quot;, sqlite3_errmsg(db));</Line>
  <Line number="9490">}</Line>
  <Line number="9491"></Line>
  <Line number="9492">/*</Line>
  <Line number="9493">** Prepare an SQL statement.</Line>
  <Line number="9494">*/</Line>
  <Line number="9495">static int idxPrepareStmt(</Line>
  <Line number="9496">  sqlite3 *db,                    /* Database handle to compile against */</Line>
  <Line number="9497">  sqlite3_stmt **ppStmt,          /* OUT: Compiled SQL statement */</Line>
  <Line number="9498">  char **pzErrmsg,                /* OUT: sqlite3_malloc()ed error message */</Line>
  <Line number="9499">  const char *zSql                /* SQL statement to compile */</Line>
  <Line number="9500">){</Line>
  <Line number="9501">  int rc = sqlite3_prepare_v2(db, zSql, <CheckRefs ids="2253">-</CheckRefs>1, ppStmt, 0);</Line>
  <Line number="9502">  if( rc!=SQLITE_OK ){</Line>
  <Line number="9503">    *ppStmt = 0;</Line>
  <Line number="9504">    idxDatabaseError(db, pzErrmsg);</Line>
  <Line number="9505">  }</Line>
  <Line number="9506">  return rc;</Line>
  <Line number="9507">}</Line>
  <Line number="9508"></Line>
  <Line number="9509">/*</Line>
  <Line number="9510">** Prepare an SQL statement using the results of a printf() formatting.</Line>
  <Line number="9511">*/</Line>
  <Line number="9512">static int idxPrintfPrepareStmt(</Line>
  <Line number="9513">  sqlite3 *db,                    /* Database handle to compile against */</Line>
  <Line number="9514">  sqlite3_stmt **ppStmt,          /* OUT: Compiled SQL statement */</Line>
  <Line number="9515">  char **pzErrmsg,                /* OUT: sqlite3_malloc()ed error message */</Line>
  <Line number="9516">  const char *zFmt,               /* printf() format of SQL statement */</Line>
  <Line number="9517">  ...                             /* Trailing printf() arguments */</Line>
  <Line number="9518">){</Line>
  <Line number="9519">  va_list ap;</Line>
  <Line number="9520">  int rc;</Line>
  <Line number="9521">  char *zSql;</Line>
  <Line number="9522">  va_start(ap, zFmt);</Line>
  <Line number="9523">  zSql = sqlite3_vmprintf(zFmt, ap);</Line>
  <Line number="9524">  if( zSql==0 ){</Line>
  <Line number="9525">    rc = SQLITE_NOMEM;</Line>
  <Line number="9526">  }else{</Line>
  <Line number="9527">    rc = idxPrepareStmt(db, ppStmt, pzErrmsg, zSql);</Line>
  <Line number="9528">    sqlite3_free(zSql);</Line>
  <Line number="9529">  }</Line>
  <Line number="9530">  va_end(ap);</Line>
  <Line number="9531">  return rc;</Line>
  <Line number="9532">}</Line>
  <Line number="9533"></Line>
  <Line number="9534"></Line>
  <Line number="9535">/*************************************************************************</Line>
  <Line number="9536">** Beginning of virtual table implementation.</Line>
  <Line number="9537">*/</Line>
  <Line number="9538">typedef struct ExpertVtab ExpertVtab;</Line>
  <Line number="9539">struct ExpertVtab {</Line>
  <Line number="9540">  sqlite3_vtab base;</Line>
  <Line number="9541">  IdxTable *pTab;</Line>
  <Line number="9542">  sqlite3expert *pExpert;</Line>
  <Line number="9543">};</Line>
  <Line number="9544"></Line>
  <Line number="9545">typedef struct ExpertCsr ExpertCsr;</Line>
  <Line number="9546">struct ExpertCsr {</Line>
  <Line number="9547">  sqlite3_vtab_cursor base;</Line>
  <Line number="9548">  sqlite3_stmt *pData;</Line>
  <Line number="9549">};</Line>
  <Line number="9550"></Line>
  <Line number="9551">static char *expertDequote(const char *zIn){</Line>
  <Line number="9552">  int n = <CheckRefs ids="2254">STRLEN</CheckRefs>(zIn);</Line>
  <Line number="9553">  char *zRet = sqlite3_malloc(n);</Line>
  <Line number="9554"></Line>
  <Line number="9555">  <CheckRefs ids="2255,2256">assert</CheckRefs>( zIn[0]==&apos;\&apos;&apos; );</Line>
  <Line number="9556">  <CheckRefs ids="2257,2259,2258">assert</CheckRefs>( zIn[n-1]==&apos;\&apos;&apos; );</Line>
  <Line number="9557"></Line>
  <Line number="9558">  if( zRet ){</Line>
  <Line number="9559">    int iOut = 0;</Line>
  <Line number="9560">    int iIn = 0;</Line>
  <Line number="9561">    for(iIn=1; iIn&lt;(n<CheckRefs ids="2260">-</CheckRefs>1); iIn<CheckRefs ids="2261">++</CheckRefs>){</Line>
  <Line number="9562">      if( <CheckRefs ids="2262">zIn</CheckRefs>[iIn]==&apos;\&apos;&apos; ){</Line>
  <Line number="9563">        <CheckRefs ids="2263,2265,2264">assert</CheckRefs>( zIn[iIn+1]==&apos;\&apos;&apos; );</Line>
  <Line number="9564">        iIn<CheckRefs ids="2266">++</CheckRefs>;</Line>
  <Line number="9565">      }</Line>
  <Line number="9566">      zRet[iOut<CheckRefs ids="2267">++</CheckRefs>] = zIn[iIn];</Line>
  <Line number="9567">    }</Line>
  <Line number="9568">    zRet[iOut] = <CheckRefs ids="2268">&apos;\0&apos;</CheckRefs>;</Line>
  <Line number="9569">  }</Line>
  <Line number="9570"></Line>
  <Line number="9571">  return zRet;</Line>
  <Line number="9572">}</Line>
  <Line number="9573"></Line>
  <Line number="9574">/* </Line>
  <Line number="9575">** This function is the implementation of both the xConnect and xCreate</Line>
  <Line number="9576">** methods of the r-tree virtual table.</Line>
  <Line number="9577">**</Line>
  <Line number="9578">**   argv[0]   -&gt; module name</Line>
  <Line number="9579">**   argv[1]   -&gt; database name</Line>
  <Line number="9580">**   argv[2]   -&gt; table name</Line>
  <Line number="9581">**   argv[...] -&gt; column names...</Line>
  <Line number="9582">*/</Line>
  <Line number="9583">static int expertConnect(</Line>
  <Line number="9584">  sqlite3 *db,</Line>
  <Line number="9585">  void *pAux,</Line>
  <Line number="9586">  int argc, const char *const*argv,</Line>
  <Line number="9587">  sqlite3_vtab **ppVtab,</Line>
  <Line number="9588">  char **pzErr</Line>
  <Line number="9589">){</Line>
  <Line number="9590">  sqlite3expert *pExpert = (sqlite3expert*)pAux;</Line>
  <Line number="9591">  ExpertVtab *p = 0;</Line>
  <Line number="9592">  int rc;</Line>
  <Line number="9593"></Line>
  <Line number="9594">  if( argc!=4 ){</Line>
  <Line number="9595">    *pzErr = sqlite3_mprintf(&quot;internal error!&quot;);</Line>
  <Line number="9596">    rc = SQLITE_ERROR;</Line>
  <Line number="9597">  }else{</Line>
  <Line number="9598">    char *zCreateTable = expertDequote(argv[3]);</Line>
  <Line number="9599">    if( zCreateTable ){</Line>
  <Line number="9600">      rc = sqlite3_declare_vtab(db, zCreateTable);</Line>
  <Line number="9601">      if( rc==SQLITE_OK ){</Line>
  <Line number="9602">        p = idxMalloc(&amp;rc, <CheckRefs ids="2269">sizeof</CheckRefs>(ExpertVtab));</Line>
  <Line number="9603">      }</Line>
  <Line number="9604">      if( rc==SQLITE_OK ){</Line>
  <Line number="9605">        p-&gt;pExpert = pExpert;</Line>
  <Line number="9606">        p-&gt;pTab = pExpert-&gt;pTable;</Line>
  <Line number="9607">        <CheckRefs ids="2270">assert</CheckRefs>( sqlite3_stricmp(p-&gt;pTab-&gt;zName, argv[2])==0 );</Line>
  <Line number="9608">      }</Line>
  <Line number="9609">      sqlite3_free(zCreateTable);</Line>
  <Line number="9610">    }else{</Line>
  <Line number="9611">      rc = SQLITE_NOMEM;</Line>
  <Line number="9612">    }</Line>
  <Line number="9613">  }</Line>
  <Line number="9614"></Line>
  <Line number="9615">  *ppVtab = (sqlite3_vtab*)p;</Line>
  <Line number="9616">  return rc;</Line>
  <Line number="9617">}</Line>
  <Line number="9618"></Line>
  <Line number="9619">static int expertDisconnect(sqlite3_vtab *pVtab){</Line>
  <Line number="9620">  ExpertVtab *p = (ExpertVtab*)pVtab;</Line>
  <Line number="9621">  sqlite3_free(p);</Line>
  <Line number="9622">  return SQLITE_OK;</Line>
  <Line number="9623">}</Line>
  <Line number="9624"></Line>
  <Line number="9625">static int expertBestIndex(sqlite3_vtab *pVtab, sqlite3_index_info *pIdxInfo){</Line>
  <Line number="9626">  ExpertVtab *p = (ExpertVtab*)pVtab;</Line>
  <Line number="9627">  int rc = SQLITE_OK;</Line>
  <Line number="9628">  int n = 0;</Line>
  <Line number="9629">  IdxScan *pScan;</Line>
  <Line number="9630">  const int opmask = </Line>
  <Line number="9631">    SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_GT |</Line>
  <Line number="9632">    SQLITE_INDEX_CONSTRAINT_LT | SQLITE_INDEX_CONSTRAINT_GE |</Line>
  <Line number="9633">    SQLITE_INDEX_CONSTRAINT_LE;</Line>
  <Line number="9634"></Line>
  <Line number="9635">  pScan = idxMalloc(&amp;rc, <CheckRefs ids="2271">sizeof</CheckRefs>(IdxScan));</Line>
  <Line number="9636">  if( pScan ){</Line>
  <Line number="9637">    int i;</Line>
  <Line number="9638"></Line>
  <Line number="9639">    /* Link the new scan object into the list */</Line>
  <Line number="9640">    pScan-&gt;pTab = p-&gt;pTab;</Line>
  <Line number="9641">    pScan-&gt;pNextScan = p-&gt;pExpert-&gt;pScan;</Line>
  <Line number="9642">    p-&gt;pExpert-&gt;pScan = pScan;</Line>
  <Line number="9643"></Line>
  <Line number="9644">    /* Add the constraints to the IdxScan object */</Line>
  <Line number="9645">    for(i=0; i&lt;pIdxInfo-&gt;nConstraint; i<CheckRefs ids="2272">++</CheckRefs>){</Line>
  <Line number="9646">      struct sqlite3_index_constraint *pCons = &amp;pIdxInfo-&gt;aConstraint[i];</Line>
  <Line number="9647">      if( <CheckRefs ids="2273">pCons</CheckRefs>-&gt;usable </Line>
  <Line number="9648">       &amp;&amp; pCons-&gt;iColumn&gt;=0 </Line>
  <Line number="9649">       &amp;&amp; p-&gt;pTab-&gt;aCol[pCons-&gt;iColumn].iPk==0</Line>
  <Line number="9650">       &amp;&amp; (<CheckRefs ids="2274">pCons</CheckRefs>-&gt;op &amp; opmask) </Line>
  <Line number="9651">      ){</Line>
  <Line number="9652">        IdxConstraint *pNew;</Line>
  <Line number="9653">        const char *zColl = sqlite3_vtab_collation(pIdxInfo, i);</Line>
  <Line number="9654">        pNew = idxNewConstraint(&amp;rc, zColl);</Line>
  <Line number="9655">        if( pNew ){</Line>
  <Line number="9656">          pNew-&gt;iCol = pCons-&gt;iColumn;</Line>
  <Line number="9657">          if( <CheckRefs ids="2275">pCons</CheckRefs>-&gt;op==SQLITE_INDEX_CONSTRAINT_EQ ){</Line>
  <Line number="9658">            pNew-&gt;pNext = pScan-&gt;pEq;</Line>
  <Line number="9659">            pScan-&gt;pEq = pNew;</Line>
  <Line number="9660">          }else{</Line>
  <Line number="9661">            pNew-&gt;bRange = 1;</Line>
  <Line number="9662">            pNew-&gt;pNext = pScan-&gt;pRange;</Line>
  <Line number="9663">            pScan-&gt;pRange = pNew;</Line>
  <Line number="9664">          }</Line>
  <Line number="9665">        }</Line>
  <Line number="9666">        n<CheckRefs ids="2276">++</CheckRefs>;</Line>
  <Line number="9667">        pIdxInfo-&gt;aConstraintUsage[i].argvIndex = n;</Line>
  <Line number="9668">      }</Line>
  <Line number="9669">    }</Line>
  <Line number="9670"></Line>
  <Line number="9671">    /* Add the ORDER BY to the IdxScan object */</Line>
  <Line number="9672">    for(i=pIdxInfo-&gt;nOrderBy<CheckRefs ids="2277">-</CheckRefs>1; i&gt;=0; i<CheckRefs ids="2278">--</CheckRefs>){</Line>
  <Line number="9673">      int iCol = pIdxInfo-&gt;aOrderBy[i].iColumn;</Line>
  <Line number="9674">      if( iCol&gt;=0 ){</Line>
  <Line number="9675">        IdxConstraint *pNew = idxNewConstraint(&amp;rc, p-&gt;pTab-&gt;aCol[iCol].zColl);</Line>
  <Line number="9676">        if( pNew ){</Line>
  <Line number="9677">          pNew-&gt;iCol = iCol;</Line>
  <Line number="9678">          pNew-&gt;bDesc = <CheckRefs ids="2279">pIdxInfo</CheckRefs>-&gt;aOrderBy[i].desc;</Line>
  <Line number="9679">          pNew-&gt;pNext = pScan-&gt;pOrder;</Line>
  <Line number="9680">          pNew-&gt;pLink = pScan-&gt;pOrder;</Line>
  <Line number="9681">          pScan-&gt;pOrder = pNew;</Line>
  <Line number="9682">          n<CheckRefs ids="2280">++</CheckRefs>;</Line>
  <Line number="9683">        }</Line>
  <Line number="9684">      }</Line>
  <Line number="9685">    }</Line>
  <Line number="9686">  }</Line>
  <Line number="9687"></Line>
  <Line number="9688">  pIdxInfo-&gt;estimatedCost <CheckRefs ids="2281">=</CheckRefs> 1000000.0 <CheckRefs ids="2282,2283">/</CheckRefs> <CheckRefs ids="2284">(</CheckRefs>n<CheckRefs ids="2285">+</CheckRefs>1);</Line>
  <Line number="9689">  return rc;</Line>
  <Line number="9690">}</Line>
  <Line number="9691"></Line>
  <Line number="9692">static int expertUpdate(</Line>
  <Line number="9693">  sqlite3_vtab *pVtab, </Line>
  <Line number="9694">  int nData, </Line>
  <Line number="9695">  sqlite3_value **azData, </Line>
  <Line number="9696">  sqlite_int64 *pRowid</Line>
  <Line number="9697">){</Line>
  <Line number="9698">  (void)pVtab;</Line>
  <Line number="9699">  (void)nData;</Line>
  <Line number="9700">  (void)azData;</Line>
  <Line number="9701">  (void)pRowid;</Line>
  <Line number="9702">  return SQLITE_OK;</Line>
  <Line number="9703">}</Line>
  <Line number="9704"></Line>
  <Line number="9705">/* </Line>
  <Line number="9706">** Virtual table module xOpen method.</Line>
  <Line number="9707">*/</Line>
  <Line number="9708">static int expertOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){</Line>
  <Line number="9709">  int rc = SQLITE_OK;</Line>
  <Line number="9710">  ExpertCsr *pCsr;</Line>
  <Line number="9711">  (void)pVTab;</Line>
  <Line number="9712">  pCsr = idxMalloc(&amp;rc, <CheckRefs ids="2286">sizeof</CheckRefs>(ExpertCsr));</Line>
  <Line number="9713">  *ppCursor = (sqlite3_vtab_cursor*)pCsr;</Line>
  <Line number="9714">  return rc;</Line>
  <Line number="9715">}</Line>
  <Line number="9716"></Line>
  <Line number="9717">/* </Line>
  <Line number="9718">** Virtual table module xClose method.</Line>
  <Line number="9719">*/</Line>
  <Line number="9720">static int expertClose(sqlite3_vtab_cursor *cur){</Line>
  <Line number="9721">  ExpertCsr *pCsr = (ExpertCsr*)cur;</Line>
  <Line number="9722">  sqlite3_finalize(pCsr-&gt;pData);</Line>
  <Line number="9723">  sqlite3_free(pCsr);</Line>
  <Line number="9724">  return SQLITE_OK;</Line>
  <Line number="9725">}</Line>
  <Line number="9726"></Line>
  <Line number="9727">/*</Line>
  <Line number="9728">** Virtual table module xEof method.</Line>
  <Line number="9729">**</Line>
  <Line number="9730">** Return non-zero if the cursor does not currently point to a valid </Line>
  <Line number="9731">** record (i.e if the scan has finished), or zero otherwise.</Line>
  <Line number="9732">*/</Line>
  <Line number="9733">static int expertEof(sqlite3_vtab_cursor *cur){</Line>
  <Line number="9734">  ExpertCsr *pCsr = (ExpertCsr*)cur;</Line>
  <Line number="9735">  return pCsr-&gt;pData==0;</Line>
  <Line number="9736">}</Line>
  <Line number="9737"></Line>
  <Line number="9738">/* </Line>
  <Line number="9739">** Virtual table module xNext method.</Line>
  <Line number="9740">*/</Line>
  <Line number="9741">static int expertNext(sqlite3_vtab_cursor *cur){</Line>
  <Line number="9742">  ExpertCsr *pCsr = (ExpertCsr*)cur;</Line>
  <Line number="9743">  int rc = SQLITE_OK;</Line>
  <Line number="9744"></Line>
  <Line number="9745">  <CheckRefs ids="2287">assert</CheckRefs>( pCsr-&gt;pData );</Line>
  <Line number="9746">  rc = sqlite3_step(pCsr-&gt;pData);</Line>
  <Line number="9747">  if( rc!=SQLITE_ROW ){</Line>
  <Line number="9748">    rc = sqlite3_finalize(pCsr-&gt;pData);</Line>
  <Line number="9749">    pCsr-&gt;pData = 0;</Line>
  <Line number="9750">  }else{</Line>
  <Line number="9751">    rc = SQLITE_OK;</Line>
  <Line number="9752">  }</Line>
  <Line number="9753"></Line>
  <Line number="9754">  return rc;</Line>
  <Line number="9755">}</Line>
  <Line number="9756"></Line>
  <Line number="9757">/* </Line>
  <Line number="9758">** Virtual table module xRowid method.</Line>
  <Line number="9759">*/</Line>
  <Line number="9760">static int expertRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){</Line>
  <Line number="9761">  (void)cur;</Line>
  <Line number="9762">  *pRowid = <CheckRefs ids="2288">0</CheckRefs>;</Line>
  <Line number="9763">  return SQLITE_OK;</Line>
  <Line number="9764">}</Line>
  <Line number="9765"></Line>
  <Line number="9766">/* </Line>
  <Line number="9767">** Virtual table module xColumn method.</Line>
  <Line number="9768">*/</Line>
  <Line number="9769">static int expertColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){</Line>
  <Line number="9770">  ExpertCsr *pCsr = (ExpertCsr*)cur;</Line>
  <Line number="9771">  sqlite3_value *pVal;</Line>
  <Line number="9772">  pVal = sqlite3_column_value(pCsr-&gt;pData, i);</Line>
  <Line number="9773">  if( pVal ){</Line>
  <Line number="9774">    sqlite3_result_value(ctx, pVal);</Line>
  <Line number="9775">  }</Line>
  <Line number="9776">  return SQLITE_OK;</Line>
  <Line number="9777">}</Line>
  <Line number="9778"></Line>
  <Line number="9779">/* </Line>
  <Line number="9780">** Virtual table module xFilter method.</Line>
  <Line number="9781">*/</Line>
  <Line number="9782">static int expertFilter(</Line>
  <Line number="9783">  sqlite3_vtab_cursor *cur, </Line>
  <Line number="9784">  int idxNum, const char *idxStr,</Line>
  <Line number="9785">  int argc, sqlite3_value **argv</Line>
  <Line number="9786">){</Line>
  <Line number="9787">  ExpertCsr *pCsr = (ExpertCsr*)cur;</Line>
  <Line number="9788">  ExpertVtab *pVtab = (ExpertVtab*)(cur-&gt;pVtab);</Line>
  <Line number="9789">  sqlite3expert *pExpert = pVtab-&gt;pExpert;</Line>
  <Line number="9790">  int rc;</Line>
  <Line number="9791"></Line>
  <Line number="9792">  (void)idxNum;</Line>
  <Line number="9793">  (void)idxStr;</Line>
  <Line number="9794">  (void)argc;</Line>
  <Line number="9795">  (void)argv;</Line>
  <Line number="9796">  rc = sqlite3_finalize(pCsr-&gt;pData);</Line>
  <Line number="9797">  pCsr-&gt;pData = 0;</Line>
  <Line number="9798">  if( rc==SQLITE_OK ){</Line>
  <Line number="9799">    rc = idxPrintfPrepareStmt(pExpert-&gt;db, &amp;pCsr-&gt;pData, &amp;pVtab-&gt;base.zErrMsg,</Line>
  <Line number="9800">        &quot;SELECT * FROM main.%Q WHERE sample()&quot;, pVtab-&gt;pTab-&gt;zName</Line>
  <Line number="9801">    );</Line>
  <Line number="9802">  }</Line>
  <Line number="9803"></Line>
  <Line number="9804">  if( rc==SQLITE_OK ){</Line>
  <Line number="9805">    rc = expertNext(cur);</Line>
  <Line number="9806">  }</Line>
  <Line number="9807">  return rc;</Line>
  <Line number="9808">}</Line>
  <Line number="9809"></Line>
  <Line number="9810">static int idxRegisterVtab(sqlite3expert *p){</Line>
  <Line number="9811">  static sqlite3_module expertModule = {</Line>
  <Line number="9812">    2,                            /* iVersion */</Line>
  <Line number="9813">    expertConnect,                /* xCreate - create a table */</Line>
  <Line number="9814">    expertConnect,                /* xConnect - connect to an existing table */</Line>
  <Line number="9815">    expertBestIndex,              /* xBestIndex - Determine search strategy */</Line>
  <Line number="9816">    expertDisconnect,             /* xDisconnect - Disconnect from a table */</Line>
  <Line number="9817">    expertDisconnect,             /* xDestroy - Drop a table */</Line>
  <Line number="9818">    expertOpen,                   /* xOpen - open a cursor */</Line>
  <Line number="9819">    expertClose,                  /* xClose - close a cursor */</Line>
  <Line number="9820">    expertFilter,                 /* xFilter - configure scan constraints */</Line>
  <Line number="9821">    expertNext,                   /* xNext - advance a cursor */</Line>
  <Line number="9822">    expertEof,                    /* xEof */</Line>
  <Line number="9823">    expertColumn,                 /* xColumn - read data */</Line>
  <Line number="9824">    expertRowid,                  /* xRowid - read data */</Line>
  <Line number="9825">    expertUpdate,                 /* xUpdate - write data */</Line>
  <Line number="9826">    0,                            /* xBegin - begin transaction */</Line>
  <Line number="9827">    0,                            /* xSync - sync transaction */</Line>
  <Line number="9828">    0,                            /* xCommit - commit transaction */</Line>
  <Line number="9829">    0,                            /* xRollback - rollback transaction */</Line>
  <Line number="9830">    0,                            /* xFindFunction - function overloading */</Line>
  <Line number="9831">    0,                            /* xRename - rename the table */</Line>
  <Line number="9832">    0,                            /* xSavepoint */</Line>
  <Line number="9833">    0,                            /* xRelease */</Line>
  <Line number="9834">    0,                            /* xRollbackTo */</Line>
  <Line number="9835">    0,                            /* xShadowName */</Line>
  <Line number="9836">  };</Line>
  <Line number="9837"></Line>
  <Line number="9838">  return sqlite3_create_module(p-&gt;dbv, &quot;expert&quot;, &amp;expertModule, (void*)p);</Line>
  <Line number="9839">}</Line>
  <Line number="9840">/*</Line>
  <Line number="9841">** End of virtual table implementation.</Line>
  <Line number="9842">*************************************************************************/</Line>
  <Line number="9843">/*</Line>
  <Line number="9844">** Finalize SQL statement pStmt. If (*pRc) is SQLITE_OK when this function</Line>
  <Line number="9845">** is called, set it to the return value of sqlite3_finalize() before</Line>
  <Line number="9846">** returning. Otherwise, discard the sqlite3_finalize() return value.</Line>
  <Line number="9847">*/</Line>
  <Line number="9848">static void idxFinalize(int *pRc, sqlite3_stmt *pStmt){</Line>
  <Line number="9849">  int rc = sqlite3_finalize(pStmt);</Line>
  <Line number="9850">  if( *pRc==SQLITE_OK ) *pRc = rc;</Line>
  <Line number="9851">}</Line>
  <Line number="9852"></Line>
  <Line number="9853">/*</Line>
  <Line number="9854">** Attempt to allocate an IdxTable structure corresponding to table zTab</Line>
  <Line number="9855">** in the main database of connection db. If successful, set (*ppOut) to</Line>
  <Line number="9856">** point to the new object and return SQLITE_OK. Otherwise, return an</Line>
  <Line number="9857">** SQLite error code and set (*ppOut) to NULL. In this case *pzErrmsg may be</Line>
  <Line number="9858">** set to point to an error string.</Line>
  <Line number="9859">**</Line>
  <Line number="9860">** It is the responsibility of the caller to eventually free either the</Line>
  <Line number="9861">** IdxTable object or error message using sqlite3_free().</Line>
  <Line number="9862">*/</Line>
  <Line number="9863">static int idxGetTableInfo(</Line>
  <Line number="9864">  sqlite3 *db,                    /* Database connection to read details from */</Line>
  <Line number="9865">  const char *zTab,               /* Table name */</Line>
  <Line number="9866">  IdxTable **ppOut,               /* OUT: New object (if successful) */</Line>
  <Line number="9867">  char **pzErrmsg                 /* OUT: Error message (if not) */</Line>
  <Line number="9868">){</Line>
  <Line number="9869">  sqlite3_stmt *p1 = 0;</Line>
  <Line number="9870">  int nCol = 0;</Line>
  <Line number="9871">  int nTab = <CheckRefs ids="2289">STRLEN</CheckRefs>(zTab);</Line>
  <Line number="9872">  int nByte = sizeof(IdxTable) <CheckRefs ids="2292">+</CheckRefs> <CheckRefs ids="2293">nTab</CheckRefs> <CheckRefs ids="2290,2291">+</CheckRefs> <CheckRefs ids="2294">1</CheckRefs>;</Line>
  <Line number="9873">  IdxTable *pNew = 0;</Line>
  <Line number="9874">  int rc, rc2;</Line>
  <Line number="9875">  char *pCsr = 0;</Line>
  <Line number="9876">  int nPk = 0;</Line>
  <Line number="9877"></Line>
  <Line number="9878">  rc = idxPrintfPrepareStmt(db, &amp;p1, pzErrmsg, &quot;PRAGMA table_xinfo=%Q&quot;, zTab);</Line>
  <Line number="9879">  while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(p1) ){</Line>
  <Line number="9880">    const char *zCol = (const char*)sqlite3_column_text(p1, 1);</Line>
  <Line number="9881">    nByte <CheckRefs ids="2295">+=</CheckRefs> 1 <CheckRefs ids="2296">+</CheckRefs> <CheckRefs ids="2297">STRLEN</CheckRefs>(zCol);</Line>
  <Line number="9882">    rc = sqlite3_table_column_metadata(</Line>
  <Line number="9883">        db, &quot;main&quot;, zTab, zCol, 0, &amp;zCol, 0, 0, 0</Line>
  <Line number="9884">    );</Line>
  <Line number="9885">    nByte <CheckRefs ids="2298">+=</CheckRefs> 1 <CheckRefs ids="2299">+</CheckRefs> <CheckRefs ids="2300">STRLEN</CheckRefs>(zCol);</Line>
  <Line number="9886">    nCol<CheckRefs ids="2301">++</CheckRefs>;</Line>
  <Line number="9887">    nPk <CheckRefs ids="2302">+=</CheckRefs> (sqlite3_column_int(p1, 5)&gt;0);</Line>
  <Line number="9888">  }</Line>
  <Line number="9889">  rc2 = sqlite3_reset(p1);</Line>
  <Line number="9890">  if( rc==SQLITE_OK ) rc = rc2;</Line>
  <Line number="9891"></Line>
  <Line number="9892">  nByte <CheckRefs ids="2303">+=</CheckRefs> sizeof(IdxColumn) <CheckRefs ids="2304">*</CheckRefs> <CheckRefs ids="2305">nCol</CheckRefs>;</Line>
  <Line number="9893">  if( rc==SQLITE_OK ){</Line>
  <Line number="9894">    pNew = idxMalloc(&amp;rc, nByte);</Line>
  <Line number="9895">  }</Line>
  <Line number="9896">  if( rc==SQLITE_OK ){</Line>
  <Line number="9897">    pNew-&gt;aCol = (IdxColumn*)&amp;pNew[1];</Line>
  <Line number="9898">    pNew-&gt;nCol = nCol;</Line>
  <Line number="9899">    pCsr = (char*)&amp;pNew-&gt;aCol[nCol];</Line>
  <Line number="9900">  }</Line>
  <Line number="9901"></Line>
  <Line number="9902">  nCol = 0;</Line>
  <Line number="9903">  while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(p1) ){</Line>
  <Line number="9904">    const char *zCol = (const char*)sqlite3_column_text(p1, 1);</Line>
  <Line number="9905">    int nCopy = <CheckRefs ids="2307">STRLEN</CheckRefs>(zCol) <CheckRefs ids="2306">+</CheckRefs> 1;</Line>
  <Line number="9906">    pNew-&gt;aCol[nCol].zName = pCsr;</Line>
  <Line number="9907">    pNew-&gt;aCol[nCol].iPk = (sqlite3_column_int(p1, 5)==1 &amp;&amp; nPk==1);</Line>
  <Line number="9908">    memcpy(pCsr, zCol, <CheckRefs ids="2308">nCopy</CheckRefs>);</Line>
  <Line number="9909">    pCsr += nCopy;</Line>
  <Line number="9910"></Line>
  <Line number="9911">    rc = sqlite3_table_column_metadata(</Line>
  <Line number="9912">        db, &quot;main&quot;, zTab, zCol, 0, &amp;zCol, 0, 0, 0</Line>
  <Line number="9913">    );</Line>
  <Line number="9914">    if( rc==SQLITE_OK ){</Line>
  <Line number="9915">      nCopy = <CheckRefs ids="2310">STRLEN</CheckRefs>(zCol) <CheckRefs ids="2309">+</CheckRefs> 1;</Line>
  <Line number="9916">      pNew-&gt;aCol[nCol].zColl = pCsr;</Line>
  <Line number="9917">      memcpy(pCsr, zCol, <CheckRefs ids="2311">nCopy</CheckRefs>);</Line>
  <Line number="9918">      pCsr += nCopy;</Line>
  <Line number="9919">    }</Line>
  <Line number="9920"></Line>
  <Line number="9921">    nCol<CheckRefs ids="2312">++</CheckRefs>;</Line>
  <Line number="9922">  }</Line>
  <Line number="9923">  idxFinalize(&amp;rc, p1);</Line>
  <Line number="9924"></Line>
  <Line number="9925">  if( rc!=SQLITE_OK ){</Line>
  <Line number="9926">    sqlite3_free(pNew);</Line>
  <Line number="9927">    pNew = 0;</Line>
  <Line number="9928">  }else{</Line>
  <Line number="9929">    pNew-&gt;zName = pCsr;</Line>
  <Line number="9930">    memcpy(pNew-&gt;zName, zTab, nTab<CheckRefs ids="2313,2314">+</CheckRefs>1);</Line>
  <Line number="9931">  }</Line>
  <Line number="9932"></Line>
  <Line number="9933">  *ppOut = pNew;</Line>
  <Line number="9934">  return rc;</Line>
  <Line number="9935">}</Line>
  <Line number="9936"></Line>
  <Line number="9937">/*</Line>
  <Line number="9938">** This function is a no-op if *pRc is set to anything other than </Line>
  <Line number="9939">** SQLITE_OK when it is called.</Line>
  <Line number="9940">**</Line>
  <Line number="9941">** If *pRc is initially set to SQLITE_OK, then the text specified by</Line>
  <Line number="9942">** the printf() style arguments is appended to zIn and the result returned</Line>
  <Line number="9943">** in a buffer allocated by sqlite3_malloc(). sqlite3_free() is called on</Line>
  <Line number="9944">** zIn before returning.</Line>
  <Line number="9945">*/</Line>
  <Line number="9946">static char *idxAppendText(int *pRc, char *zIn, const char *zFmt, ...){</Line>
  <Line number="9947">  va_list ap;</Line>
  <Line number="9948">  char *zAppend = 0;</Line>
  <Line number="9949">  char *zRet = 0;</Line>
  <Line number="9950">  int nIn = zIn ? <CheckRefs ids="2315">STRLEN</CheckRefs>(zIn) : 0;</Line>
  <Line number="9951">  int nAppend = 0;</Line>
  <Line number="9952">  va_start(ap, zFmt);</Line>
  <Line number="9953">  if( *pRc==SQLITE_OK ){</Line>
  <Line number="9954">    zAppend = sqlite3_vmprintf(zFmt, ap);</Line>
  <Line number="9955">    if( zAppend ){</Line>
  <Line number="9956">      nAppend = <CheckRefs ids="2316">STRLEN</CheckRefs>(zAppend);</Line>
  <Line number="9957">      zRet = (char*)sqlite3_malloc(nIn <CheckRefs ids="2318">+</CheckRefs> nAppend <CheckRefs ids="2317">+</CheckRefs> 1);</Line>
  <Line number="9958">    }</Line>
  <Line number="9959">    if( zAppend &amp;&amp; zRet ){</Line>
  <Line number="9960">      if( nIn ) memcpy(zRet, zIn, <CheckRefs ids="2319">nIn</CheckRefs>);</Line>
  <Line number="9961">      memcpy(&amp;zRet[nIn], zAppend, nAppend<CheckRefs ids="2320,2321">+</CheckRefs>1);</Line>
  <Line number="9962">    }else{</Line>
  <Line number="9963">      sqlite3_free(zRet);</Line>
  <Line number="9964">      zRet = 0;</Line>
  <Line number="9965">      *pRc = SQLITE_NOMEM;</Line>
  <Line number="9966">    }</Line>
  <Line number="9967">    sqlite3_free(zAppend);</Line>
  <Line number="9968">    sqlite3_free(zIn);</Line>
  <Line number="9969">  }</Line>
  <Line number="9970">  va_end(ap);</Line>
  <Line number="9971">  return zRet;</Line>
  <Line number="9972">}</Line>
  <Line number="9973"></Line>
  <Line number="9974">/*</Line>
  <Line number="9975">** Return true if zId must be quoted in order to use it as an SQL</Line>
  <Line number="9976">** identifier, or false otherwise.</Line>
  <Line number="9977">*/</Line>
  <Line number="9978">static int idxIdentifierRequiresQuotes(const char *zId){</Line>
  <Line number="9979">  int i;</Line>
  <Line number="9980">  for(i=0; zId[i]; i<CheckRefs ids="2322">++</CheckRefs>){</Line>
  <Line number="9981">    if( !(<CheckRefs ids="2323">zId</CheckRefs>[i]==&apos;_&apos;)</Line>
  <Line number="9982">     &amp;&amp; !(<CheckRefs ids="2324">zId</CheckRefs>[i]&gt;=&apos;0&apos; &amp;&amp; <CheckRefs ids="2325">zId</CheckRefs>[i]&lt;=&apos;9&apos;)</Line>
  <Line number="9983">     &amp;&amp; !(<CheckRefs ids="2326">zId</CheckRefs>[i]&gt;=&apos;a&apos; &amp;&amp; <CheckRefs ids="2327">zId</CheckRefs>[i]&lt;=&apos;z&apos;)</Line>
  <Line number="9984">     &amp;&amp; !(<CheckRefs ids="2328">zId</CheckRefs>[i]&gt;=&apos;A&apos; &amp;&amp; <CheckRefs ids="2329">zId</CheckRefs>[i]&lt;=&apos;Z&apos;)</Line>
  <Line number="9985">    ){</Line>
  <Line number="9986">      return 1;</Line>
  <Line number="9987">    }</Line>
  <Line number="9988">  }</Line>
  <Line number="9989">  return 0;</Line>
  <Line number="9990">}</Line>
  <Line number="9991"></Line>
  <Line number="9992">/*</Line>
  <Line number="9993">** This function appends an index column definition suitable for constraint</Line>
  <Line number="9994">** pCons to the string passed as zIn and returns the result.</Line>
  <Line number="9995">*/</Line>
  <Line number="9996">static char *idxAppendColDefn(</Line>
  <Line number="9997">  int *pRc,                       /* IN/OUT: Error code */</Line>
  <Line number="9998">  char *zIn,                      /* Column defn accumulated so far */</Line>
  <Line number="9999">  IdxTable *pTab,                 /* Table index will be created on */</Line>
  <Line number="10000">  IdxConstraint *pCons</Line>
  <Line number="10001">){</Line>
  <Line number="10002">  char *zRet = zIn;</Line>
  <Line number="10003">  IdxColumn *p = &amp;pTab-&gt;aCol[pCons-&gt;iCol];</Line>
  <Line number="10004">  if( zRet ) zRet = idxAppendText(pRc, zRet, &quot;, &quot;);</Line>
  <Line number="10005"></Line>
  <Line number="10006">  if( idxIdentifierRequiresQuotes(p-&gt;zName) ){</Line>
  <Line number="10007">    zRet = idxAppendText(pRc, zRet, &quot;%Q&quot;, p-&gt;zName);</Line>
  <Line number="10008">  }else{</Line>
  <Line number="10009">    zRet = idxAppendText(pRc, zRet, &quot;%s&quot;, p-&gt;zName);</Line>
  <Line number="10010">  }</Line>
  <Line number="10011"></Line>
  <Line number="10012">  if( sqlite3_stricmp(p-&gt;zColl, pCons-&gt;zColl) ){</Line>
  <Line number="10013">    if( idxIdentifierRequiresQuotes(pCons-&gt;zColl) ){</Line>
  <Line number="10014">      zRet = idxAppendText(pRc, zRet, &quot; COLLATE %Q&quot;, pCons-&gt;zColl);</Line>
  <Line number="10015">    }else{</Line>
  <Line number="10016">      zRet = idxAppendText(pRc, zRet, &quot; COLLATE %s&quot;, pCons-&gt;zColl);</Line>
  <Line number="10017">    }</Line>
  <Line number="10018">  }</Line>
  <Line number="10019"></Line>
  <Line number="10020">  if( pCons-&gt;bDesc ){</Line>
  <Line number="10021">    zRet = idxAppendText(pRc, zRet, &quot; DESC&quot;);</Line>
  <Line number="10022">  }</Line>
  <Line number="10023">  return zRet;</Line>
  <Line number="10024">}</Line>
  <Line number="10025"></Line>
  <Line number="10026">/*</Line>
  <Line number="10027">** Search database dbm for an index compatible with the one idxCreateFromCons()</Line>
  <Line number="10028">** would create from arguments pScan, pEq and pTail. If no error occurs and </Line>
  <Line number="10029">** such an index is found, return non-zero. Or, if no such index is found,</Line>
  <Line number="10030">** return zero.</Line>
  <Line number="10031">**</Line>
  <Line number="10032">** If an error occurs, set *pRc to an SQLite error code and return zero.</Line>
  <Line number="10033">*/</Line>
  <Line number="10034">static int idxFindCompatible(</Line>
  <Line number="10035">  int *pRc,                       /* OUT: Error code */</Line>
  <Line number="10036">  sqlite3* dbm,                   /* Database to search */</Line>
  <Line number="10037">  IdxScan *pScan,                 /* Scan for table to search for index on */</Line>
  <Line number="10038">  IdxConstraint *pEq,             /* List of == constraints */</Line>
  <Line number="10039">  IdxConstraint *pTail            /* List of range constraints */</Line>
  <Line number="10040">){</Line>
  <Line number="10041">  const char *zTbl = pScan-&gt;pTab-&gt;zName;</Line>
  <Line number="10042">  sqlite3_stmt *pIdxList = 0;</Line>
  <Line number="10043">  IdxConstraint *pIter;</Line>
  <Line number="10044">  int nEq = 0;                    /* Number of elements in pEq */</Line>
  <Line number="10045">  int rc;</Line>
  <Line number="10046"></Line>
  <Line number="10047">  /* Count the elements in list pEq */</Line>
  <Line number="10048">  for(pIter=pEq; pIter; pIter=pIter-&gt;pLink) nEq<CheckRefs ids="2330">++</CheckRefs>;</Line>
  <Line number="10049"></Line>
  <Line number="10050">  rc = idxPrintfPrepareStmt(dbm, &amp;pIdxList, 0, &quot;PRAGMA index_list=%Q&quot;, zTbl);</Line>
  <Line number="10051">  while( rc==SQLITE_OK &amp;&amp; sqlite3_step(pIdxList)==SQLITE_ROW ){</Line>
  <Line number="10052">    int bMatch = 1;</Line>
  <Line number="10053">    IdxConstraint *pT = pTail;</Line>
  <Line number="10054">    sqlite3_stmt *pInfo = 0;</Line>
  <Line number="10055">    const char *zIdx = (const char*)sqlite3_column_text(pIdxList, 1);</Line>
  <Line number="10056"></Line>
  <Line number="10057">    /* Zero the IdxConstraint.bFlag values in the pEq list */</Line>
  <Line number="10058">    for(pIter=pEq; pIter; pIter=pIter-&gt;pLink) pIter-&gt;bFlag = 0;</Line>
  <Line number="10059"></Line>
  <Line number="10060">    rc = idxPrintfPrepareStmt(dbm, &amp;pInfo, 0, &quot;PRAGMA index_xInfo=%Q&quot;, zIdx);</Line>
  <Line number="10061">    while( rc==SQLITE_OK &amp;&amp; sqlite3_step(pInfo)==SQLITE_ROW ){</Line>
  <Line number="10062">      int iIdx = sqlite3_column_int(pInfo, 0);</Line>
  <Line number="10063">      int iCol = sqlite3_column_int(pInfo, 1);</Line>
  <Line number="10064">      const char *zColl = (const char*)sqlite3_column_text(pInfo, 4);</Line>
  <Line number="10065"></Line>
  <Line number="10066">      if( iIdx&lt;nEq ){</Line>
  <Line number="10067">        for(pIter=pEq; pIter; pIter=pIter-&gt;pLink){</Line>
  <Line number="10068">          if( pIter-&gt;bFlag ) continue;</Line>
  <Line number="10069">          if( pIter-&gt;iCol!=iCol ) continue;</Line>
  <Line number="10070">          if( sqlite3_stricmp(pIter-&gt;zColl, zColl) ) continue;</Line>
  <Line number="10071">          pIter-&gt;bFlag = 1;</Line>
  <Line number="10072">          break;</Line>
  <Line number="10073">        }</Line>
  <Line number="10074">        if( pIter==0 ){</Line>
  <Line number="10075">          bMatch = 0;</Line>
  <Line number="10076">          break;</Line>
  <Line number="10077">        }</Line>
  <Line number="10078">      }else{</Line>
  <Line number="10079">        if( pT ){</Line>
  <Line number="10080">          if( pT-&gt;iCol!=iCol || sqlite3_stricmp(pT-&gt;zColl, zColl) ){</Line>
  <Line number="10081">            bMatch = 0;</Line>
  <Line number="10082">            break;</Line>
  <Line number="10083">          }</Line>
  <Line number="10084">          pT = pT-&gt;pLink;</Line>
  <Line number="10085">        }</Line>
  <Line number="10086">      }</Line>
  <Line number="10087">    }</Line>
  <Line number="10088">    idxFinalize(&amp;rc, pInfo);</Line>
  <Line number="10089"></Line>
  <Line number="10090">    if( rc==SQLITE_OK &amp;&amp; bMatch ){</Line>
  <Line number="10091">      sqlite3_finalize(pIdxList);</Line>
  <Line number="10092">      return 1;</Line>
  <Line number="10093">    }</Line>
  <Line number="10094">  }</Line>
  <Line number="10095">  idxFinalize(&amp;rc, pIdxList);</Line>
  <Line number="10096"></Line>
  <Line number="10097">  *pRc = rc;</Line>
  <Line number="10098">  return 0;</Line>
  <Line number="10099">}</Line>
  <Line number="10100"></Line>
  <Line number="10101">static int idxCreateFromCons(</Line>
  <Line number="10102">  sqlite3expert *p,</Line>
  <Line number="10103">  IdxScan *pScan,</Line>
  <Line number="10104">  IdxConstraint *pEq, </Line>
  <Line number="10105">  IdxConstraint *pTail</Line>
  <Line number="10106">){</Line>
  <Line number="10107">  sqlite3 *dbm = p-&gt;dbm;</Line>
  <Line number="10108">  int rc = SQLITE_OK;</Line>
  <Line number="10109">  if( (pEq || pTail) &amp;&amp; 0==idxFindCompatible(&amp;rc, dbm, pScan, pEq, pTail) ){</Line>
  <Line number="10110">    IdxTable *pTab = pScan-&gt;pTab;</Line>
  <Line number="10111">    char *zCols = 0;</Line>
  <Line number="10112">    char *zIdx = 0;</Line>
  <Line number="10113">    IdxConstraint *pCons;</Line>
  <Line number="10114">    unsigned int h = <CheckRefs ids="2331">0</CheckRefs>;</Line>
  <Line number="10115">    const char *zFmt;</Line>
  <Line number="10116"></Line>
  <Line number="10117">    for(pCons=pEq; pCons; pCons=pCons-&gt;pLink){</Line>
  <Line number="10118">      zCols = idxAppendColDefn(&amp;rc, zCols, pTab, pCons);</Line>
  <Line number="10119">    }</Line>
  <Line number="10120">    for(pCons=pTail; pCons; pCons=pCons-&gt;pLink){</Line>
  <Line number="10121">      zCols = idxAppendColDefn(&amp;rc, zCols, pTab, pCons);</Line>
  <Line number="10122">    }</Line>
  <Line number="10123"></Line>
  <Line number="10124">    if( rc==SQLITE_OK ){</Line>
  <Line number="10125">      /* Hash the list of columns to come up with a name for the index */</Line>
  <Line number="10126">      const char *zTable = pScan-&gt;pTab-&gt;zName;</Line>
  <Line number="10127">      char *zName;                /* Index name */</Line>
  <Line number="10128">      int i;</Line>
  <Line number="10129">      for(i=0; zCols[i]; i<CheckRefs ids="2332">++</CheckRefs>){</Line>
  <Line number="10130">        h <CheckRefs ids="2333">+=</CheckRefs> ((h<CheckRefs ids="2335">&lt;&lt;</CheckRefs>3) <CheckRefs ids="2334">+</CheckRefs> <CheckRefs ids="2336">zCols</CheckRefs>[i]);</Line>
  <Line number="10131">      }</Line>
  <Line number="10132">      zName = sqlite3_mprintf(&quot;%s_idx_%08x&quot;, zTable, h);</Line>
  <Line number="10133">      if( zName==0 ){ </Line>
  <Line number="10134">        rc = SQLITE_NOMEM;</Line>
  <Line number="10135">      }else{</Line>
  <Line number="10136">        if( idxIdentifierRequiresQuotes(zTable) ){</Line>
  <Line number="10137">          zFmt = &quot;CREATE INDEX &apos;%q&apos; ON %Q(%s)&quot;;</Line>
  <Line number="10138">        }else{</Line>
  <Line number="10139">          zFmt = &quot;CREATE INDEX %s ON %s(%s)&quot;;</Line>
  <Line number="10140">        }</Line>
  <Line number="10141">        zIdx = sqlite3_mprintf(zFmt, zName, zTable, zCols);</Line>
  <Line number="10142">        if( !zIdx ){</Line>
  <Line number="10143">          rc = SQLITE_NOMEM;</Line>
  <Line number="10144">        }else{</Line>
  <Line number="10145">          rc = sqlite3_exec(dbm, zIdx, 0, 0, p-&gt;pzErrmsg);</Line>
  <Line number="10146">          idxHashAdd(&amp;rc, &amp;p-&gt;hIdx, zName, zIdx);</Line>
  <Line number="10147">        }</Line>
  <Line number="10148">        sqlite3_free(zName);</Line>
  <Line number="10149">        sqlite3_free(zIdx);</Line>
  <Line number="10150">      }</Line>
  <Line number="10151">    }</Line>
  <Line number="10152"></Line>
  <Line number="10153">    sqlite3_free(zCols);</Line>
  <Line number="10154">  }</Line>
  <Line number="10155">  return rc;</Line>
  <Line number="10156">}</Line>
  <Line number="10157"></Line>
  <Line number="10158">/*</Line>
  <Line number="10159">** Return true if list pList (linked by IdxConstraint.pLink) contains</Line>
  <Line number="10160">** a constraint compatible with *p. Otherwise return false.</Line>
  <Line number="10161">*/</Line>
  <Line number="10162">static int idxFindConstraint(IdxConstraint *pList, IdxConstraint *p){</Line>
  <Line number="10163">  IdxConstraint *pCmp;</Line>
  <Line number="10164">  for(pCmp=pList; pCmp; pCmp=pCmp-&gt;pLink){</Line>
  <Line number="10165">    if( p-&gt;iCol==pCmp-&gt;iCol ) return 1;</Line>
  <Line number="10166">  }</Line>
  <Line number="10167">  return 0;</Line>
  <Line number="10168">}</Line>
  <Line number="10169"></Line>
  <Line number="10170">static int idxCreateFromWhere(</Line>
  <Line number="10171">  sqlite3expert *p, </Line>
  <Line number="10172">  IdxScan *pScan,                 /* Create indexes for this scan */</Line>
  <Line number="10173">  IdxConstraint *pTail            /* range/ORDER BY constraints for inclusion */</Line>
  <Line number="10174">){</Line>
  <Line number="10175">  IdxConstraint *p1 = 0;</Line>
  <Line number="10176">  IdxConstraint *pCon;</Line>
  <Line number="10177">  int rc;</Line>
  <Line number="10178"></Line>
  <Line number="10179">  /* Gather up all the == constraints. */</Line>
  <Line number="10180">  for(pCon=pScan-&gt;pEq; pCon; pCon=pCon-&gt;pNext){</Line>
  <Line number="10181">    if( !idxFindConstraint(p1, pCon) &amp;&amp; !idxFindConstraint(pTail, pCon) ){</Line>
  <Line number="10182">      pCon-&gt;pLink = p1;</Line>
  <Line number="10183">      p1 = pCon;</Line>
  <Line number="10184">    }</Line>
  <Line number="10185">  }</Line>
  <Line number="10186"></Line>
  <Line number="10187">  /* Create an index using the == constraints collected above. And the</Line>
  <Line number="10188">  ** range constraint/ORDER BY terms passed in by the caller, if any. */</Line>
  <Line number="10189">  rc = idxCreateFromCons(p, pScan, p1, pTail);</Line>
  <Line number="10190"></Line>
  <Line number="10191">  /* If no range/ORDER BY passed by the caller, create a version of the</Line>
  <Line number="10192">  ** index for each range constraint.  */</Line>
  <Line number="10193">  if( pTail==0 ){</Line>
  <Line number="10194">    for(pCon=pScan-&gt;pRange; rc==SQLITE_OK &amp;&amp; pCon; pCon=pCon-&gt;pNext){</Line>
  <Line number="10195">      <CheckRefs ids="2337">assert</CheckRefs>( pCon-&gt;pLink==0 );</Line>
  <Line number="10196">      if( !idxFindConstraint(p1, pCon) &amp;&amp; !idxFindConstraint(pTail, pCon) ){</Line>
  <Line number="10197">        rc = idxCreateFromCons(p, pScan, p1, pCon);</Line>
  <Line number="10198">      }</Line>
  <Line number="10199">    }</Line>
  <Line number="10200">  }</Line>
  <Line number="10201"></Line>
  <Line number="10202">  return rc;</Line>
  <Line number="10203">}</Line>
  <Line number="10204"></Line>
  <Line number="10205">/*</Line>
  <Line number="10206">** Create candidate indexes in database [dbm] based on the data in </Line>
  <Line number="10207">** linked-list pScan.</Line>
  <Line number="10208">*/</Line>
  <Line number="10209">static int idxCreateCandidates(sqlite3expert *p){</Line>
  <Line number="10210">  int rc = SQLITE_OK;</Line>
  <Line number="10211">  IdxScan *pIter;</Line>
  <Line number="10212"></Line>
  <Line number="10213">  for(pIter=p-&gt;pScan; pIter &amp;&amp; rc==SQLITE_OK; pIter=pIter-&gt;pNextScan){</Line>
  <Line number="10214">    rc = idxCreateFromWhere(p, pIter, 0);</Line>
  <Line number="10215">    if( rc==SQLITE_OK &amp;&amp; pIter-&gt;pOrder ){</Line>
  <Line number="10216">      rc = idxCreateFromWhere(p, pIter, pIter-&gt;pOrder);</Line>
  <Line number="10217">    }</Line>
  <Line number="10218">  }</Line>
  <Line number="10219"></Line>
  <Line number="10220">  return rc;</Line>
  <Line number="10221">}</Line>
  <Line number="10222"></Line>
  <Line number="10223">/*</Line>
  <Line number="10224">** Free all elements of the linked list starting at pConstraint.</Line>
  <Line number="10225">*/</Line>
  <Line number="10226">static void idxConstraintFree(IdxConstraint *pConstraint){</Line>
  <Line number="10227">  IdxConstraint *pNext;</Line>
  <Line number="10228">  IdxConstraint *p;</Line>
  <Line number="10229"></Line>
  <Line number="10230">  for(p=pConstraint; p; p=pNext){</Line>
  <Line number="10231">    pNext = p-&gt;pNext;</Line>
  <Line number="10232">    sqlite3_free(p);</Line>
  <Line number="10233">  }</Line>
  <Line number="10234">}</Line>
  <Line number="10235"></Line>
  <Line number="10236">/*</Line>
  <Line number="10237">** Free all elements of the linked list starting from pScan up until pLast</Line>
  <Line number="10238">** (pLast is not freed).</Line>
  <Line number="10239">*/</Line>
  <Line number="10240">static void idxScanFree(IdxScan *pScan, IdxScan *pLast){</Line>
  <Line number="10241">  IdxScan *p;</Line>
  <Line number="10242">  IdxScan *pNext;</Line>
  <Line number="10243">  for(p=pScan; p!=pLast; p=pNext){</Line>
  <Line number="10244">    pNext = p-&gt;pNextScan;</Line>
  <Line number="10245">    idxConstraintFree(p-&gt;pOrder);</Line>
  <Line number="10246">    idxConstraintFree(p-&gt;pEq);</Line>
  <Line number="10247">    idxConstraintFree(p-&gt;pRange);</Line>
  <Line number="10248">    sqlite3_free(p);</Line>
  <Line number="10249">  }</Line>
  <Line number="10250">}</Line>
  <Line number="10251"></Line>
  <Line number="10252">/*</Line>
  <Line number="10253">** Free all elements of the linked list starting from pStatement up </Line>
  <Line number="10254">** until pLast (pLast is not freed).</Line>
  <Line number="10255">*/</Line>
  <Line number="10256">static void idxStatementFree(IdxStatement *pStatement, IdxStatement *pLast){</Line>
  <Line number="10257">  IdxStatement *p;</Line>
  <Line number="10258">  IdxStatement *pNext;</Line>
  <Line number="10259">  for(p=pStatement; p!=pLast; p=pNext){</Line>
  <Line number="10260">    pNext = p-&gt;pNext;</Line>
  <Line number="10261">    sqlite3_free(p-&gt;zEQP);</Line>
  <Line number="10262">    sqlite3_free(p-&gt;zIdx);</Line>
  <Line number="10263">    sqlite3_free(p);</Line>
  <Line number="10264">  }</Line>
  <Line number="10265">}</Line>
  <Line number="10266"></Line>
  <Line number="10267">/*</Line>
  <Line number="10268">** Free the linked list of IdxTable objects starting at pTab.</Line>
  <Line number="10269">*/</Line>
  <Line number="10270">static void idxTableFree(IdxTable *pTab){</Line>
  <Line number="10271">  IdxTable *pIter;</Line>
  <Line number="10272">  IdxTable *pNext;</Line>
  <Line number="10273">  for(pIter=pTab; pIter; pIter=pNext){</Line>
  <Line number="10274">    pNext = pIter-&gt;pNext;</Line>
  <Line number="10275">    sqlite3_free(pIter);</Line>
  <Line number="10276">  }</Line>
  <Line number="10277">}</Line>
  <Line number="10278"></Line>
  <Line number="10279">/*</Line>
  <Line number="10280">** Free the linked list of IdxWrite objects starting at pTab.</Line>
  <Line number="10281">*/</Line>
  <Line number="10282">static void idxWriteFree(IdxWrite *pTab){</Line>
  <Line number="10283">  IdxWrite *pIter;</Line>
  <Line number="10284">  IdxWrite *pNext;</Line>
  <Line number="10285">  for(pIter=pTab; pIter; pIter=pNext){</Line>
  <Line number="10286">    pNext = pIter-&gt;pNext;</Line>
  <Line number="10287">    sqlite3_free(pIter);</Line>
  <Line number="10288">  }</Line>
  <Line number="10289">}</Line>
  <Line number="10290"></Line>
  <Line number="10291"></Line>
  <Line number="10292"></Line>
  <Line number="10293">/*</Line>
  <Line number="10294">** This function is called after candidate indexes have been created. It</Line>
  <Line number="10295">** runs all the queries to see which indexes they prefer, and populates</Line>
  <Line number="10296">** IdxStatement.zIdx and IdxStatement.zEQP with the results.</Line>
  <Line number="10297">*/</Line>
  <Line number="10298">int idxFindIndexes(</Line>
  <Line number="10299">  sqlite3expert *p,</Line>
  <Line number="10300">  char **pzErr                         /* OUT: Error message (sqlite3_malloc) */</Line>
  <Line number="10301">){</Line>
  <Line number="10302">  IdxStatement *pStmt;</Line>
  <Line number="10303">  sqlite3 *dbm = p-&gt;dbm;</Line>
  <Line number="10304">  int rc = SQLITE_OK;</Line>
  <Line number="10305"></Line>
  <Line number="10306">  IdxHash hIdx;</Line>
  <Line number="10307">  idxHashInit(&amp;hIdx);</Line>
  <Line number="10308"></Line>
  <Line number="10309">  for(pStmt=p-&gt;pStatement; rc==SQLITE_OK &amp;&amp; pStmt; pStmt=pStmt-&gt;pNext){</Line>
  <Line number="10310">    IdxHashEntry *pEntry;</Line>
  <Line number="10311">    sqlite3_stmt *pExplain = 0;</Line>
  <Line number="10312">    idxHashClear(&amp;hIdx);</Line>
  <Line number="10313">    rc = idxPrintfPrepareStmt(dbm, &amp;pExplain, pzErr,</Line>
  <Line number="10314">        &quot;EXPLAIN QUERY PLAN %s&quot;, pStmt-&gt;zSql</Line>
  <Line number="10315">    );</Line>
  <Line number="10316">    while( rc==SQLITE_OK &amp;&amp; sqlite3_step(pExplain)==SQLITE_ROW ){</Line>
  <Line number="10317">      /* int iId = sqlite3_column_int(pExplain, 0); */</Line>
  <Line number="10318">      /* int iParent = sqlite3_column_int(pExplain, 1); */</Line>
  <Line number="10319">      /* int iNotUsed = sqlite3_column_int(pExplain, 2); */</Line>
  <Line number="10320">      const char *zDetail = (const char*)sqlite3_column_text(pExplain, 3);</Line>
  <Line number="10321">      int nDetail;</Line>
  <Line number="10322">      int i;</Line>
  <Line number="10323"></Line>
  <Line number="10324">      if( !zDetail ) continue;</Line>
  <Line number="10325">      nDetail = <CheckRefs ids="2338">STRLEN</CheckRefs>(zDetail);</Line>
  <Line number="10326"></Line>
  <Line number="10327">      for(i=0; i&lt;nDetail; i<CheckRefs ids="2339">++</CheckRefs>){</Line>
  <Line number="10328">        const char *zIdx = 0;</Line>
  <Line number="10329">        if( i<CheckRefs ids="2340">+</CheckRefs>13&lt;nDetail &amp;&amp; memcmp(&amp;zDetail[i], &quot; USING INDEX &quot;, <CheckRefs ids="2341">13</CheckRefs>)==0 ){</Line>
  <Line number="10330">          zIdx = &amp;zDetail[i<CheckRefs ids="2342">+</CheckRefs>13];</Line>
  <Line number="10331">        }else if( i<CheckRefs ids="2343">+</CheckRefs>22&lt;nDetail </Line>
  <Line number="10332">            &amp;&amp; memcmp(&amp;zDetail[i], &quot; USING COVERING INDEX &quot;, <CheckRefs ids="2344">22</CheckRefs>)==0 </Line>
  <Line number="10333">        ){</Line>
  <Line number="10334">          zIdx = &amp;zDetail[i<CheckRefs ids="2345">+</CheckRefs>22];</Line>
  <Line number="10335">        }</Line>
  <Line number="10336">        if( zIdx ){</Line>
  <Line number="10337">          const char *zSql;</Line>
  <Line number="10338">          int nIdx = 0;</Line>
  <Line number="10339">          while( <CheckRefs ids="2346">zIdx</CheckRefs>[nIdx]!=&apos;\0&apos; &amp;&amp; (<CheckRefs ids="2347">zIdx</CheckRefs>[nIdx]!=&apos; &apos; || <CheckRefs ids="2348">zIdx</CheckRefs>[nIdx<CheckRefs ids="2349">+</CheckRefs>1]!=&apos;(&apos;) ){</Line>
  <Line number="10340">            nIdx<CheckRefs ids="2350">++</CheckRefs>;</Line>
  <Line number="10341">          }</Line>
  <Line number="10342">          zSql = idxHashSearch(&amp;p-&gt;hIdx, zIdx, nIdx);</Line>
  <Line number="10343">          if( zSql ){</Line>
  <Line number="10344">            idxHashAdd(&amp;rc, &amp;hIdx, zSql, 0);</Line>
  <Line number="10345">            if( rc ) goto find_indexes_out;</Line>
  <Line number="10346">          }</Line>
  <Line number="10347">          break;</Line>
  <Line number="10348">        }</Line>
  <Line number="10349">      }</Line>
  <Line number="10350"></Line>
  <Line number="10351">      if( <CheckRefs ids="2351">zDetail</CheckRefs>[0]!=&apos;-&apos; ){</Line>
  <Line number="10352">        pStmt-&gt;zEQP = idxAppendText(&amp;rc, pStmt-&gt;zEQP, &quot;%s\n&quot;, zDetail);</Line>
  <Line number="10353">      }</Line>
  <Line number="10354">    }</Line>
  <Line number="10355"></Line>
  <Line number="10356">    for(pEntry=hIdx.pFirst; pEntry; pEntry=pEntry-&gt;pNext){</Line>
  <Line number="10357">      pStmt-&gt;zIdx = idxAppendText(&amp;rc, pStmt-&gt;zIdx, &quot;%s;\n&quot;, pEntry-&gt;zKey);</Line>
  <Line number="10358">    }</Line>
  <Line number="10359"></Line>
  <Line number="10360">    idxFinalize(&amp;rc, pExplain);</Line>
  <Line number="10361">  }</Line>
  <Line number="10362"></Line>
  <Line number="10363"> find_indexes_out:</Line>
  <Line number="10364">  idxHashClear(&amp;hIdx);</Line>
  <Line number="10365">  return rc;</Line>
  <Line number="10366">}</Line>
  <Line number="10367"></Line>
  <Line number="10368">static int idxAuthCallback(</Line>
  <Line number="10369">  void *pCtx,</Line>
  <Line number="10370">  int eOp,</Line>
  <Line number="10371">  const char *z3,</Line>
  <Line number="10372">  const char *z4,</Line>
  <Line number="10373">  const char *zDb,</Line>
  <Line number="10374">  const char *zTrigger</Line>
  <Line number="10375">){</Line>
  <Line number="10376">  int rc = SQLITE_OK;</Line>
  <Line number="10377">  (void)z4;</Line>
  <Line number="10378">  (void)zTrigger;</Line>
  <Line number="10379">  if( eOp==SQLITE_INSERT || eOp==SQLITE_UPDATE || eOp==SQLITE_DELETE ){</Line>
  <Line number="10380">    if( sqlite3_stricmp(zDb, &quot;main&quot;)==0 ){</Line>
  <Line number="10381">      sqlite3expert *p = (sqlite3expert*)pCtx;</Line>
  <Line number="10382">      IdxTable *pTab;</Line>
  <Line number="10383">      for(pTab=p-&gt;pTable; pTab; pTab=pTab-&gt;pNext){</Line>
  <Line number="10384">        if( 0==sqlite3_stricmp(z3, pTab-&gt;zName) ) break;</Line>
  <Line number="10385">      }</Line>
  <Line number="10386">      if( pTab ){</Line>
  <Line number="10387">        IdxWrite *pWrite;</Line>
  <Line number="10388">        for(pWrite=p-&gt;pWrite; pWrite; pWrite=pWrite-&gt;pNext){</Line>
  <Line number="10389">          if( pWrite-&gt;pTab==pTab &amp;&amp; pWrite-&gt;eOp==eOp ) break;</Line>
  <Line number="10390">        }</Line>
  <Line number="10391">        if( pWrite==0 ){</Line>
  <Line number="10392">          pWrite = idxMalloc(&amp;rc, <CheckRefs ids="2352">sizeof</CheckRefs>(IdxWrite));</Line>
  <Line number="10393">          if( rc==SQLITE_OK ){</Line>
  <Line number="10394">            pWrite-&gt;pTab = pTab;</Line>
  <Line number="10395">            pWrite-&gt;eOp = eOp;</Line>
  <Line number="10396">            pWrite-&gt;pNext = p-&gt;pWrite;</Line>
  <Line number="10397">            p-&gt;pWrite = pWrite;</Line>
  <Line number="10398">          }</Line>
  <Line number="10399">        }</Line>
  <Line number="10400">      }</Line>
  <Line number="10401">    }</Line>
  <Line number="10402">  }</Line>
  <Line number="10403">  return rc;</Line>
  <Line number="10404">}</Line>
  <Line number="10405"></Line>
  <Line number="10406">static int idxProcessOneTrigger(</Line>
  <Line number="10407">  sqlite3expert *p, </Line>
  <Line number="10408">  IdxWrite *pWrite, </Line>
  <Line number="10409">  char **pzErr</Line>
  <Line number="10410">){</Line>
  <Line number="10411">  static const char *zInt = UNIQUE_TABLE_NAME;</Line>
  <Line number="10412">  static const char *zDrop = &quot;DROP TABLE &quot; UNIQUE_TABLE_NAME;</Line>
  <Line number="10413">  IdxTable *pTab = pWrite-&gt;pTab;</Line>
  <Line number="10414">  const char *zTab = pTab-&gt;zName;</Line>
  <Line number="10415">  const char *zSql = </Line>
  <Line number="10416">    &quot;SELECT &apos;CREATE TEMP&apos; || substr(sql, 7) FROM sqlite_schema &quot;</Line>
  <Line number="10417">    &quot;WHERE tbl_name = %Q AND type IN (&apos;table&apos;, &apos;trigger&apos;) &quot;</Line>
  <Line number="10418">    &quot;ORDER BY type;&quot;;</Line>
  <Line number="10419">  sqlite3_stmt *pSelect = 0;</Line>
  <Line number="10420">  int rc = SQLITE_OK;</Line>
  <Line number="10421">  char *zWrite = 0;</Line>
  <Line number="10422"></Line>
  <Line number="10423">  /* Create the table and its triggers in the temp schema */</Line>
  <Line number="10424">  rc = idxPrintfPrepareStmt(p-&gt;db, &amp;pSelect, pzErr, zSql, zTab, zTab);</Line>
  <Line number="10425">  while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pSelect) ){</Line>
  <Line number="10426">    const char *zCreate = (const char*)sqlite3_column_text(pSelect, 0);</Line>
  <Line number="10427">    rc = sqlite3_exec(p-&gt;dbv, zCreate, 0, 0, pzErr);</Line>
  <Line number="10428">  }</Line>
  <Line number="10429">  idxFinalize(&amp;rc, pSelect);</Line>
  <Line number="10430"></Line>
  <Line number="10431">  /* Rename the table in the temp schema to zInt */</Line>
  <Line number="10432">  if( rc==SQLITE_OK ){</Line>
  <Line number="10433">    char *z = sqlite3_mprintf(&quot;ALTER TABLE temp.%Q RENAME TO %Q&quot;, zTab, zInt);</Line>
  <Line number="10434">    if( z==0 ){</Line>
  <Line number="10435">      rc = SQLITE_NOMEM;</Line>
  <Line number="10436">    }else{</Line>
  <Line number="10437">      rc = sqlite3_exec(p-&gt;dbv, z, 0, 0, pzErr);</Line>
  <Line number="10438">      sqlite3_free(z);</Line>
  <Line number="10439">    }</Line>
  <Line number="10440">  }</Line>
  <Line number="10441"></Line>
  <Line number="10442">  switch( pWrite-&gt;eOp ){</Line>
  <Line number="10443">    case SQLITE_INSERT: {</Line>
  <Line number="10444">      int i;</Line>
  <Line number="10445">      zWrite = idxAppendText(&amp;rc, zWrite, &quot;INSERT INTO %Q VALUES(&quot;, zInt);</Line>
  <Line number="10446">      for(i=0; i&lt;pTab-&gt;nCol; i<CheckRefs ids="2353">++</CheckRefs>){</Line>
  <Line number="10447">        zWrite = idxAppendText(&amp;rc, zWrite, &quot;%s?&quot;, i==0 ? &quot;&quot; : &quot;, &quot;);</Line>
  <Line number="10448">      }</Line>
  <Line number="10449">      zWrite = idxAppendText(&amp;rc, zWrite, &quot;)&quot;);</Line>
  <Line number="10450">      break;</Line>
  <Line number="10451">    }</Line>
  <Line number="10452">    case SQLITE_UPDATE: {</Line>
  <Line number="10453">      int i;</Line>
  <Line number="10454">      zWrite = idxAppendText(&amp;rc, zWrite, &quot;UPDATE %Q SET &quot;, zInt);</Line>
  <Line number="10455">      for(i=0; i&lt;pTab-&gt;nCol; i<CheckRefs ids="2354">++</CheckRefs>){</Line>
  <Line number="10456">        zWrite = idxAppendText(&amp;rc, zWrite, &quot;%s%Q=?&quot;, i==0 ? &quot;&quot; : &quot;, &quot;, </Line>
  <Line number="10457">            pTab-&gt;aCol[i].zName</Line>
  <Line number="10458">        );</Line>
  <Line number="10459">      }</Line>
  <Line number="10460">      break;</Line>
  <Line number="10461">    }</Line>
  <Line number="10462">    default: {</Line>
  <Line number="10463">      <CheckRefs ids="2355">assert</CheckRefs>( pWrite-&gt;eOp==SQLITE_DELETE );</Line>
  <Line number="10464">      if( rc==SQLITE_OK ){</Line>
  <Line number="10465">        zWrite = sqlite3_mprintf(&quot;DELETE FROM %Q&quot;, zInt);</Line>
  <Line number="10466">        if( zWrite==0 ) rc = SQLITE_NOMEM;</Line>
  <Line number="10467">      }</Line>
  <Line number="10468">    }</Line>
  <Line number="10469">  }</Line>
  <Line number="10470"></Line>
  <Line number="10471">  if( rc==SQLITE_OK ){</Line>
  <Line number="10472">    sqlite3_stmt *pX = 0;</Line>
  <Line number="10473">    rc = sqlite3_prepare_v2(p-&gt;dbv, zWrite, <CheckRefs ids="2356">-</CheckRefs>1, &amp;pX, 0);</Line>
  <Line number="10474">    idxFinalize(&amp;rc, pX);</Line>
  <Line number="10475">    if( rc!=SQLITE_OK ){</Line>
  <Line number="10476">      idxDatabaseError(p-&gt;dbv, pzErr);</Line>
  <Line number="10477">    }</Line>
  <Line number="10478">  }</Line>
  <Line number="10479">  sqlite3_free(zWrite);</Line>
  <Line number="10480"></Line>
  <Line number="10481">  if( rc==SQLITE_OK ){</Line>
  <Line number="10482">    rc = sqlite3_exec(p-&gt;dbv, zDrop, 0, 0, pzErr);</Line>
  <Line number="10483">  }</Line>
  <Line number="10484"></Line>
  <Line number="10485">  return rc;</Line>
  <Line number="10486">}</Line>
  <Line number="10487"></Line>
  <Line number="10488">static int idxProcessTriggers(sqlite3expert *p, char **pzErr){</Line>
  <Line number="10489">  int rc = SQLITE_OK;</Line>
  <Line number="10490">  IdxWrite *pEnd = 0;</Line>
  <Line number="10491">  IdxWrite *pFirst = p-&gt;pWrite;</Line>
  <Line number="10492"></Line>
  <Line number="10493">  while( rc==SQLITE_OK &amp;&amp; pFirst!=pEnd ){</Line>
  <Line number="10494">    IdxWrite *pIter;</Line>
  <Line number="10495">    for(pIter=pFirst; rc==SQLITE_OK &amp;&amp; pIter!=pEnd; pIter=pIter-&gt;pNext){</Line>
  <Line number="10496">      rc = idxProcessOneTrigger(p, pIter, pzErr);</Line>
  <Line number="10497">    }</Line>
  <Line number="10498">    pEnd = pFirst;</Line>
  <Line number="10499">    pFirst = p-&gt;pWrite;</Line>
  <Line number="10500">  }</Line>
  <Line number="10501"></Line>
  <Line number="10502">  return rc;</Line>
  <Line number="10503">}</Line>
  <Line number="10504"></Line>
  <Line number="10505"></Line>
  <Line number="10506">static int idxCreateVtabSchema(sqlite3expert *p, char **pzErrmsg){</Line>
  <Line number="10507">  int rc = idxRegisterVtab(p);</Line>
  <Line number="10508">  sqlite3_stmt *pSchema = 0;</Line>
  <Line number="10509"></Line>
  <Line number="10510">  /* For each table in the main db schema:</Line>
  <Line number="10511">  **</Line>
  <Line number="10512">  **   1) Add an entry to the p-&gt;pTable list, and</Line>
  <Line number="10513">  **   2) Create the equivalent virtual table in dbv.</Line>
  <Line number="10514">  */</Line>
  <Line number="10515">  rc = idxPrepareStmt(p-&gt;db, &amp;pSchema, pzErrmsg,</Line>
  <Line number="10516">      &quot;SELECT type, name, sql, 1 FROM sqlite_schema &quot;</Line>
  <Line number="10517">      &quot;WHERE type IN (&apos;table&apos;,&apos;view&apos;) AND name NOT LIKE &apos;sqlite_%%&apos; &quot;</Line>
  <Line number="10518">      &quot; UNION ALL &quot;</Line>
  <Line number="10519">      &quot;SELECT type, name, sql, 2 FROM sqlite_schema &quot;</Line>
  <Line number="10520">      &quot;WHERE type = &apos;trigger&apos;&quot;</Line>
  <Line number="10521">      &quot;  AND tbl_name IN(SELECT name FROM sqlite_schema WHERE type = &apos;view&apos;) &quot;</Line>
  <Line number="10522">      &quot;ORDER BY 4, 1&quot;</Line>
  <Line number="10523">  );</Line>
  <Line number="10524">  while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pSchema) ){</Line>
  <Line number="10525">    const char *zType = (const char*)sqlite3_column_text(pSchema, 0);</Line>
  <Line number="10526">    const char *zName = (const char*)sqlite3_column_text(pSchema, 1);</Line>
  <Line number="10527">    const char *zSql = (const char*)sqlite3_column_text(pSchema, 2);</Line>
  <Line number="10528"></Line>
  <Line number="10529">    if( <CheckRefs ids="2357">zType</CheckRefs>[0]==&apos;v&apos; || <CheckRefs ids="2358">zType</CheckRefs>[1]==&apos;r&apos; ){</Line>
  <Line number="10530">      rc = sqlite3_exec(p-&gt;dbv, zSql, 0, 0, pzErrmsg);</Line>
  <Line number="10531">    }else{</Line>
  <Line number="10532">      IdxTable *pTab;</Line>
  <Line number="10533">      rc = idxGetTableInfo(p-&gt;db, zName, &amp;pTab, pzErrmsg);</Line>
  <Line number="10534">      if( rc==SQLITE_OK ){</Line>
  <Line number="10535">        int i;</Line>
  <Line number="10536">        char *zInner = 0;</Line>
  <Line number="10537">        char *zOuter = 0;</Line>
  <Line number="10538">        pTab-&gt;pNext = p-&gt;pTable;</Line>
  <Line number="10539">        p-&gt;pTable = pTab;</Line>
  <Line number="10540"></Line>
  <Line number="10541">        /* The statement the vtab will pass to sqlite3_declare_vtab() */</Line>
  <Line number="10542">        zInner = idxAppendText(&amp;rc, 0, &quot;CREATE TABLE x(&quot;);</Line>
  <Line number="10543">        for(i=0; i&lt;pTab-&gt;nCol; i<CheckRefs ids="2359">++</CheckRefs>){</Line>
  <Line number="10544">          zInner = idxAppendText(&amp;rc, zInner, &quot;%s%Q COLLATE %s&quot;, </Line>
  <Line number="10545">              (i==0 ? &quot;&quot; : &quot;, &quot;), pTab-&gt;aCol[i].zName, pTab-&gt;aCol[i].zColl</Line>
  <Line number="10546">          );</Line>
  <Line number="10547">        }</Line>
  <Line number="10548">        zInner = idxAppendText(&amp;rc, zInner, &quot;)&quot;);</Line>
  <Line number="10549"></Line>
  <Line number="10550">        /* The CVT statement to create the vtab */</Line>
  <Line number="10551">        zOuter = idxAppendText(&amp;rc, 0, </Line>
  <Line number="10552">            &quot;CREATE VIRTUAL TABLE %Q USING expert(%Q)&quot;, zName, zInner</Line>
  <Line number="10553">        );</Line>
  <Line number="10554">        if( rc==SQLITE_OK ){</Line>
  <Line number="10555">          rc = sqlite3_exec(p-&gt;dbv, zOuter, 0, 0, pzErrmsg);</Line>
  <Line number="10556">        }</Line>
  <Line number="10557">        sqlite3_free(zInner);</Line>
  <Line number="10558">        sqlite3_free(zOuter);</Line>
  <Line number="10559">      }</Line>
  <Line number="10560">    }</Line>
  <Line number="10561">  }</Line>
  <Line number="10562">  idxFinalize(&amp;rc, pSchema);</Line>
  <Line number="10563">  return rc;</Line>
  <Line number="10564">}</Line>
  <Line number="10565"></Line>
  <Line number="10566">struct IdxSampleCtx {</Line>
  <Line number="10567">  int iTarget;</Line>
  <Line number="10568">  double target;                  /* Target nRet/nRow value */</Line>
  <Line number="10569">  double nRow;                    /* Number of rows seen */</Line>
  <Line number="10570">  double nRet;                    /* Number of rows returned */</Line>
  <Line number="10571">};</Line>
  <Line number="10572"></Line>
  <Line number="10573">static void idxSampleFunc(</Line>
  <Line number="10574">  sqlite3_context *pCtx,</Line>
  <Line number="10575">  int argc,</Line>
  <Line number="10576">  sqlite3_value **argv</Line>
  <Line number="10577">){</Line>
  <Line number="10578">  struct IdxSampleCtx *p = (struct IdxSampleCtx*)sqlite3_user_data(pCtx);</Line>
  <Line number="10579">  int bRet;</Line>
  <Line number="10580"></Line>
  <Line number="10581">  (void)argv;</Line>
  <Line number="10582">  <CheckRefs ids="2360">assert</CheckRefs>( argc==0 );</Line>
  <Line number="10583">  if( p-&gt;nRow==0.0 ){</Line>
  <Line number="10584">    bRet = 1;</Line>
  <Line number="10585">  }else{</Line>
  <Line number="10586">    bRet = (p-&gt;nRet <CheckRefs ids="2361,2362">/</CheckRefs> p-&gt;nRow) &lt;= p-&gt;target;</Line>
  <Line number="10587">    if( bRet==0 ){</Line>
  <Line number="10588">      unsigned short rnd;</Line>
  <Line number="10589">      sqlite3_randomness(2, (void*)&amp;rnd);</Line>
  <Line number="10590">      bRet = (<CheckRefs ids="2364">(</CheckRefs>int)rnd <CheckRefs ids="2363">%</CheckRefs> 100) &lt;= p-&gt;iTarget;</Line>
  <Line number="10591">    }</Line>
  <Line number="10592">  }</Line>
  <Line number="10593"></Line>
  <Line number="10594">  sqlite3_result_int(pCtx, bRet);</Line>
  <Line number="10595">  p-&gt;nRow <CheckRefs ids="2365">+=</CheckRefs> 1.0;</Line>
  <Line number="10596">  p-&gt;nRet <CheckRefs ids="2366">+=</CheckRefs> <CheckRefs ids="2367">(</CheckRefs>double)bRet;</Line>
  <Line number="10597">}</Line>
  <Line number="10598"></Line>
  <Line number="10599">struct IdxRemCtx {</Line>
  <Line number="10600">  int nSlot;</Line>
  <Line number="10601">  struct IdxRemSlot {</Line>
  <Line number="10602">    int eType;                    /* SQLITE_NULL, INTEGER, REAL, TEXT, BLOB */</Line>
  <Line number="10603">    i64 iVal;                     /* SQLITE_INTEGER value */</Line>
  <Line number="10604">    double rVal;                  /* SQLITE_FLOAT value */</Line>
  <Line number="10605">    int nByte;                    /* Bytes of space allocated at z */</Line>
  <Line number="10606">    int n;                        /* Size of buffer z */</Line>
  <Line number="10607">    char *z;                      /* SQLITE_TEXT/BLOB value */</Line>
  <Line number="10608">  } aSlot[1];</Line>
  <Line number="10609">};</Line>
  <Line number="10610"></Line>
  <Line number="10611">/*</Line>
  <Line number="10612">** Implementation of scalar function rem().</Line>
  <Line number="10613">*/</Line>
  <Line number="10614">static void idxRemFunc(</Line>
  <Line number="10615">  sqlite3_context *pCtx,</Line>
  <Line number="10616">  int argc,</Line>
  <Line number="10617">  sqlite3_value **argv</Line>
  <Line number="10618">){</Line>
  <Line number="10619">  struct IdxRemCtx *p = (struct IdxRemCtx*)sqlite3_user_data(pCtx);</Line>
  <Line number="10620">  struct IdxRemSlot *pSlot;</Line>
  <Line number="10621">  int iSlot;</Line>
  <Line number="10622">  <CheckRefs ids="2368">assert</CheckRefs>( argc==2 );</Line>
  <Line number="10623"></Line>
  <Line number="10624">  iSlot = sqlite3_value_int(argv[0]);</Line>
  <Line number="10625">  <CheckRefs ids="2369">assert</CheckRefs>( iSlot&lt;=p-&gt;nSlot );</Line>
  <Line number="10626">  pSlot = &amp;p-&gt;aSlot[iSlot<CheckRefs ids="2370">]</CheckRefs>;</Line>
  <Line number="10627"></Line>
  <Line number="10628">  switch( pSlot-&gt;eType ){</Line>
  <Line number="10629">    case SQLITE_NULL:</Line>
  <Line number="10630">      /* no-op */</Line>
  <Line number="10631">      break;</Line>
  <Line number="10632"></Line>
  <Line number="10633">    case SQLITE_INTEGER:</Line>
  <Line number="10634">      sqlite3_result_int64(pCtx, pSlot-&gt;iVal);</Line>
  <Line number="10635">      break;</Line>
  <Line number="10636"></Line>
  <Line number="10637">    case SQLITE_FLOAT:</Line>
  <Line number="10638">      sqlite3_result_double(pCtx, pSlot-&gt;rVal);</Line>
  <Line number="10639">      break;</Line>
  <Line number="10640"></Line>
  <Line number="10641">    case SQLITE_BLOB:</Line>
  <Line number="10642">      sqlite3_result_blob(pCtx, pSlot-&gt;z, pSlot-&gt;n, <CheckRefs ids="2371">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="10643">      break;</Line>
  <Line number="10644"></Line>
  <Line number="10645">    case SQLITE_TEXT:</Line>
  <Line number="10646">      sqlite3_result_text(pCtx, pSlot-&gt;z, pSlot-&gt;n, <CheckRefs ids="2372">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="10647">      break;</Line>
  <Line number="10648">  }</Line>
  <Line number="10649"></Line>
  <Line number="10650">  pSlot-&gt;eType = sqlite3_value_type(argv[1]);</Line>
  <Line number="10651">  switch( pSlot-&gt;eType ){</Line>
  <Line number="10652">    case SQLITE_NULL:</Line>
  <Line number="10653">      /* no-op */</Line>
  <Line number="10654">      break;</Line>
  <Line number="10655"></Line>
  <Line number="10656">    case SQLITE_INTEGER:</Line>
  <Line number="10657">      pSlot-&gt;iVal = sqlite3_value_int64(argv[1]);</Line>
  <Line number="10658">      break;</Line>
  <Line number="10659"></Line>
  <Line number="10660">    case SQLITE_FLOAT:</Line>
  <Line number="10661">      pSlot-&gt;rVal <CheckRefs ids="2373">=</CheckRefs> sqlite3_value_double(argv[1]);</Line>
  <Line number="10662">      break;</Line>
  <Line number="10663"></Line>
  <Line number="10664">    case SQLITE_BLOB:</Line>
  <Line number="10665">    case SQLITE_TEXT: {</Line>
  <Line number="10666">      int nByte = sqlite3_value_bytes(argv[1]);</Line>
  <Line number="10667">      if( nByte&gt;pSlot-&gt;nByte ){</Line>
  <Line number="10668">        char *zNew = (char*)sqlite3_realloc(pSlot-&gt;z, nByte<CheckRefs ids="2374">*</CheckRefs>2);</Line>
  <Line number="10669">        if( zNew==0 ){</Line>
  <Line number="10670">          sqlite3_result_error_nomem(pCtx);</Line>
  <Line number="10671">          return;</Line>
  <Line number="10672">        }</Line>
  <Line number="10673">        pSlot-&gt;nByte = nByte<CheckRefs ids="2375">*</CheckRefs>2;</Line>
  <Line number="10674">        pSlot-&gt;z = zNew;</Line>
  <Line number="10675">      }</Line>
  <Line number="10676">      pSlot-&gt;n = nByte;</Line>
  <Line number="10677">      if( pSlot-&gt;eType==SQLITE_BLOB ){</Line>
  <Line number="10678">        memcpy(pSlot-&gt;z, sqlite3_value_blob(argv[1]), <CheckRefs ids="2376">nByte</CheckRefs>);</Line>
  <Line number="10679">      }else{</Line>
  <Line number="10680">        memcpy(pSlot-&gt;z, sqlite3_value_text(argv[1]), <CheckRefs ids="2377">nByte</CheckRefs>);</Line>
  <Line number="10681">      }</Line>
  <Line number="10682">      break;</Line>
  <Line number="10683">    }</Line>
  <Line number="10684">  }</Line>
  <Line number="10685">}</Line>
  <Line number="10686"></Line>
  <Line number="10687">static int idxLargestIndex(sqlite3 *db, int *pnMax, char **pzErr){</Line>
  <Line number="10688">  int rc = SQLITE_OK;</Line>
  <Line number="10689">  const char *zMax = </Line>
  <Line number="10690">    &quot;SELECT max(i.seqno) FROM &quot;</Line>
  <Line number="10691">    &quot;  sqlite_schema AS s, &quot;</Line>
  <Line number="10692">    &quot;  pragma_index_list(s.name) AS l, &quot;</Line>
  <Line number="10693">    &quot;  pragma_index_info(l.name) AS i &quot;</Line>
  <Line number="10694">    &quot;WHERE s.type = &apos;table&apos;&quot;;</Line>
  <Line number="10695">  sqlite3_stmt *pMax = 0;</Line>
  <Line number="10696"></Line>
  <Line number="10697">  *pnMax = 0;</Line>
  <Line number="10698">  rc = idxPrepareStmt(db, &amp;pMax, pzErr, zMax);</Line>
  <Line number="10699">  if( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pMax) ){</Line>
  <Line number="10700">    *pnMax = sqlite3_column_int(pMax, 0) <CheckRefs ids="2378">+</CheckRefs> 1;</Line>
  <Line number="10701">  }</Line>
  <Line number="10702">  idxFinalize(&amp;rc, pMax);</Line>
  <Line number="10703"></Line>
  <Line number="10704">  return rc;</Line>
  <Line number="10705">}</Line>
  <Line number="10706"></Line>
  <Line number="10707">static int idxPopulateOneStat1(</Line>
  <Line number="10708">  sqlite3expert *p,</Line>
  <Line number="10709">  sqlite3_stmt *pIndexXInfo,</Line>
  <Line number="10710">  sqlite3_stmt *pWriteStat,</Line>
  <Line number="10711">  const char *zTab,</Line>
  <Line number="10712">  const char *zIdx,</Line>
  <Line number="10713">  char **pzErr</Line>
  <Line number="10714">){</Line>
  <Line number="10715">  char *zCols = 0;</Line>
  <Line number="10716">  char *zOrder = 0;</Line>
  <Line number="10717">  char *zQuery = 0;</Line>
  <Line number="10718">  int nCol = 0;</Line>
  <Line number="10719">  int i;</Line>
  <Line number="10720">  sqlite3_stmt *pQuery = 0;</Line>
  <Line number="10721">  int *aStat = 0;</Line>
  <Line number="10722">  int rc = SQLITE_OK;</Line>
  <Line number="10723"></Line>
  <Line number="10724">  <CheckRefs ids="2379">assert</CheckRefs>( p-&gt;iSample&gt;0 );</Line>
  <Line number="10725"></Line>
  <Line number="10726">  /* Formulate the query text */</Line>
  <Line number="10727">  sqlite3_bind_text(pIndexXInfo, 1, zIdx, <CheckRefs ids="2380">-</CheckRefs>1, SQLITE_STATIC);</Line>
  <Line number="10728">  while( SQLITE_OK==rc &amp;&amp; SQLITE_ROW==sqlite3_step(pIndexXInfo) ){</Line>
  <Line number="10729">    const char *zComma = zCols==0 ? &quot;&quot; : &quot;, &quot;;</Line>
  <Line number="10730">    const char *zName = (const char*)sqlite3_column_text(pIndexXInfo, 0);</Line>
  <Line number="10731">    const char *zColl = (const char*)sqlite3_column_text(pIndexXInfo, 1);</Line>
  <Line number="10732">    zCols = idxAppendText(&amp;rc, zCols, </Line>
  <Line number="10733">        &quot;%sx.%Q IS rem(%d, x.%Q) COLLATE %s&quot;, zComma, zName, nCol, zName, zColl</Line>
  <Line number="10734">    );</Line>
  <Line number="10735">    zOrder = idxAppendText(&amp;rc, zOrder, &quot;%s%d&quot;, zComma, <CheckRefs ids="2381">++</CheckRefs>nCol);</Line>
  <Line number="10736">  }</Line>
  <Line number="10737">  sqlite3_reset(pIndexXInfo);</Line>
  <Line number="10738">  if( rc==SQLITE_OK ){</Line>
  <Line number="10739">    if( p-&gt;iSample==100 ){</Line>
  <Line number="10740">      zQuery = sqlite3_mprintf(</Line>
  <Line number="10741">          &quot;SELECT %s FROM %Q x ORDER BY %s&quot;, zCols, zTab, zOrder</Line>
  <Line number="10742">      );</Line>
  <Line number="10743">    }else{</Line>
  <Line number="10744">      zQuery = sqlite3_mprintf(</Line>
  <Line number="10745">          &quot;SELECT %s FROM temp.&quot;UNIQUE_TABLE_NAME&quot; x ORDER BY %s&quot;, zCols, zOrder</Line>
  <Line number="10746">      );</Line>
  <Line number="10747">    }</Line>
  <Line number="10748">  }</Line>
  <Line number="10749">  sqlite3_free(zCols);</Line>
  <Line number="10750">  sqlite3_free(zOrder);</Line>
  <Line number="10751"></Line>
  <Line number="10752">  /* Formulate the query text */</Line>
  <Line number="10753">  if( rc==SQLITE_OK ){</Line>
  <Line number="10754">    sqlite3 *dbrem = (p-&gt;iSample==100 ? p-&gt;db : p-&gt;dbv);</Line>
  <Line number="10755">    rc = idxPrepareStmt(dbrem, &amp;pQuery, pzErr, zQuery);</Line>
  <Line number="10756">  }</Line>
  <Line number="10757">  sqlite3_free(zQuery);</Line>
  <Line number="10758"></Line>
  <Line number="10759">  if( rc==SQLITE_OK ){</Line>
  <Line number="10760">    aStat = (int*)idxMalloc(&amp;rc, sizeof(int)<CheckRefs ids="2382,2383">*</CheckRefs><CheckRefs ids="2384">(</CheckRefs>nCol<CheckRefs ids="2385">+</CheckRefs>1));</Line>
  <Line number="10761">  }</Line>
  <Line number="10762">  if( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pQuery) ){</Line>
  <Line number="10763">    IdxHashEntry *pEntry;</Line>
  <Line number="10764">    char *zStat = 0;</Line>
  <Line number="10765">    for(i=0; i&lt;=nCol; i<CheckRefs ids="2386">++</CheckRefs>) aStat[i] = 1;</Line>
  <Line number="10766">    while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pQuery) ){</Line>
  <Line number="10767">      aStat[0]<CheckRefs ids="2387">++</CheckRefs>;</Line>
  <Line number="10768">      for(i=0; i&lt;nCol; i<CheckRefs ids="2388">++</CheckRefs>){</Line>
  <Line number="10769">        if( sqlite3_column_int(pQuery, i)==0 ) break;</Line>
  <Line number="10770">      }</Line>
  <Line number="10771">      for(/*no-op*/; i&lt;nCol; i<CheckRefs ids="2389">++</CheckRefs>){</Line>
  <Line number="10772">        aStat[i<CheckRefs ids="2391">+</CheckRefs>1]<CheckRefs ids="2390">++</CheckRefs>;</Line>
  <Line number="10773">      }</Line>
  <Line number="10774">    }</Line>
  <Line number="10775"></Line>
  <Line number="10776">    if( rc==SQLITE_OK ){</Line>
  <Line number="10777">      int s0 = aStat[0];</Line>
  <Line number="10778">      zStat = sqlite3_mprintf(&quot;%d&quot;, s0);</Line>
  <Line number="10779">      if( zStat==0 ) rc = SQLITE_NOMEM;</Line>
  <Line number="10780">      for(i=1; rc==SQLITE_OK &amp;&amp; i&lt;=nCol; i<CheckRefs ids="2392">++</CheckRefs>){</Line>
  <Line number="10781">        zStat = idxAppendText(&amp;rc, zStat, &quot; %d&quot;, (s0<CheckRefs ids="2395">+</CheckRefs>aStat[i]<CheckRefs ids="2397,2396">/</CheckRefs>2) <CheckRefs ids="2394,2393">/</CheckRefs> aStat[i]);</Line>
  <Line number="10782">      }</Line>
  <Line number="10783">    }</Line>
  <Line number="10784"></Line>
  <Line number="10785">    if( rc==SQLITE_OK ){</Line>
  <Line number="10786">      sqlite3_bind_text(pWriteStat, 1, zTab, <CheckRefs ids="2398">-</CheckRefs>1, SQLITE_STATIC);</Line>
  <Line number="10787">      sqlite3_bind_text(pWriteStat, 2, zIdx, <CheckRefs ids="2399">-</CheckRefs>1, SQLITE_STATIC);</Line>
  <Line number="10788">      sqlite3_bind_text(pWriteStat, 3, zStat, <CheckRefs ids="2400">-</CheckRefs>1, SQLITE_STATIC);</Line>
  <Line number="10789">      sqlite3_step(pWriteStat);</Line>
  <Line number="10790">      rc = sqlite3_reset(pWriteStat);</Line>
  <Line number="10791">    }</Line>
  <Line number="10792"></Line>
  <Line number="10793">    pEntry = idxHashFind(&amp;p-&gt;hIdx, zIdx, <CheckRefs ids="2401">STRLEN</CheckRefs>(zIdx));</Line>
  <Line number="10794">    if( pEntry ){</Line>
  <Line number="10795">      <CheckRefs ids="2402">assert</CheckRefs>( pEntry-&gt;zVal2==0 );</Line>
  <Line number="10796">      pEntry-&gt;zVal2 = zStat;</Line>
  <Line number="10797">    }else{</Line>
  <Line number="10798">      sqlite3_free(zStat);</Line>
  <Line number="10799">    }</Line>
  <Line number="10800">  }</Line>
  <Line number="10801">  sqlite3_free(aStat);</Line>
  <Line number="10802">  idxFinalize(&amp;rc, pQuery);</Line>
  <Line number="10803"></Line>
  <Line number="10804">  return rc;</Line>
  <Line number="10805">}</Line>
  <Line number="10806"></Line>
  <Line number="10807">static int idxBuildSampleTable(sqlite3expert *p, const char *zTab){</Line>
  <Line number="10808">  int rc;</Line>
  <Line number="10809">  char *zSql;</Line>
  <Line number="10810"></Line>
  <Line number="10811">  rc = sqlite3_exec(p-&gt;dbv,&quot;DROP TABLE IF EXISTS temp.&quot;UNIQUE_TABLE_NAME,0,0,0);</Line>
  <Line number="10812">  if( rc!=SQLITE_OK ) return rc;</Line>
  <Line number="10813"></Line>
  <Line number="10814">  zSql = sqlite3_mprintf(</Line>
  <Line number="10815">      &quot;CREATE TABLE temp.&quot; UNIQUE_TABLE_NAME &quot; AS SELECT * FROM %Q&quot;, zTab</Line>
  <Line number="10816">  );</Line>
  <Line number="10817">  if( zSql==0 ) return SQLITE_NOMEM;</Line>
  <Line number="10818">  rc = sqlite3_exec(p-&gt;dbv, zSql, 0, 0, 0);</Line>
  <Line number="10819">  sqlite3_free(zSql);</Line>
  <Line number="10820"></Line>
  <Line number="10821">  return rc;</Line>
  <Line number="10822">}</Line>
  <Line number="10823"></Line>
  <Line number="10824">/*</Line>
  <Line number="10825">** This function is called as part of sqlite3_expert_analyze(). Candidate</Line>
  <Line number="10826">** indexes have already been created in database sqlite3expert.dbm, this</Line>
  <Line number="10827">** function populates sqlite_stat1 table in the same database.</Line>
  <Line number="10828">**</Line>
  <Line number="10829">** The stat1 data is generated by querying the </Line>
  <Line number="10830">*/</Line>
  <Line number="10831">static int idxPopulateStat1(sqlite3expert *p, char **pzErr){</Line>
  <Line number="10832">  int rc = SQLITE_OK;</Line>
  <Line number="10833">  int nMax =0;</Line>
  <Line number="10834">  struct IdxRemCtx *pCtx = 0;</Line>
  <Line number="10835">  struct IdxSampleCtx samplectx; </Line>
  <Line number="10836">  int i;</Line>
  <Line number="10837">  i64 iPrev = <CheckRefs ids="2403,2404">-</CheckRefs>100000;</Line>
  <Line number="10838">  sqlite3_stmt *pAllIndex = 0;</Line>
  <Line number="10839">  sqlite3_stmt *pIndexXInfo = 0;</Line>
  <Line number="10840">  sqlite3_stmt *pWrite = 0;</Line>
  <Line number="10841"></Line>
  <Line number="10842">  const char *zAllIndex =</Line>
  <Line number="10843">    &quot;SELECT s.rowid, s.name, l.name FROM &quot;</Line>
  <Line number="10844">    &quot;  sqlite_schema AS s, &quot;</Line>
  <Line number="10845">    &quot;  pragma_index_list(s.name) AS l &quot;</Line>
  <Line number="10846">    &quot;WHERE s.type = &apos;table&apos;&quot;;</Line>
  <Line number="10847">  const char *zIndexXInfo = </Line>
  <Line number="10848">    &quot;SELECT name, coll FROM pragma_index_xinfo(?) WHERE key&quot;;</Line>
  <Line number="10849">  const char *zWrite = &quot;INSERT INTO sqlite_stat1 VALUES(?, ?, ?)&quot;;</Line>
  <Line number="10850"></Line>
  <Line number="10851">  /* If iSample==0, no sqlite_stat1 data is required. */</Line>
  <Line number="10852">  if( p-&gt;iSample==0 ) return SQLITE_OK;</Line>
  <Line number="10853"></Line>
  <Line number="10854">  rc = idxLargestIndex(p-&gt;dbm, &amp;nMax, pzErr);</Line>
  <Line number="10855">  if( nMax&lt;=0 || rc!=SQLITE_OK ) return rc;</Line>
  <Line number="10856"></Line>
  <Line number="10857">  rc = sqlite3_exec(p-&gt;dbm, &quot;ANALYZE; PRAGMA writable_schema=1&quot;, 0, 0, 0);</Line>
  <Line number="10858"></Line>
  <Line number="10859">  if( rc==SQLITE_OK ){</Line>
  <Line number="10860">    int nByte = sizeof(struct IdxRemCtx) <CheckRefs ids="2405,2406">+</CheckRefs> (sizeof(struct IdxRemSlot) <CheckRefs ids="2407">*</CheckRefs> <CheckRefs ids="2408">nMax</CheckRefs>);</Line>
  <Line number="10861">    pCtx = (struct IdxRemCtx*)idxMalloc(&amp;rc, nByte);</Line>
  <Line number="10862">  }</Line>
  <Line number="10863"></Line>
  <Line number="10864">  if( rc==SQLITE_OK ){</Line>
  <Line number="10865">    sqlite3 *dbrem = (p-&gt;iSample==100 ? p-&gt;db : p-&gt;dbv);</Line>
  <Line number="10866">    rc = sqlite3_create_function(</Line>
  <Line number="10867">        dbrem, &quot;rem&quot;, 2, SQLITE_UTF8, (void*)pCtx, idxRemFunc, 0, 0</Line>
  <Line number="10868">    );</Line>
  <Line number="10869">  }</Line>
  <Line number="10870">  if( rc==SQLITE_OK ){</Line>
  <Line number="10871">    rc = sqlite3_create_function(</Line>
  <Line number="10872">        p-&gt;db, &quot;sample&quot;, 0, SQLITE_UTF8, (void*)&amp;samplectx, idxSampleFunc, 0, 0</Line>
  <Line number="10873">    );</Line>
  <Line number="10874">  }</Line>
  <Line number="10875"></Line>
  <Line number="10876">  if( rc==SQLITE_OK ){</Line>
  <Line number="10877">    pCtx-&gt;nSlot = nMax<CheckRefs ids="2409">+</CheckRefs>1;</Line>
  <Line number="10878">    rc = idxPrepareStmt(p-&gt;dbm, &amp;pAllIndex, pzErr, zAllIndex);</Line>
  <Line number="10879">  }</Line>
  <Line number="10880">  if( rc==SQLITE_OK ){</Line>
  <Line number="10881">    rc = idxPrepareStmt(p-&gt;dbm, &amp;pIndexXInfo, pzErr, zIndexXInfo);</Line>
  <Line number="10882">  }</Line>
  <Line number="10883">  if( rc==SQLITE_OK ){</Line>
  <Line number="10884">    rc = idxPrepareStmt(p-&gt;dbm, &amp;pWrite, pzErr, zWrite);</Line>
  <Line number="10885">  }</Line>
  <Line number="10886"></Line>
  <Line number="10887">  while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pAllIndex) ){</Line>
  <Line number="10888">    i64 iRowid = sqlite3_column_int64(pAllIndex, 0);</Line>
  <Line number="10889">    const char *zTab = (const char*)sqlite3_column_text(pAllIndex, 1);</Line>
  <Line number="10890">    const char *zIdx = (const char*)sqlite3_column_text(pAllIndex, 2);</Line>
  <Line number="10891">    if( p-&gt;iSample&lt;100 &amp;&amp; iPrev!=iRowid ){</Line>
  <Line number="10892">      samplectx.target <CheckRefs ids="2410">=</CheckRefs> <CheckRefs ids="2413">(</CheckRefs>double)p-&gt;iSample <CheckRefs ids="2411,2412">/</CheckRefs> 100.0;</Line>
  <Line number="10893">      samplectx.iTarget = p-&gt;iSample;</Line>
  <Line number="10894">      samplectx.nRow <CheckRefs ids="2414">=</CheckRefs> 0.0;</Line>
  <Line number="10895">      samplectx.nRet <CheckRefs ids="2415">=</CheckRefs> 0.0;</Line>
  <Line number="10896">      rc = idxBuildSampleTable(p, zTab);</Line>
  <Line number="10897">      if( rc!=SQLITE_OK ) break;</Line>
  <Line number="10898">    }</Line>
  <Line number="10899">    rc = idxPopulateOneStat1(p, pIndexXInfo, pWrite, zTab, zIdx, pzErr);</Line>
  <Line number="10900">    iPrev = iRowid;</Line>
  <Line number="10901">  }</Line>
  <Line number="10902">  if( rc==SQLITE_OK &amp;&amp; p-&gt;iSample&lt;100 ){</Line>
  <Line number="10903">    rc = sqlite3_exec(p-&gt;dbv, </Line>
  <Line number="10904">        &quot;DROP TABLE IF EXISTS temp.&quot; UNIQUE_TABLE_NAME, 0,0,0</Line>
  <Line number="10905">    );</Line>
  <Line number="10906">  }</Line>
  <Line number="10907"></Line>
  <Line number="10908">  idxFinalize(&amp;rc, pAllIndex);</Line>
  <Line number="10909">  idxFinalize(&amp;rc, pIndexXInfo);</Line>
  <Line number="10910">  idxFinalize(&amp;rc, pWrite);</Line>
  <Line number="10911"></Line>
  <Line number="10912">  if( pCtx ){</Line>
  <Line number="10913">    for(i=0; i&lt;pCtx-&gt;nSlot; i<CheckRefs ids="2416">++</CheckRefs>){</Line>
  <Line number="10914">      sqlite3_free(pCtx-&gt;aSlot[i<CheckRefs ids="2417">]</CheckRefs>.z);</Line>
  <Line number="10915">    }</Line>
  <Line number="10916">    sqlite3_free(pCtx);</Line>
  <Line number="10917">  }</Line>
  <Line number="10918"></Line>
  <Line number="10919">  if( rc==SQLITE_OK ){</Line>
  <Line number="10920">    rc = sqlite3_exec(p-&gt;dbm, &quot;ANALYZE sqlite_schema&quot;, 0, 0, 0);</Line>
  <Line number="10921">  }</Line>
  <Line number="10922"></Line>
  <Line number="10923">  sqlite3_exec(p-&gt;db, &quot;DROP TABLE IF EXISTS temp.&quot;UNIQUE_TABLE_NAME,0,0,0);</Line>
  <Line number="10924">  return rc;</Line>
  <Line number="10925">}</Line>
  <Line number="10926"></Line>
  <Line number="10927">/*</Line>
  <Line number="10928">** Allocate a new sqlite3expert object.</Line>
  <Line number="10929">*/</Line>
  <Line number="10930">sqlite3expert *sqlite3_expert_new(sqlite3 *db, char **pzErrmsg){</Line>
  <Line number="10931">  int rc = SQLITE_OK;</Line>
  <Line number="10932">  sqlite3expert *pNew;</Line>
  <Line number="10933"></Line>
  <Line number="10934">  pNew = (sqlite3expert*)idxMalloc(&amp;rc, <CheckRefs ids="2418">sizeof</CheckRefs>(sqlite3expert));</Line>
  <Line number="10935"></Line>
  <Line number="10936">  /* Open two in-memory databases to work with. The &quot;vtab database&quot; (dbv)</Line>
  <Line number="10937">  ** will contain a virtual table corresponding to each real table in</Line>
  <Line number="10938">  ** the user database schema, and a copy of each view. It is used to</Line>
  <Line number="10939">  ** collect information regarding the WHERE, ORDER BY and other clauses</Line>
  <Line number="10940">  ** of the user&apos;s query.</Line>
  <Line number="10941">  */</Line>
  <Line number="10942">  if( rc==SQLITE_OK ){</Line>
  <Line number="10943">    pNew-&gt;db = db;</Line>
  <Line number="10944">    pNew-&gt;iSample = 100;</Line>
  <Line number="10945">    rc = sqlite3_open(&quot;:memory:&quot;, &amp;pNew-&gt;dbv);</Line>
  <Line number="10946">  }</Line>
  <Line number="10947">  if( rc==SQLITE_OK ){</Line>
  <Line number="10948">    rc = sqlite3_open(&quot;:memory:&quot;, &amp;pNew-&gt;dbm);</Line>
  <Line number="10949">    if( rc==SQLITE_OK ){</Line>
  <Line number="10950">      sqlite3_db_config(pNew-&gt;dbm, SQLITE_DBCONFIG_TRIGGER_EQP, 1, (int*)0);</Line>
  <Line number="10951">    }</Line>
  <Line number="10952">  }</Line>
  <Line number="10953">  </Line>
  <Line number="10954"></Line>
  <Line number="10955">  /* Copy the entire schema of database [db] into [dbm]. */</Line>
  <Line number="10956">  if( rc==SQLITE_OK ){</Line>
  <Line number="10957">    sqlite3_stmt *pSql;</Line>
  <Line number="10958">    rc = idxPrintfPrepareStmt(pNew-&gt;db, &amp;pSql, pzErrmsg, </Line>
  <Line number="10959">        &quot;SELECT sql FROM sqlite_schema WHERE name NOT LIKE &apos;sqlite_%%&apos;&quot;</Line>
  <Line number="10960">        &quot; AND sql NOT LIKE &apos;CREATE VIRTUAL %%&apos;&quot;</Line>
  <Line number="10961">    );</Line>
  <Line number="10962">    while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pSql) ){</Line>
  <Line number="10963">      const char *zSql = (const char*)sqlite3_column_text(pSql, 0);</Line>
  <Line number="10964">      rc = sqlite3_exec(pNew-&gt;dbm, zSql, 0, 0, pzErrmsg);</Line>
  <Line number="10965">    }</Line>
  <Line number="10966">    idxFinalize(&amp;rc, pSql);</Line>
  <Line number="10967">  }</Line>
  <Line number="10968"></Line>
  <Line number="10969">  /* Create the vtab schema */</Line>
  <Line number="10970">  if( rc==SQLITE_OK ){</Line>
  <Line number="10971">    rc = idxCreateVtabSchema(pNew, pzErrmsg);</Line>
  <Line number="10972">  }</Line>
  <Line number="10973"></Line>
  <Line number="10974">  /* Register the auth callback with dbv */</Line>
  <Line number="10975">  if( rc==SQLITE_OK ){</Line>
  <Line number="10976">    sqlite3_set_authorizer(pNew-&gt;dbv, idxAuthCallback, (void*)pNew);</Line>
  <Line number="10977">  }</Line>
  <Line number="10978"></Line>
  <Line number="10979">  /* If an error has occurred, free the new object and reutrn NULL. Otherwise,</Line>
  <Line number="10980">  ** return the new sqlite3expert handle.  */</Line>
  <Line number="10981">  if( rc!=SQLITE_OK ){</Line>
  <Line number="10982">    sqlite3_expert_destroy(pNew);</Line>
  <Line number="10983">    pNew = 0;</Line>
  <Line number="10984">  }</Line>
  <Line number="10985">  return pNew;</Line>
  <Line number="10986">}</Line>
  <Line number="10987"></Line>
  <Line number="10988">/*</Line>
  <Line number="10989">** Configure an sqlite3expert object.</Line>
  <Line number="10990">*/</Line>
  <Line number="10991">int sqlite3_expert_config(sqlite3expert *p, int op, ...){</Line>
  <Line number="10992">  int rc = SQLITE_OK;</Line>
  <Line number="10993">  va_list ap;</Line>
  <Line number="10994">  va_start(ap, op);</Line>
  <Line number="10995">  switch( op ){</Line>
  <Line number="10996">    case EXPERT_CONFIG_SAMPLE: {</Line>
  <Line number="10997">      int iVal = va_arg(ap, int);</Line>
  <Line number="10998">      if( iVal&lt;0 ) iVal = 0;</Line>
  <Line number="10999">      if( iVal&gt;100 ) iVal = 100;</Line>
  <Line number="11000">      p-&gt;iSample = iVal;</Line>
  <Line number="11001">      break;</Line>
  <Line number="11002">    }</Line>
  <Line number="11003">    default:</Line>
  <Line number="11004">      rc = SQLITE_NOTFOUND;</Line>
  <Line number="11005">      break;</Line>
  <Line number="11006">  }</Line>
  <Line number="11007"></Line>
  <Line number="11008">  va_end(ap);</Line>
  <Line number="11009">  return rc;</Line>
  <Line number="11010">}</Line>
  <Line number="11011"></Line>
  <Line number="11012">/*</Line>
  <Line number="11013">** Add an SQL statement to the analysis.</Line>
  <Line number="11014">*/</Line>
  <Line number="11015">int sqlite3_expert_sql(</Line>
  <Line number="11016">  sqlite3expert *p,               /* From sqlite3_expert_new() */</Line>
  <Line number="11017">  const char *zSql,               /* SQL statement to add */</Line>
  <Line number="11018">  char **pzErr                    /* OUT: Error message (if any) */</Line>
  <Line number="11019">){</Line>
  <Line number="11020">  IdxScan *pScanOrig = p-&gt;pScan;</Line>
  <Line number="11021">  IdxStatement *pStmtOrig = p-&gt;pStatement;</Line>
  <Line number="11022">  int rc = SQLITE_OK;</Line>
  <Line number="11023">  const char *zStmt = zSql;</Line>
  <Line number="11024"></Line>
  <Line number="11025">  if( p-&gt;bRun ) return SQLITE_MISUSE;</Line>
  <Line number="11026"></Line>
  <Line number="11027">  while( rc==SQLITE_OK &amp;&amp; zStmt &amp;&amp; <CheckRefs ids="2419">zStmt</CheckRefs>[0] ){</Line>
  <Line number="11028">    sqlite3_stmt *pStmt = 0;</Line>
  <Line number="11029">    rc = sqlite3_prepare_v2(p-&gt;dbv, zStmt, <CheckRefs ids="2420">-</CheckRefs>1, &amp;pStmt, &amp;zStmt);</Line>
  <Line number="11030">    if( rc==SQLITE_OK ){</Line>
  <Line number="11031">      if( pStmt ){</Line>
  <Line number="11032">        IdxStatement *pNew;</Line>
  <Line number="11033">        const char *z = sqlite3_sql(pStmt);</Line>
  <Line number="11034">        int n = <CheckRefs ids="2421">STRLEN</CheckRefs>(z);</Line>
  <Line number="11035">        pNew = (IdxStatement*)idxMalloc(&amp;rc, sizeof(IdxStatement) <CheckRefs ids="2424">+</CheckRefs> <CheckRefs ids="2425">n</CheckRefs><CheckRefs ids="2422,2423">+</CheckRefs><CheckRefs ids="2426">1</CheckRefs>);</Line>
  <Line number="11036">        if( rc==SQLITE_OK ){</Line>
  <Line number="11037">          pNew-&gt;zSql = (char*)&amp;pNew[1];</Line>
  <Line number="11038">          memcpy(pNew-&gt;zSql, z, n<CheckRefs ids="2427,2428">+</CheckRefs>1);</Line>
  <Line number="11039">          pNew-&gt;pNext = p-&gt;pStatement;</Line>
  <Line number="11040">          if( p-&gt;pStatement ) pNew-&gt;iId = p-&gt;pStatement-&gt;iId<CheckRefs ids="2429">+</CheckRefs>1;</Line>
  <Line number="11041">          p-&gt;pStatement = pNew;</Line>
  <Line number="11042">        }</Line>
  <Line number="11043">        sqlite3_finalize(pStmt);</Line>
  <Line number="11044">      }</Line>
  <Line number="11045">    }else{</Line>
  <Line number="11046">      idxDatabaseError(p-&gt;dbv, pzErr);</Line>
  <Line number="11047">    }</Line>
  <Line number="11048">  }</Line>
  <Line number="11049"></Line>
  <Line number="11050">  if( rc!=SQLITE_OK ){</Line>
  <Line number="11051">    idxScanFree(p-&gt;pScan, pScanOrig);</Line>
  <Line number="11052">    idxStatementFree(p-&gt;pStatement, pStmtOrig);</Line>
  <Line number="11053">    p-&gt;pScan = pScanOrig;</Line>
  <Line number="11054">    p-&gt;pStatement = pStmtOrig;</Line>
  <Line number="11055">  }</Line>
  <Line number="11056"></Line>
  <Line number="11057">  return rc;</Line>
  <Line number="11058">}</Line>
  <Line number="11059"></Line>
  <Line number="11060">int sqlite3_expert_analyze(sqlite3expert *p, char **pzErr){</Line>
  <Line number="11061">  int rc;</Line>
  <Line number="11062">  IdxHashEntry *pEntry;</Line>
  <Line number="11063"></Line>
  <Line number="11064">  /* Do trigger processing to collect any extra IdxScan structures */</Line>
  <Line number="11065">  rc = idxProcessTriggers(p, pzErr);</Line>
  <Line number="11066"></Line>
  <Line number="11067">  /* Create candidate indexes within the in-memory database file */</Line>
  <Line number="11068">  if( rc==SQLITE_OK ){</Line>
  <Line number="11069">    rc = idxCreateCandidates(p);</Line>
  <Line number="11070">  }</Line>
  <Line number="11071"></Line>
  <Line number="11072">  /* Generate the stat1 data */</Line>
  <Line number="11073">  if( rc==SQLITE_OK ){</Line>
  <Line number="11074">    rc = idxPopulateStat1(p, pzErr);</Line>
  <Line number="11075">  }</Line>
  <Line number="11076"></Line>
  <Line number="11077">  /* Formulate the EXPERT_REPORT_CANDIDATES text */</Line>
  <Line number="11078">  for(pEntry=p-&gt;hIdx.pFirst; pEntry; pEntry=pEntry-&gt;pNext){</Line>
  <Line number="11079">    p-&gt;zCandidates = idxAppendText(&amp;rc, p-&gt;zCandidates, </Line>
  <Line number="11080">        &quot;%s;%s%s\n&quot;, pEntry-&gt;zVal, </Line>
  <Line number="11081">        pEntry-&gt;zVal2 ? &quot; -- stat1: &quot; : &quot;&quot;, pEntry-&gt;zVal2</Line>
  <Line number="11082">    );</Line>
  <Line number="11083">  }</Line>
  <Line number="11084"></Line>
  <Line number="11085">  /* Figure out which of the candidate indexes are preferred by the query</Line>
  <Line number="11086">  ** planner and report the results to the user.  */</Line>
  <Line number="11087">  if( rc==SQLITE_OK ){</Line>
  <Line number="11088">    rc = idxFindIndexes(p, pzErr);</Line>
  <Line number="11089">  }</Line>
  <Line number="11090"></Line>
  <Line number="11091">  if( rc==SQLITE_OK ){</Line>
  <Line number="11092">    p-&gt;bRun = 1;</Line>
  <Line number="11093">  }</Line>
  <Line number="11094">  return rc;</Line>
  <Line number="11095">}</Line>
  <Line number="11096"></Line>
  <Line number="11097">/*</Line>
  <Line number="11098">** Return the total number of statements that have been added to this</Line>
  <Line number="11099">** sqlite3expert using sqlite3_expert_sql().</Line>
  <Line number="11100">*/</Line>
  <Line number="11101">int sqlite3_expert_count(sqlite3expert *p){</Line>
  <Line number="11102">  int nRet = 0;</Line>
  <Line number="11103">  if( p-&gt;pStatement ) nRet = p-&gt;pStatement-&gt;iId<CheckRefs ids="2430">+</CheckRefs>1;</Line>
  <Line number="11104">  return nRet;</Line>
  <Line number="11105">}</Line>
  <Line number="11106"></Line>
  <Line number="11107">/*</Line>
  <Line number="11108">** Return a component of the report.</Line>
  <Line number="11109">*/</Line>
  <Line number="11110">const char *sqlite3_expert_report(sqlite3expert *p, int iStmt, int eReport){</Line>
  <Line number="11111">  const char *zRet = 0;</Line>
  <Line number="11112">  IdxStatement *pStmt;</Line>
  <Line number="11113"></Line>
  <Line number="11114">  if( p-&gt;bRun==0 ) return 0;</Line>
  <Line number="11115">  for(pStmt=p-&gt;pStatement; pStmt &amp;&amp; pStmt-&gt;iId!=iStmt; pStmt=pStmt-&gt;pNext);</Line>
  <Line number="11116">  switch( eReport ){</Line>
  <Line number="11117">    case EXPERT_REPORT_SQL:</Line>
  <Line number="11118">      if( pStmt ) zRet = pStmt-&gt;zSql;</Line>
  <Line number="11119">      break;</Line>
  <Line number="11120">    case EXPERT_REPORT_INDEXES:</Line>
  <Line number="11121">      if( pStmt ) zRet = pStmt-&gt;zIdx;</Line>
  <Line number="11122">      break;</Line>
  <Line number="11123">    case EXPERT_REPORT_PLAN:</Line>
  <Line number="11124">      if( pStmt ) zRet = pStmt-&gt;zEQP;</Line>
  <Line number="11125">      break;</Line>
  <Line number="11126">    case EXPERT_REPORT_CANDIDATES:</Line>
  <Line number="11127">      zRet = p-&gt;zCandidates;</Line>
  <Line number="11128">      break;</Line>
  <Line number="11129">  }</Line>
  <Line number="11130">  return zRet;</Line>
  <Line number="11131">}</Line>
  <Line number="11132"></Line>
  <Line number="11133">/*</Line>
  <Line number="11134">** Free an sqlite3expert object.</Line>
  <Line number="11135">*/</Line>
  <Line number="11136">void sqlite3_expert_destroy(sqlite3expert *p){</Line>
  <Line number="11137">  if( p ){</Line>
  <Line number="11138">    sqlite3_close(p-&gt;dbm);</Line>
  <Line number="11139">    sqlite3_close(p-&gt;dbv);</Line>
  <Line number="11140">    idxScanFree(p-&gt;pScan, 0);</Line>
  <Line number="11141">    idxStatementFree(p-&gt;pStatement, 0);</Line>
  <Line number="11142">    idxTableFree(p-&gt;pTable);</Line>
  <Line number="11143">    idxWriteFree(p-&gt;pWrite);</Line>
  <Line number="11144">    idxHashClear(&amp;p-&gt;hIdx);</Line>
  <Line number="11145">    sqlite3_free(p-&gt;zCandidates);</Line>
  <Line number="11146">    sqlite3_free(p);</Line>
  <Line number="11147">  }</Line>
  <Line number="11148">}</Line>
  <Line number="11149"></Line>
  <Line number="11150">#endif /* ifndef SQLITE_OMIT_VIRTUALTABLE */</Line>
  <Line number="11151"></Line>
  <Line number="11152">/************************* End ../ext/expert/sqlite3expert.c ********************/</Line>
  <Line number="11153"></Line>
  <Line number="11154">#if !defined(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; defined(SQLITE_ENABLE_DBPAGE_VTAB)</Line>
  <Line number="11155">/************************* Begin ../ext/misc/dbdata.c ******************/</Line>
  <Line number="11156">/*</Line>
  <Line number="11157">** 2019-04-17</Line>
  <Line number="11158">**</Line>
  <Line number="11159">** The author disclaims copyright to this source code.  In place of</Line>
  <Line number="11160">** a legal notice, here is a blessing:</Line>
  <Line number="11161">**</Line>
  <Line number="11162">**    May you do good and not evil.</Line>
  <Line number="11163">**    May you find forgiveness for yourself and forgive others.</Line>
  <Line number="11164">**    May you share freely, never taking more than you give.</Line>
  <Line number="11165">**</Line>
  <Line number="11166">******************************************************************************</Line>
  <Line number="11167">**</Line>
  <Line number="11168">** This file contains an implementation of two eponymous virtual tables,</Line>
  <Line number="11169">** &quot;sqlite_dbdata&quot; and &quot;sqlite_dbptr&quot;. Both modules require that the</Line>
  <Line number="11170">** &quot;sqlite_dbpage&quot; eponymous virtual table be available.</Line>
  <Line number="11171">**</Line>
  <Line number="11172">** SQLITE_DBDATA:</Line>
  <Line number="11173">**   sqlite_dbdata is used to extract data directly from a database b-tree</Line>
  <Line number="11174">**   page and its associated overflow pages, bypassing the b-tree layer.</Line>
  <Line number="11175">**   The table schema is equivalent to:</Line>
  <Line number="11176">**</Line>
  <Line number="11177">**     CREATE TABLE sqlite_dbdata(</Line>
  <Line number="11178">**       pgno INTEGER,</Line>
  <Line number="11179">**       cell INTEGER,</Line>
  <Line number="11180">**       field INTEGER,</Line>
  <Line number="11181">**       value ANY,</Line>
  <Line number="11182">**       schema TEXT HIDDEN</Line>
  <Line number="11183">**     );</Line>
  <Line number="11184">**</Line>
  <Line number="11185">**   IMPORTANT: THE VIRTUAL TABLE SCHEMA ABOVE IS SUBJECT TO CHANGE. IN THE</Line>
  <Line number="11186">**   FUTURE NEW NON-HIDDEN COLUMNS MAY BE ADDED BETWEEN &quot;value&quot; AND</Line>
  <Line number="11187">**   &quot;schema&quot;.</Line>
  <Line number="11188">**</Line>
  <Line number="11189">**   Each page of the database is inspected. If it cannot be interpreted as</Line>
  <Line number="11190">**   a b-tree page, or if it is a b-tree page containing 0 entries, the</Line>
  <Line number="11191">**   sqlite_dbdata table contains no rows for that page.  Otherwise, the</Line>
  <Line number="11192">**   table contains one row for each field in the record associated with</Line>
  <Line number="11193">**   each cell on the page. For intkey b-trees, the key value is stored in</Line>
  <Line number="11194">**   field -1.</Line>
  <Line number="11195">**</Line>
  <Line number="11196">**   For example, for the database:</Line>
  <Line number="11197">**</Line>
  <Line number="11198">**     CREATE TABLE t1(a, b);     -- root page is page 2</Line>
  <Line number="11199">**     INSERT INTO t1(rowid, a, b) VALUES(5, &apos;v&apos;, &apos;five&apos;);</Line>
  <Line number="11200">**     INSERT INTO t1(rowid, a, b) VALUES(10, &apos;x&apos;, &apos;ten&apos;);</Line>
  <Line number="11201">**</Line>
  <Line number="11202">**   the sqlite_dbdata table contains, as well as from entries related to </Line>
  <Line number="11203">**   page 1, content equivalent to:</Line>
  <Line number="11204">**</Line>
  <Line number="11205">**     INSERT INTO sqlite_dbdata(pgno, cell, field, value) VALUES</Line>
  <Line number="11206">**         (2, 0, -1, 5     ),</Line>
  <Line number="11207">**         (2, 0,  0, &apos;v&apos;   ),</Line>
  <Line number="11208">**         (2, 0,  1, &apos;five&apos;),</Line>
  <Line number="11209">**         (2, 1, -1, 10    ),</Line>
  <Line number="11210">**         (2, 1,  0, &apos;x&apos;   ),</Line>
  <Line number="11211">**         (2, 1,  1, &apos;ten&apos; );</Line>
  <Line number="11212">**</Line>
  <Line number="11213">**   If database corruption is encountered, this module does not report an</Line>
  <Line number="11214">**   error. Instead, it attempts to extract as much data as possible and</Line>
  <Line number="11215">**   ignores the corruption.</Line>
  <Line number="11216">**</Line>
  <Line number="11217">** SQLITE_DBPTR:</Line>
  <Line number="11218">**   The sqlite_dbptr table has the following schema:</Line>
  <Line number="11219">**</Line>
  <Line number="11220">**     CREATE TABLE sqlite_dbptr(</Line>
  <Line number="11221">**       pgno INTEGER,</Line>
  <Line number="11222">**       child INTEGER,</Line>
  <Line number="11223">**       schema TEXT HIDDEN</Line>
  <Line number="11224">**     );</Line>
  <Line number="11225">**</Line>
  <Line number="11226">**   It contains one entry for each b-tree pointer between a parent and</Line>
  <Line number="11227">**   child page in the database.</Line>
  <Line number="11228">*/</Line>
  <Line number="11229">#if !defined(SQLITEINT_H) </Line>
  <Line number="11230">/* #include &quot;sqlite3ext.h&quot; */</Line>
  <Line number="11231"></Line>
  <Line number="11232">/* typedef unsigned char u8; */</Line>
  <Line number="11233"></Line>
  <Line number="11234">#endif</Line>
  <Line number="11235">SQLITE_EXTENSION_INIT1</Line>
  <Line number="11236">#include &lt;string.h&gt;</Line>
  <Line number="11237">#include &lt;assert.h&gt;</Line>
  <Line number="11238"></Line>
  <Line number="11239">#define DBDATA_PADDING_BYTES 100 </Line>
  <Line number="11240"></Line>
  <Line number="11241">typedef struct DbdataTable DbdataTable;</Line>
  <Line number="11242">typedef struct DbdataCursor DbdataCursor;</Line>
  <Line number="11243"></Line>
  <Line number="11244">/* Cursor object */</Line>
  <Line number="11245">struct DbdataCursor {</Line>
  <Line number="11246">  sqlite3_vtab_cursor base;       /* Base class.  Must be first */</Line>
  <Line number="11247">  sqlite3_stmt *pStmt;            /* For fetching database pages */</Line>
  <Line number="11248"></Line>
  <Line number="11249">  int iPgno;                      /* Current page number */</Line>
  <Line number="11250">  u8 *aPage;                      /* Buffer containing page */</Line>
  <Line number="11251">  int nPage;                      /* Size of aPage[] in bytes */</Line>
  <Line number="11252">  int nCell;                      /* Number of cells on aPage[] */</Line>
  <Line number="11253">  int iCell;                      /* Current cell number */</Line>
  <Line number="11254">  int bOnePage;                   /* True to stop after one page */</Line>
  <Line number="11255">  int szDb;</Line>
  <Line number="11256">  sqlite3_int64 iRowid;</Line>
  <Line number="11257"></Line>
  <Line number="11258">  /* Only for the sqlite_dbdata table */</Line>
  <Line number="11259">  u8 *pRec;                       /* Buffer containing current record */</Line>
  <Line number="11260">  int nRec;                       /* Size of pRec[] in bytes */</Line>
  <Line number="11261">  int nHdr;                       /* Size of header in bytes */</Line>
  <Line number="11262">  int iField;                     /* Current field number */</Line>
  <Line number="11263">  u8 *pHdrPtr;</Line>
  <Line number="11264">  u8 *pPtr;</Line>
  <Line number="11265">  </Line>
  <Line number="11266">  sqlite3_int64 iIntkey;          /* Integer key value */</Line>
  <Line number="11267">};</Line>
  <Line number="11268"></Line>
  <Line number="11269">/* Table object */</Line>
  <Line number="11270">struct DbdataTable {</Line>
  <Line number="11271">  sqlite3_vtab base;              /* Base class.  Must be first */</Line>
  <Line number="11272">  sqlite3 *db;                    /* The database connection */</Line>
  <Line number="11273">  sqlite3_stmt *pStmt;            /* For fetching database pages */</Line>
  <Line number="11274">  int bPtr;                       /* True for sqlite3_dbptr table */</Line>
  <Line number="11275">};</Line>
  <Line number="11276"></Line>
  <Line number="11277">/* Column and schema definitions for sqlite_dbdata */</Line>
  <Line number="11278">#define DBDATA_COLUMN_PGNO        0</Line>
  <Line number="11279">#define DBDATA_COLUMN_CELL        1</Line>
  <Line number="11280">#define DBDATA_COLUMN_FIELD       2</Line>
  <Line number="11281">#define DBDATA_COLUMN_VALUE       3</Line>
  <Line number="11282">#define DBDATA_COLUMN_SCHEMA      4</Line>
  <Line number="11283">#define DBDATA_SCHEMA             \</Line>
  <Line number="11284">      &quot;CREATE TABLE x(&quot;           \</Line>
  <Line number="11285">      &quot;  pgno INTEGER,&quot;           \</Line>
  <Line number="11286">      &quot;  cell INTEGER,&quot;           \</Line>
  <Line number="11287">      &quot;  field INTEGER,&quot;          \</Line>
  <Line number="11288">      &quot;  value ANY,&quot;              \</Line>
  <Line number="11289">      &quot;  schema TEXT HIDDEN&quot;      \</Line>
  <Line number="11290">      &quot;)&quot;</Line>
  <Line number="11291"></Line>
  <Line number="11292">/* Column and schema definitions for sqlite_dbptr */</Line>
  <Line number="11293">#define DBPTR_COLUMN_PGNO         0</Line>
  <Line number="11294">#define DBPTR_COLUMN_CHILD        1</Line>
  <Line number="11295">#define DBPTR_COLUMN_SCHEMA       2</Line>
  <Line number="11296">#define DBPTR_SCHEMA              \</Line>
  <Line number="11297">      &quot;CREATE TABLE x(&quot;           \</Line>
  <Line number="11298">      &quot;  pgno INTEGER,&quot;           \</Line>
  <Line number="11299">      &quot;  child INTEGER,&quot;          \</Line>
  <Line number="11300">      &quot;  schema TEXT HIDDEN&quot;      \</Line>
  <Line number="11301">      &quot;)&quot;</Line>
  <Line number="11302"></Line>
  <Line number="11303">/*</Line>
  <Line number="11304">** Connect to an sqlite_dbdata (pAux==0) or sqlite_dbptr (pAux!=0) virtual </Line>
  <Line number="11305">** table.</Line>
  <Line number="11306">*/</Line>
  <Line number="11307">static int dbdataConnect(</Line>
  <Line number="11308">  sqlite3 *db,</Line>
  <Line number="11309">  void *pAux,</Line>
  <Line number="11310">  int argc, const char *const*argv,</Line>
  <Line number="11311">  sqlite3_vtab **ppVtab,</Line>
  <Line number="11312">  char **pzErr</Line>
  <Line number="11313">){</Line>
  <Line number="11314">  DbdataTable *pTab = 0;</Line>
  <Line number="11315">  int rc = sqlite3_declare_vtab(db, pAux ? DBPTR_SCHEMA : DBDATA_SCHEMA);</Line>
  <Line number="11316"></Line>
  <Line number="11317">  if( rc==SQLITE_OK ){</Line>
  <Line number="11318">    pTab = (DbdataTable*)sqlite3_malloc64(sizeof(DbdataTable));</Line>
  <Line number="11319">    if( pTab==0 ){</Line>
  <Line number="11320">      rc = SQLITE_NOMEM;</Line>
  <Line number="11321">    }else{</Line>
  <Line number="11322">      memset(pTab, 0, sizeof(DbdataTable));</Line>
  <Line number="11323">      pTab-&gt;db = db;</Line>
  <Line number="11324">      pTab-&gt;bPtr = (pAux!=0);</Line>
  <Line number="11325">    }</Line>
  <Line number="11326">  }</Line>
  <Line number="11327"></Line>
  <Line number="11328">  *ppVtab = (sqlite3_vtab*)pTab;</Line>
  <Line number="11329">  return rc;</Line>
  <Line number="11330">}</Line>
  <Line number="11331"></Line>
  <Line number="11332">/*</Line>
  <Line number="11333">** Disconnect from or destroy a sqlite_dbdata or sqlite_dbptr virtual table.</Line>
  <Line number="11334">*/</Line>
  <Line number="11335">static int dbdataDisconnect(sqlite3_vtab *pVtab){</Line>
  <Line number="11336">  DbdataTable *pTab = (DbdataTable*)pVtab;</Line>
  <Line number="11337">  if( pTab ){</Line>
  <Line number="11338">    sqlite3_finalize(pTab-&gt;pStmt);</Line>
  <Line number="11339">    sqlite3_free(pVtab);</Line>
  <Line number="11340">  }</Line>
  <Line number="11341">  return SQLITE_OK;</Line>
  <Line number="11342">}</Line>
  <Line number="11343"></Line>
  <Line number="11344">/*</Line>
  <Line number="11345">** This function interprets two types of constraints:</Line>
  <Line number="11346">**</Line>
  <Line number="11347">**       schema=?</Line>
  <Line number="11348">**       pgno=?</Line>
  <Line number="11349">**</Line>
  <Line number="11350">** If neither are present, idxNum is set to 0. If schema=? is present,</Line>
  <Line number="11351">** the 0x01 bit in idxNum is set. If pgno=? is present, the 0x02 bit</Line>
  <Line number="11352">** in idxNum is set.</Line>
  <Line number="11353">**</Line>
  <Line number="11354">** If both parameters are present, schema is in position 0 and pgno in</Line>
  <Line number="11355">** position 1.</Line>
  <Line number="11356">*/</Line>
  <Line number="11357">static int dbdataBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdx){</Line>
  <Line number="11358">  DbdataTable *pTab = (DbdataTable*)tab;</Line>
  <Line number="11359">  int i;</Line>
  <Line number="11360">  int iSchema = -1;</Line>
  <Line number="11361">  int iPgno = -1;</Line>
  <Line number="11362">  int colSchema = (pTab-&gt;bPtr ? DBPTR_COLUMN_SCHEMA : DBDATA_COLUMN_SCHEMA);</Line>
  <Line number="11363"></Line>
  <Line number="11364">  for(i=0; i&lt;pIdx-&gt;nConstraint; i++){</Line>
  <Line number="11365">    struct sqlite3_index_constraint *p = &amp;pIdx-&gt;aConstraint[i];</Line>
  <Line number="11366">    if( p-&gt;op==SQLITE_INDEX_CONSTRAINT_EQ ){</Line>
  <Line number="11367">      if( p-&gt;iColumn==colSchema ){</Line>
  <Line number="11368">        if( p-&gt;usable==0 ) return SQLITE_CONSTRAINT;</Line>
  <Line number="11369">        iSchema = i;</Line>
  <Line number="11370">      }</Line>
  <Line number="11371">      if( p-&gt;iColumn==DBDATA_COLUMN_PGNO &amp;&amp; p-&gt;usable ){</Line>
  <Line number="11372">        iPgno = i;</Line>
  <Line number="11373">      }</Line>
  <Line number="11374">    }</Line>
  <Line number="11375">  }</Line>
  <Line number="11376"></Line>
  <Line number="11377">  if( iSchema&gt;=0 ){</Line>
  <Line number="11378">    pIdx-&gt;aConstraintUsage[iSchema].argvIndex = 1;</Line>
  <Line number="11379">    pIdx-&gt;aConstraintUsage[iSchema].omit = 1;</Line>
  <Line number="11380">  }</Line>
  <Line number="11381">  if( iPgno&gt;=0 ){</Line>
  <Line number="11382">    pIdx-&gt;aConstraintUsage[iPgno].argvIndex = 1 + (iSchema&gt;=0);</Line>
  <Line number="11383">    pIdx-&gt;aConstraintUsage[iPgno].omit = 1;</Line>
  <Line number="11384">    pIdx-&gt;estimatedCost = 100;</Line>
  <Line number="11385">    pIdx-&gt;estimatedRows =  50;</Line>
  <Line number="11386"></Line>
  <Line number="11387">    if( pTab-&gt;bPtr==0 &amp;&amp; pIdx-&gt;nOrderBy &amp;&amp; pIdx-&gt;aOrderBy[0].desc==0 ){</Line>
  <Line number="11388">      int iCol = pIdx-&gt;aOrderBy[0].iColumn;</Line>
  <Line number="11389">      if( pIdx-&gt;nOrderBy==1 ){</Line>
  <Line number="11390">        pIdx-&gt;orderByConsumed = (iCol==0 || iCol==1);</Line>
  <Line number="11391">      }else if( pIdx-&gt;nOrderBy==2 &amp;&amp; pIdx-&gt;aOrderBy[1].desc==0 &amp;&amp; iCol==0 ){</Line>
  <Line number="11392">        pIdx-&gt;orderByConsumed = (pIdx-&gt;aOrderBy[1].iColumn==1);</Line>
  <Line number="11393">      }</Line>
  <Line number="11394">    }</Line>
  <Line number="11395"></Line>
  <Line number="11396">  }else{</Line>
  <Line number="11397">    pIdx-&gt;estimatedCost = 100000000;</Line>
  <Line number="11398">    pIdx-&gt;estimatedRows = 1000000000;</Line>
  <Line number="11399">  }</Line>
  <Line number="11400">  pIdx-&gt;idxNum = (iSchema&gt;=0 ? 0x01 : 0x00) | (iPgno&gt;=0 ? 0x02 : 0x00);</Line>
  <Line number="11401">  return SQLITE_OK;</Line>
  <Line number="11402">}</Line>
  <Line number="11403"></Line>
  <Line number="11404">/*</Line>
  <Line number="11405">** Open a new sqlite_dbdata or sqlite_dbptr cursor.</Line>
  <Line number="11406">*/</Line>
  <Line number="11407">static int dbdataOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){</Line>
  <Line number="11408">  DbdataCursor *pCsr;</Line>
  <Line number="11409"></Line>
  <Line number="11410">  pCsr = (DbdataCursor*)sqlite3_malloc64(sizeof(DbdataCursor));</Line>
  <Line number="11411">  if( pCsr==0 ){</Line>
  <Line number="11412">    return SQLITE_NOMEM;</Line>
  <Line number="11413">  }else{</Line>
  <Line number="11414">    memset(pCsr, 0, sizeof(DbdataCursor));</Line>
  <Line number="11415">    pCsr-&gt;base.pVtab = pVTab;</Line>
  <Line number="11416">  }</Line>
  <Line number="11417"></Line>
  <Line number="11418">  *ppCursor = (sqlite3_vtab_cursor *)pCsr;</Line>
  <Line number="11419">  return SQLITE_OK;</Line>
  <Line number="11420">}</Line>
  <Line number="11421"></Line>
  <Line number="11422">/*</Line>
  <Line number="11423">** Restore a cursor object to the state it was in when first allocated </Line>
  <Line number="11424">** by dbdataOpen().</Line>
  <Line number="11425">*/</Line>
  <Line number="11426">static void dbdataResetCursor(DbdataCursor *pCsr){</Line>
  <Line number="11427">  DbdataTable *pTab = (DbdataTable*)(pCsr-&gt;base.pVtab);</Line>
  <Line number="11428">  if( pTab-&gt;pStmt==0 ){</Line>
  <Line number="11429">    pTab-&gt;pStmt = pCsr-&gt;pStmt;</Line>
  <Line number="11430">  }else{</Line>
  <Line number="11431">    sqlite3_finalize(pCsr-&gt;pStmt);</Line>
  <Line number="11432">  }</Line>
  <Line number="11433">  pCsr-&gt;pStmt = 0;</Line>
  <Line number="11434">  pCsr-&gt;iPgno = 1;</Line>
  <Line number="11435">  pCsr-&gt;iCell = 0;</Line>
  <Line number="11436">  pCsr-&gt;iField = 0;</Line>
  <Line number="11437">  pCsr-&gt;bOnePage = 0;</Line>
  <Line number="11438">  sqlite3_free(pCsr-&gt;aPage);</Line>
  <Line number="11439">  sqlite3_free(pCsr-&gt;pRec);</Line>
  <Line number="11440">  pCsr-&gt;pRec = 0;</Line>
  <Line number="11441">  pCsr-&gt;aPage = 0;</Line>
  <Line number="11442">}</Line>
  <Line number="11443"></Line>
  <Line number="11444">/*</Line>
  <Line number="11445">** Close an sqlite_dbdata or sqlite_dbptr cursor.</Line>
  <Line number="11446">*/</Line>
  <Line number="11447">static int dbdataClose(sqlite3_vtab_cursor *pCursor){</Line>
  <Line number="11448">  DbdataCursor *pCsr = (DbdataCursor*)pCursor;</Line>
  <Line number="11449">  dbdataResetCursor(pCsr);</Line>
  <Line number="11450">  sqlite3_free(pCsr);</Line>
  <Line number="11451">  return SQLITE_OK;</Line>
  <Line number="11452">}</Line>
  <Line number="11453"></Line>
  <Line number="11454">/* </Line>
  <Line number="11455">** Utility methods to decode 16 and 32-bit big-endian unsigned integers. </Line>
  <Line number="11456">*/</Line>
  <Line number="11457">static unsigned int get_uint16(unsigned char *a){</Line>
  <Line number="11458">  return (a[0]&lt;&lt;8)|a[1];</Line>
  <Line number="11459">}</Line>
  <Line number="11460">static unsigned int get_uint32(unsigned char *a){</Line>
  <Line number="11461">  return ((unsigned int)a[0]&lt;&lt;24)</Line>
  <Line number="11462">       | ((unsigned int)a[1]&lt;&lt;16)</Line>
  <Line number="11463">       | ((unsigned int)a[2]&lt;&lt;8)</Line>
  <Line number="11464">       | ((unsigned int)a[3]);</Line>
  <Line number="11465">}</Line>
  <Line number="11466"></Line>
  <Line number="11467">/*</Line>
  <Line number="11468">** Load page pgno from the database via the sqlite_dbpage virtual table.</Line>
  <Line number="11469">** If successful, set (*ppPage) to point to a buffer containing the page</Line>
  <Line number="11470">** data, (*pnPage) to the size of that buffer in bytes and return</Line>
  <Line number="11471">** SQLITE_OK. In this case it is the responsibility of the caller to</Line>
  <Line number="11472">** eventually free the buffer using sqlite3_free().</Line>
  <Line number="11473">**</Line>
  <Line number="11474">** Or, if an error occurs, set both (*ppPage) and (*pnPage) to 0 and</Line>
  <Line number="11475">** return an SQLite error code.</Line>
  <Line number="11476">*/</Line>
  <Line number="11477">static int dbdataLoadPage(</Line>
  <Line number="11478">  DbdataCursor *pCsr,             /* Cursor object */</Line>
  <Line number="11479">  unsigned int pgno,              /* Page number of page to load */</Line>
  <Line number="11480">  u8 **ppPage,                    /* OUT: pointer to page buffer */</Line>
  <Line number="11481">  int *pnPage                     /* OUT: Size of (*ppPage) in bytes */</Line>
  <Line number="11482">){</Line>
  <Line number="11483">  int rc2;</Line>
  <Line number="11484">  int rc = SQLITE_OK;</Line>
  <Line number="11485">  sqlite3_stmt *pStmt = pCsr-&gt;pStmt;</Line>
  <Line number="11486"></Line>
  <Line number="11487">  *ppPage = 0;</Line>
  <Line number="11488">  *pnPage = 0;</Line>
  <Line number="11489">  sqlite3_bind_int64(pStmt, 2, pgno);</Line>
  <Line number="11490">  if( SQLITE_ROW==sqlite3_step(pStmt) ){</Line>
  <Line number="11491">    int nCopy = sqlite3_column_bytes(pStmt, 0);</Line>
  <Line number="11492">    if( nCopy&gt;0 ){</Line>
  <Line number="11493">      u8 *pPage;</Line>
  <Line number="11494">      pPage = (u8*)sqlite3_malloc64(nCopy + DBDATA_PADDING_BYTES);</Line>
  <Line number="11495">      if( pPage==0 ){</Line>
  <Line number="11496">        rc = SQLITE_NOMEM;</Line>
  <Line number="11497">      }else{</Line>
  <Line number="11498">        const u8 *pCopy = sqlite3_column_blob(pStmt, 0);</Line>
  <Line number="11499">        memcpy(pPage, pCopy, nCopy);</Line>
  <Line number="11500">        memset(&amp;pPage[nCopy], 0, DBDATA_PADDING_BYTES);</Line>
  <Line number="11501">      }</Line>
  <Line number="11502">      *ppPage = pPage;</Line>
  <Line number="11503">      *pnPage = nCopy;</Line>
  <Line number="11504">    }</Line>
  <Line number="11505">  }</Line>
  <Line number="11506">  rc2 = sqlite3_reset(pStmt);</Line>
  <Line number="11507">  if( rc==SQLITE_OK ) rc = rc2;</Line>
  <Line number="11508"></Line>
  <Line number="11509">  return rc;</Line>
  <Line number="11510">}</Line>
  <Line number="11511"></Line>
  <Line number="11512">/*</Line>
  <Line number="11513">** Read a varint.  Put the value in *pVal and return the number of bytes.</Line>
  <Line number="11514">*/</Line>
  <Line number="11515">static int dbdataGetVarint(const u8 *z, sqlite3_int64 *pVal){</Line>
  <Line number="11516">  sqlite3_int64 v = 0;</Line>
  <Line number="11517">  int i;</Line>
  <Line number="11518">  for(i=0; i&lt;8; i++){</Line>
  <Line number="11519">    v = (v&lt;&lt;7) + (z[i]&amp;0x7f);</Line>
  <Line number="11520">    if( (z[i]&amp;0x80)==0 ){ *pVal = v; return i+1; }</Line>
  <Line number="11521">  }</Line>
  <Line number="11522">  v = (v&lt;&lt;8) + (z[i]&amp;0xff);</Line>
  <Line number="11523">  *pVal = v;</Line>
  <Line number="11524">  return 9;</Line>
  <Line number="11525">}</Line>
  <Line number="11526"></Line>
  <Line number="11527">/*</Line>
  <Line number="11528">** Return the number of bytes of space used by an SQLite value of type</Line>
  <Line number="11529">** eType.</Line>
  <Line number="11530">*/</Line>
  <Line number="11531">static int dbdataValueBytes(int eType){</Line>
  <Line number="11532">  switch( eType ){</Line>
  <Line number="11533">    case 0: case 8: case 9:</Line>
  <Line number="11534">    case 10: case 11:</Line>
  <Line number="11535">      return 0;</Line>
  <Line number="11536">    case 1:</Line>
  <Line number="11537">      return 1;</Line>
  <Line number="11538">    case 2:</Line>
  <Line number="11539">      return 2;</Line>
  <Line number="11540">    case 3:</Line>
  <Line number="11541">      return 3;</Line>
  <Line number="11542">    case 4:</Line>
  <Line number="11543">      return 4;</Line>
  <Line number="11544">    case 5:</Line>
  <Line number="11545">      return 6;</Line>
  <Line number="11546">    case 6:</Line>
  <Line number="11547">    case 7:</Line>
  <Line number="11548">      return 8;</Line>
  <Line number="11549">    default:</Line>
  <Line number="11550">      if( eType&gt;0 ){</Line>
  <Line number="11551">        return ((eType-12) / 2);</Line>
  <Line number="11552">      }</Line>
  <Line number="11553">      return 0;</Line>
  <Line number="11554">  }</Line>
  <Line number="11555">}</Line>
  <Line number="11556"></Line>
  <Line number="11557">/*</Line>
  <Line number="11558">** Load a value of type eType from buffer pData and use it to set the</Line>
  <Line number="11559">** result of context object pCtx.</Line>
  <Line number="11560">*/</Line>
  <Line number="11561">static void dbdataValue(</Line>
  <Line number="11562">  sqlite3_context *pCtx, </Line>
  <Line number="11563">  int eType, </Line>
  <Line number="11564">  u8 *pData,</Line>
  <Line number="11565">  int nData</Line>
  <Line number="11566">){</Line>
  <Line number="11567">  if( eType&gt;=0 &amp;&amp; dbdataValueBytes(eType)&lt;=nData ){</Line>
  <Line number="11568">    switch( eType ){</Line>
  <Line number="11569">      case 0: </Line>
  <Line number="11570">      case 10: </Line>
  <Line number="11571">      case 11: </Line>
  <Line number="11572">        sqlite3_result_null(pCtx);</Line>
  <Line number="11573">        break;</Line>
  <Line number="11574">      </Line>
  <Line number="11575">      case 8: </Line>
  <Line number="11576">        sqlite3_result_int(pCtx, 0);</Line>
  <Line number="11577">        break;</Line>
  <Line number="11578">      case 9:</Line>
  <Line number="11579">        sqlite3_result_int(pCtx, 1);</Line>
  <Line number="11580">        break;</Line>
  <Line number="11581">  </Line>
  <Line number="11582">      case 1: case 2: case 3: case 4: case 5: case 6: case 7: {</Line>
  <Line number="11583">        sqlite3_uint64 v = (signed char)pData[0];</Line>
  <Line number="11584">        pData++;</Line>
  <Line number="11585">        switch( eType ){</Line>
  <Line number="11586">          case 7:</Line>
  <Line number="11587">          case 6:  v = (v&lt;&lt;16) + (pData[0]&lt;&lt;8) + pData[1];  pData += 2;</Line>
  <Line number="11588">          case 5:  v = (v&lt;&lt;16) + (pData[0]&lt;&lt;8) + pData[1];  pData += 2;</Line>
  <Line number="11589">          case 4:  v = (v&lt;&lt;8) + pData[0];  pData++;</Line>
  <Line number="11590">          case 3:  v = (v&lt;&lt;8) + pData[0];  pData++;</Line>
  <Line number="11591">          case 2:  v = (v&lt;&lt;8) + pData[0];  pData++;</Line>
  <Line number="11592">        }</Line>
  <Line number="11593">  </Line>
  <Line number="11594">        if( eType==7 ){</Line>
  <Line number="11595">          double r;</Line>
  <Line number="11596">          memcpy(&amp;r, &amp;v, sizeof(r));</Line>
  <Line number="11597">          sqlite3_result_double(pCtx, r);</Line>
  <Line number="11598">        }else{</Line>
  <Line number="11599">          sqlite3_result_int64(pCtx, (sqlite3_int64)v);</Line>
  <Line number="11600">        }</Line>
  <Line number="11601">        break;</Line>
  <Line number="11602">      }</Line>
  <Line number="11603">  </Line>
  <Line number="11604">      default: {</Line>
  <Line number="11605">        int n = ((eType-12) / 2);</Line>
  <Line number="11606">        if( eType % 2 ){</Line>
  <Line number="11607">          sqlite3_result_text(pCtx, (const char*)pData, n, SQLITE_TRANSIENT);</Line>
  <Line number="11608">        }else{</Line>
  <Line number="11609">          sqlite3_result_blob(pCtx, pData, n, SQLITE_TRANSIENT);</Line>
  <Line number="11610">        }</Line>
  <Line number="11611">      }</Line>
  <Line number="11612">    }</Line>
  <Line number="11613">  }</Line>
  <Line number="11614">}</Line>
  <Line number="11615"></Line>
  <Line number="11616">/*</Line>
  <Line number="11617">** Move an sqlite_dbdata or sqlite_dbptr cursor to the next entry.</Line>
  <Line number="11618">*/</Line>
  <Line number="11619">static int dbdataNext(sqlite3_vtab_cursor *pCursor){</Line>
  <Line number="11620">  DbdataCursor *pCsr = (DbdataCursor*)pCursor;</Line>
  <Line number="11621">  DbdataTable *pTab = (DbdataTable*)pCursor-&gt;pVtab;</Line>
  <Line number="11622"></Line>
  <Line number="11623">  pCsr-&gt;iRowid++;</Line>
  <Line number="11624">  while( 1 ){</Line>
  <Line number="11625">    int rc;</Line>
  <Line number="11626">    int iOff = (pCsr-&gt;iPgno==1 ? 100 : 0);</Line>
  <Line number="11627">    int bNextPage = 0;</Line>
  <Line number="11628"></Line>
  <Line number="11629">    if( pCsr-&gt;aPage==0 ){</Line>
  <Line number="11630">      while( 1 ){</Line>
  <Line number="11631">        if( pCsr-&gt;bOnePage==0 &amp;&amp; pCsr-&gt;iPgno&gt;pCsr-&gt;szDb ) return SQLITE_OK;</Line>
  <Line number="11632">        rc = dbdataLoadPage(pCsr, pCsr-&gt;iPgno, &amp;pCsr-&gt;aPage, &amp;pCsr-&gt;nPage);</Line>
  <Line number="11633">        if( rc!=SQLITE_OK ) return rc;</Line>
  <Line number="11634">        if( pCsr-&gt;aPage ) break;</Line>
  <Line number="11635">        pCsr-&gt;iPgno++;</Line>
  <Line number="11636">      }</Line>
  <Line number="11637">      pCsr-&gt;iCell = pTab-&gt;bPtr ? -2 : 0;</Line>
  <Line number="11638">      pCsr-&gt;nCell = get_uint16(&amp;pCsr-&gt;aPage[iOff+3]);</Line>
  <Line number="11639">    }</Line>
  <Line number="11640"></Line>
  <Line number="11641">    if( pTab-&gt;bPtr ){</Line>
  <Line number="11642">      if( pCsr-&gt;aPage[iOff]!=0x02 &amp;&amp; pCsr-&gt;aPage[iOff]!=0x05 ){</Line>
  <Line number="11643">        pCsr-&gt;iCell = pCsr-&gt;nCell;</Line>
  <Line number="11644">      }</Line>
  <Line number="11645">      pCsr-&gt;iCell++;</Line>
  <Line number="11646">      if( pCsr-&gt;iCell&gt;=pCsr-&gt;nCell ){</Line>
  <Line number="11647">        sqlite3_free(pCsr-&gt;aPage);</Line>
  <Line number="11648">        pCsr-&gt;aPage = 0;</Line>
  <Line number="11649">        if( pCsr-&gt;bOnePage ) return SQLITE_OK;</Line>
  <Line number="11650">        pCsr-&gt;iPgno++;</Line>
  <Line number="11651">      }else{</Line>
  <Line number="11652">        return SQLITE_OK;</Line>
  <Line number="11653">      }</Line>
  <Line number="11654">    }else{</Line>
  <Line number="11655">      /* If there is no record loaded, load it now. */</Line>
  <Line number="11656">      if( pCsr-&gt;pRec==0 ){</Line>
  <Line number="11657">        int bHasRowid = 0;</Line>
  <Line number="11658">        int nPointer = 0;</Line>
  <Line number="11659">        sqlite3_int64 nPayload = 0;</Line>
  <Line number="11660">        sqlite3_int64 nHdr = 0;</Line>
  <Line number="11661">        int iHdr;</Line>
  <Line number="11662">        int U, X;</Line>
  <Line number="11663">        int nLocal;</Line>
  <Line number="11664">  </Line>
  <Line number="11665">        switch( pCsr-&gt;aPage[iOff] ){</Line>
  <Line number="11666">          case 0x02:</Line>
  <Line number="11667">            nPointer = 4;</Line>
  <Line number="11668">            break;</Line>
  <Line number="11669">          case 0x0a:</Line>
  <Line number="11670">            break;</Line>
  <Line number="11671">          case 0x0d:</Line>
  <Line number="11672">            bHasRowid = 1;</Line>
  <Line number="11673">            break;</Line>
  <Line number="11674">          default:</Line>
  <Line number="11675">            /* This is not a b-tree page with records on it. Continue. */</Line>
  <Line number="11676">            pCsr-&gt;iCell = pCsr-&gt;nCell;</Line>
  <Line number="11677">            break;</Line>
  <Line number="11678">        }</Line>
  <Line number="11679"></Line>
  <Line number="11680">        if( pCsr-&gt;iCell&gt;=pCsr-&gt;nCell ){</Line>
  <Line number="11681">          bNextPage = 1;</Line>
  <Line number="11682">        }else{</Line>
  <Line number="11683">  </Line>
  <Line number="11684">          iOff += 8 + nPointer + pCsr-&gt;iCell*2;</Line>
  <Line number="11685">          if( iOff&gt;pCsr-&gt;nPage ){</Line>
  <Line number="11686">            bNextPage = 1;</Line>
  <Line number="11687">          }else{</Line>
  <Line number="11688">            iOff = get_uint16(&amp;pCsr-&gt;aPage[iOff]);</Line>
  <Line number="11689">          }</Line>
  <Line number="11690">    </Line>
  <Line number="11691">          /* For an interior node cell, skip past the child-page number */</Line>
  <Line number="11692">          iOff += nPointer;</Line>
  <Line number="11693">    </Line>
  <Line number="11694">          /* Load the &quot;byte of payload including overflow&quot; field */</Line>
  <Line number="11695">          if( bNextPage || iOff&gt;pCsr-&gt;nPage ){</Line>
  <Line number="11696">            bNextPage = 1;</Line>
  <Line number="11697">          }else{</Line>
  <Line number="11698">            iOff += dbdataGetVarint(&amp;pCsr-&gt;aPage[iOff], &amp;nPayload);</Line>
  <Line number="11699">          }</Line>
  <Line number="11700">    </Line>
  <Line number="11701">          /* If this is a leaf intkey cell, load the rowid */</Line>
  <Line number="11702">          if( bHasRowid &amp;&amp; !bNextPage &amp;&amp; iOff&lt;pCsr-&gt;nPage ){</Line>
  <Line number="11703">            iOff += dbdataGetVarint(&amp;pCsr-&gt;aPage[iOff], &amp;pCsr-&gt;iIntkey);</Line>
  <Line number="11704">          }</Line>
  <Line number="11705">    </Line>
  <Line number="11706">          /* Figure out how much data to read from the local page */</Line>
  <Line number="11707">          U = pCsr-&gt;nPage;</Line>
  <Line number="11708">          if( bHasRowid ){</Line>
  <Line number="11709">            X = U-35;</Line>
  <Line number="11710">          }else{</Line>
  <Line number="11711">            X = ((U-12)*64/255)-23;</Line>
  <Line number="11712">          }</Line>
  <Line number="11713">          if( nPayload&lt;=X ){</Line>
  <Line number="11714">            nLocal = nPayload;</Line>
  <Line number="11715">          }else{</Line>
  <Line number="11716">            int M, K;</Line>
  <Line number="11717">            M = ((U-12)*32/255)-23;</Line>
  <Line number="11718">            K = M+((nPayload-M)%(U-4));</Line>
  <Line number="11719">            if( K&lt;=X ){</Line>
  <Line number="11720">              nLocal = K;</Line>
  <Line number="11721">            }else{</Line>
  <Line number="11722">              nLocal = M;</Line>
  <Line number="11723">            }</Line>
  <Line number="11724">          }</Line>
  <Line number="11725"></Line>
  <Line number="11726">          if( bNextPage || nLocal+iOff&gt;pCsr-&gt;nPage ){</Line>
  <Line number="11727">            bNextPage = 1;</Line>
  <Line number="11728">          }else{</Line>
  <Line number="11729"></Line>
  <Line number="11730">            /* Allocate space for payload. And a bit more to catch small buffer</Line>
  <Line number="11731">            ** overruns caused by attempting to read a varint or similar from </Line>
  <Line number="11732">            ** near the end of a corrupt record.  */</Line>
  <Line number="11733">            pCsr-&gt;pRec = (u8*)sqlite3_malloc64(nPayload+DBDATA_PADDING_BYTES);</Line>
  <Line number="11734">            if( pCsr-&gt;pRec==0 ) return SQLITE_NOMEM;</Line>
  <Line number="11735">            memset(pCsr-&gt;pRec, 0, nPayload+DBDATA_PADDING_BYTES);</Line>
  <Line number="11736">            pCsr-&gt;nRec = nPayload;</Line>
  <Line number="11737"></Line>
  <Line number="11738">            /* Load the nLocal bytes of payload */</Line>
  <Line number="11739">            memcpy(pCsr-&gt;pRec, &amp;pCsr-&gt;aPage[iOff], nLocal);</Line>
  <Line number="11740">            iOff += nLocal;</Line>
  <Line number="11741"></Line>
  <Line number="11742">            /* Load content from overflow pages */</Line>
  <Line number="11743">            if( nPayload&gt;nLocal ){</Line>
  <Line number="11744">              sqlite3_int64 nRem = nPayload - nLocal;</Line>
  <Line number="11745">              unsigned int pgnoOvfl = get_uint32(&amp;pCsr-&gt;aPage[iOff]);</Line>
  <Line number="11746">              while( nRem&gt;0 ){</Line>
  <Line number="11747">                u8 *aOvfl = 0;</Line>
  <Line number="11748">                int nOvfl = 0;</Line>
  <Line number="11749">                int nCopy;</Line>
  <Line number="11750">                rc = dbdataLoadPage(pCsr, pgnoOvfl, &amp;aOvfl, &amp;nOvfl);</Line>
  <Line number="11751">                assert( rc!=SQLITE_OK || aOvfl==0 || nOvfl==pCsr-&gt;nPage );</Line>
  <Line number="11752">                if( rc!=SQLITE_OK ) return rc;</Line>
  <Line number="11753">                if( aOvfl==0 ) break;</Line>
  <Line number="11754"></Line>
  <Line number="11755">                nCopy = U-4;</Line>
  <Line number="11756">                if( nCopy&gt;nRem ) nCopy = nRem;</Line>
  <Line number="11757">                memcpy(&amp;pCsr-&gt;pRec[nPayload-nRem], &amp;aOvfl[4], nCopy);</Line>
  <Line number="11758">                nRem -= nCopy;</Line>
  <Line number="11759"></Line>
  <Line number="11760">                pgnoOvfl = get_uint32(aOvfl);</Line>
  <Line number="11761">                sqlite3_free(aOvfl);</Line>
  <Line number="11762">              }</Line>
  <Line number="11763">            }</Line>
  <Line number="11764">    </Line>
  <Line number="11765">            iHdr = dbdataGetVarint(pCsr-&gt;pRec, &amp;nHdr);</Line>
  <Line number="11766">            pCsr-&gt;nHdr = nHdr;</Line>
  <Line number="11767">            pCsr-&gt;pHdrPtr = &amp;pCsr-&gt;pRec[iHdr];</Line>
  <Line number="11768">            pCsr-&gt;pPtr = &amp;pCsr-&gt;pRec[pCsr-&gt;nHdr];</Line>
  <Line number="11769">            pCsr-&gt;iField = (bHasRowid ? -1 : 0);</Line>
  <Line number="11770">          }</Line>
  <Line number="11771">        }</Line>
  <Line number="11772">      }else{</Line>
  <Line number="11773">        pCsr-&gt;iField++;</Line>
  <Line number="11774">        if( pCsr-&gt;iField&gt;0 ){</Line>
  <Line number="11775">          sqlite3_int64 iType;</Line>
  <Line number="11776">          if( pCsr-&gt;pHdrPtr&gt;&amp;pCsr-&gt;pRec[pCsr-&gt;nRec] ){</Line>
  <Line number="11777">            bNextPage = 1;</Line>
  <Line number="11778">          }else{</Line>
  <Line number="11779">            pCsr-&gt;pHdrPtr += dbdataGetVarint(pCsr-&gt;pHdrPtr, &amp;iType);</Line>
  <Line number="11780">            pCsr-&gt;pPtr += dbdataValueBytes(iType);</Line>
  <Line number="11781">          }</Line>
  <Line number="11782">        }</Line>
  <Line number="11783">      }</Line>
  <Line number="11784"></Line>
  <Line number="11785">      if( bNextPage ){</Line>
  <Line number="11786">        sqlite3_free(pCsr-&gt;aPage);</Line>
  <Line number="11787">        sqlite3_free(pCsr-&gt;pRec);</Line>
  <Line number="11788">        pCsr-&gt;aPage = 0;</Line>
  <Line number="11789">        pCsr-&gt;pRec = 0;</Line>
  <Line number="11790">        if( pCsr-&gt;bOnePage ) return SQLITE_OK;</Line>
  <Line number="11791">        pCsr-&gt;iPgno++;</Line>
  <Line number="11792">      }else{</Line>
  <Line number="11793">        if( pCsr-&gt;iField&lt;0 || pCsr-&gt;pHdrPtr&lt;&amp;pCsr-&gt;pRec[pCsr-&gt;nHdr] ){</Line>
  <Line number="11794">          return SQLITE_OK;</Line>
  <Line number="11795">        }</Line>
  <Line number="11796"></Line>
  <Line number="11797">        /* Advance to the next cell. The next iteration of the loop will load</Line>
  <Line number="11798">        ** the record and so on. */</Line>
  <Line number="11799">        sqlite3_free(pCsr-&gt;pRec);</Line>
  <Line number="11800">        pCsr-&gt;pRec = 0;</Line>
  <Line number="11801">        pCsr-&gt;iCell++;</Line>
  <Line number="11802">      }</Line>
  <Line number="11803">    }</Line>
  <Line number="11804">  }</Line>
  <Line number="11805"></Line>
  <Line number="11806">  assert( !&quot;can&apos;t get here&quot; );</Line>
  <Line number="11807">  return SQLITE_OK;</Line>
  <Line number="11808">}</Line>
  <Line number="11809"></Line>
  <Line number="11810">/* </Line>
  <Line number="11811">** Return true if the cursor is at EOF.</Line>
  <Line number="11812">*/</Line>
  <Line number="11813">static int dbdataEof(sqlite3_vtab_cursor *pCursor){</Line>
  <Line number="11814">  DbdataCursor *pCsr = (DbdataCursor*)pCursor;</Line>
  <Line number="11815">  return pCsr-&gt;aPage==0;</Line>
  <Line number="11816">}</Line>
  <Line number="11817"></Line>
  <Line number="11818">/* </Line>
  <Line number="11819">** Determine the size in pages of database zSchema (where zSchema is</Line>
  <Line number="11820">** &quot;main&quot;, &quot;temp&quot; or the name of an attached database) and set </Line>
  <Line number="11821">** pCsr-&gt;szDb accordingly. If successful, return SQLITE_OK. Otherwise,</Line>
  <Line number="11822">** an SQLite error code.</Line>
  <Line number="11823">*/</Line>
  <Line number="11824">static int dbdataDbsize(DbdataCursor *pCsr, const char *zSchema){</Line>
  <Line number="11825">  DbdataTable *pTab = (DbdataTable*)pCsr-&gt;base.pVtab;</Line>
  <Line number="11826">  char *zSql = 0;</Line>
  <Line number="11827">  int rc, rc2;</Line>
  <Line number="11828">  sqlite3_stmt *pStmt = 0;</Line>
  <Line number="11829"></Line>
  <Line number="11830">  zSql = sqlite3_mprintf(&quot;PRAGMA %Q.page_count&quot;, zSchema);</Line>
  <Line number="11831">  if( zSql==0 ) return SQLITE_NOMEM;</Line>
  <Line number="11832">  rc = sqlite3_prepare_v2(pTab-&gt;db, zSql, -1, &amp;pStmt, 0);</Line>
  <Line number="11833">  sqlite3_free(zSql);</Line>
  <Line number="11834">  if( rc==SQLITE_OK &amp;&amp; sqlite3_step(pStmt)==SQLITE_ROW ){</Line>
  <Line number="11835">    pCsr-&gt;szDb = sqlite3_column_int(pStmt, 0);</Line>
  <Line number="11836">  }</Line>
  <Line number="11837">  rc2 = sqlite3_finalize(pStmt);</Line>
  <Line number="11838">  if( rc==SQLITE_OK ) rc = rc2;</Line>
  <Line number="11839">  return rc;</Line>
  <Line number="11840">}</Line>
  <Line number="11841"></Line>
  <Line number="11842">/* </Line>
  <Line number="11843">** xFilter method for sqlite_dbdata and sqlite_dbptr.</Line>
  <Line number="11844">*/</Line>
  <Line number="11845">static int dbdataFilter(</Line>
  <Line number="11846">  sqlite3_vtab_cursor *pCursor, </Line>
  <Line number="11847">  int idxNum, const char *idxStr,</Line>
  <Line number="11848">  int argc, sqlite3_value **argv</Line>
  <Line number="11849">){</Line>
  <Line number="11850">  DbdataCursor *pCsr = (DbdataCursor*)pCursor;</Line>
  <Line number="11851">  DbdataTable *pTab = (DbdataTable*)pCursor-&gt;pVtab;</Line>
  <Line number="11852">  int rc = SQLITE_OK;</Line>
  <Line number="11853">  const char *zSchema = &quot;main&quot;;</Line>
  <Line number="11854"></Line>
  <Line number="11855">  dbdataResetCursor(pCsr);</Line>
  <Line number="11856">  assert( pCsr-&gt;iPgno==1 );</Line>
  <Line number="11857">  if( idxNum &amp; 0x01 ){</Line>
  <Line number="11858">    zSchema = (const char*)sqlite3_value_text(argv[0]);</Line>
  <Line number="11859">  }</Line>
  <Line number="11860">  if( idxNum &amp; 0x02 ){</Line>
  <Line number="11861">    pCsr-&gt;iPgno = sqlite3_value_int(argv[(idxNum &amp; 0x01)]);</Line>
  <Line number="11862">    pCsr-&gt;bOnePage = 1;</Line>
  <Line number="11863">  }else{</Line>
  <Line number="11864">    pCsr-&gt;nPage = dbdataDbsize(pCsr, zSchema);</Line>
  <Line number="11865">    rc = dbdataDbsize(pCsr, zSchema);</Line>
  <Line number="11866">  }</Line>
  <Line number="11867"></Line>
  <Line number="11868">  if( rc==SQLITE_OK ){</Line>
  <Line number="11869">    if( pTab-&gt;pStmt ){</Line>
  <Line number="11870">      pCsr-&gt;pStmt = pTab-&gt;pStmt;</Line>
  <Line number="11871">      pTab-&gt;pStmt = 0;</Line>
  <Line number="11872">    }else{</Line>
  <Line number="11873">      rc = sqlite3_prepare_v2(pTab-&gt;db, </Line>
  <Line number="11874">          &quot;SELECT data FROM sqlite_dbpage(?) WHERE pgno=?&quot;, -1,</Line>
  <Line number="11875">          &amp;pCsr-&gt;pStmt, 0</Line>
  <Line number="11876">      );</Line>
  <Line number="11877">    }</Line>
  <Line number="11878">  }</Line>
  <Line number="11879">  if( rc==SQLITE_OK ){</Line>
  <Line number="11880">    rc = sqlite3_bind_text(pCsr-&gt;pStmt, 1, zSchema, -1, SQLITE_TRANSIENT);</Line>
  <Line number="11881">  }else{</Line>
  <Line number="11882">    pTab-&gt;base.zErrMsg = sqlite3_mprintf(&quot;%s&quot;, sqlite3_errmsg(pTab-&gt;db));</Line>
  <Line number="11883">  }</Line>
  <Line number="11884">  if( rc==SQLITE_OK ){</Line>
  <Line number="11885">    rc = dbdataNext(pCursor);</Line>
  <Line number="11886">  }</Line>
  <Line number="11887">  return rc;</Line>
  <Line number="11888">}</Line>
  <Line number="11889"></Line>
  <Line number="11890">/* </Line>
  <Line number="11891">** Return a column for the sqlite_dbdata or sqlite_dbptr table.</Line>
  <Line number="11892">*/</Line>
  <Line number="11893">static int dbdataColumn(</Line>
  <Line number="11894">  sqlite3_vtab_cursor *pCursor, </Line>
  <Line number="11895">  sqlite3_context *ctx, </Line>
  <Line number="11896">  int i</Line>
  <Line number="11897">){</Line>
  <Line number="11898">  DbdataCursor *pCsr = (DbdataCursor*)pCursor;</Line>
  <Line number="11899">  DbdataTable *pTab = (DbdataTable*)pCursor-&gt;pVtab;</Line>
  <Line number="11900">  if( pTab-&gt;bPtr ){</Line>
  <Line number="11901">    switch( i ){</Line>
  <Line number="11902">      case DBPTR_COLUMN_PGNO:</Line>
  <Line number="11903">        sqlite3_result_int64(ctx, pCsr-&gt;iPgno);</Line>
  <Line number="11904">        break;</Line>
  <Line number="11905">      case DBPTR_COLUMN_CHILD: {</Line>
  <Line number="11906">        int iOff = pCsr-&gt;iPgno==1 ? 100 : 0;</Line>
  <Line number="11907">        if( pCsr-&gt;iCell&lt;0 ){</Line>
  <Line number="11908">          iOff += 8;</Line>
  <Line number="11909">        }else{</Line>
  <Line number="11910">          iOff += 12 + pCsr-&gt;iCell*2;</Line>
  <Line number="11911">          if( iOff&gt;pCsr-&gt;nPage ) return SQLITE_OK;</Line>
  <Line number="11912">          iOff = get_uint16(&amp;pCsr-&gt;aPage[iOff]);</Line>
  <Line number="11913">        }</Line>
  <Line number="11914">        if( iOff&lt;=pCsr-&gt;nPage ){</Line>
  <Line number="11915">          sqlite3_result_int64(ctx, get_uint32(&amp;pCsr-&gt;aPage[iOff]));</Line>
  <Line number="11916">        }</Line>
  <Line number="11917">        break;</Line>
  <Line number="11918">      }</Line>
  <Line number="11919">    }</Line>
  <Line number="11920">  }else{</Line>
  <Line number="11921">    switch( i ){</Line>
  <Line number="11922">      case DBDATA_COLUMN_PGNO:</Line>
  <Line number="11923">        sqlite3_result_int64(ctx, pCsr-&gt;iPgno);</Line>
  <Line number="11924">        break;</Line>
  <Line number="11925">      case DBDATA_COLUMN_CELL:</Line>
  <Line number="11926">        sqlite3_result_int(ctx, pCsr-&gt;iCell);</Line>
  <Line number="11927">        break;</Line>
  <Line number="11928">      case DBDATA_COLUMN_FIELD:</Line>
  <Line number="11929">        sqlite3_result_int(ctx, pCsr-&gt;iField);</Line>
  <Line number="11930">        break;</Line>
  <Line number="11931">      case DBDATA_COLUMN_VALUE: {</Line>
  <Line number="11932">        if( pCsr-&gt;iField&lt;0 ){</Line>
  <Line number="11933">          sqlite3_result_int64(ctx, pCsr-&gt;iIntkey);</Line>
  <Line number="11934">        }else{</Line>
  <Line number="11935">          sqlite3_int64 iType;</Line>
  <Line number="11936">          dbdataGetVarint(pCsr-&gt;pHdrPtr, &amp;iType);</Line>
  <Line number="11937">          dbdataValue(</Line>
  <Line number="11938">              ctx, iType, pCsr-&gt;pPtr, &amp;pCsr-&gt;pRec[pCsr-&gt;nRec] - pCsr-&gt;pPtr</Line>
  <Line number="11939">          );</Line>
  <Line number="11940">        }</Line>
  <Line number="11941">        break;</Line>
  <Line number="11942">      }</Line>
  <Line number="11943">    }</Line>
  <Line number="11944">  }</Line>
  <Line number="11945">  return SQLITE_OK;</Line>
  <Line number="11946">}</Line>
  <Line number="11947"></Line>
  <Line number="11948">/* </Line>
  <Line number="11949">** Return the rowid for an sqlite_dbdata or sqlite_dptr table.</Line>
  <Line number="11950">*/</Line>
  <Line number="11951">static int dbdataRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){</Line>
  <Line number="11952">  DbdataCursor *pCsr = (DbdataCursor*)pCursor;</Line>
  <Line number="11953">  *pRowid = pCsr-&gt;iRowid;</Line>
  <Line number="11954">  return SQLITE_OK;</Line>
  <Line number="11955">}</Line>
  <Line number="11956"></Line>
  <Line number="11957"></Line>
  <Line number="11958">/*</Line>
  <Line number="11959">** Invoke this routine to register the &quot;sqlite_dbdata&quot; virtual table module</Line>
  <Line number="11960">*/</Line>
  <Line number="11961">static int sqlite3DbdataRegister(sqlite3 *db){</Line>
  <Line number="11962">  static sqlite3_module dbdata_module = {</Line>
  <Line number="11963">    0,                            /* iVersion */</Line>
  <Line number="11964">    0,                            /* xCreate */</Line>
  <Line number="11965">    dbdataConnect,                /* xConnect */</Line>
  <Line number="11966">    dbdataBestIndex,              /* xBestIndex */</Line>
  <Line number="11967">    dbdataDisconnect,             /* xDisconnect */</Line>
  <Line number="11968">    0,                            /* xDestroy */</Line>
  <Line number="11969">    dbdataOpen,                   /* xOpen - open a cursor */</Line>
  <Line number="11970">    dbdataClose,                  /* xClose - close a cursor */</Line>
  <Line number="11971">    dbdataFilter,                 /* xFilter - configure scan constraints */</Line>
  <Line number="11972">    dbdataNext,                   /* xNext - advance a cursor */</Line>
  <Line number="11973">    dbdataEof,                    /* xEof - check for end of scan */</Line>
  <Line number="11974">    dbdataColumn,                 /* xColumn - read data */</Line>
  <Line number="11975">    dbdataRowid,                  /* xRowid - read data */</Line>
  <Line number="11976">    0,                            /* xUpdate */</Line>
  <Line number="11977">    0,                            /* xBegin */</Line>
  <Line number="11978">    0,                            /* xSync */</Line>
  <Line number="11979">    0,                            /* xCommit */</Line>
  <Line number="11980">    0,                            /* xRollback */</Line>
  <Line number="11981">    0,                            /* xFindMethod */</Line>
  <Line number="11982">    0,                            /* xRename */</Line>
  <Line number="11983">    0,                            /* xSavepoint */</Line>
  <Line number="11984">    0,                            /* xRelease */</Line>
  <Line number="11985">    0,                            /* xRollbackTo */</Line>
  <Line number="11986">    0                             /* xShadowName */</Line>
  <Line number="11987">  };</Line>
  <Line number="11988"></Line>
  <Line number="11989">  int rc = sqlite3_create_module(db, &quot;sqlite_dbdata&quot;, &amp;dbdata_module, 0);</Line>
  <Line number="11990">  if( rc==SQLITE_OK ){</Line>
  <Line number="11991">    rc = sqlite3_create_module(db, &quot;sqlite_dbptr&quot;, &amp;dbdata_module, (void*)1);</Line>
  <Line number="11992">  }</Line>
  <Line number="11993">  return rc;</Line>
  <Line number="11994">}</Line>
  <Line number="11995"></Line>
  <Line number="11996">#ifdef _WIN32</Line>
  <Line number="11997"></Line>
  <Line number="11998">#endif</Line>
  <Line number="11999">int sqlite3_dbdata_init(</Line>
  <Line number="12000">  sqlite3 *db, </Line>
  <Line number="12001">  char **pzErrMsg, </Line>
  <Line number="12002">  const sqlite3_api_routines *pApi</Line>
  <Line number="12003">){</Line>
  <Line number="12004">  SQLITE_EXTENSION_INIT2(pApi);</Line>
  <Line number="12005">  return sqlite3DbdataRegister(db);</Line>
  <Line number="12006">}</Line>
  <Line number="12007"></Line>
  <Line number="12008">/************************* End ../ext/misc/dbdata.c ********************/</Line>
  <Line number="12009">#endif</Line>
  <Line number="12010"></Line>
  <Line number="12011">#if defined(SQLITE_ENABLE_SESSION)</Line>
  <Line number="12012">/*</Line>
  <Line number="12013">** State information for a single open session</Line>
  <Line number="12014">*/</Line>
  <Line number="12015">typedef struct OpenSession OpenSession;</Line>
  <Line number="12016">struct OpenSession {</Line>
  <Line number="12017">  char *zName;             /* Symbolic name for this session */</Line>
  <Line number="12018">  int nFilter;             /* Number of xFilter rejection GLOB patterns */</Line>
  <Line number="12019">  char **azFilter;         /* Array of xFilter rejection GLOB patterns */</Line>
  <Line number="12020">  sqlite3_session *p;      /* The open session */</Line>
  <Line number="12021">};</Line>
  <Line number="12022">#endif</Line>
  <Line number="12023"></Line>
  <Line number="12024">typedef struct ExpertInfo ExpertInfo;</Line>
  <Line number="12025">struct ExpertInfo {</Line>
  <Line number="12026">  sqlite3expert *pExpert;</Line>
  <Line number="12027">  int bVerbose;</Line>
  <Line number="12028">};</Line>
  <Line number="12029"></Line>
  <Line number="12030">/* A single line in the EQP output */</Line>
  <Line number="12031">typedef struct EQPGraphRow EQPGraphRow;</Line>
  <Line number="12032">struct EQPGraphRow {</Line>
  <Line number="12033">  int iEqpId;           /* ID for this row */</Line>
  <Line number="12034">  int iParentId;        /* ID of the parent row */</Line>
  <Line number="12035">  EQPGraphRow *pNext;   /* Next row in sequence */</Line>
  <Line number="12036">  char zText[1];        /* Text to display for this row */</Line>
  <Line number="12037">};</Line>
  <Line number="12038"></Line>
  <Line number="12039">/* All EQP output is collected into an instance of the following */</Line>
  <Line number="12040">typedef struct EQPGraph EQPGraph;</Line>
  <Line number="12041">struct EQPGraph {</Line>
  <Line number="12042">  EQPGraphRow *pRow;    /* Linked list of all rows of the EQP output */</Line>
  <Line number="12043">  EQPGraphRow *pLast;   /* Last element of the pRow list */</Line>
  <Line number="12044">  char zPrefix[100];    /* Graph prefix */</Line>
  <Line number="12045">};</Line>
  <Line number="12046"></Line>
  <Line number="12047">/*</Line>
  <Line number="12048">** State information about the database connection is contained in an</Line>
  <Line number="12049">** instance of the following structure.</Line>
  <Line number="12050">*/</Line>
  <Line number="12051">typedef struct ShellState ShellState;</Line>
  <Line number="12052">struct ShellState {</Line>
  <Line number="12053">  sqlite3 *db;           /* The database */</Line>
  <Line number="12054">  u8 autoExplain;        /* Automatically turn on .explain mode */</Line>
  <Line number="12055">  u8 autoEQP;            /* Run EXPLAIN QUERY PLAN prior to seach SQL stmt */</Line>
  <Line number="12056">  u8 autoEQPtest;        /* autoEQP is in test mode */</Line>
  <Line number="12057">  u8 autoEQPtrace;       /* autoEQP is in trace mode */</Line>
  <Line number="12058">  u8 scanstatsOn;        /* True to display scan stats before each finalize */</Line>
  <Line number="12059">  u8 openMode;           /* SHELL_OPEN_NORMAL, _APPENDVFS, or _ZIPFILE */</Line>
  <Line number="12060">  u8 doXdgOpen;          /* Invoke start/open/xdg-open in output_reset() */</Line>
  <Line number="12061">  u8 nEqpLevel;          /* Depth of the EQP output graph */</Line>
  <Line number="12062">  u8 eTraceType;         /* SHELL_TRACE_* value for type of trace */</Line>
  <Line number="12063">  unsigned statsOn;      /* True to display memory stats before each finalize */</Line>
  <Line number="12064">  unsigned mEqpLines;    /* Mask of veritical lines in the EQP output graph */</Line>
  <Line number="12065">  int outCount;          /* Revert to stdout when reaching zero */</Line>
  <Line number="12066">  int cnt;               /* Number of records displayed so far */</Line>
  <Line number="12067">  int lineno;            /* Line number of last line read from in */</Line>
  <Line number="12068">  int openFlags;         /* Additional flags to open.  (SQLITE_OPEN_NOFOLLOW) */</Line>
  <Line number="12069">  FILE *in;              /* Read commands from this stream */</Line>
  <Line number="12070">  FILE *out;             /* Write results here */</Line>
  <Line number="12071">  FILE *traceOut;        /* Output for sqlite3_trace() */</Line>
  <Line number="12072">  int nErr;              /* Number of errors seen */</Line>
  <Line number="12073">  int mode;              /* An output mode setting */</Line>
  <Line number="12074">  int modePrior;         /* Saved mode */</Line>
  <Line number="12075">  int cMode;             /* temporary output mode for the current query */</Line>
  <Line number="12076">  int normalMode;        /* Output mode before &quot;.explain on&quot; */</Line>
  <Line number="12077">  int writableSchema;    /* True if PRAGMA writable_schema=ON */</Line>
  <Line number="12078">  int showHeader;        /* True to show column names in List or Column mode */</Line>
  <Line number="12079">  int nCheck;            /* Number of &quot;.check&quot; commands run */</Line>
  <Line number="12080">  unsigned nProgress;    /* Number of progress callbacks encountered */</Line>
  <Line number="12081">  unsigned mxProgress;   /* Maximum progress callbacks before failing */</Line>
  <Line number="12082">  unsigned flgProgress;  /* Flags for the progress callback */</Line>
  <Line number="12083">  unsigned shellFlgs;    /* Various flags */</Line>
  <Line number="12084">  unsigned priorShFlgs;  /* Saved copy of flags */</Line>
  <Line number="12085">  sqlite3_int64 szMax;   /* --maxsize argument to .open */</Line>
  <Line number="12086">  char *zDestTable;      /* Name of destination table when MODE_Insert */</Line>
  <Line number="12087">  char *zTempFile;       /* Temporary file that might need deleting */</Line>
  <Line number="12088">  char zTestcase[30];    /* Name of current test case */</Line>
  <Line number="12089">  char colSeparator[20]; /* Column separator character for several modes */</Line>
  <Line number="12090">  char rowSeparator[20]; /* Row separator character for MODE_Ascii */</Line>
  <Line number="12091">  char colSepPrior[20];  /* Saved column separator */</Line>
  <Line number="12092">  char rowSepPrior[20];  /* Saved row separator */</Line>
  <Line number="12093">  int *colWidth;         /* Requested width of each column in columnar modes */</Line>
  <Line number="12094">  int *actualWidth;      /* Actual width of each column */</Line>
  <Line number="12095">  int nWidth;            /* Number of slots in colWidth[] and actualWidth[] */</Line>
  <Line number="12096">  char nullValue[20];    /* The text to print when a NULL comes back from</Line>
  <Line number="12097">                         ** the database */</Line>
  <Line number="12098">  char outfile[20]; /* mkb:Filename for *out */</Line>
  <Line number="12099">  const char *zDbFilename;    /* name of the database file */</Line>
  <Line number="12100">  char *zFreeOnClose;         /* Filename to free when closing */</Line>
  <Line number="12101">  const char *zVfs;           /* Name of VFS to use */</Line>
  <Line number="12102">  sqlite3_stmt *pStmt;   /* Current statement if any. */</Line>
  <Line number="12103">  FILE *pLog;            /* Write log output here */</Line>
  <Line number="12104">  int *aiIndent;         /* Array of indents used in MODE_Explain */</Line>
  <Line number="12105">  int nIndent;           /* Size of array aiIndent[] */</Line>
  <Line number="12106">  int iIndent;           /* Index of current op in aiIndent[] */</Line>
  <Line number="12107">  EQPGraph sGraph;       /* Information for the graphical EXPLAIN QUERY PLAN */</Line>
  <Line number="12108">#if defined(SQLITE_ENABLE_SESSION)</Line>
  <Line number="12109">  int nSession;             /* Number of active sessions */</Line>
  <Line number="12110">  OpenSession aSession[4];  /* Array of sessions.  [0] is in focus. */</Line>
  <Line number="12111">#endif</Line>
  <Line number="12112">  ExpertInfo expert;        /* Valid if previous command was &quot;.expert OPT...&quot; */</Line>
  <Line number="12113">};</Line>
  <Line number="12114"></Line>
  <Line number="12115"></Line>
  <Line number="12116">/* Allowed values for ShellState.autoEQP</Line>
  <Line number="12117">*/</Line>
  <Line number="12118">#define AUTOEQP_off      0           /* Automatic EXPLAIN QUERY PLAN is off */</Line>
  <Line number="12119">#define AUTOEQP_on       1           /* Automatic EQP is on */</Line>
  <Line number="12120">#define AUTOEQP_trigger  2           /* On and also show plans for triggers */</Line>
  <Line number="12121">#define AUTOEQP_full     3           /* Show full EXPLAIN */</Line>
  <Line number="12122"></Line>
  <Line number="12123">/* Allowed values for ShellState.openMode</Line>
  <Line number="12124">*/</Line>
  <Line number="12125">#define SHELL_OPEN_UNSPEC      0      /* No open-mode specified */</Line>
  <Line number="12126">#define SHELL_OPEN_NORMAL      1      /* Normal database file */</Line>
  <Line number="12127">#define SHELL_OPEN_APPENDVFS   2      /* Use appendvfs */</Line>
  <Line number="12128">#define SHELL_OPEN_ZIPFILE     3      /* Use the zipfile virtual table */</Line>
  <Line number="12129">#define SHELL_OPEN_READONLY    4      /* Open a normal database read-only */</Line>
  <Line number="12130">#define SHELL_OPEN_DESERIALIZE 5      /* Open using sqlite3_deserialize() */</Line>
  <Line number="12131">#define SHELL_OPEN_HEXDB       6      /* Use &quot;dbtotxt&quot; output as data source */</Line>
  <Line number="12132"></Line>
  <Line number="12133">/* Allowed values for ShellState.eTraceType</Line>
  <Line number="12134">*/</Line>
  <Line number="12135">#define SHELL_TRACE_PLAIN      0      /* Show input SQL text */</Line>
  <Line number="12136">#define SHELL_TRACE_EXPANDED   1      /* Show expanded SQL text */</Line>
  <Line number="12137">#define SHELL_TRACE_NORMALIZED 2      /* Show normalized SQL text */</Line>
  <Line number="12138"></Line>
  <Line number="12139">/* Bits in the ShellState.flgProgress variable */</Line>
  <Line number="12140">#define SHELL_PROGRESS_QUIET 0x01  /* Omit announcing every progress callback */</Line>
  <Line number="12141">#define SHELL_PROGRESS_RESET 0x02  /* Reset the count when the progres</Line>
  <Line number="12142">                                   ** callback limit is reached, and for each</Line>
  <Line number="12143">                                   ** top-level SQL statement */</Line>
  <Line number="12144">#define SHELL_PROGRESS_ONCE  0x04  /* Cancel the --limit after firing once */</Line>
  <Line number="12145"></Line>
  <Line number="12146">/*</Line>
  <Line number="12147">** These are the allowed shellFlgs values</Line>
  <Line number="12148">*/</Line>
  <Line number="12149">#define SHFLG_Pagecache      0x00000001 /* The --pagecache option is used */</Line>
  <Line number="12150">#define SHFLG_Lookaside      0x00000002 /* Lookaside memory is used */</Line>
  <Line number="12151">#define SHFLG_Backslash      0x00000004 /* The --backslash option is used */</Line>
  <Line number="12152">#define SHFLG_PreserveRowid  0x00000008 /* .dump preserves rowid values */</Line>
  <Line number="12153">#define SHFLG_Newlines       0x00000010 /* .dump --newline flag */</Line>
  <Line number="12154">#define SHFLG_CountChanges   0x00000020 /* .changes setting */</Line>
  <Line number="12155">#define SHFLG_Echo           0x00000040 /* .echo or --echo setting */</Line>
  <Line number="12156">#define SHFLG_HeaderSet      0x00000080 /* .header has been used */</Line>
  <Line number="12157">#define SHFLG_DumpDataOnly   0x00000100 /* .dump show data only */</Line>
  <Line number="12158">#define SHFLG_DumpNoSys      0x00000200 /* .dump omits system tables */</Line>
  <Line number="12159"></Line>
  <Line number="12160">/*</Line>
  <Line number="12161">** Macros for testing and setting shellFlgs</Line>
  <Line number="12162">*/</Line>
  <Line number="12163">#define ShellHasFlag(P,X)    (((P)-&gt;shellFlgs &amp; (X))!=0)</Line>
  <Line number="12164">#define ShellSetFlag(P,X)    ((P)-&gt;shellFlgs|=(X))</Line>
  <Line number="12165">#define ShellClearFlag(P,X)  ((P)-&gt;shellFlgs&amp;=(~(X)))</Line>
  <Line number="12166"></Line>
  <Line number="12167">/*</Line>
  <Line number="12168">** These are the allowed modes.</Line>
  <Line number="12169">*/</Line>
  <Line number="12170">#define MODE_Line     0  /* One column per line.  Blank line between records */</Line>
  <Line number="12171">#define MODE_Column   1  /* One record per line in neat columns */</Line>
  <Line number="12172">#define MODE_List     2  /* One record per line with a separator */</Line>
  <Line number="12173">#define MODE_Semi     3  /* Same as MODE_List but append &quot;;&quot; to each line */</Line>
  <Line number="12174">#define MODE_Html     4  /* Generate an XHTML table */</Line>
  <Line number="12175">#define MODE_Insert   5  /* Generate SQL &quot;insert&quot; statements */</Line>
  <Line number="12176">#define MODE_Quote    6  /* Quote values as for SQL */</Line>
  <Line number="12177">#define MODE_Tcl      7  /* Generate ANSI-C or TCL quoted elements */</Line>
  <Line number="12178">#define MODE_Csv      8  /* Quote strings, numbers are plain */</Line>
  <Line number="12179">#define MODE_Explain  9  /* Like MODE_Column, but do not truncate data */</Line>
  <Line number="12180">#define MODE_Ascii   10  /* Use ASCII unit and record separators (0x1F/0x1E) */</Line>
  <Line number="12181">#define MODE_Pretty  11  /* Pretty-print schemas */</Line>
  <Line number="12182">#define MODE_EQP     12  /* Converts EXPLAIN QUERY PLAN output into a graph */</Line>
  <Line number="12183">#define MODE_Json    13  /* Output JSON */</Line>
  <Line number="12184">#define MODE_Markdown 14 /* Markdown formatting */</Line>
  <Line number="12185">#define MODE_Table   15  /* MySQL-style table formatting */</Line>
  <Line number="12186">#define MODE_Box     16  /* Unicode box-drawing characters */</Line>
  <Line number="12187"></Line>
  <Line number="12188">static const char *modeDescr[] = {</Line>
  <Line number="12189">  &quot;line&quot;,</Line>
  <Line number="12190">  &quot;column&quot;,</Line>
  <Line number="12191">  &quot;list&quot;,</Line>
  <Line number="12192">  &quot;semi&quot;,</Line>
  <Line number="12193">  &quot;html&quot;,</Line>
  <Line number="12194">  &quot;insert&quot;,</Line>
  <Line number="12195">  &quot;quote&quot;,</Line>
  <Line number="12196">  &quot;tcl&quot;,</Line>
  <Line number="12197">  &quot;csv&quot;,</Line>
  <Line number="12198">  &quot;explain&quot;,</Line>
  <Line number="12199">  &quot;ascii&quot;,</Line>
  <Line number="12200">  &quot;prettyprint&quot;,</Line>
  <Line number="12201">  &quot;eqp&quot;,</Line>
  <Line number="12202">  &quot;json&quot;,</Line>
  <Line number="12203">  &quot;markdown&quot;,</Line>
  <Line number="12204">  &quot;table&quot;,</Line>
  <Line number="12205">  &quot;box&quot;</Line>
  <Line number="12206">};</Line>
  <Line number="12207"></Line>
  <Line number="12208">/*</Line>
  <Line number="12209">** These are the column/row/line separators used by the various</Line>
  <Line number="12210">** import/export modes.</Line>
  <Line number="12211">*/</Line>
  <Line number="12212">#define SEP_Column    &quot;|&quot;</Line>
  <Line number="12213">#define SEP_Row       &quot;\n&quot;</Line>
  <Line number="12214">#define SEP_Tab       &quot;\t&quot;</Line>
  <Line number="12215">#define SEP_Space     &quot; &quot;</Line>
  <Line number="12216">#define SEP_Comma     &quot;,&quot;</Line>
  <Line number="12217">#define SEP_CrLf      &quot;\r\n&quot;</Line>
  <Line number="12218">#define SEP_Unit      &quot;\x1F&quot;</Line>
  <Line number="12219">#define SEP_Record    &quot;\x1E&quot;</Line>
  <Line number="12220"></Line>
  <Line number="12221">/*</Line>
  <Line number="12222">** A callback for the sqlite3_log() interface.</Line>
  <Line number="12223">*/</Line>
  <Line number="12224">static void shellLog(void *pArg, int iErrCode, const char *zMsg){</Line>
  <Line number="12225">  ShellState *p = (ShellState*)pArg;</Line>
  <Line number="12226">  if( p-&gt;pLog==0 ) return;</Line>
  <Line number="12227">  utf8_printf(p-&gt;pLog, &quot;(%d) %s\n&quot;, iErrCode, zMsg);</Line>
  <Line number="12228">  fflush(p-&gt;pLog);</Line>
  <Line number="12229">}</Line>
  <Line number="12230"></Line>
  <Line number="12231">/*</Line>
  <Line number="12232">** SQL function:  shell_putsnl(X)</Line>
  <Line number="12233">**</Line>
  <Line number="12234">** Write the text X to the screen (or whatever output is being directed)</Line>
  <Line number="12235">** adding a newline at the end, and then return X.</Line>
  <Line number="12236">*/</Line>
  <Line number="12237">static void shellPutsFunc(</Line>
  <Line number="12238">  sqlite3_context *pCtx,</Line>
  <Line number="12239">  int nVal,</Line>
  <Line number="12240">  sqlite3_value **apVal</Line>
  <Line number="12241">){</Line>
  <Line number="12242">  ShellState *p = (ShellState*)sqlite3_user_data(pCtx);</Line>
  <Line number="12243">  (void)nVal;</Line>
  <Line number="12244">  utf8_printf(p-&gt;out, &quot;%s\n&quot;, sqlite3_value_text(apVal[0]));</Line>
  <Line number="12245">  sqlite3_result_value(pCtx, apVal[0]);</Line>
  <Line number="12246">}</Line>
  <Line number="12247"></Line>
  <Line number="12248">/*</Line>
  <Line number="12249">** SQL function:   edit(VALUE)</Line>
  <Line number="12250">**                 edit(VALUE,EDITOR)</Line>
  <Line number="12251">**</Line>
  <Line number="12252">** These steps:</Line>
  <Line number="12253">**</Line>
  <Line number="12254">**     (1) Write VALUE into a temporary file.</Line>
  <Line number="12255">**     (2) Run program EDITOR on that temporary file.</Line>
  <Line number="12256">**     (3) Read the temporary file back and return its content as the result.</Line>
  <Line number="12257">**     (4) Delete the temporary file</Line>
  <Line number="12258">**</Line>
  <Line number="12259">** If the EDITOR argument is omitted, use the value in the VISUAL</Line>
  <Line number="12260">** environment variable.  If still there is no EDITOR, through an error.</Line>
  <Line number="12261">**</Line>
  <Line number="12262">** Also throw an error if the EDITOR program returns a non-zero exit code.</Line>
  <Line number="12263">*/</Line>
  <Line number="12264">#ifndef SQLITE_NOHAVE_SYSTEM</Line>
  <Line number="12265">static void editFunc(</Line>
  <Line number="12266">  sqlite3_context *context,</Line>
  <Line number="12267">  int argc,</Line>
  <Line number="12268">  sqlite3_value **argv</Line>
  <Line number="12269">){</Line>
  <Line number="12270">  const char *zEditor;</Line>
  <Line number="12271">  char *zTempFile = 0;</Line>
  <Line number="12272">  sqlite3 *db;</Line>
  <Line number="12273">  char *zCmd = 0;</Line>
  <Line number="12274">  int bBin;</Line>
  <Line number="12275">  int rc;</Line>
  <Line number="12276">  int hasCRNL = 0;</Line>
  <Line number="12277">  FILE *f = 0;</Line>
  <Line number="12278">  sqlite3_int64 sz;</Line>
  <Line number="12279">  sqlite3_int64 x;</Line>
  <Line number="12280">  unsigned char *p = 0;</Line>
  <Line number="12281"></Line>
  <Line number="12282">  if( argc==2 ){</Line>
  <Line number="12283">    zEditor = (const char*)sqlite3_value_text(argv[1]);</Line>
  <Line number="12284">  }else{</Line>
  <Line number="12285">    zEditor = getenv(&quot;VISUAL&quot;);</Line>
  <Line number="12286">  }</Line>
  <Line number="12287">  if( zEditor==0 ){</Line>
  <Line number="12288">    sqlite3_result_error(context, &quot;no editor for edit()&quot;, <CheckRefs ids="2431">-</CheckRefs>1);</Line>
  <Line number="12289">    return;</Line>
  <Line number="12290">  }</Line>
  <Line number="12291">  if( sqlite3_value_type(argv[0])==SQLITE_NULL ){</Line>
  <Line number="12292">    sqlite3_result_error(context, &quot;NULL input to edit()&quot;, <CheckRefs ids="2432">-</CheckRefs>1);</Line>
  <Line number="12293">    return;</Line>
  <Line number="12294">  }</Line>
  <Line number="12295">  db = sqlite3_context_db_handle(context);</Line>
  <Line number="12296">  zTempFile = 0;</Line>
  <Line number="12297">  sqlite3_file_control(db, 0, SQLITE_FCNTL_TEMPFILENAME, &amp;zTempFile);</Line>
  <Line number="12298">  if( zTempFile==0 ){</Line>
  <Line number="12299">    sqlite3_uint64 r = <CheckRefs ids="2433">0</CheckRefs>;</Line>
  <Line number="12300">    sqlite3_randomness(<CheckRefs ids="2434">sizeof</CheckRefs>(r), &amp;r);</Line>
  <Line number="12301">    zTempFile = sqlite3_mprintf(&quot;temp%llx&quot;, r);</Line>
  <Line number="12302">    if( zTempFile==0 ){</Line>
  <Line number="12303">      sqlite3_result_error_nomem(context);</Line>
  <Line number="12304">      return;</Line>
  <Line number="12305">    }</Line>
  <Line number="12306">  }</Line>
  <Line number="12307">  bBin = sqlite3_value_type(argv[0])==SQLITE_BLOB;</Line>
  <Line number="12308">  /* When writing the file to be edited, do \n to \r\n conversions on systems</Line>
  <Line number="12309">  ** that want \r\n line endings */</Line>
  <Line number="12310">  f = fopen(zTempFile, bBin ? &quot;wb&quot; : &quot;w&quot;);</Line>
  <Line number="12311">  if( f==0 ){</Line>
  <Line number="12312">    sqlite3_result_error(context, &quot;edit() cannot open temp file&quot;, <CheckRefs ids="2435">-</CheckRefs>1);</Line>
  <Line number="12313">    goto edit_func_end;</Line>
  <Line number="12314">  }</Line>
  <Line number="12315">  sz = <CheckRefs ids="2436">sqlite3_value_bytes</CheckRefs>(argv[0]);</Line>
  <Line number="12316">  if( bBin ){</Line>
  <Line number="12317">    x = <CheckRefs ids="2437">fwrite</CheckRefs>(sqlite3_value_blob(argv[0]), <CheckRefs ids="2438">1</CheckRefs>, <CheckRefs ids="2439">(</CheckRefs>size_t)sz, f);</Line>
  <Line number="12318">  }else{</Line>
  <Line number="12319">    const char *z = (const char*)sqlite3_value_text(argv[0]);</Line>
  <Line number="12320">    /* Remember whether or not the value originally contained \r\n */</Line>
  <Line number="12321">    if( z &amp;&amp; strstr(z,&quot;\r\n&quot;)!=0 ) hasCRNL = 1;</Line>
  <Line number="12322">    x = <CheckRefs ids="2440">fwrite</CheckRefs>(sqlite3_value_text(argv[0]), <CheckRefs ids="2441">1</CheckRefs>, <CheckRefs ids="2442">(</CheckRefs>size_t)sz, f);</Line>
  <Line number="12323">  }</Line>
  <Line number="12324">  fclose(f);</Line>
  <Line number="12325">  f = 0;</Line>
  <Line number="12326">  if( x!=sz ){</Line>
  <Line number="12327">    sqlite3_result_error(context, &quot;edit() could not write the whole file&quot;, <CheckRefs ids="2443">-</CheckRefs>1);</Line>
  <Line number="12328">    goto edit_func_end;</Line>
  <Line number="12329">  }</Line>
  <Line number="12330">  zCmd = sqlite3_mprintf(&quot;%s \&quot;%s\&quot;&quot;, zEditor, zTempFile);</Line>
  <Line number="12331">  if( zCmd==0 ){</Line>
  <Line number="12332">    sqlite3_result_error_nomem(context);</Line>
  <Line number="12333">    goto edit_func_end;</Line>
  <Line number="12334">  }</Line>
  <Line number="12335">  rc = system(zCmd);</Line>
  <Line number="12336">  sqlite3_free(zCmd);</Line>
  <Line number="12337">  if( rc ){</Line>
  <Line number="12338">    sqlite3_result_error(context, &quot;EDITOR returned non-zero&quot;, <CheckRefs ids="2444">-</CheckRefs>1);</Line>
  <Line number="12339">    goto edit_func_end;</Line>
  <Line number="12340">  }</Line>
  <Line number="12341">  f = fopen(zTempFile, &quot;rb&quot;);</Line>
  <Line number="12342">  if( f==0 ){</Line>
  <Line number="12343">    sqlite3_result_error(context,</Line>
  <Line number="12344">      &quot;edit() cannot reopen temp file after edit&quot;, <CheckRefs ids="2445">-</CheckRefs>1);</Line>
  <Line number="12345">    goto edit_func_end;</Line>
  <Line number="12346">  }</Line>
  <Line number="12347">  fseek(f, <CheckRefs ids="2446">0</CheckRefs>, SEEK_END);</Line>
  <Line number="12348">  sz = <CheckRefs ids="2447">ftell</CheckRefs>(f);</Line>
  <Line number="12349">  rewind(f);</Line>
  <Line number="12350">  p = sqlite3_malloc64( sz<CheckRefs ids="2448,2449">+</CheckRefs><CheckRefs ids="2450">1</CheckRefs> );</Line>
  <Line number="12351">  if( p==0 ){</Line>
  <Line number="12352">    sqlite3_result_error_nomem(context);</Line>
  <Line number="12353">    goto edit_func_end;</Line>
  <Line number="12354">  }</Line>
  <Line number="12355">  x = <CheckRefs ids="2451">fread</CheckRefs>(p, <CheckRefs ids="2452">1</CheckRefs>, <CheckRefs ids="2453">(</CheckRefs>size_t)sz, f);</Line>
  <Line number="12356">  fclose(f);</Line>
  <Line number="12357">  f = 0;</Line>
  <Line number="12358">  if( x!=sz ){</Line>
  <Line number="12359">    sqlite3_result_error(context, &quot;could not read back the whole file&quot;, <CheckRefs ids="2454">-</CheckRefs>1);</Line>
  <Line number="12360">    goto edit_func_end;</Line>
  <Line number="12361">  }</Line>
  <Line number="12362">  if( bBin ){</Line>
  <Line number="12363">    sqlite3_result_blob64(context, p, <CheckRefs ids="2455">sz</CheckRefs>, sqlite3_free);</Line>
  <Line number="12364">  }else{</Line>
  <Line number="12365">    sqlite3_int64 i, j;</Line>
  <Line number="12366">    if( hasCRNL ){</Line>
  <Line number="12367">      /* If the original contains \r\n then do no conversions back to \n */</Line>
  <Line number="12368">      j = sz;</Line>
  <Line number="12369">    }else{</Line>
  <Line number="12370">      /* If the file did not originally contain \r\n then convert any new</Line>
  <Line number="12371">      ** \r\n back into \n */</Line>
  <Line number="12372">      for(i=j=<CheckRefs ids="2456">0</CheckRefs>; i&lt;sz; i<CheckRefs ids="2457">++</CheckRefs>){</Line>
  <Line number="12373">        if( <CheckRefs ids="2458">p</CheckRefs>[i]==&apos;\r&apos; &amp;&amp; <CheckRefs ids="2459">p</CheckRefs>[i<CheckRefs ids="2460">+</CheckRefs><CheckRefs ids="2461">1</CheckRefs>]==&apos;\n&apos; ) i<CheckRefs ids="2462">++</CheckRefs>;</Line>
  <Line number="12374">        p[j<CheckRefs ids="2463">++</CheckRefs>] = p[i];</Line>
  <Line number="12375">      }</Line>
  <Line number="12376">      sz = j;</Line>
  <Line number="12377">      p[sz] = <CheckRefs ids="2464">0</CheckRefs>;</Line>
  <Line number="12378">    } </Line>
  <Line number="12379">    sqlite3_result_text64(context, (const char*)p, <CheckRefs ids="2465">sz</CheckRefs>,</Line>
  <Line number="12380">                          sqlite3_free, <CheckRefs ids="2466">SQLITE_UTF8</CheckRefs>);</Line>
  <Line number="12381">  }</Line>
  <Line number="12382">  p = 0;</Line>
  <Line number="12383"></Line>
  <Line number="12384">edit_func_end:</Line>
  <Line number="12385">  if( f ) fclose(f);</Line>
  <Line number="12386">  unlink(zTempFile);</Line>
  <Line number="12387">  sqlite3_free(zTempFile);</Line>
  <Line number="12388">  sqlite3_free(p);</Line>
  <Line number="12389">}</Line>
  <Line number="12390">#endif /* SQLITE_NOHAVE_SYSTEM */</Line>
  <Line number="12391"></Line>
  <Line number="12392">/*</Line>
  <Line number="12393">** Save or restore the current output mode</Line>
  <Line number="12394">*/</Line>
  <Line number="12395">static void outputModePush(ShellState *p){</Line>
  <Line number="12396">  p-&gt;modePrior = p-&gt;mode;</Line>
  <Line number="12397">  p-&gt;priorShFlgs = p-&gt;shellFlgs;</Line>
  <Line number="12398">  memcpy(p-&gt;colSepPrior, p-&gt;colSeparator, sizeof(p-&gt;colSeparator));</Line>
  <Line number="12399">  memcpy(p-&gt;rowSepPrior, p-&gt;rowSeparator, sizeof(p-&gt;rowSeparator));</Line>
  <Line number="12400">}</Line>
  <Line number="12401">static void outputModePop(ShellState *p){</Line>
  <Line number="12402">  p-&gt;mode = p-&gt;modePrior;</Line>
  <Line number="12403">  p-&gt;shellFlgs = p-&gt;priorShFlgs;</Line>
  <Line number="12404">  memcpy(p-&gt;colSeparator, p-&gt;colSepPrior, sizeof(p-&gt;colSeparator));</Line>
  <Line number="12405">  memcpy(p-&gt;rowSeparator, p-&gt;rowSepPrior, sizeof(p-&gt;rowSeparator));</Line>
  <Line number="12406">}</Line>
  <Line number="12407"></Line>
  <Line number="12408">/*</Line>
  <Line number="12409">** Output the given string as a hex-encoded blob (eg. X&apos;1234&apos; )</Line>
  <Line number="12410">*/</Line>
  <Line number="12411">static void output_hex_blob(FILE *out, const void *pBlob, int nBlob){</Line>
  <Line number="12412">  int i;</Line>
  <Line number="12413">  char *zBlob = (char *)pBlob;</Line>
  <Line number="12414">  raw_printf(out,&quot;X&apos;&quot;);</Line>
  <Line number="12415">  for(i=0; i&lt;nBlob; i<CheckRefs ids="2467">++</CheckRefs>){ raw_printf(out,&quot;%02x&quot;,<CheckRefs ids="2468">zBlob</CheckRefs>[i]&amp;0xff); }</Line>
  <Line number="12416">  raw_printf(out,&quot;&apos;&quot;);</Line>
  <Line number="12417">}</Line>
  <Line number="12418"></Line>
  <Line number="12419">/*</Line>
  <Line number="12420">** Find a string that is not found anywhere in z[].  Return a pointer</Line>
  <Line number="12421">** to that string.</Line>
  <Line number="12422">**</Line>
  <Line number="12423">** Try to use zA and zB first.  If both of those are already found in z[]</Line>
  <Line number="12424">** then make up some string and store it in the buffer zBuf.</Line>
  <Line number="12425">*/</Line>
  <Line number="12426">static const char *unused_string(</Line>
  <Line number="12427">  const char *z,                    /* Result must not appear anywhere in z */</Line>
  <Line number="12428">  const char *zA, const char *zB,   /* Try these first */</Line>
  <Line number="12429">  char *zBuf                        /* Space to store a generated string */</Line>
  <Line number="12430">){</Line>
  <Line number="12431">  unsigned i = <CheckRefs ids="2469">0</CheckRefs>;</Line>
  <Line number="12432">  if( strstr(z, zA)==0 ) return zA;</Line>
  <Line number="12433">  if( strstr(z, zB)==0 ) return zB;</Line>
  <Line number="12434">  do{</Line>
  <Line number="12435">    sqlite3_snprintf(20,zBuf,&quot;(%s%u)&quot;, zA, i<CheckRefs ids="2470">++</CheckRefs>);</Line>
  <Line number="12436">  }while( strstr(z,zBuf)!=0 );</Line>
  <Line number="12437">  return zBuf;</Line>
  <Line number="12438">}</Line>
  <Line number="12439"></Line>
  <Line number="12440">/*</Line>
  <Line number="12441">** Output the given string as a quoted string using SQL quoting conventions.</Line>
  <Line number="12442">**</Line>
  <Line number="12443">** See also: output_quoted_escaped_string()</Line>
  <Line number="12444">*/</Line>
  <Line number="12445">static void output_quoted_string(FILE *out, const char *z){</Line>
  <Line number="12446">  int i;</Line>
  <Line number="12447">  char c;</Line>
  <Line number="12448">  setBinaryMode(out, 1);</Line>
  <Line number="12449">  for(i=0; <CheckRefs ids="2471">(</CheckRefs>c = z[i])!=0 &amp;&amp; <CheckRefs ids="2472">c</CheckRefs>!=&apos;\&apos;&apos;; i<CheckRefs ids="2473">++</CheckRefs>){}</Line>
  <Line number="12450">  if( <CheckRefs ids="2474">c</CheckRefs>==0 ){</Line>
  <Line number="12451">    utf8_printf(out,&quot;&apos;%s&apos;&quot;,z);</Line>
  <Line number="12452">  }else{</Line>
  <Line number="12453">    raw_printf(out, &quot;&apos;&quot;);</Line>
  <Line number="12454">    while( *z ){</Line>
  <Line number="12455">      for(i=0; <CheckRefs ids="2475">(</CheckRefs>c = z[i])!=0 &amp;&amp; <CheckRefs ids="2476">c</CheckRefs>!=&apos;\&apos;&apos;; i<CheckRefs ids="2477">++</CheckRefs>){}</Line>
  <Line number="12456">      if( <CheckRefs ids="2478">c</CheckRefs>==&apos;\&apos;&apos; ) i<CheckRefs ids="2479">++</CheckRefs>;</Line>
  <Line number="12457">      if( i ){</Line>
  <Line number="12458">        utf8_printf(out, &quot;%.*s&quot;, i, z);</Line>
  <Line number="12459">        z += i;</Line>
  <Line number="12460">      }</Line>
  <Line number="12461">      if( <CheckRefs ids="2480">c</CheckRefs>==&apos;\&apos;&apos; ){</Line>
  <Line number="12462">        raw_printf(out, &quot;&apos;&quot;);</Line>
  <Line number="12463">        continue;</Line>
  <Line number="12464">      }</Line>
  <Line number="12465">      if( <CheckRefs ids="2481">c</CheckRefs>==0 ){</Line>
  <Line number="12466">        break;</Line>
  <Line number="12467">      }</Line>
  <Line number="12468">      z++;</Line>
  <Line number="12469">    }</Line>
  <Line number="12470">    raw_printf(out, &quot;&apos;&quot;);</Line>
  <Line number="12471">  }</Line>
  <Line number="12472">  setTextMode(out, 1);</Line>
  <Line number="12473">}</Line>
  <Line number="12474"></Line>
  <Line number="12475">/*</Line>
  <Line number="12476">** Output the given string as a quoted string using SQL quoting conventions.</Line>
  <Line number="12477">** Additionallly , escape the &quot;\n&quot; and &quot;\r&quot; characters so that they do not</Line>
  <Line number="12478">** get corrupted by end-of-line translation facilities in some operating</Line>
  <Line number="12479">** systems.</Line>
  <Line number="12480">**</Line>
  <Line number="12481">** This is like output_quoted_string() but with the addition of the \r\n</Line>
  <Line number="12482">** escape mechanism.</Line>
  <Line number="12483">*/</Line>
  <Line number="12484">static void output_quoted_escaped_string(FILE *out, const char *z){</Line>
  <Line number="12485">  int i;</Line>
  <Line number="12486">  char c;</Line>
  <Line number="12487">  setBinaryMode(out, 1);</Line>
  <Line number="12488">  for(i=0; <CheckRefs ids="2482">(</CheckRefs>c = z[i])!=0 &amp;&amp; <CheckRefs ids="2483">c</CheckRefs>!=&apos;\&apos;&apos; &amp;&amp; <CheckRefs ids="2484">c</CheckRefs>!=&apos;\n&apos; &amp;&amp; <CheckRefs ids="2485">c</CheckRefs>!=&apos;\r&apos;; i<CheckRefs ids="2486">++</CheckRefs>){}</Line>
  <Line number="12489">  if( <CheckRefs ids="2487">c</CheckRefs>==0 ){</Line>
  <Line number="12490">    utf8_printf(out,&quot;&apos;%s&apos;&quot;,z);</Line>
  <Line number="12491">  }else{</Line>
  <Line number="12492">    const char *zNL = 0;</Line>
  <Line number="12493">    const char *zCR = 0;</Line>
  <Line number="12494">    int nNL = 0;</Line>
  <Line number="12495">    int nCR = 0;</Line>
  <Line number="12496">    char zBuf1[20], zBuf2[20];</Line>
  <Line number="12497">    for(i=0; z[i]; i<CheckRefs ids="2488">++</CheckRefs>){</Line>
  <Line number="12498">      if( <CheckRefs ids="2489">z</CheckRefs>[i]==&apos;\n&apos; ) nNL<CheckRefs ids="2490">++</CheckRefs>;</Line>
  <Line number="12499">      if( <CheckRefs ids="2491">z</CheckRefs>[i]==&apos;\r&apos; ) nCR<CheckRefs ids="2492">++</CheckRefs>;</Line>
  <Line number="12500">    }</Line>
  <Line number="12501">    if( nNL ){</Line>
  <Line number="12502">      raw_printf(out, &quot;replace(&quot;);</Line>
  <Line number="12503">      zNL = unused_string(z, &quot;\\n&quot;, &quot;\\012&quot;, zBuf1);</Line>
  <Line number="12504">    }</Line>
  <Line number="12505">    if( nCR ){</Line>
  <Line number="12506">      raw_printf(out, &quot;replace(&quot;);</Line>
  <Line number="12507">      zCR = unused_string(z, &quot;\\r&quot;, &quot;\\015&quot;, zBuf2);</Line>
  <Line number="12508">    }</Line>
  <Line number="12509">    raw_printf(out, &quot;&apos;&quot;);</Line>
  <Line number="12510">    while( *z ){</Line>
  <Line number="12511">      for(i=0; <CheckRefs ids="2493">(</CheckRefs>c = z[i])!=0 &amp;&amp; <CheckRefs ids="2494">c</CheckRefs>!=&apos;\n&apos; &amp;&amp; <CheckRefs ids="2495">c</CheckRefs>!=&apos;\r&apos; &amp;&amp; <CheckRefs ids="2496">c</CheckRefs>!=&apos;\&apos;&apos;; i<CheckRefs ids="2497">++</CheckRefs>){}</Line>
  <Line number="12512">      if( <CheckRefs ids="2498">c</CheckRefs>==&apos;\&apos;&apos; ) i<CheckRefs ids="2499">++</CheckRefs>;</Line>
  <Line number="12513">      if( i ){</Line>
  <Line number="12514">        utf8_printf(out, &quot;%.*s&quot;, i, z);</Line>
  <Line number="12515">        z += i;</Line>
  <Line number="12516">      }</Line>
  <Line number="12517">      if( <CheckRefs ids="2500">c</CheckRefs>==&apos;\&apos;&apos; ){</Line>
  <Line number="12518">        raw_printf(out, &quot;&apos;&quot;);</Line>
  <Line number="12519">        continue;</Line>
  <Line number="12520">      }</Line>
  <Line number="12521">      if( <CheckRefs ids="2501">c</CheckRefs>==0 ){</Line>
  <Line number="12522">        break;</Line>
  <Line number="12523">      }</Line>
  <Line number="12524">      z++;</Line>
  <Line number="12525">      if( <CheckRefs ids="2502">c</CheckRefs>==&apos;\n&apos; ){</Line>
  <Line number="12526">        raw_printf(out, &quot;%s&quot;, zNL);</Line>
  <Line number="12527">        continue;</Line>
  <Line number="12528">      }</Line>
  <Line number="12529">      raw_printf(out, &quot;%s&quot;, zCR);</Line>
  <Line number="12530">    }</Line>
  <Line number="12531">    raw_printf(out, &quot;&apos;&quot;);</Line>
  <Line number="12532">    if( nCR ){</Line>
  <Line number="12533">      raw_printf(out, &quot;,&apos;%s&apos;,char(13))&quot;, zCR);</Line>
  <Line number="12534">    }</Line>
  <Line number="12535">    if( nNL ){</Line>
  <Line number="12536">      raw_printf(out, &quot;,&apos;%s&apos;,char(10))&quot;, zNL);</Line>
  <Line number="12537">    }</Line>
  <Line number="12538">  }</Line>
  <Line number="12539">  setTextMode(out, 1);</Line>
  <Line number="12540">}</Line>
  <Line number="12541"></Line>
  <Line number="12542">/*</Line>
  <Line number="12543">** Output the given string as a quoted according to C or TCL quoting rules.</Line>
  <Line number="12544">*/</Line>
  <Line number="12545">static void output_c_string(FILE *out, const char *z){</Line>
  <Line number="12546">  unsigned int c;</Line>
  <Line number="12547">  fputc(&apos;&quot;&apos;, out);</Line>
  <Line number="12548">  while( (c = <CheckRefs ids="2503">*</CheckRefs>(z++))!=<CheckRefs ids="2504">0</CheckRefs> ){</Line>
  <Line number="12549">    if( c==<CheckRefs ids="2505">&apos;\\&apos;</CheckRefs> ){</Line>
  <Line number="12550">      fputc(<CheckRefs ids="2506">c</CheckRefs>, out);</Line>
  <Line number="12551">      fputc(<CheckRefs ids="2507">c</CheckRefs>, out);</Line>
  <Line number="12552">    }else if( c==<CheckRefs ids="2508">&apos;&quot;&apos;</CheckRefs> ){</Line>
  <Line number="12553">      fputc(&apos;\\&apos;, out);</Line>
  <Line number="12554">      fputc(&apos;&quot;&apos;, out);</Line>
  <Line number="12555">    }else if( c==<CheckRefs ids="2509">&apos;\t&apos;</CheckRefs> ){</Line>
  <Line number="12556">      fputc(&apos;\\&apos;, out);</Line>
  <Line number="12557">      fputc(&apos;t&apos;, out);</Line>
  <Line number="12558">    }else if( c==<CheckRefs ids="2510">&apos;\n&apos;</CheckRefs> ){</Line>
  <Line number="12559">      fputc(&apos;\\&apos;, out);</Line>
  <Line number="12560">      fputc(&apos;n&apos;, out);</Line>
  <Line number="12561">    }else if( c==<CheckRefs ids="2511">&apos;\r&apos;</CheckRefs> ){</Line>
  <Line number="12562">      fputc(&apos;\\&apos;, out);</Line>
  <Line number="12563">      fputc(&apos;r&apos;, out);</Line>
  <Line number="12564">    }else if( !<CheckRefs ids="2512,2514,2515,2516,2513">isprint</CheckRefs>(c&amp;0xff) ){</Line>
  <Line number="12565">      raw_printf(out, &quot;\\%03o&quot;, c&amp;<CheckRefs ids="2517">0xff</CheckRefs>);</Line>
  <Line number="12566">    }else{</Line>
  <Line number="12567">      fputc(<CheckRefs ids="2518">c</CheckRefs>, out);</Line>
  <Line number="12568">    }</Line>
  <Line number="12569">  }</Line>
  <Line number="12570">  fputc(&apos;&quot;&apos;, out);</Line>
  <Line number="12571">}</Line>
  <Line number="12572"></Line>
  <Line number="12573">/*</Line>
  <Line number="12574">** Output the given string as a quoted according to JSON quoting rules.</Line>
  <Line number="12575">*/</Line>
  <Line number="12576">static void output_json_string(FILE *out, const char *z, int n){</Line>
  <Line number="12577">  unsigned int c;</Line>
  <Line number="12578">  if( n&lt;0 ) n = <CheckRefs ids="2519">(</CheckRefs>int)strlen(z);</Line>
  <Line number="12579">  fputc(&apos;&quot;&apos;, out);</Line>
  <Line number="12580">  while( n<CheckRefs ids="2520">--</CheckRefs> ){</Line>
  <Line number="12581">    c = <CheckRefs ids="2521">*</CheckRefs>(z++);</Line>
  <Line number="12582">    if( c==<CheckRefs ids="2522">&apos;\\&apos;</CheckRefs> || c==<CheckRefs ids="2523">&apos;&quot;&apos;</CheckRefs> ){</Line>
  <Line number="12583">      fputc(&apos;\\&apos;, out);</Line>
  <Line number="12584">      fputc(<CheckRefs ids="2524">c</CheckRefs>, out);</Line>
  <Line number="12585">    }else if( c&lt;=<CheckRefs ids="2525">0x1f</CheckRefs> ){</Line>
  <Line number="12586">      fputc(&apos;\\&apos;, out);</Line>
  <Line number="12587">      if( c==<CheckRefs ids="2526">&apos;\b&apos;</CheckRefs> ){</Line>
  <Line number="12588">        fputc(&apos;b&apos;, out);</Line>
  <Line number="12589">      }else if( c==<CheckRefs ids="2527">&apos;\f&apos;</CheckRefs> ){</Line>
  <Line number="12590">        fputc(&apos;f&apos;, out);</Line>
  <Line number="12591">      }else if( c==<CheckRefs ids="2528">&apos;\n&apos;</CheckRefs> ){</Line>
  <Line number="12592">        fputc(&apos;n&apos;, out);</Line>
  <Line number="12593">      }else if( c==<CheckRefs ids="2529">&apos;\r&apos;</CheckRefs> ){</Line>
  <Line number="12594">        fputc(&apos;r&apos;, out);</Line>
  <Line number="12595">      }else if( c==<CheckRefs ids="2530">&apos;\t&apos;</CheckRefs> ){</Line>
  <Line number="12596">        fputc(&apos;t&apos;, out);</Line>
  <Line number="12597">      }else{</Line>
  <Line number="12598">         raw_printf(out, &quot;u%04x&quot;,c);</Line>
  <Line number="12599">      }</Line>
  <Line number="12600">    }else{</Line>
  <Line number="12601">      fputc(<CheckRefs ids="2531">c</CheckRefs>, out);</Line>
  <Line number="12602">    }</Line>
  <Line number="12603">  }</Line>
  <Line number="12604">  fputc(&apos;&quot;&apos;, out);</Line>
  <Line number="12605">}</Line>
  <Line number="12606"></Line>
  <Line number="12607">/*</Line>
  <Line number="12608">** Output the given string with characters that are special to</Line>
  <Line number="12609">** HTML escaped.</Line>
  <Line number="12610">*/</Line>
  <Line number="12611">static void output_html_string(FILE *out, const char *z){</Line>
  <Line number="12612">  int i;</Line>
  <Line number="12613">  if( z==0 ) z = &quot;&quot;;</Line>
  <Line number="12614">  while( *z ){</Line>
  <Line number="12615">    for(i=0;   <CheckRefs ids="2532">z</CheckRefs>[i]</Line>
  <Line number="12616">            &amp;&amp; <CheckRefs ids="2533">z</CheckRefs>[i]!=&apos;&lt;&apos;</Line>
  <Line number="12617">            &amp;&amp; <CheckRefs ids="2534">z</CheckRefs>[i]!=&apos;&amp;&apos;</Line>
  <Line number="12618">            &amp;&amp; <CheckRefs ids="2535">z</CheckRefs>[i]!=&apos;&gt;&apos;</Line>
  <Line number="12619">            &amp;&amp; <CheckRefs ids="2536">z</CheckRefs>[i]!=&apos;\&quot;&apos;</Line>
  <Line number="12620">            &amp;&amp; <CheckRefs ids="2537">z</CheckRefs>[i]!=&apos;\&apos;&apos;;</Line>
  <Line number="12621">        i<CheckRefs ids="2538">++</CheckRefs>){}</Line>
  <Line number="12622">    if( i&gt;0 ){</Line>
  <Line number="12623">      utf8_printf(out,&quot;%.*s&quot;,i,z);</Line>
  <Line number="12624">    }</Line>
  <Line number="12625">    if( <CheckRefs ids="2539">z</CheckRefs>[i]==&apos;&lt;&apos; ){</Line>
  <Line number="12626">      raw_printf(out,&quot;&amp;lt;&quot;);</Line>
  <Line number="12627">    }else if( <CheckRefs ids="2540">z</CheckRefs>[i]==&apos;&amp;&apos; ){</Line>
  <Line number="12628">      raw_printf(out,&quot;&amp;amp;&quot;);</Line>
  <Line number="12629">    }else if( <CheckRefs ids="2541">z</CheckRefs>[i]==&apos;&gt;&apos; ){</Line>
  <Line number="12630">      raw_printf(out,&quot;&amp;gt;&quot;);</Line>
  <Line number="12631">    }else if( <CheckRefs ids="2542">z</CheckRefs>[i]==&apos;\&quot;&apos; ){</Line>
  <Line number="12632">      raw_printf(out,&quot;&amp;quot;&quot;);</Line>
  <Line number="12633">    }else if( <CheckRefs ids="2543">z</CheckRefs>[i]==&apos;\&apos;&apos; ){</Line>
  <Line number="12634">      raw_printf(out,&quot;&amp;#39;&quot;);</Line>
  <Line number="12635">    }else{</Line>
  <Line number="12636">      break;</Line>
  <Line number="12637">    }</Line>
  <Line number="12638">    z += i <CheckRefs ids="2544">+</CheckRefs> 1;</Line>
  <Line number="12639">  }</Line>
  <Line number="12640">}</Line>
  <Line number="12641"></Line>
  <Line number="12642">/*</Line>
  <Line number="12643">** If a field contains any character identified by a 1 in the following</Line>
  <Line number="12644">** array, then the string must be quoted for CSV.</Line>
  <Line number="12645">*/</Line>
  <Line number="12646">static const char needCsvQuote[] = {</Line>
  <Line number="12647">  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,</Line>
  <Line number="12648">  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,</Line>
  <Line number="12649">  1, 0, 1, 0, 0, 0, 0, 1,   0, 0, 0, 0, 0, 0, 0, 0,</Line>
  <Line number="12650">  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,</Line>
  <Line number="12651">  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,</Line>
  <Line number="12652">  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,</Line>
  <Line number="12653">  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,</Line>
  <Line number="12654">  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 1,</Line>
  <Line number="12655">  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,</Line>
  <Line number="12656">  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,</Line>
  <Line number="12657">  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,</Line>
  <Line number="12658">  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,</Line>
  <Line number="12659">  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,</Line>
  <Line number="12660">  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,</Line>
  <Line number="12661">  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,</Line>
  <Line number="12662">  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,</Line>
  <Line number="12663">};</Line>
  <Line number="12664"></Line>
  <Line number="12665">/*</Line>
  <Line number="12666">** Output a single term of CSV.  Actually, p-&gt;colSeparator is used for</Line>
  <Line number="12667">** the separator, which may or may not be a comma.  p-&gt;nullValue is</Line>
  <Line number="12668">** the null value.  Strings are quoted if necessary.  The separator</Line>
  <Line number="12669">** is only issued if bSep is true.</Line>
  <Line number="12670">*/</Line>
  <Line number="12671">static void output_csv(ShellState *p, const char *z, int bSep){</Line>
  <Line number="12672">  FILE *out = p-&gt;out;</Line>
  <Line number="12673">  if( z==0 ){</Line>
  <Line number="12674">    utf8_printf(out,&quot;%s&quot;,p-&gt;nullValue);</Line>
  <Line number="12675">  }else{</Line>
  <Line number="12676">    int i;</Line>
  <Line number="12677">    int nSep = strlen30(p-&gt;colSeparator);</Line>
  <Line number="12678">    for(i=0; z[i]; i<CheckRefs ids="2545">++</CheckRefs>){</Line>
  <Line number="12679">      if( <CheckRefs ids="2546">needCsvQuote</CheckRefs>[((unsigned char*)z)[i]<CheckRefs ids="2547">]</CheckRefs></Line>
  <Line number="12680">         || (<CheckRefs ids="2548">z</CheckRefs>[i]==<CheckRefs ids="2549">p</CheckRefs>-&gt;colSeparator[0<CheckRefs ids="2550">]</CheckRefs> &amp;&amp;</Line>
  <Line number="12681">             (nSep==1 || memcmp(z, p-&gt;colSeparator, <CheckRefs ids="2551">nSep</CheckRefs>)==0)) ){</Line>
  <Line number="12682">        i = 0;</Line>
  <Line number="12683">        break;</Line>
  <Line number="12684">      }</Line>
  <Line number="12685">    }</Line>
  <Line number="12686">    if( i==0 ){</Line>
  <Line number="12687">      char *zQuoted = sqlite3_mprintf(&quot;\&quot;%w\&quot;&quot;, z);</Line>
  <Line number="12688">      utf8_printf(out, &quot;%s&quot;, zQuoted);</Line>
  <Line number="12689">      sqlite3_free(zQuoted);</Line>
  <Line number="12690">    }else{</Line>
  <Line number="12691">      utf8_printf(out, &quot;%s&quot;, z);</Line>
  <Line number="12692">    }</Line>
  <Line number="12693">  }</Line>
  <Line number="12694">  if( bSep ){</Line>
  <Line number="12695">    utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;colSeparator);</Line>
  <Line number="12696">  }</Line>
  <Line number="12697">}</Line>
  <Line number="12698"></Line>
  <Line number="12699">/*</Line>
  <Line number="12700">** This routine runs when the user presses Ctrl-C</Line>
  <Line number="12701">*/</Line>
  <Line number="12702">static void interrupt_handler(int NotUsed){</Line>
  <Line number="12703">  UNUSED_PARAMETER(NotUsed);</Line>
  <Line number="12704">  seenInterrupt<CheckRefs ids="2552">++</CheckRefs>;</Line>
  <Line number="12705">  if( seenInterrupt&gt;2 ) exit(1);</Line>
  <Line number="12706">  if( globalDb ) sqlite3_interrupt(globalDb);</Line>
  <Line number="12707">}</Line>
  <Line number="12708"></Line>
  <Line number="12709">#if (defined(_WIN32) || defined(WIN32)) &amp;&amp; !defined(_WIN32_WCE)</Line>
  <Line number="12710">/*</Line>
  <Line number="12711">** This routine runs for console events (e.g. Ctrl-C) on Win32</Line>
  <Line number="12712">*/</Line>
  <Line number="12713">static BOOL WINAPI ConsoleCtrlHandler(</Line>
  <Line number="12714">  DWORD dwCtrlType /* One of the CTRL_*_EVENT constants */</Line>
  <Line number="12715">){</Line>
  <Line number="12716">  if( dwCtrlType==CTRL_C_EVENT ){</Line>
  <Line number="12717">    interrupt_handler(0);</Line>
  <Line number="12718">    return TRUE;</Line>
  <Line number="12719">  }</Line>
  <Line number="12720">  return FALSE;</Line>
  <Line number="12721">}</Line>
  <Line number="12722">#endif</Line>
  <Line number="12723"></Line>
  <Line number="12724">#ifndef SQLITE_OMIT_AUTHORIZATION</Line>
  <Line number="12725">/*</Line>
  <Line number="12726">** When the &quot;.auth ON&quot; is set, the following authorizer callback is</Line>
  <Line number="12727">** invoked.  It always returns SQLITE_OK.</Line>
  <Line number="12728">*/</Line>
  <Line number="12729">static int shellAuth(</Line>
  <Line number="12730">  void *pClientData,</Line>
  <Line number="12731">  int op,</Line>
  <Line number="12732">  const char *zA1,</Line>
  <Line number="12733">  const char *zA2,</Line>
  <Line number="12734">  const char *zA3,</Line>
  <Line number="12735">  const char *zA4</Line>
  <Line number="12736">){</Line>
  <Line number="12737">  ShellState *p = (ShellState*)pClientData;</Line>
  <Line number="12738">  static const char *azAction[] = { 0,</Line>
  <Line number="12739">     &quot;CREATE_INDEX&quot;,         &quot;CREATE_TABLE&quot;,         &quot;CREATE_TEMP_INDEX&quot;,</Line>
  <Line number="12740">     &quot;CREATE_TEMP_TABLE&quot;,    &quot;CREATE_TEMP_TRIGGER&quot;,  &quot;CREATE_TEMP_VIEW&quot;,</Line>
  <Line number="12741">     &quot;CREATE_TRIGGER&quot;,       &quot;CREATE_VIEW&quot;,          &quot;DELETE&quot;,</Line>
  <Line number="12742">     &quot;DROP_INDEX&quot;,           &quot;DROP_TABLE&quot;,           &quot;DROP_TEMP_INDEX&quot;,</Line>
  <Line number="12743">     &quot;DROP_TEMP_TABLE&quot;,      &quot;DROP_TEMP_TRIGGER&quot;,    &quot;DROP_TEMP_VIEW&quot;,</Line>
  <Line number="12744">     &quot;DROP_TRIGGER&quot;,         &quot;DROP_VIEW&quot;,            &quot;INSERT&quot;,</Line>
  <Line number="12745">     &quot;PRAGMA&quot;,               &quot;READ&quot;,                 &quot;SELECT&quot;,</Line>
  <Line number="12746">     &quot;TRANSACTION&quot;,          &quot;UPDATE&quot;,               &quot;ATTACH&quot;,</Line>
  <Line number="12747">     &quot;DETACH&quot;,               &quot;ALTER_TABLE&quot;,          &quot;REINDEX&quot;,</Line>
  <Line number="12748">     &quot;ANALYZE&quot;,              &quot;CREATE_VTABLE&quot;,        &quot;DROP_VTABLE&quot;,</Line>
  <Line number="12749">     &quot;FUNCTION&quot;,             &quot;SAVEPOINT&quot;,            &quot;RECURSIVE&quot;</Line>
  <Line number="12750">  };</Line>
  <Line number="12751">  int i;</Line>
  <Line number="12752">  const char *az[4];</Line>
  <Line number="12753">  az[0<CheckRefs ids="2553">]</CheckRefs> = zA1;</Line>
  <Line number="12754">  az[1<CheckRefs ids="2554">]</CheckRefs> = zA2;</Line>
  <Line number="12755">  az[2<CheckRefs ids="2555">]</CheckRefs> = zA3;</Line>
  <Line number="12756">  az[3<CheckRefs ids="2556">]</CheckRefs> = zA4;</Line>
  <Line number="12757">  utf8_printf(p-&gt;out, &quot;authorizer: %s&quot;, azAction[op<CheckRefs ids="2557">]</CheckRefs>);</Line>
  <Line number="12758">  for(i=0; i&lt;4; i<CheckRefs ids="2558">++</CheckRefs>){</Line>
  <Line number="12759">    raw_printf(p-&gt;out, &quot; &quot;);</Line>
  <Line number="12760">    if( az[i<CheckRefs ids="2559">]</CheckRefs> ){</Line>
  <Line number="12761">      output_c_string(p-&gt;out, az[i<CheckRefs ids="2560">]</CheckRefs>);</Line>
  <Line number="12762">    }else{</Line>
  <Line number="12763">      raw_printf(p-&gt;out, &quot;NULL&quot;);</Line>
  <Line number="12764">    }</Line>
  <Line number="12765">  }</Line>
  <Line number="12766">  raw_printf(p-&gt;out, &quot;\n&quot;);</Line>
  <Line number="12767">  return SQLITE_OK;</Line>
  <Line number="12768">}</Line>
  <Line number="12769">#endif</Line>
  <Line number="12770"></Line>
  <Line number="12771">/*</Line>
  <Line number="12772">** Print a schema statement.  Part of MODE_Semi and MODE_Pretty output.</Line>
  <Line number="12773">**</Line>
  <Line number="12774">** This routine converts some CREATE TABLE statements for shadow tables</Line>
  <Line number="12775">** in FTS3/4/5 into CREATE TABLE IF NOT EXISTS statements.</Line>
  <Line number="12776">*/</Line>
  <Line number="12777">static void printSchemaLine(FILE *out, const char *z, const char *zTail){</Line>
  <Line number="12778">  if( z==0 ) return;</Line>
  <Line number="12779">  if( zTail==0 ) return;</Line>
  <Line number="12780">  if( sqlite3_strglob(&quot;CREATE TABLE [&apos;\&quot;]*&quot;, z)==0 ){</Line>
  <Line number="12781">    utf8_printf(out, &quot;CREATE TABLE IF NOT EXISTS %s%s&quot;, z+13, zTail);</Line>
  <Line number="12782">  }else{</Line>
  <Line number="12783">    utf8_printf(out, &quot;%s%s&quot;, z, zTail);</Line>
  <Line number="12784">  }</Line>
  <Line number="12785">}</Line>
  <Line number="12786">static void printSchemaLineN(FILE *out, char *z, int n, const char *zTail){</Line>
  <Line number="12787">  char c = z[n];</Line>
  <Line number="12788">  z[n] = <CheckRefs ids="2561">0</CheckRefs>;</Line>
  <Line number="12789">  printSchemaLine(out, z, zTail);</Line>
  <Line number="12790">  z[n] = c;</Line>
  <Line number="12791">}</Line>
  <Line number="12792"></Line>
  <Line number="12793">/*</Line>
  <Line number="12794">** Return true if string z[] has nothing but whitespace and comments to the</Line>
  <Line number="12795">** end of the first line.</Line>
  <Line number="12796">*/</Line>
  <Line number="12797">static int wsToEol(const char *z){</Line>
  <Line number="12798">  int i;</Line>
  <Line number="12799">  for(i=0; z[i]; i<CheckRefs ids="2562">++</CheckRefs>){</Line>
  <Line number="12800">    if( <CheckRefs ids="2563">z</CheckRefs>[i]==&apos;\n&apos; ) return 1;</Line>
  <Line number="12801">    if( <CheckRefs ids="2564,2565,2567,2568,2566">IsSpace</CheckRefs>(z[i]) ) continue;</Line>
  <Line number="12802">    if( <CheckRefs ids="2569">z</CheckRefs>[i]==&apos;-&apos; &amp;&amp; <CheckRefs ids="2570">z</CheckRefs>[i<CheckRefs ids="2571">+</CheckRefs>1]==&apos;-&apos; ) return 1;</Line>
  <Line number="12803">    return 0;</Line>
  <Line number="12804">  }</Line>
  <Line number="12805">  return 1;</Line>
  <Line number="12806">}</Line>
  <Line number="12807"></Line>
  <Line number="12808">/*</Line>
  <Line number="12809">** Add a new entry to the EXPLAIN QUERY PLAN data</Line>
  <Line number="12810">*/</Line>
  <Line number="12811">static void eqp_append(ShellState *p, int iEqpId, int p2, const char *zText){</Line>
  <Line number="12812">  EQPGraphRow *pNew;</Line>
  <Line number="12813">  int nText = strlen30(zText);</Line>
  <Line number="12814">  if( p-&gt;autoEQPtest ){</Line>
  <Line number="12815">    utf8_printf(p-&gt;out, &quot;%d,%d,%s\n&quot;, iEqpId, p2, zText);</Line>
  <Line number="12816">  }</Line>
  <Line number="12817">  pNew = sqlite3_malloc64( sizeof(*pNew) <CheckRefs ids="2572,2573">+</CheckRefs> <CheckRefs ids="2574">nText</CheckRefs> );</Line>
  <Line number="12818">  if( pNew==0 ) shell_out_of_memory();</Line>
  <Line number="12819">  pNew-&gt;iEqpId = iEqpId;</Line>
  <Line number="12820">  pNew-&gt;iParentId = p2;</Line>
  <Line number="12821">  memcpy(pNew-&gt;zText, zText, nText<CheckRefs ids="2575,2576">+</CheckRefs>1);</Line>
  <Line number="12822">  pNew-&gt;pNext = 0;</Line>
  <Line number="12823">  if( p-&gt;sGraph.pLast ){</Line>
  <Line number="12824">    p-&gt;sGraph.pLast-&gt;pNext = pNew;</Line>
  <Line number="12825">  }else{</Line>
  <Line number="12826">    p-&gt;sGraph.pRow = pNew;</Line>
  <Line number="12827">  }</Line>
  <Line number="12828">  p-&gt;sGraph.pLast = pNew;</Line>
  <Line number="12829">}</Line>
  <Line number="12830"></Line>
  <Line number="12831">/*</Line>
  <Line number="12832">** Free and reset the EXPLAIN QUERY PLAN data that has been collected</Line>
  <Line number="12833">** in p-&gt;sGraph.</Line>
  <Line number="12834">*/</Line>
  <Line number="12835">static void eqp_reset(ShellState *p){</Line>
  <Line number="12836">  EQPGraphRow *pRow, *pNext;</Line>
  <Line number="12837">  for(pRow = p-&gt;sGraph.pRow; pRow; pRow = pNext){</Line>
  <Line number="12838">    pNext = pRow-&gt;pNext;</Line>
  <Line number="12839">    sqlite3_free(pRow);</Line>
  <Line number="12840">  }</Line>
  <Line number="12841">  memset(&amp;p-&gt;sGraph, 0, sizeof(p-&gt;sGraph));</Line>
  <Line number="12842">}</Line>
  <Line number="12843"></Line>
  <Line number="12844">/* Return the next EXPLAIN QUERY PLAN line with iEqpId that occurs after</Line>
  <Line number="12845">** pOld, or return the first such line if pOld is NULL</Line>
  <Line number="12846">*/</Line>
  <Line number="12847">static EQPGraphRow *eqp_next_row(ShellState *p, int iEqpId, EQPGraphRow *pOld){</Line>
  <Line number="12848">  EQPGraphRow *pRow = pOld ? pOld-&gt;pNext : p-&gt;sGraph.pRow;</Line>
  <Line number="12849">  while( pRow &amp;&amp; pRow-&gt;iParentId!=iEqpId ) pRow = pRow-&gt;pNext;</Line>
  <Line number="12850">  return pRow;</Line>
  <Line number="12851">}</Line>
  <Line number="12852"></Line>
  <Line number="12853">/* Render a single level of the graph that has iEqpId as its parent.  Called</Line>
  <Line number="12854">** recursively to render sublevels.</Line>
  <Line number="12855">*/</Line>
  <Line number="12856">static void eqp_render_level(ShellState *p, int iEqpId){</Line>
  <Line number="12857">  EQPGraphRow *pRow, *pNext;</Line>
  <Line number="12858">  int n = strlen30(p-&gt;sGraph.zPrefix);</Line>
  <Line number="12859">  char *z;</Line>
  <Line number="12860">  for(pRow = eqp_next_row(p, iEqpId, 0); pRow; pRow = pNext){</Line>
  <Line number="12861">    pNext = eqp_next_row(p, iEqpId, pRow);</Line>
  <Line number="12862">    z = pRow-&gt;zText;</Line>
  <Line number="12863">    utf8_printf(p-&gt;out, &quot;%s%s%s\n&quot;, p-&gt;sGraph.zPrefix,</Line>
  <Line number="12864">                pNext ? &quot;|--&quot; : &quot;`--&quot;, z);</Line>
  <Line number="12865">    if( n&lt;<CheckRefs ids="2578">(</CheckRefs>int)sizeof(p-&gt;sGraph.zPrefix)<CheckRefs ids="2577">-</CheckRefs>7 ){</Line>
  <Line number="12866">      memcpy(&amp;p-&gt;sGraph.zPrefix[n<CheckRefs ids="2579">]</CheckRefs>, pNext ? &quot;|  &quot; : &quot;   &quot;, <CheckRefs ids="2580">4</CheckRefs>);</Line>
  <Line number="12867">      eqp_render_level(p, pRow-&gt;iEqpId);</Line>
  <Line number="12868">      p-&gt;sGraph.zPrefix[n<CheckRefs ids="2581">]</CheckRefs> = <CheckRefs ids="2582">0</CheckRefs>;</Line>
  <Line number="12869">    }</Line>
  <Line number="12870">  }</Line>
  <Line number="12871">}</Line>
  <Line number="12872"></Line>
  <Line number="12873">/*</Line>
  <Line number="12874">** Display and reset the EXPLAIN QUERY PLAN data</Line>
  <Line number="12875">*/</Line>
  <Line number="12876">static void eqp_render(ShellState *p){</Line>
  <Line number="12877">  EQPGraphRow *pRow = p-&gt;sGraph.pRow;</Line>
  <Line number="12878">  if( pRow ){</Line>
  <Line number="12879">    if( <CheckRefs ids="2583">pRow</CheckRefs>-&gt;zText[0<CheckRefs ids="2584">]</CheckRefs>==&apos;-&apos; ){</Line>
  <Line number="12880">      if( pRow-&gt;pNext==0 ){</Line>
  <Line number="12881">        eqp_reset(p);</Line>
  <Line number="12882">        return;</Line>
  <Line number="12883">      }</Line>
  <Line number="12884">      utf8_printf(p-&gt;out, &quot;%s\n&quot;, pRow-&gt;zText+3);</Line>
  <Line number="12885">      p-&gt;sGraph.pRow = pRow-&gt;pNext;</Line>
  <Line number="12886">      sqlite3_free(pRow);</Line>
  <Line number="12887">    }else{</Line>
  <Line number="12888">      utf8_printf(p-&gt;out, &quot;QUERY PLAN\n&quot;);</Line>
  <Line number="12889">    }</Line>
  <Line number="12890">    p-&gt;sGraph.zPrefix[0<CheckRefs ids="2585">]</CheckRefs> = <CheckRefs ids="2586">0</CheckRefs>;</Line>
  <Line number="12891">    eqp_render_level(p, 0);</Line>
  <Line number="12892">    eqp_reset(p);</Line>
  <Line number="12893">  }</Line>
  <Line number="12894">}</Line>
  <Line number="12895"></Line>
  <Line number="12896">#ifndef SQLITE_OMIT_PROGRESS_CALLBACK</Line>
  <Line number="12897">/*</Line>
  <Line number="12898">** Progress handler callback.</Line>
  <Line number="12899">*/</Line>
  <Line number="12900">static int progress_handler(void *pClientData) {</Line>
  <Line number="12901">  ShellState *p = (ShellState*)pClientData;</Line>
  <Line number="12902">  p-&gt;nProgress<CheckRefs ids="2587">++</CheckRefs>;</Line>
  <Line number="12903">  if( p-&gt;nProgress&gt;=p-&gt;mxProgress &amp;&amp; p-&gt;mxProgress&gt;<CheckRefs ids="2588">0</CheckRefs> ){</Line>
  <Line number="12904">    raw_printf(p-&gt;out, &quot;Progress limit reached (%u)\n&quot;, p-&gt;nProgress);</Line>
  <Line number="12905">    if( p-&gt;flgProgress &amp; <CheckRefs ids="2589">SHELL_PROGRESS_RESET</CheckRefs> ) p-&gt;nProgress = <CheckRefs ids="2590">0</CheckRefs>;</Line>
  <Line number="12906">    if( p-&gt;flgProgress &amp; <CheckRefs ids="2591">SHELL_PROGRESS_ONCE</CheckRefs> ) p-&gt;mxProgress = <CheckRefs ids="2592">0</CheckRefs>;</Line>
  <Line number="12907">    return 1;</Line>
  <Line number="12908">  }</Line>
  <Line number="12909">  if( (p-&gt;flgProgress &amp; <CheckRefs ids="2593">SHELL_PROGRESS_QUIET</CheckRefs>)==<CheckRefs ids="2594">0</CheckRefs> ){</Line>
  <Line number="12910">    raw_printf(p-&gt;out, &quot;Progress %u\n&quot;, p-&gt;nProgress);</Line>
  <Line number="12911">  }</Line>
  <Line number="12912">  return 0;</Line>
  <Line number="12913">}</Line>
  <Line number="12914">#endif /* SQLITE_OMIT_PROGRESS_CALLBACK */</Line>
  <Line number="12915"></Line>
  <Line number="12916">/*</Line>
  <Line number="12917">** Print N dashes</Line>
  <Line number="12918">*/</Line>
  <Line number="12919">static void print_dashes(FILE *out, int N){</Line>
  <Line number="12920">  const char zDash[] = &quot;--------------------------------------------------&quot;;</Line>
  <Line number="12921">  const int nDash = sizeof(zDash) <CheckRefs ids="2595,2596">-</CheckRefs> <CheckRefs ids="2597">1</CheckRefs>;</Line>
  <Line number="12922">  while( N&gt;nDash ){</Line>
  <Line number="12923">    fputs(zDash, out);</Line>
  <Line number="12924">    N <CheckRefs ids="2598">-=</CheckRefs> nDash;</Line>
  <Line number="12925">  }</Line>
  <Line number="12926">  raw_printf(out, &quot;%.*s&quot;, N, zDash);</Line>
  <Line number="12927">}</Line>
  <Line number="12928"></Line>
  <Line number="12929">/*</Line>
  <Line number="12930">** Print a markdown or table-style row separator using ascii-art</Line>
  <Line number="12931">*/</Line>
  <Line number="12932">static void print_row_separator(</Line>
  <Line number="12933">  ShellState *p,</Line>
  <Line number="12934">  int nArg,</Line>
  <Line number="12935">  const char *zSep</Line>
  <Line number="12936">){</Line>
  <Line number="12937">  int i;</Line>
  <Line number="12938">  if( nArg&gt;0 ){</Line>
  <Line number="12939">    fputs(zSep, p-&gt;out);</Line>
  <Line number="12940">    print_dashes(p-&gt;out, p-&gt;actualWidth[0]<CheckRefs ids="2599">+</CheckRefs>2);</Line>
  <Line number="12941">    for(i=1; i&lt;nArg; i<CheckRefs ids="2600">++</CheckRefs>){</Line>
  <Line number="12942">      fputs(zSep, p-&gt;out);</Line>
  <Line number="12943">      print_dashes(p-&gt;out, p-&gt;actualWidth[i]<CheckRefs ids="2601">+</CheckRefs>2);</Line>
  <Line number="12944">    }</Line>
  <Line number="12945">    fputs(zSep, p-&gt;out);</Line>
  <Line number="12946">  }</Line>
  <Line number="12947">  fputs(&quot;\n&quot;, p-&gt;out);</Line>
  <Line number="12948">}</Line>
  <Line number="12949"></Line>
  <Line number="12950">/*</Line>
  <Line number="12951">** This is the callback routine that the shell</Line>
  <Line number="12952">** invokes for each row of a query result.</Line>
  <Line number="12953">*/</Line>
  <Line number="12954">static int shell_callback(</Line>
  <Line number="12955">  void *pArg,</Line>
  <Line number="12956">  int nArg,        /* Number of result columns */</Line>
  <Line number="12957">  char **azArg,    /* Text of each result column */</Line>
  <Line number="12958">  char **azCol,    /* Column names */</Line>
  <Line number="12959">  int *aiType      /* Column types.  Might be NULL */</Line>
  <Line number="12960">){</Line>
  <Line number="12961">  int i;</Line>
  <Line number="12962">  ShellState *p = (ShellState*)pArg;</Line>
  <Line number="12963"></Line>
  <Line number="12964">  if( azArg==0 ) return 0;</Line>
  <Line number="12965">  switch( p-&gt;cMode ){</Line>
  <Line number="12966">    case MODE_Line: {</Line>
  <Line number="12967">      int w = 5;</Line>
  <Line number="12968">      if( azArg==0 ) break;</Line>
  <Line number="12969">      for(i=0; i&lt;nArg; i<CheckRefs ids="2602">++</CheckRefs>){</Line>
  <Line number="12970">        int len = strlen30(azCol[i] ? azCol[i] : &quot;&quot;);</Line>
  <Line number="12971">        if( len&gt;w ) w = len;</Line>
  <Line number="12972">      }</Line>
  <Line number="12973">      if( p-&gt;cnt<CheckRefs ids="2603">++</CheckRefs>&gt;0 ) utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;rowSeparator);</Line>
  <Line number="12974">      for(i=0; i&lt;nArg; i<CheckRefs ids="2604">++</CheckRefs>){</Line>
  <Line number="12975">        utf8_printf(p-&gt;out,&quot;%*s = %s%s&quot;, w, azCol[i],</Line>
  <Line number="12976">                azArg[i] ? azArg[i] : p-&gt;nullValue, p-&gt;rowSeparator);</Line>
  <Line number="12977">      }</Line>
  <Line number="12978">      break;</Line>
  <Line number="12979">    }</Line>
  <Line number="12980">    case MODE_Explain: {</Line>
  <Line number="12981">      static const int aExplainWidth[] = {4, 13, 4, 4, 4, 13, 2, 13};</Line>
  <Line number="12982">      if( nArg&gt;<CheckRefs ids="2606,2605,2607">ArraySize</CheckRefs>(aExplainWidth) ){</Line>
  <Line number="12983">        nArg = <CheckRefs ids="2608,2610,2609">ArraySize</CheckRefs>(aExplainWidth);</Line>
  <Line number="12984">      }</Line>
  <Line number="12985">      if( p-&gt;cnt<CheckRefs ids="2611">++</CheckRefs>==0 ){</Line>
  <Line number="12986">        for(i=0; i&lt;nArg; i<CheckRefs ids="2612">++</CheckRefs>){</Line>
  <Line number="12987">          int w = aExplainWidth[i<CheckRefs ids="2613">]</CheckRefs>;</Line>
  <Line number="12988">          utf8_width_print(p-&gt;out, w, azCol[i]);</Line>
  <Line number="12989">          fputs(i==nArg<CheckRefs ids="2614">-</CheckRefs>1 ? &quot;\n&quot; : &quot;  &quot;, p-&gt;out);</Line>
  <Line number="12990">        }</Line>
  <Line number="12991">        for(i=0; i&lt;nArg; i<CheckRefs ids="2615">++</CheckRefs>){</Line>
  <Line number="12992">          int w = aExplainWidth[i<CheckRefs ids="2616">]</CheckRefs>;</Line>
  <Line number="12993">          print_dashes(p-&gt;out, w);</Line>
  <Line number="12994">          fputs(i==nArg<CheckRefs ids="2617">-</CheckRefs>1 ? &quot;\n&quot; : &quot;  &quot;, p-&gt;out);</Line>
  <Line number="12995">        }</Line>
  <Line number="12996">      }</Line>
  <Line number="12997">      if( azArg==0 ) break;</Line>
  <Line number="12998">      for(i=0; i&lt;nArg; i<CheckRefs ids="2618">++</CheckRefs>){</Line>
  <Line number="12999">        int w = aExplainWidth[i<CheckRefs ids="2619">]</CheckRefs>;</Line>
  <Line number="13000">        if( i==nArg<CheckRefs ids="2620">-</CheckRefs>1 ) w = 0;</Line>
  <Line number="13001">        if( azArg[i] &amp;&amp; strlenChar(azArg[i])&gt;w ){</Line>
  <Line number="13002">          w = strlenChar(azArg[i]);</Line>
  <Line number="13003">        }</Line>
  <Line number="13004">        if( i==1 &amp;&amp; p-&gt;aiIndent &amp;&amp; p-&gt;pStmt ){</Line>
  <Line number="13005">          if( p-&gt;iIndent&lt;p-&gt;nIndent ){</Line>
  <Line number="13006">            utf8_printf(p-&gt;out, &quot;%*.s&quot;, p-&gt;aiIndent[p-&gt;iIndent], &quot;&quot;);</Line>
  <Line number="13007">          }</Line>
  <Line number="13008">          p-&gt;iIndent<CheckRefs ids="2621">++</CheckRefs>;</Line>
  <Line number="13009">        }</Line>
  <Line number="13010">        utf8_width_print(p-&gt;out, w, azArg[i] ? azArg[i] : p-&gt;nullValue);</Line>
  <Line number="13011">        fputs(i==nArg<CheckRefs ids="2622">-</CheckRefs>1 ? &quot;\n&quot; : &quot;  &quot;, p-&gt;out);</Line>
  <Line number="13012">      }</Line>
  <Line number="13013">      break;</Line>
  <Line number="13014">    }</Line>
  <Line number="13015">    case MODE_Semi: {   /* .schema and .fullschema output */</Line>
  <Line number="13016">      printSchemaLine(p-&gt;out, azArg[0], &quot;;\n&quot;);</Line>
  <Line number="13017">      break;</Line>
  <Line number="13018">    }</Line>
  <Line number="13019">    case MODE_Pretty: {  /* .schema and .fullschema with --indent */</Line>
  <Line number="13020">      char *z;</Line>
  <Line number="13021">      int j;</Line>
  <Line number="13022">      int nParen = 0;</Line>
  <Line number="13023">      char cEnd = <CheckRefs ids="2623">0</CheckRefs>;</Line>
  <Line number="13024">      char c;</Line>
  <Line number="13025">      int nLine = 0;</Line>
  <Line number="13026">      <CheckRefs ids="2624">assert</CheckRefs>( nArg==1 );</Line>
  <Line number="13027">      if( azArg[0]==0 ) break;</Line>
  <Line number="13028">      if( sqlite3_strlike(&quot;CREATE VIEW%&quot;, azArg[0], <CheckRefs ids="2625">0</CheckRefs>)==0</Line>
  <Line number="13029">       || sqlite3_strlike(&quot;CREATE TRIG%&quot;, azArg[0], <CheckRefs ids="2626">0</CheckRefs>)==0</Line>
  <Line number="13030">      ){</Line>
  <Line number="13031">        utf8_printf(p-&gt;out, &quot;%s;\n&quot;, azArg[0]);</Line>
  <Line number="13032">        break;</Line>
  <Line number="13033">      }</Line>
  <Line number="13034">      z = sqlite3_mprintf(&quot;%s&quot;, azArg[0]);</Line>
  <Line number="13035">      j = 0;</Line>
  <Line number="13036">      for(i=0; <CheckRefs ids="2627,2631,2630,2628,2629">IsSpace</CheckRefs>(z[i]); i<CheckRefs ids="2632">++</CheckRefs>){}</Line>
  <Line number="13037">      for(; <CheckRefs ids="2633">(</CheckRefs>c = z[i])!=0; i<CheckRefs ids="2634">++</CheckRefs>){</Line>
  <Line number="13038">        if( <CheckRefs ids="2635,2636,2638,2639,2637">IsSpace</CheckRefs>(c) ){</Line>
  <Line number="13039">          if( <CheckRefs ids="2640">z</CheckRefs>[j<CheckRefs ids="2641">-</CheckRefs>1]==&apos;\r&apos; ) z[j<CheckRefs ids="2642">-</CheckRefs>1] = <CheckRefs ids="2643">&apos;\n&apos;</CheckRefs>;</Line>
  <Line number="13040">          if( <CheckRefs ids="2644,2645,2648,2649,2646,2647">IsSpace</CheckRefs>(z[j-1]) || <CheckRefs ids="2650">z</CheckRefs>[j<CheckRefs ids="2651">-</CheckRefs>1]==&apos;(&apos; ) continue;</Line>
  <Line number="13041">        }else if( (<CheckRefs ids="2652">c</CheckRefs>==&apos;(&apos; || <CheckRefs ids="2653">c</CheckRefs>==&apos;)&apos;) &amp;&amp; j&gt;0 &amp;&amp; <CheckRefs ids="2654,2655,2659,2658,2657,2656">IsSpace</CheckRefs>(z[j-1]) ){</Line>
  <Line number="13042">          j<CheckRefs ids="2660">--</CheckRefs>;</Line>
  <Line number="13043">        }</Line>
  <Line number="13044">        z[j<CheckRefs ids="2661">++</CheckRefs>] = c;</Line>
  <Line number="13045">      }</Line>
  <Line number="13046">      while( j&gt;0 &amp;&amp; <CheckRefs ids="2662,2663,2666,2667,2664,2665">IsSpace</CheckRefs>(z[j-1]) ){ j<CheckRefs ids="2668">--</CheckRefs>; }</Line>
  <Line number="13047">      z[j] = <CheckRefs ids="2669">0</CheckRefs>;</Line>
  <Line number="13048">      if( strlen30(z)&gt;=79 ){</Line>
  <Line number="13049">        for(i=j=0; <CheckRefs ids="2670">(</CheckRefs>c = z[i])!=0; i<CheckRefs ids="2671">++</CheckRefs>){ /* Copy from z[i] back to z[j] */</Line>
  <Line number="13050">          if( <CheckRefs ids="2672">c</CheckRefs>==<CheckRefs ids="2673">cEnd</CheckRefs> ){</Line>
  <Line number="13051">            cEnd = <CheckRefs ids="2674">0</CheckRefs>;</Line>
  <Line number="13052">          }else if( <CheckRefs ids="2675">c</CheckRefs>==&apos;&quot;&apos; || <CheckRefs ids="2676">c</CheckRefs>==&apos;\&apos;&apos; || <CheckRefs ids="2677">c</CheckRefs>==&apos;`&apos; ){</Line>
  <Line number="13053">            cEnd = c;</Line>
  <Line number="13054">          }else if( <CheckRefs ids="2678">c</CheckRefs>==&apos;[&apos; ){</Line>
  <Line number="13055">            cEnd = <CheckRefs ids="2679">&apos;]&apos;</CheckRefs>;</Line>
  <Line number="13056">          }else if( <CheckRefs ids="2680">c</CheckRefs>==&apos;-&apos; &amp;&amp; <CheckRefs ids="2681">z</CheckRefs>[i<CheckRefs ids="2682">+</CheckRefs>1]==&apos;-&apos; ){</Line>
  <Line number="13057">            cEnd = <CheckRefs ids="2683">&apos;\n&apos;</CheckRefs>;</Line>
  <Line number="13058">          }else if( <CheckRefs ids="2684">c</CheckRefs>==&apos;(&apos; ){</Line>
  <Line number="13059">            nParen<CheckRefs ids="2685">++</CheckRefs>;</Line>
  <Line number="13060">          }else if( <CheckRefs ids="2686">c</CheckRefs>==&apos;)&apos; ){</Line>
  <Line number="13061">            nParen<CheckRefs ids="2687">--</CheckRefs>;</Line>
  <Line number="13062">            if( nLine&gt;0 &amp;&amp; nParen==0 &amp;&amp; j&gt;0 ){</Line>
  <Line number="13063">              printSchemaLineN(p-&gt;out, z, j, &quot;\n&quot;);</Line>
  <Line number="13064">              j = 0;</Line>
  <Line number="13065">            }</Line>
  <Line number="13066">          }</Line>
  <Line number="13067">          z[j<CheckRefs ids="2688">++</CheckRefs>] = c;</Line>
  <Line number="13068">          if( nParen==1 &amp;&amp; <CheckRefs ids="2689">cEnd</CheckRefs>==0</Line>
  <Line number="13069">           &amp;&amp; (<CheckRefs ids="2690">c</CheckRefs>==&apos;(&apos; || <CheckRefs ids="2691">c</CheckRefs>==&apos;\n&apos; || (<CheckRefs ids="2692">c</CheckRefs>==&apos;,&apos; &amp;&amp; !wsToEol(z+i+1)))</Line>
  <Line number="13070">          ){</Line>
  <Line number="13071">            if( <CheckRefs ids="2693">c</CheckRefs>==&apos;\n&apos; ) j<CheckRefs ids="2694">--</CheckRefs>;</Line>
  <Line number="13072">            printSchemaLineN(p-&gt;out, z, j, &quot;\n  &quot;);</Line>
  <Line number="13073">            j = 0;</Line>
  <Line number="13074">            nLine<CheckRefs ids="2695">++</CheckRefs>;</Line>
  <Line number="13075">            while( <CheckRefs ids="2696,2697,2700,2701,2698,2699">IsSpace</CheckRefs>(z[i+1]) ){ i<CheckRefs ids="2702">++</CheckRefs>; }</Line>
  <Line number="13076">          }</Line>
  <Line number="13077">        }</Line>
  <Line number="13078">        z[j] = <CheckRefs ids="2703">0</CheckRefs>;</Line>
  <Line number="13079">      }</Line>
  <Line number="13080">      printSchemaLine(p-&gt;out, z, &quot;;\n&quot;);</Line>
  <Line number="13081">      sqlite3_free(z);</Line>
  <Line number="13082">      break;</Line>
  <Line number="13083">    }</Line>
  <Line number="13084">    case MODE_List: {</Line>
  <Line number="13085">      if( p-&gt;cnt<CheckRefs ids="2704">++</CheckRefs>==0 &amp;&amp; p-&gt;showHeader ){</Line>
  <Line number="13086">        for(i=0; i&lt;nArg; i<CheckRefs ids="2705">++</CheckRefs>){</Line>
  <Line number="13087">          utf8_printf(p-&gt;out,&quot;%s%s&quot;,azCol[i],</Line>
  <Line number="13088">                  i==nArg<CheckRefs ids="2706">-</CheckRefs>1 ? p-&gt;rowSeparator : p-&gt;colSeparator);</Line>
  <Line number="13089">        }</Line>
  <Line number="13090">      }</Line>
  <Line number="13091">      if( azArg==0 ) break;</Line>
  <Line number="13092">      for(i=0; i&lt;nArg; i<CheckRefs ids="2707">++</CheckRefs>){</Line>
  <Line number="13093">        char *z = azArg[i];</Line>
  <Line number="13094">        if( z==0 ) z = p-&gt;nullValue;</Line>
  <Line number="13095">        utf8_printf(p-&gt;out, &quot;%s&quot;, z);</Line>
  <Line number="13096">        if( i&lt;nArg<CheckRefs ids="2708">-</CheckRefs>1 ){</Line>
  <Line number="13097">          utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;colSeparator);</Line>
  <Line number="13098">        }else{</Line>
  <Line number="13099">          utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;rowSeparator);</Line>
  <Line number="13100">        }</Line>
  <Line number="13101">      }</Line>
  <Line number="13102">      break;</Line>
  <Line number="13103">    }</Line>
  <Line number="13104">    case MODE_Html: {</Line>
  <Line number="13105">      if( p-&gt;cnt<CheckRefs ids="2709">++</CheckRefs>==0 &amp;&amp; p-&gt;showHeader ){</Line>
  <Line number="13106">        raw_printf(p-&gt;out,&quot;&lt;TR&gt;&quot;);</Line>
  <Line number="13107">        for(i=0; i&lt;nArg; i<CheckRefs ids="2710">++</CheckRefs>){</Line>
  <Line number="13108">          raw_printf(p-&gt;out,&quot;&lt;TH&gt;&quot;);</Line>
  <Line number="13109">          output_html_string(p-&gt;out, azCol[i]);</Line>
  <Line number="13110">          raw_printf(p-&gt;out,&quot;&lt;/TH&gt;\n&quot;);</Line>
  <Line number="13111">        }</Line>
  <Line number="13112">        raw_printf(p-&gt;out,&quot;&lt;/TR&gt;\n&quot;);</Line>
  <Line number="13113">      }</Line>
  <Line number="13114">      if( azArg==0 ) break;</Line>
  <Line number="13115">      raw_printf(p-&gt;out,&quot;&lt;TR&gt;&quot;);</Line>
  <Line number="13116">      for(i=0; i&lt;nArg; i<CheckRefs ids="2711">++</CheckRefs>){</Line>
  <Line number="13117">        raw_printf(p-&gt;out,&quot;&lt;TD&gt;&quot;);</Line>
  <Line number="13118">        output_html_string(p-&gt;out, azArg[i] ? azArg[i] : p-&gt;nullValue);</Line>
  <Line number="13119">        raw_printf(p-&gt;out,&quot;&lt;/TD&gt;\n&quot;);</Line>
  <Line number="13120">      }</Line>
  <Line number="13121">      raw_printf(p-&gt;out,&quot;&lt;/TR&gt;\n&quot;);</Line>
  <Line number="13122">      break;</Line>
  <Line number="13123">    }</Line>
  <Line number="13124">    case MODE_Tcl: {</Line>
  <Line number="13125">      if( p-&gt;cnt<CheckRefs ids="2712">++</CheckRefs>==0 &amp;&amp; p-&gt;showHeader ){</Line>
  <Line number="13126">        for(i=0; i&lt;nArg; i<CheckRefs ids="2713">++</CheckRefs>){</Line>
  <Line number="13127">          output_c_string(p-&gt;out,azCol[i] ? azCol[i] : &quot;&quot;);</Line>
  <Line number="13128">          if(i&lt;nArg<CheckRefs ids="2714">-</CheckRefs>1) utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;colSeparator);</Line>
  <Line number="13129">        }</Line>
  <Line number="13130">        utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;rowSeparator);</Line>
  <Line number="13131">      }</Line>
  <Line number="13132">      if( azArg==0 ) break;</Line>
  <Line number="13133">      for(i=0; i&lt;nArg; i<CheckRefs ids="2715">++</CheckRefs>){</Line>
  <Line number="13134">        output_c_string(p-&gt;out, azArg[i] ? azArg[i] : p-&gt;nullValue);</Line>
  <Line number="13135">        if(i&lt;nArg<CheckRefs ids="2716">-</CheckRefs>1) utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;colSeparator);</Line>
  <Line number="13136">      }</Line>
  <Line number="13137">      utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;rowSeparator);</Line>
  <Line number="13138">      break;</Line>
  <Line number="13139">    }</Line>
  <Line number="13140">    case MODE_Csv: {</Line>
  <Line number="13141">      setBinaryMode(p-&gt;out, 1);</Line>
  <Line number="13142">      if( p-&gt;cnt<CheckRefs ids="2717">++</CheckRefs>==0 &amp;&amp; p-&gt;showHeader ){</Line>
  <Line number="13143">        for(i=0; i&lt;nArg; i<CheckRefs ids="2718">++</CheckRefs>){</Line>
  <Line number="13144">          output_csv(p, azCol[i] ? azCol[i] : &quot;&quot;, i&lt;nArg<CheckRefs ids="2719">-</CheckRefs>1);</Line>
  <Line number="13145">        }</Line>
  <Line number="13146">        utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;rowSeparator);</Line>
  <Line number="13147">      }</Line>
  <Line number="13148">      if( nArg&gt;0 ){</Line>
  <Line number="13149">        for(i=0; i&lt;nArg; i<CheckRefs ids="2720">++</CheckRefs>){</Line>
  <Line number="13150">          output_csv(p, azArg[i], i&lt;nArg<CheckRefs ids="2721">-</CheckRefs>1);</Line>
  <Line number="13151">        }</Line>
  <Line number="13152">        utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;rowSeparator);</Line>
  <Line number="13153">      }</Line>
  <Line number="13154">      setTextMode(p-&gt;out, 1);</Line>
  <Line number="13155">      break;</Line>
  <Line number="13156">    }</Line>
  <Line number="13157">    case MODE_Insert: {</Line>
  <Line number="13158">      if( azArg==0 ) break;</Line>
  <Line number="13159">      utf8_printf(p-&gt;out,&quot;INSERT INTO %s&quot;,p-&gt;zDestTable);</Line>
  <Line number="13160">      if( p-&gt;showHeader ){</Line>
  <Line number="13161">        raw_printf(p-&gt;out,&quot;(&quot;);</Line>
  <Line number="13162">        for(i=0; i&lt;nArg; i<CheckRefs ids="2722">++</CheckRefs>){</Line>
  <Line number="13163">          if( i&gt;0 ) raw_printf(p-&gt;out, &quot;,&quot;);</Line>
  <Line number="13164">          if( quoteChar(azCol[i]) ){</Line>
  <Line number="13165">            char *z = sqlite3_mprintf(&quot;\&quot;%w\&quot;&quot;, azCol[i]);</Line>
  <Line number="13166">            utf8_printf(p-&gt;out, &quot;%s&quot;, z);</Line>
  <Line number="13167">            sqlite3_free(z);</Line>
  <Line number="13168">          }else{</Line>
  <Line number="13169">            raw_printf(p-&gt;out, &quot;%s&quot;, azCol[i]);</Line>
  <Line number="13170">          }</Line>
  <Line number="13171">        }</Line>
  <Line number="13172">        raw_printf(p-&gt;out,&quot;)&quot;);</Line>
  <Line number="13173">      }</Line>
  <Line number="13174">      p-&gt;cnt<CheckRefs ids="2723">++</CheckRefs>;</Line>
  <Line number="13175">      for(i=0; i&lt;nArg; i<CheckRefs ids="2724">++</CheckRefs>){</Line>
  <Line number="13176">        raw_printf(p-&gt;out, i&gt;0 ? &quot;,&quot; : &quot; VALUES(&quot;);</Line>
  <Line number="13177">        if( (azArg[i]==0) || (aiType &amp;&amp; aiType[i]==SQLITE_NULL) ){</Line>
  <Line number="13178">          utf8_printf(p-&gt;out,&quot;NULL&quot;);</Line>
  <Line number="13179">        }else if( aiType &amp;&amp; aiType[i]==SQLITE_TEXT ){</Line>
  <Line number="13180">          if( <CheckRefs ids="2725,2726">ShellHasFlag</CheckRefs>(p, SHFLG_Newlines) ){</Line>
  <Line number="13181">            output_quoted_string(p-&gt;out, azArg[i]);</Line>
  <Line number="13182">          }else{</Line>
  <Line number="13183">            output_quoted_escaped_string(p-&gt;out, azArg[i]);</Line>
  <Line number="13184">          }</Line>
  <Line number="13185">        }else if( aiType &amp;&amp; aiType[i]==SQLITE_INTEGER ){</Line>
  <Line number="13186">          utf8_printf(p-&gt;out,&quot;%s&quot;, azArg[i]);</Line>
  <Line number="13187">        }else if( aiType &amp;&amp; aiType[i]==SQLITE_FLOAT ){</Line>
  <Line number="13188">          char z[50];</Line>
  <Line number="13189">          double r = sqlite3_column_double(p-&gt;pStmt, i);</Line>
  <Line number="13190">          sqlite3_uint64 ur;</Line>
  <Line number="13191">          memcpy(&amp;ur,&amp;r,sizeof(r));</Line>
  <Line number="13192">          if( ur==<CheckRefs ids="2727">0x7ff0000000000000LL</CheckRefs> ){</Line>
  <Line number="13193">            raw_printf(p-&gt;out, &quot;1e999&quot;);</Line>
  <Line number="13194">          }else if( ur==0xfff0000000000000LL ){</Line>
  <Line number="13195">            raw_printf(p-&gt;out, &quot;-1e999&quot;);</Line>
  <Line number="13196">          }else{</Line>
  <Line number="13197">            sqlite3_snprintf(50,z,&quot;%!.20g&quot;, r);</Line>
  <Line number="13198">            raw_printf(p-&gt;out, &quot;%s&quot;, z);</Line>
  <Line number="13199">          }</Line>
  <Line number="13200">        }else if( aiType &amp;&amp; aiType[i]==SQLITE_BLOB &amp;&amp; p-&gt;pStmt ){</Line>
  <Line number="13201">          const void *pBlob = sqlite3_column_blob(p-&gt;pStmt, i);</Line>
  <Line number="13202">          int nBlob = sqlite3_column_bytes(p-&gt;pStmt, i);</Line>
  <Line number="13203">          output_hex_blob(p-&gt;out, pBlob, nBlob);</Line>
  <Line number="13204">        }else if( isNumber(azArg[i], 0) ){</Line>
  <Line number="13205">          utf8_printf(p-&gt;out,&quot;%s&quot;, azArg[i]);</Line>
  <Line number="13206">        }else if( <CheckRefs ids="2728,2729">ShellHasFlag</CheckRefs>(p, SHFLG_Newlines) ){</Line>
  <Line number="13207">          output_quoted_string(p-&gt;out, azArg[i]);</Line>
  <Line number="13208">        }else{</Line>
  <Line number="13209">          output_quoted_escaped_string(p-&gt;out, azArg[i]);</Line>
  <Line number="13210">        }</Line>
  <Line number="13211">      }</Line>
  <Line number="13212">      raw_printf(p-&gt;out,&quot;);\n&quot;);</Line>
  <Line number="13213">      break;</Line>
  <Line number="13214">    }</Line>
  <Line number="13215">    case MODE_Json: {</Line>
  <Line number="13216">      if( azArg==0 ) break;</Line>
  <Line number="13217">      if( p-&gt;cnt==0 ){</Line>
  <Line number="13218">        fputs(&quot;[{&quot;, p-&gt;out);</Line>
  <Line number="13219">      }else{</Line>
  <Line number="13220">        fputs(&quot;,\n{&quot;, p-&gt;out);</Line>
  <Line number="13221">      }</Line>
  <Line number="13222">      p-&gt;cnt<CheckRefs ids="2730">++</CheckRefs>;</Line>
  <Line number="13223">      for(i=0; i&lt;nArg; i<CheckRefs ids="2731">++</CheckRefs>){</Line>
  <Line number="13224">        output_json_string(p-&gt;out, azCol[i], <CheckRefs ids="2732">-</CheckRefs>1);</Line>
  <Line number="13225">        putc(&apos;:&apos;, p-&gt;out);</Line>
  <Line number="13226">        if( (azArg[i]==0) || (aiType &amp;&amp; aiType[i]==SQLITE_NULL) ){</Line>
  <Line number="13227">          fputs(&quot;null&quot;,p-&gt;out);</Line>
  <Line number="13228">        }else if( aiType &amp;&amp; aiType[i]==SQLITE_FLOAT ){</Line>
  <Line number="13229">          char z[50];</Line>
  <Line number="13230">          double r = sqlite3_column_double(p-&gt;pStmt, i);</Line>
  <Line number="13231">          sqlite3_uint64 ur;</Line>
  <Line number="13232">          memcpy(&amp;ur,&amp;r,sizeof(r));</Line>
  <Line number="13233">          if( ur==<CheckRefs ids="2733">0x7ff0000000000000LL</CheckRefs> ){</Line>
  <Line number="13234">            raw_printf(p-&gt;out, &quot;1e999&quot;);</Line>
  <Line number="13235">          }else if( ur==0xfff0000000000000LL ){</Line>
  <Line number="13236">            raw_printf(p-&gt;out, &quot;-1e999&quot;);</Line>
  <Line number="13237">          }else{</Line>
  <Line number="13238">            sqlite3_snprintf(50,z,&quot;%!.20g&quot;, r);</Line>
  <Line number="13239">            raw_printf(p-&gt;out, &quot;%s&quot;, z);</Line>
  <Line number="13240">          }</Line>
  <Line number="13241">        }else if( aiType &amp;&amp; aiType[i]==SQLITE_BLOB &amp;&amp; p-&gt;pStmt ){</Line>
  <Line number="13242">          const void *pBlob = sqlite3_column_blob(p-&gt;pStmt, i);</Line>
  <Line number="13243">          int nBlob = sqlite3_column_bytes(p-&gt;pStmt, i);</Line>
  <Line number="13244">          output_json_string(p-&gt;out, pBlob, nBlob);</Line>
  <Line number="13245">        }else if( aiType &amp;&amp; aiType[i]==SQLITE_TEXT ){</Line>
  <Line number="13246">          output_json_string(p-&gt;out, azArg[i], <CheckRefs ids="2734">-</CheckRefs>1);</Line>
  <Line number="13247">        }else{</Line>
  <Line number="13248">          utf8_printf(p-&gt;out,&quot;%s&quot;, azArg[i]);</Line>
  <Line number="13249">        }</Line>
  <Line number="13250">        if( i&lt;nArg<CheckRefs ids="2735">-</CheckRefs>1 ){</Line>
  <Line number="13251">          putc(&apos;,&apos;, p-&gt;out);</Line>
  <Line number="13252">        }</Line>
  <Line number="13253">      }</Line>
  <Line number="13254">      putc(&apos;}&apos;, p-&gt;out);</Line>
  <Line number="13255">      break;</Line>
  <Line number="13256">    }</Line>
  <Line number="13257">    case MODE_Quote: {</Line>
  <Line number="13258">      if( azArg==0 ) break;</Line>
  <Line number="13259">      if( p-&gt;cnt==0 &amp;&amp; p-&gt;showHeader ){</Line>
  <Line number="13260">        for(i=0; i&lt;nArg; i<CheckRefs ids="2736">++</CheckRefs>){</Line>
  <Line number="13261">          if( i&gt;0 ) fputs(p-&gt;colSeparator, p-&gt;out);</Line>
  <Line number="13262">          output_quoted_string(p-&gt;out, azCol[i]);</Line>
  <Line number="13263">        }</Line>
  <Line number="13264">        fputs(p-&gt;rowSeparator, p-&gt;out);</Line>
  <Line number="13265">      }</Line>
  <Line number="13266">      p-&gt;cnt<CheckRefs ids="2737">++</CheckRefs>;</Line>
  <Line number="13267">      for(i=0; i&lt;nArg; i<CheckRefs ids="2738">++</CheckRefs>){</Line>
  <Line number="13268">        if( i&gt;0 ) fputs(p-&gt;colSeparator, p-&gt;out);</Line>
  <Line number="13269">        if( (azArg[i]==0) || (aiType &amp;&amp; aiType[i]==SQLITE_NULL) ){</Line>
  <Line number="13270">          utf8_printf(p-&gt;out,&quot;NULL&quot;);</Line>
  <Line number="13271">        }else if( aiType &amp;&amp; aiType[i]==SQLITE_TEXT ){</Line>
  <Line number="13272">          output_quoted_string(p-&gt;out, azArg[i]);</Line>
  <Line number="13273">        }else if( aiType &amp;&amp; aiType[i]==SQLITE_INTEGER ){</Line>
  <Line number="13274">          utf8_printf(p-&gt;out,&quot;%s&quot;, azArg[i]);</Line>
  <Line number="13275">        }else if( aiType &amp;&amp; aiType[i]==SQLITE_FLOAT ){</Line>
  <Line number="13276">          char z[50];</Line>
  <Line number="13277">          double r = sqlite3_column_double(p-&gt;pStmt, i);</Line>
  <Line number="13278">          sqlite3_snprintf(50,z,&quot;%!.20g&quot;, r);</Line>
  <Line number="13279">          raw_printf(p-&gt;out, &quot;%s&quot;, z);</Line>
  <Line number="13280">        }else if( aiType &amp;&amp; aiType[i]==SQLITE_BLOB &amp;&amp; p-&gt;pStmt ){</Line>
  <Line number="13281">          const void *pBlob = sqlite3_column_blob(p-&gt;pStmt, i);</Line>
  <Line number="13282">          int nBlob = sqlite3_column_bytes(p-&gt;pStmt, i);</Line>
  <Line number="13283">          output_hex_blob(p-&gt;out, pBlob, nBlob);</Line>
  <Line number="13284">        }else if( isNumber(azArg[i], 0) ){</Line>
  <Line number="13285">          utf8_printf(p-&gt;out,&quot;%s&quot;, azArg[i]);</Line>
  <Line number="13286">        }else{</Line>
  <Line number="13287">          output_quoted_string(p-&gt;out, azArg[i]);</Line>
  <Line number="13288">        }</Line>
  <Line number="13289">      }</Line>
  <Line number="13290">      fputs(p-&gt;rowSeparator, p-&gt;out);</Line>
  <Line number="13291">      break;</Line>
  <Line number="13292">    }</Line>
  <Line number="13293">    case MODE_Ascii: {</Line>
  <Line number="13294">      if( p-&gt;cnt<CheckRefs ids="2739">++</CheckRefs>==0 &amp;&amp; p-&gt;showHeader ){</Line>
  <Line number="13295">        for(i=0; i&lt;nArg; i<CheckRefs ids="2740">++</CheckRefs>){</Line>
  <Line number="13296">          if( i&gt;0 ) utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;colSeparator);</Line>
  <Line number="13297">          utf8_printf(p-&gt;out,&quot;%s&quot;,azCol[i] ? azCol[i] : &quot;&quot;);</Line>
  <Line number="13298">        }</Line>
  <Line number="13299">        utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;rowSeparator);</Line>
  <Line number="13300">      }</Line>
  <Line number="13301">      if( azArg==0 ) break;</Line>
  <Line number="13302">      for(i=0; i&lt;nArg; i<CheckRefs ids="2741">++</CheckRefs>){</Line>
  <Line number="13303">        if( i&gt;0 ) utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;colSeparator);</Line>
  <Line number="13304">        utf8_printf(p-&gt;out,&quot;%s&quot;,azArg[i] ? azArg[i] : p-&gt;nullValue);</Line>
  <Line number="13305">      }</Line>
  <Line number="13306">      utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;rowSeparator);</Line>
  <Line number="13307">      break;</Line>
  <Line number="13308">    }</Line>
  <Line number="13309">    case MODE_EQP: {</Line>
  <Line number="13310">      eqp_append(p, atoi(azArg[0]), atoi(azArg[1]), azArg[3]);</Line>
  <Line number="13311">      break;</Line>
  <Line number="13312">    }</Line>
  <Line number="13313">  }</Line>
  <Line number="13314">  return 0;</Line>
  <Line number="13315">}</Line>
  <Line number="13316"></Line>
  <Line number="13317">/*</Line>
  <Line number="13318">** This is the callback routine that the SQLite library</Line>
  <Line number="13319">** invokes for each row of a query result.</Line>
  <Line number="13320">*/</Line>
  <Line number="13321">static int callback(void *pArg, int nArg, char **azArg, char **azCol){</Line>
  <Line number="13322">  /* since we don&apos;t have type info, call the shell_callback with a NULL value */</Line>
  <Line number="13323">  return shell_callback(pArg, nArg, azArg, azCol, NULL);</Line>
  <Line number="13324">}</Line>
  <Line number="13325"></Line>
  <Line number="13326">/*</Line>
  <Line number="13327">** This is the callback routine from sqlite3_exec() that appends all</Line>
  <Line number="13328">** output onto the end of a ShellText object.</Line>
  <Line number="13329">*/</Line>
  <Line number="13330">static int captureOutputCallback(void *pArg, int nArg, char **azArg, char **az){</Line>
  <Line number="13331">  ShellText *p = (ShellText*)pArg;</Line>
  <Line number="13332">  int i;</Line>
  <Line number="13333">  UNUSED_PARAMETER(az);</Line>
  <Line number="13334">  if( azArg==0 ) return 0;</Line>
  <Line number="13335">  if( p-&gt;n ) appendText(p, &quot;|&quot;, <CheckRefs ids="2742">0</CheckRefs>);</Line>
  <Line number="13336">  for(i=0; i&lt;nArg; i<CheckRefs ids="2743">++</CheckRefs>){</Line>
  <Line number="13337">    if( i ) appendText(p, &quot;,&quot;, <CheckRefs ids="2744">0</CheckRefs>);</Line>
  <Line number="13338">    if( azArg[i] ) appendText(p, azArg[i], <CheckRefs ids="2745">0</CheckRefs>);</Line>
  <Line number="13339">  }</Line>
  <Line number="13340">  return 0;</Line>
  <Line number="13341">}</Line>
  <Line number="13342"></Line>
  <Line number="13343">/*</Line>
  <Line number="13344">** Generate an appropriate SELFTEST table in the main database.</Line>
  <Line number="13345">*/</Line>
  <Line number="13346">static void createSelftestTable(ShellState *p){</Line>
  <Line number="13347">  char *zErrMsg = 0;</Line>
  <Line number="13348">  sqlite3_exec(p-&gt;db,</Line>
  <Line number="13349">    &quot;SAVEPOINT selftest_init;\n&quot;</Line>
  <Line number="13350">    &quot;CREATE TABLE IF NOT EXISTS selftest(\n&quot;</Line>
  <Line number="13351">    &quot;  tno INTEGER PRIMARY KEY,\n&quot;   /* Test number */</Line>
  <Line number="13352">    &quot;  op TEXT,\n&quot;                   /* Operator:  memo run */</Line>
  <Line number="13353">    &quot;  cmd TEXT,\n&quot;                  /* Command text */</Line>
  <Line number="13354">    &quot;  ans TEXT\n&quot;                   /* Desired answer */</Line>
  <Line number="13355">    &quot;);&quot;</Line>
  <Line number="13356">    &quot;CREATE TEMP TABLE [_shell$self](op,cmd,ans);\n&quot;</Line>
  <Line number="13357">    &quot;INSERT INTO [_shell$self](rowid,op,cmd)\n&quot;</Line>
  <Line number="13358">    &quot;  VALUES(coalesce((SELECT (max(tno)+100)/10 FROM selftest),10),\n&quot;</Line>
  <Line number="13359">    &quot;         &apos;memo&apos;,&apos;Tests generated by --init&apos;);\n&quot;</Line>
  <Line number="13360">    &quot;INSERT INTO [_shell$self]\n&quot;</Line>
  <Line number="13361">    &quot;  SELECT &apos;run&apos;,\n&quot;</Line>
  <Line number="13362">    &quot;    &apos;SELECT hex(sha3_query(&apos;&apos;SELECT type,name,tbl_name,sql &quot;</Line>
  <Line number="13363">                                 &quot;FROM sqlite_schema ORDER BY 2&apos;&apos;,224))&apos;,\n&quot;</Line>
  <Line number="13364">    &quot;    hex(sha3_query(&apos;SELECT type,name,tbl_name,sql &quot;</Line>
  <Line number="13365">                          &quot;FROM sqlite_schema ORDER BY 2&apos;,224));\n&quot;</Line>
  <Line number="13366">    &quot;INSERT INTO [_shell$self]\n&quot;</Line>
  <Line number="13367">    &quot;  SELECT &apos;run&apos;,&quot;</Line>
  <Line number="13368">    &quot;    &apos;SELECT hex(sha3_query(&apos;&apos;SELECT * FROM \&quot;&apos; ||&quot;</Line>
  <Line number="13369">    &quot;        printf(&apos;%w&apos;,name) || &apos;\&quot; NOT INDEXED&apos;&apos;,224))&apos;,\n&quot;</Line>
  <Line number="13370">    &quot;    hex(sha3_query(printf(&apos;SELECT * FROM \&quot;%w\&quot; NOT INDEXED&apos;,name),224))\n&quot;</Line>
  <Line number="13371">    &quot;  FROM (\n&quot;</Line>
  <Line number="13372">    &quot;    SELECT name FROM sqlite_schema\n&quot;</Line>
  <Line number="13373">    &quot;     WHERE type=&apos;table&apos;\n&quot;</Line>
  <Line number="13374">    &quot;       AND name&lt;&gt;&apos;selftest&apos;\n&quot;</Line>
  <Line number="13375">    &quot;       AND coalesce(rootpage,0)&gt;0\n&quot;</Line>
  <Line number="13376">    &quot;  )\n&quot;</Line>
  <Line number="13377">    &quot; ORDER BY name;\n&quot;</Line>
  <Line number="13378">    &quot;INSERT INTO [_shell$self]\n&quot;</Line>
  <Line number="13379">    &quot;  VALUES(&apos;run&apos;,&apos;PRAGMA integrity_check&apos;,&apos;ok&apos;);\n&quot;</Line>
  <Line number="13380">    &quot;INSERT INTO selftest(tno,op,cmd,ans)&quot;</Line>
  <Line number="13381">    &quot;  SELECT rowid*10,op,cmd,ans FROM [_shell$self];\n&quot;</Line>
  <Line number="13382">    &quot;DROP TABLE [_shell$self];&quot;</Line>
  <Line number="13383">    ,0,0,&amp;zErrMsg);</Line>
  <Line number="13384">  if( zErrMsg ){</Line>
  <Line number="13385">    utf8_printf(stderr, &quot;SELFTEST initialization failure: %s\n&quot;, zErrMsg);</Line>
  <Line number="13386">    sqlite3_free(zErrMsg);</Line>
  <Line number="13387">  }</Line>
  <Line number="13388">  sqlite3_exec(p-&gt;db, &quot;RELEASE selftest_init&quot;,0,0,0);</Line>
  <Line number="13389">}</Line>
  <Line number="13390"></Line>
  <Line number="13391"></Line>
  <Line number="13392">/*</Line>
  <Line number="13393">** Set the destination table field of the ShellState structure to</Line>
  <Line number="13394">** the name of the table given.  Escape any quote characters in the</Line>
  <Line number="13395">** table name.</Line>
  <Line number="13396">*/</Line>
  <Line number="13397">static void set_table_name(ShellState *p, const char *zName){</Line>
  <Line number="13398">  int i, n;</Line>
  <Line number="13399">  char cQuote;</Line>
  <Line number="13400">  char *z;</Line>
  <Line number="13401"></Line>
  <Line number="13402">  if( p-&gt;zDestTable ){</Line>
  <Line number="13403">    free(p-&gt;zDestTable);</Line>
  <Line number="13404">    p-&gt;zDestTable = 0;</Line>
  <Line number="13405">  }</Line>
  <Line number="13406">  if( zName==0 ) return;</Line>
  <Line number="13407">  cQuote = quoteChar(zName);</Line>
  <Line number="13408">  n = strlen30(zName);</Line>
  <Line number="13409">  if( cQuote ) n <CheckRefs ids="2746">+=</CheckRefs> n<CheckRefs ids="2747">+</CheckRefs>2;</Line>
  <Line number="13410">  z = p-&gt;zDestTable = malloc( n<CheckRefs ids="2748,2749">+</CheckRefs>1 );</Line>
  <Line number="13411">  if( z==0 ) shell_out_of_memory();</Line>
  <Line number="13412">  n = 0;</Line>
  <Line number="13413">  if( cQuote ) z[n<CheckRefs ids="2750">++</CheckRefs>] = cQuote;</Line>
  <Line number="13414">  for(i=0; zName[i]; i<CheckRefs ids="2751">++</CheckRefs>){</Line>
  <Line number="13415">    z[n<CheckRefs ids="2752">++</CheckRefs>] = zName[i];</Line>
  <Line number="13416">    if( <CheckRefs ids="2753">zName</CheckRefs>[i]==<CheckRefs ids="2754">cQuote</CheckRefs> ) z[n<CheckRefs ids="2755">++</CheckRefs>] = cQuote;</Line>
  <Line number="13417">  }</Line>
  <Line number="13418">  if( cQuote ) z[n<CheckRefs ids="2756">++</CheckRefs>] = cQuote;</Line>
  <Line number="13419">  z[n] = <CheckRefs ids="2757">0</CheckRefs>;</Line>
  <Line number="13420">}</Line>
  <Line number="13421"></Line>
  <Line number="13422"></Line>
  <Line number="13423">/*</Line>
  <Line number="13424">** Execute a query statement that will generate SQL output.  Print</Line>
  <Line number="13425">** the result columns, comma-separated, on a line and then add a</Line>
  <Line number="13426">** semicolon terminator to the end of that line.</Line>
  <Line number="13427">**</Line>
  <Line number="13428">** If the number of columns is 1 and that column contains text &quot;--&quot;</Line>
  <Line number="13429">** then write the semicolon on a separate line.  That way, if a</Line>
  <Line number="13430">** &quot;--&quot; comment occurs at the end of the statement, the comment</Line>
  <Line number="13431">** won&apos;t consume the semicolon terminator.</Line>
  <Line number="13432">*/</Line>
  <Line number="13433">static int run_table_dump_query(</Line>
  <Line number="13434">  ShellState *p,           /* Query context */</Line>
  <Line number="13435">  const char *zSelect      /* SELECT statement to extract content */</Line>
  <Line number="13436">){</Line>
  <Line number="13437">  sqlite3_stmt *pSelect;</Line>
  <Line number="13438">  int rc;</Line>
  <Line number="13439">  int nResult;</Line>
  <Line number="13440">  int i;</Line>
  <Line number="13441">  const char *z;</Line>
  <Line number="13442">  rc = sqlite3_prepare_v2(p-&gt;db, zSelect, <CheckRefs ids="2758">-</CheckRefs>1, &amp;pSelect, 0);</Line>
  <Line number="13443">  if( rc!=SQLITE_OK || !pSelect ){</Line>
  <Line number="13444">    utf8_printf(p-&gt;out, &quot;/**** ERROR: (%d) %s *****/\n&quot;, rc,</Line>
  <Line number="13445">                sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="13446">    if( (rc&amp;0xff)!=SQLITE_CORRUPT ) p-&gt;nErr<CheckRefs ids="2759">++</CheckRefs>;</Line>
  <Line number="13447">    return rc;</Line>
  <Line number="13448">  }</Line>
  <Line number="13449">  rc = sqlite3_step(pSelect);</Line>
  <Line number="13450">  nResult = sqlite3_column_count(pSelect);</Line>
  <Line number="13451">  while( rc==SQLITE_ROW ){</Line>
  <Line number="13452">    z = (const char*)sqlite3_column_text(pSelect, 0);</Line>
  <Line number="13453">    utf8_printf(p-&gt;out, &quot;%s&quot;, z);</Line>
  <Line number="13454">    for(i=1; i&lt;nResult; i<CheckRefs ids="2760">++</CheckRefs>){</Line>
  <Line number="13455">      utf8_printf(p-&gt;out, &quot;,%s&quot;, sqlite3_column_text(pSelect, i));</Line>
  <Line number="13456">    }</Line>
  <Line number="13457">    if( z==0 ) z = &quot;&quot;;</Line>
  <Line number="13458">    while( <CheckRefs ids="2761">z</CheckRefs>[0] &amp;&amp; (<CheckRefs ids="2762">z</CheckRefs>[0]!=&apos;-&apos; || <CheckRefs ids="2763">z</CheckRefs>[1]!=&apos;-&apos;) ) z++;</Line>
  <Line number="13459">    if( z[0] ){</Line>
  <Line number="13460">      raw_printf(p-&gt;out, &quot;\n;\n&quot;);</Line>
  <Line number="13461">    }else{</Line>
  <Line number="13462">      raw_printf(p-&gt;out, &quot;;\n&quot;);</Line>
  <Line number="13463">    }</Line>
  <Line number="13464">    rc = sqlite3_step(pSelect);</Line>
  <Line number="13465">  }</Line>
  <Line number="13466">  rc = sqlite3_finalize(pSelect);</Line>
  <Line number="13467">  if( rc!=SQLITE_OK ){</Line>
  <Line number="13468">    utf8_printf(p-&gt;out, &quot;/**** ERROR: (%d) %s *****/\n&quot;, rc,</Line>
  <Line number="13469">                sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="13470">    if( (rc&amp;0xff)!=SQLITE_CORRUPT ) p-&gt;nErr<CheckRefs ids="2764">++</CheckRefs>;</Line>
  <Line number="13471">  }</Line>
  <Line number="13472">  return rc;</Line>
  <Line number="13473">}</Line>
  <Line number="13474"></Line>
  <Line number="13475">/*</Line>
  <Line number="13476">** Allocate space and save off current error string.</Line>
  <Line number="13477">*/</Line>
  <Line number="13478">static char *save_err_msg(</Line>
  <Line number="13479">  sqlite3 *db            /* Database to query */</Line>
  <Line number="13480">){</Line>
  <Line number="13481">  int nErrMsg = 1<CheckRefs ids="2765">+</CheckRefs>strlen30(sqlite3_errmsg(db));</Line>
  <Line number="13482">  char *zErrMsg = sqlite3_malloc64(<CheckRefs ids="2766">nErrMsg</CheckRefs>);</Line>
  <Line number="13483">  if( zErrMsg ){</Line>
  <Line number="13484">    memcpy(zErrMsg, sqlite3_errmsg(db), <CheckRefs ids="2767">nErrMsg</CheckRefs>);</Line>
  <Line number="13485">  }</Line>
  <Line number="13486">  return zErrMsg;</Line>
  <Line number="13487">}</Line>
  <Line number="13488"></Line>
  <Line number="13489">#ifdef __linux__</Line>
  <Line number="13490">/*</Line>
  <Line number="13491">** Attempt to display I/O stats on Linux using /proc/PID/io</Line>
  <Line number="13492">*/</Line>
  <Line number="13493">static void displayLinuxIoStats(FILE *out){</Line>
  <Line number="13494">  FILE *in;</Line>
  <Line number="13495">  char z[200];</Line>
  <Line number="13496">  sqlite3_snprintf(<CheckRefs ids="2768">sizeof</CheckRefs>(z), z, &quot;/proc/%d/io&quot;, getpid());</Line>
  <Line number="13497">  in = fopen(z, &quot;rb&quot;);</Line>
  <Line number="13498">  if( in==0 ) return;</Line>
  <Line number="13499">  while( fgets(z, <CheckRefs ids="2769">sizeof</CheckRefs>(z), in)!=0 ){</Line>
  <Line number="13500">    static const struct {</Line>
  <Line number="13501">      const char *zPattern;</Line>
  <Line number="13502">      const char *zDesc;</Line>
  <Line number="13503">    } aTrans[] = {</Line>
  <Line number="13504">      { &quot;rchar: &quot;,                  &quot;Bytes received by read():&quot; },</Line>
  <Line number="13505">      { &quot;wchar: &quot;,                  &quot;Bytes sent to write():&quot;    },</Line>
  <Line number="13506">      { &quot;syscr: &quot;,                  &quot;Read() system calls:&quot;      },</Line>
  <Line number="13507">      { &quot;syscw: &quot;,                  &quot;Write() system calls:&quot;     },</Line>
  <Line number="13508">      { &quot;read_bytes: &quot;,             &quot;Bytes read from storage:&quot;  },</Line>
  <Line number="13509">      { &quot;write_bytes: &quot;,            &quot;Bytes written to storage:&quot; },</Line>
  <Line number="13510">      { &quot;cancelled_write_bytes: &quot;,  &quot;Cancelled write bytes:&quot;    },</Line>
  <Line number="13511">    };</Line>
  <Line number="13512">    int i;</Line>
  <Line number="13513">    for(i=0; i&lt;<CheckRefs ids="2772,2771,2770">ArraySize</CheckRefs>(aTrans); i<CheckRefs ids="2773">++</CheckRefs>){</Line>
  <Line number="13514">      int n = strlen30(aTrans[i<CheckRefs ids="2774">]</CheckRefs>.zPattern);</Line>
  <Line number="13515">      if( strncmp(aTrans[i<CheckRefs ids="2775">]</CheckRefs>.zPattern, z, <CheckRefs ids="2776">n</CheckRefs>)==0 ){</Line>
  <Line number="13516">        utf8_printf(out, &quot;%-36s %s&quot;, aTrans[i<CheckRefs ids="2777">]</CheckRefs>.zDesc, &amp;z[n<CheckRefs ids="2778">]</CheckRefs>);</Line>
  <Line number="13517">        break;</Line>
  <Line number="13518">      }</Line>
  <Line number="13519">    }</Line>
  <Line number="13520">  }</Line>
  <Line number="13521">  fclose(in);</Line>
  <Line number="13522">}</Line>
  <Line number="13523">#endif</Line>
  <Line number="13524"></Line>
  <Line number="13525">/*</Line>
  <Line number="13526">** Display a single line of status using 64-bit values.</Line>
  <Line number="13527">*/</Line>
  <Line number="13528">static void displayStatLine(</Line>
  <Line number="13529">  ShellState *p,            /* The shell context */</Line>
  <Line number="13530">  char *zLabel,             /* Label for this one line */</Line>
  <Line number="13531">  char *zFormat,            /* Format for the result */</Line>
  <Line number="13532">  int iStatusCtrl,          /* Which status to display */</Line>
  <Line number="13533">  int bReset                /* True to reset the stats */</Line>
  <Line number="13534">){</Line>
  <Line number="13535">  sqlite3_int64 iCur = <CheckRefs ids="2779,2780">-</CheckRefs>1;</Line>
  <Line number="13536">  sqlite3_int64 iHiwtr = <CheckRefs ids="2781,2782">-</CheckRefs>1;</Line>
  <Line number="13537">  int i, nPercent;</Line>
  <Line number="13538">  char zLine[200];</Line>
  <Line number="13539">  sqlite3_status64(iStatusCtrl, &amp;iCur, &amp;iHiwtr, bReset);</Line>
  <Line number="13540">  for(i=0, nPercent=0; zFormat[i]; i<CheckRefs ids="2783">++</CheckRefs>){</Line>
  <Line number="13541">    if( <CheckRefs ids="2784">zFormat</CheckRefs>[i]==&apos;%&apos; ) nPercent<CheckRefs ids="2785">++</CheckRefs>;</Line>
  <Line number="13542">  }</Line>
  <Line number="13543">  if( nPercent&gt;1 ){</Line>
  <Line number="13544">    sqlite3_snprintf(<CheckRefs ids="2786">sizeof</CheckRefs>(zLine), zLine, zFormat, iCur, iHiwtr);</Line>
  <Line number="13545">  }else{</Line>
  <Line number="13546">    sqlite3_snprintf(<CheckRefs ids="2787">sizeof</CheckRefs>(zLine), zLine, zFormat, iHiwtr);</Line>
  <Line number="13547">  }</Line>
  <Line number="13548">  raw_printf(p-&gt;out, &quot;%-36s %s\n&quot;, zLabel, zLine);</Line>
  <Line number="13549">}</Line>
  <Line number="13550"></Line>
  <Line number="13551">/*</Line>
  <Line number="13552">** Display memory stats.</Line>
  <Line number="13553">*/</Line>
  <Line number="13554">static int display_stats(</Line>
  <Line number="13555">  sqlite3 *db,                /* Database to query */</Line>
  <Line number="13556">  ShellState *pArg,           /* Pointer to ShellState */</Line>
  <Line number="13557">  int bReset                  /* True to reset the stats */</Line>
  <Line number="13558">){</Line>
  <Line number="13559">  int iCur;</Line>
  <Line number="13560">  int iHiwtr;</Line>
  <Line number="13561">  FILE *out;</Line>
  <Line number="13562">  if( pArg==0 || pArg-&gt;out==0 ) return 0;</Line>
  <Line number="13563">  out = pArg-&gt;out;</Line>
  <Line number="13564"></Line>
  <Line number="13565">  if( pArg-&gt;pStmt &amp;&amp; pArg-&gt;statsOn==<CheckRefs ids="2788">2</CheckRefs> ){</Line>
  <Line number="13566">    int nCol, i, x;</Line>
  <Line number="13567">    sqlite3_stmt *pStmt = pArg-&gt;pStmt;</Line>
  <Line number="13568">    char z[100];</Line>
  <Line number="13569">    nCol = sqlite3_column_count(pStmt);</Line>
  <Line number="13570">    raw_printf(out, &quot;%-36s %d\n&quot;, &quot;Number of output columns:&quot;, nCol);</Line>
  <Line number="13571">    for(i=0; i&lt;nCol; i<CheckRefs ids="2789">++</CheckRefs>){</Line>
  <Line number="13572">      sqlite3_snprintf(<CheckRefs ids="2790">sizeof</CheckRefs>(z),z,&quot;Column %d %nname:&quot;, i, &amp;x);</Line>
  <Line number="13573">      utf8_printf(out, &quot;%-36s %s\n&quot;, z, sqlite3_column_name(pStmt,i));</Line>
  <Line number="13574">#ifndef SQLITE_OMIT_DECLTYPE</Line>
  <Line number="13575">      sqlite3_snprintf(30, z+x, &quot;declared type:&quot;);</Line>
  <Line number="13576">      utf8_printf(out, &quot;%-36s %s\n&quot;, z, sqlite3_column_decltype(pStmt, i));</Line>
  <Line number="13577">#endif</Line>
  <Line number="13578">#ifdef SQLITE_ENABLE_COLUMN_METADATA</Line>
  <Line number="13579">      sqlite3_snprintf(30, z+x, &quot;database name:&quot;);</Line>
  <Line number="13580">      utf8_printf(out, &quot;%-36s %s\n&quot;, z, sqlite3_column_database_name(pStmt,i));</Line>
  <Line number="13581">      sqlite3_snprintf(30, z+x, &quot;table name:&quot;);</Line>
  <Line number="13582">      utf8_printf(out, &quot;%-36s %s\n&quot;, z, sqlite3_column_table_name(pStmt,i));</Line>
  <Line number="13583">      sqlite3_snprintf(30, z+x, &quot;origin name:&quot;);</Line>
  <Line number="13584">      utf8_printf(out, &quot;%-36s %s\n&quot;, z, sqlite3_column_origin_name(pStmt,i));</Line>
  <Line number="13585">#endif</Line>
  <Line number="13586">    }</Line>
  <Line number="13587">  }</Line>
  <Line number="13588"></Line>
  <Line number="13589">  if( pArg-&gt;statsOn==<CheckRefs ids="2791">3</CheckRefs> ){</Line>
  <Line number="13590">    if( pArg-&gt;pStmt ){</Line>
  <Line number="13591">      iCur = sqlite3_stmt_status(pArg-&gt;pStmt, SQLITE_STMTSTATUS_VM_STEP, bReset);</Line>
  <Line number="13592">      raw_printf(pArg-&gt;out, &quot;VM-steps: %d\n&quot;, iCur);</Line>
  <Line number="13593">    }</Line>
  <Line number="13594">    return 0;</Line>
  <Line number="13595">  }</Line>
  <Line number="13596"></Line>
  <Line number="13597">  displayStatLine(pArg, &quot;Memory Used:&quot;,</Line>
  <Line number="13598">     &quot;%lld (max %lld) bytes&quot;, SQLITE_STATUS_MEMORY_USED, bReset);</Line>
  <Line number="13599">  displayStatLine(pArg, &quot;Number of Outstanding Allocations:&quot;,</Line>
  <Line number="13600">     &quot;%lld (max %lld)&quot;, SQLITE_STATUS_MALLOC_COUNT, bReset);</Line>
  <Line number="13601">  if( pArg-&gt;shellFlgs &amp; <CheckRefs ids="2792">SHFLG_Pagecache</CheckRefs> ){</Line>
  <Line number="13602">    displayStatLine(pArg, &quot;Number of Pcache Pages Used:&quot;,</Line>
  <Line number="13603">       &quot;%lld (max %lld) pages&quot;, SQLITE_STATUS_PAGECACHE_USED, bReset);</Line>
  <Line number="13604">  }</Line>
  <Line number="13605">  displayStatLine(pArg, &quot;Number of Pcache Overflow Bytes:&quot;,</Line>
  <Line number="13606">     &quot;%lld (max %lld) bytes&quot;, SQLITE_STATUS_PAGECACHE_OVERFLOW, bReset);</Line>
  <Line number="13607">  displayStatLine(pArg, &quot;Largest Allocation:&quot;,</Line>
  <Line number="13608">     &quot;%lld bytes&quot;, SQLITE_STATUS_MALLOC_SIZE, bReset);</Line>
  <Line number="13609">  displayStatLine(pArg, &quot;Largest Pcache Allocation:&quot;,</Line>
  <Line number="13610">     &quot;%lld bytes&quot;, SQLITE_STATUS_PAGECACHE_SIZE, bReset);</Line>
  <Line number="13611">#ifdef YYTRACKMAXSTACKDEPTH</Line>
  <Line number="13612">  displayStatLine(pArg, &quot;Deepest Parser Stack:&quot;,</Line>
  <Line number="13613">     &quot;%lld (max %lld)&quot;, SQLITE_STATUS_PARSER_STACK, bReset);</Line>
  <Line number="13614">#endif</Line>
  <Line number="13615"></Line>
  <Line number="13616">  if( db ){</Line>
  <Line number="13617">    if( pArg-&gt;shellFlgs &amp; <CheckRefs ids="2793">SHFLG_Lookaside</CheckRefs> ){</Line>
  <Line number="13618">      iHiwtr = iCur = <CheckRefs ids="2794">-</CheckRefs>1;</Line>
  <Line number="13619">      sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_USED,</Line>
  <Line number="13620">                        &amp;iCur, &amp;iHiwtr, bReset);</Line>
  <Line number="13621">      raw_printf(pArg-&gt;out,</Line>
  <Line number="13622">              &quot;Lookaside Slots Used:                %d (max %d)\n&quot;,</Line>
  <Line number="13623">              iCur, iHiwtr);</Line>
  <Line number="13624">      sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_HIT,</Line>
  <Line number="13625">                        &amp;iCur, &amp;iHiwtr, bReset);</Line>
  <Line number="13626">      raw_printf(pArg-&gt;out, &quot;Successful lookaside attempts:       %d\n&quot;,</Line>
  <Line number="13627">              iHiwtr);</Line>
  <Line number="13628">      sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE,</Line>
  <Line number="13629">                        &amp;iCur, &amp;iHiwtr, bReset);</Line>
  <Line number="13630">      raw_printf(pArg-&gt;out, &quot;Lookaside failures due to size:      %d\n&quot;,</Line>
  <Line number="13631">              iHiwtr);</Line>
  <Line number="13632">      sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL,</Line>
  <Line number="13633">                        &amp;iCur, &amp;iHiwtr, bReset);</Line>
  <Line number="13634">      raw_printf(pArg-&gt;out, &quot;Lookaside failures due to OOM:       %d\n&quot;,</Line>
  <Line number="13635">              iHiwtr);</Line>
  <Line number="13636">    }</Line>
  <Line number="13637">    iHiwtr = iCur = <CheckRefs ids="2795">-</CheckRefs>1;</Line>
  <Line number="13638">    sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_USED, &amp;iCur, &amp;iHiwtr, bReset);</Line>
  <Line number="13639">    raw_printf(pArg-&gt;out, &quot;Pager Heap Usage:                    %d bytes\n&quot;,</Line>
  <Line number="13640">            iCur);</Line>
  <Line number="13641">    iHiwtr = iCur = <CheckRefs ids="2796">-</CheckRefs>1;</Line>
  <Line number="13642">    sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_HIT, &amp;iCur, &amp;iHiwtr, 1);</Line>
  <Line number="13643">    raw_printf(pArg-&gt;out, &quot;Page cache hits:                     %d\n&quot;, iCur);</Line>
  <Line number="13644">    iHiwtr = iCur = <CheckRefs ids="2797">-</CheckRefs>1;</Line>
  <Line number="13645">    sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_MISS, &amp;iCur, &amp;iHiwtr, 1);</Line>
  <Line number="13646">    raw_printf(pArg-&gt;out, &quot;Page cache misses:                   %d\n&quot;, iCur);</Line>
  <Line number="13647">    iHiwtr = iCur = <CheckRefs ids="2798">-</CheckRefs>1;</Line>
  <Line number="13648">    sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_WRITE, &amp;iCur, &amp;iHiwtr, 1);</Line>
  <Line number="13649">    raw_printf(pArg-&gt;out, &quot;Page cache writes:                   %d\n&quot;, iCur);</Line>
  <Line number="13650">    iHiwtr = iCur = <CheckRefs ids="2799">-</CheckRefs>1;</Line>
  <Line number="13651">    sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_SPILL, &amp;iCur, &amp;iHiwtr, 1);</Line>
  <Line number="13652">    raw_printf(pArg-&gt;out, &quot;Page cache spills:                   %d\n&quot;, iCur);</Line>
  <Line number="13653">    iHiwtr = iCur = <CheckRefs ids="2800">-</CheckRefs>1;</Line>
  <Line number="13654">    sqlite3_db_status(db, SQLITE_DBSTATUS_SCHEMA_USED, &amp;iCur, &amp;iHiwtr, bReset);</Line>
  <Line number="13655">    raw_printf(pArg-&gt;out, &quot;Schema Heap Usage:                   %d bytes\n&quot;,</Line>
  <Line number="13656">            iCur);</Line>
  <Line number="13657">    iHiwtr = iCur = <CheckRefs ids="2801">-</CheckRefs>1;</Line>
  <Line number="13658">    sqlite3_db_status(db, SQLITE_DBSTATUS_STMT_USED, &amp;iCur, &amp;iHiwtr, bReset);</Line>
  <Line number="13659">    raw_printf(pArg-&gt;out, &quot;Statement Heap/Lookaside Usage:      %d bytes\n&quot;,</Line>
  <Line number="13660">            iCur);</Line>
  <Line number="13661">  }</Line>
  <Line number="13662"></Line>
  <Line number="13663">  if( pArg-&gt;pStmt ){</Line>
  <Line number="13664">    iCur = sqlite3_stmt_status(pArg-&gt;pStmt, SQLITE_STMTSTATUS_FULLSCAN_STEP,</Line>
  <Line number="13665">                               bReset);</Line>
  <Line number="13666">    raw_printf(pArg-&gt;out, &quot;Fullscan Steps:                      %d\n&quot;, iCur);</Line>
  <Line number="13667">    iCur = sqlite3_stmt_status(pArg-&gt;pStmt, SQLITE_STMTSTATUS_SORT, bReset);</Line>
  <Line number="13668">    raw_printf(pArg-&gt;out, &quot;Sort Operations:                     %d\n&quot;, iCur);</Line>
  <Line number="13669">    iCur = sqlite3_stmt_status(pArg-&gt;pStmt, SQLITE_STMTSTATUS_AUTOINDEX,bReset);</Line>
  <Line number="13670">    raw_printf(pArg-&gt;out, &quot;Autoindex Inserts:                   %d\n&quot;, iCur);</Line>
  <Line number="13671">    iCur = sqlite3_stmt_status(pArg-&gt;pStmt, SQLITE_STMTSTATUS_VM_STEP, bReset);</Line>
  <Line number="13672">    raw_printf(pArg-&gt;out, &quot;Virtual Machine Steps:               %d\n&quot;, iCur);</Line>
  <Line number="13673">    iCur = sqlite3_stmt_status(pArg-&gt;pStmt, SQLITE_STMTSTATUS_REPREPARE,bReset);</Line>
  <Line number="13674">    raw_printf(pArg-&gt;out, &quot;Reprepare operations:                %d\n&quot;, iCur);</Line>
  <Line number="13675">    iCur = sqlite3_stmt_status(pArg-&gt;pStmt, SQLITE_STMTSTATUS_RUN, bReset);</Line>
  <Line number="13676">    raw_printf(pArg-&gt;out, &quot;Number of times run:                 %d\n&quot;, iCur);</Line>
  <Line number="13677">    iCur = sqlite3_stmt_status(pArg-&gt;pStmt, SQLITE_STMTSTATUS_MEMUSED, bReset);</Line>
  <Line number="13678">    raw_printf(pArg-&gt;out, &quot;Memory used by prepared stmt:        %d\n&quot;, iCur);</Line>
  <Line number="13679">  }</Line>
  <Line number="13680"></Line>
  <Line number="13681">#ifdef __linux__</Line>
  <Line number="13682">  displayLinuxIoStats(pArg-&gt;out);</Line>
  <Line number="13683">#endif</Line>
  <Line number="13684"></Line>
  <Line number="13685">  /* Do not remove this machine readable comment: extra-stats-output-here */</Line>
  <Line number="13686"></Line>
  <Line number="13687">  return 0;</Line>
  <Line number="13688">}</Line>
  <Line number="13689"></Line>
  <Line number="13690">/*</Line>
  <Line number="13691">** Display scan stats.</Line>
  <Line number="13692">*/</Line>
  <Line number="13693">static void display_scanstats(</Line>
  <Line number="13694">  sqlite3 *db,                    /* Database to query */</Line>
  <Line number="13695">  ShellState *pArg                /* Pointer to ShellState */</Line>
  <Line number="13696">){</Line>
  <Line number="13697">#ifndef SQLITE_ENABLE_STMT_SCANSTATUS</Line>
  <Line number="13698">  UNUSED_PARAMETER(db);</Line>
  <Line number="13699">  UNUSED_PARAMETER(pArg);</Line>
  <Line number="13700">#else</Line>
  <Line number="13701">  int i, k, n, mx;</Line>
  <Line number="13702">  raw_printf(pArg-&gt;out, &quot;-------- scanstats --------\n&quot;);</Line>
  <Line number="13703">  mx = 0;</Line>
  <Line number="13704">  for(k=0; k&lt;=mx; k++){</Line>
  <Line number="13705">    double rEstLoop = 1.0;</Line>
  <Line number="13706">    for(i=n=0; 1; i++){</Line>
  <Line number="13707">      sqlite3_stmt *p = pArg-&gt;pStmt;</Line>
  <Line number="13708">      sqlite3_int64 nLoop, nVisit;</Line>
  <Line number="13709">      double rEst;</Line>
  <Line number="13710">      int iSid;</Line>
  <Line number="13711">      const char *zExplain;</Line>
  <Line number="13712">      if( sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_NLOOP, (void*)&amp;nLoop) ){</Line>
  <Line number="13713">        break;</Line>
  <Line number="13714">      }</Line>
  <Line number="13715">      sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_SELECTID, (void*)&amp;iSid);</Line>
  <Line number="13716">      if( iSid&gt;mx ) mx = iSid;</Line>
  <Line number="13717">      if( iSid!=k ) continue;</Line>
  <Line number="13718">      if( n==0 ){</Line>
  <Line number="13719">        rEstLoop = (double)nLoop;</Line>
  <Line number="13720">        if( k&gt;0 ) raw_printf(pArg-&gt;out, &quot;-------- subquery %d -------\n&quot;, k);</Line>
  <Line number="13721">      }</Line>
  <Line number="13722">      n++;</Line>
  <Line number="13723">      sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_NVISIT, (void*)&amp;nVisit);</Line>
  <Line number="13724">      sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_EST, (void*)&amp;rEst);</Line>
  <Line number="13725">      sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_EXPLAIN, (void*)&amp;zExplain);</Line>
  <Line number="13726">      utf8_printf(pArg-&gt;out, &quot;Loop %2d: %s\n&quot;, n, zExplain);</Line>
  <Line number="13727">      rEstLoop *= rEst;</Line>
  <Line number="13728">      raw_printf(pArg-&gt;out,</Line>
  <Line number="13729">          &quot;         nLoop=%-8lld nRow=%-8lld estRow=%-8lld estRow/Loop=%-8g\n&quot;,</Line>
  <Line number="13730">          nLoop, nVisit, (sqlite3_int64)(rEstLoop+0.5), rEst</Line>
  <Line number="13731">      );</Line>
  <Line number="13732">    }</Line>
  <Line number="13733">  }</Line>
  <Line number="13734">  raw_printf(pArg-&gt;out, &quot;---------------------------\n&quot;);</Line>
  <Line number="13735">#endif</Line>
  <Line number="13736">}</Line>
  <Line number="13737"></Line>
  <Line number="13738">/*</Line>
  <Line number="13739">** Parameter azArray points to a zero-terminated array of strings. zStr</Line>
  <Line number="13740">** points to a single nul-terminated string. Return non-zero if zStr</Line>
  <Line number="13741">** is equal, according to strcmp(), to any of the strings in the array.</Line>
  <Line number="13742">** Otherwise, return zero.</Line>
  <Line number="13743">*/</Line>
  <Line number="13744">static int str_in_array(const char *zStr, const char **azArray){</Line>
  <Line number="13745">  int i;</Line>
  <Line number="13746">  for(i=0; azArray[i]; i<CheckRefs ids="2802">++</CheckRefs>){</Line>
  <Line number="13747">    if( 0==strcmp(zStr, azArray[i]) ) return 1;</Line>
  <Line number="13748">  }</Line>
  <Line number="13749">  return 0;</Line>
  <Line number="13750">}</Line>
  <Line number="13751"></Line>
  <Line number="13752">/*</Line>
  <Line number="13753">** If compiled statement pSql appears to be an EXPLAIN statement, allocate</Line>
  <Line number="13754">** and populate the ShellState.aiIndent[] array with the number of</Line>
  <Line number="13755">** spaces each opcode should be indented before it is output.</Line>
  <Line number="13756">**</Line>
  <Line number="13757">** The indenting rules are:</Line>
  <Line number="13758">**</Line>
  <Line number="13759">**     * For each &quot;Next&quot;, &quot;Prev&quot;, &quot;VNext&quot; or &quot;VPrev&quot; instruction, indent</Line>
  <Line number="13760">**       all opcodes that occur between the p2 jump destination and the opcode</Line>
  <Line number="13761">**       itself by 2 spaces.</Line>
  <Line number="13762">**</Line>
  <Line number="13763">**     * For each &quot;Goto&quot;, if the jump destination is earlier in the program</Line>
  <Line number="13764">**       and ends on one of:</Line>
  <Line number="13765">**          Yield  SeekGt  SeekLt  RowSetRead  Rewind</Line>
  <Line number="13766">**       or if the P1 parameter is one instead of zero,</Line>
  <Line number="13767">**       then indent all opcodes between the earlier instruction</Line>
  <Line number="13768">**       and &quot;Goto&quot; by 2 spaces.</Line>
  <Line number="13769">*/</Line>
  <Line number="13770">static void explain_data_prepare(ShellState *p, sqlite3_stmt *pSql){</Line>
  <Line number="13771">  const char *zSql;               /* The text of the SQL statement */</Line>
  <Line number="13772">  const char *z;                  /* Used to check if this is an EXPLAIN */</Line>
  <Line number="13773">  int *abYield = 0;               /* True if op is an OP_Yield */</Line>
  <Line number="13774">  int nAlloc = 0;                 /* Allocated size of p-&gt;aiIndent[], abYield */</Line>
  <Line number="13775">  int iOp;                        /* Index of operation in p-&gt;aiIndent[] */</Line>
  <Line number="13776"></Line>
  <Line number="13777">  const char *azNext[] = { &quot;Next&quot;, &quot;Prev&quot;, &quot;VPrev&quot;, &quot;VNext&quot;, &quot;SorterNext&quot;, 0 };</Line>
  <Line number="13778">  const char *azYield[] = { &quot;Yield&quot;, &quot;SeekLT&quot;, &quot;SeekGT&quot;, &quot;RowSetRead&quot;,</Line>
  <Line number="13779">                            &quot;Rewind&quot;, 0 };</Line>
  <Line number="13780">  const char *azGoto[] = { &quot;Goto&quot;, 0 };</Line>
  <Line number="13781"></Line>
  <Line number="13782">  /* Try to figure out if this is really an EXPLAIN statement. If this</Line>
  <Line number="13783">  ** cannot be verified, return early.  */</Line>
  <Line number="13784">  if( sqlite3_column_count(pSql)!=8 ){</Line>
  <Line number="13785">    p-&gt;cMode = p-&gt;mode;</Line>
  <Line number="13786">    return;</Line>
  <Line number="13787">  }</Line>
  <Line number="13788">  zSql = sqlite3_sql(pSql);</Line>
  <Line number="13789">  if( zSql==0 ) return;</Line>
  <Line number="13790">  for(z=zSql; <CheckRefs ids="2803">*</CheckRefs>z==&apos; &apos; || <CheckRefs ids="2804">*</CheckRefs>z==&apos;\t&apos; || <CheckRefs ids="2805">*</CheckRefs>z==&apos;\n&apos; || <CheckRefs ids="2806">*</CheckRefs>z==&apos;\f&apos; || <CheckRefs ids="2807">*</CheckRefs>z==&apos;\r&apos;; z++);</Line>
  <Line number="13791">  if( sqlite3_strnicmp(z, &quot;explain&quot;, 7) ){</Line>
  <Line number="13792">    p-&gt;cMode = p-&gt;mode;</Line>
  <Line number="13793">    return;</Line>
  <Line number="13794">  }</Line>
  <Line number="13795"></Line>
  <Line number="13796">  for(iOp=0; SQLITE_ROW==sqlite3_step(pSql); iOp<CheckRefs ids="2808">++</CheckRefs>){</Line>
  <Line number="13797">    int i;</Line>
  <Line number="13798">    int iAddr = sqlite3_column_int(pSql, 0);</Line>
  <Line number="13799">    const char *zOp = (const char*)sqlite3_column_text(pSql, 1);</Line>
  <Line number="13800"></Line>
  <Line number="13801">    /* Set p2 to the P2 field of the current opcode. Then, assuming that</Line>
  <Line number="13802">    ** p2 is an instruction address, set variable p2op to the index of that</Line>
  <Line number="13803">    ** instruction in the aiIndent[] array. p2 and p2op may be different if</Line>
  <Line number="13804">    ** the current instruction is part of a sub-program generated by an</Line>
  <Line number="13805">    ** SQL trigger or foreign key.  */</Line>
  <Line number="13806">    int p2 = sqlite3_column_int(pSql, 3);</Line>
  <Line number="13807">    int p2op = (p2 <CheckRefs ids="2809">+</CheckRefs> (iOp<CheckRefs ids="2810">-</CheckRefs>iAddr));</Line>
  <Line number="13808"></Line>
  <Line number="13809">    /* Grow the p-&gt;aiIndent array as required */</Line>
  <Line number="13810">    if( iOp&gt;=nAlloc ){</Line>
  <Line number="13811">      if( iOp==0 ){</Line>
  <Line number="13812">        /* Do further verfication that this is explain output.  Abort if</Line>
  <Line number="13813">        ** it is not */</Line>
  <Line number="13814">        static const char *explainCols[] = {</Line>
  <Line number="13815">           &quot;addr&quot;, &quot;opcode&quot;, &quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;, &quot;p4&quot;, &quot;p5&quot;, &quot;comment&quot; };</Line>
  <Line number="13816">        int jj;</Line>
  <Line number="13817">        for(jj=0; jj&lt;<CheckRefs ids="2813,2812,2811">ArraySize</CheckRefs>(explainCols); jj<CheckRefs ids="2814">++</CheckRefs>){</Line>
  <Line number="13818">          if( strcmp(sqlite3_column_name(pSql,jj),explainCols[jj<CheckRefs ids="2815">]</CheckRefs>)!=0 ){</Line>
  <Line number="13819">            p-&gt;cMode = p-&gt;mode;</Line>
  <Line number="13820">            sqlite3_reset(pSql);</Line>
  <Line number="13821">            return;</Line>
  <Line number="13822">          }</Line>
  <Line number="13823">        }</Line>
  <Line number="13824">      }</Line>
  <Line number="13825">      nAlloc <CheckRefs ids="2816">+=</CheckRefs> 100;</Line>
  <Line number="13826">      p-&gt;aiIndent = (int*)sqlite3_realloc64(p-&gt;aiIndent, <CheckRefs ids="2819">nAlloc</CheckRefs><CheckRefs ids="2817,2818">*</CheckRefs>sizeof(int));</Line>
  <Line number="13827">      if( p-&gt;aiIndent==0 ) shell_out_of_memory();</Line>
  <Line number="13828">      abYield = (int*)sqlite3_realloc64(abYield, <CheckRefs ids="2822">nAlloc</CheckRefs><CheckRefs ids="2820,2821">*</CheckRefs>sizeof(int));</Line>
  <Line number="13829">      if( abYield==0 ) shell_out_of_memory();</Line>
  <Line number="13830">    }</Line>
  <Line number="13831">    abYield[iOp] = str_in_array(zOp, azYield);</Line>
  <Line number="13832">    p-&gt;aiIndent[iOp] = 0;</Line>
  <Line number="13833">    p-&gt;nIndent = iOp<CheckRefs ids="2823">+</CheckRefs>1;</Line>
  <Line number="13834"></Line>
  <Line number="13835">    if( str_in_array(zOp, azNext) ){</Line>
  <Line number="13836">      for(i=p2op; i&lt;iOp; i<CheckRefs ids="2824">++</CheckRefs>) p-&gt;aiIndent[i] <CheckRefs ids="2825">+=</CheckRefs> 2;</Line>
  <Line number="13837">    }</Line>
  <Line number="13838">    if( str_in_array(zOp, azGoto) &amp;&amp; p2op&lt;p-&gt;nIndent</Line>
  <Line number="13839">     &amp;&amp; (abYield[p2op] || sqlite3_column_int(pSql, 2))</Line>
  <Line number="13840">    ){</Line>
  <Line number="13841">      for(i=p2op; i&lt;iOp; i<CheckRefs ids="2826">++</CheckRefs>) p-&gt;aiIndent[i] <CheckRefs ids="2827">+=</CheckRefs> 2;</Line>
  <Line number="13842">    }</Line>
  <Line number="13843">  }</Line>
  <Line number="13844"></Line>
  <Line number="13845">  p-&gt;iIndent = 0;</Line>
  <Line number="13846">  sqlite3_free(abYield);</Line>
  <Line number="13847">  sqlite3_reset(pSql);</Line>
  <Line number="13848">}</Line>
  <Line number="13849"></Line>
  <Line number="13850">/*</Line>
  <Line number="13851">** Free the array allocated by explain_data_prepare().</Line>
  <Line number="13852">*/</Line>
  <Line number="13853">static void explain_data_delete(ShellState *p){</Line>
  <Line number="13854">  sqlite3_free(p-&gt;aiIndent);</Line>
  <Line number="13855">  p-&gt;aiIndent = 0;</Line>
  <Line number="13856">  p-&gt;nIndent = 0;</Line>
  <Line number="13857">  p-&gt;iIndent = 0;</Line>
  <Line number="13858">}</Line>
  <Line number="13859"></Line>
  <Line number="13860">/*</Line>
  <Line number="13861">** Disable and restore .wheretrace and .selecttrace settings.</Line>
  <Line number="13862">*/</Line>
  <Line number="13863">static unsigned int savedSelectTrace;</Line>
  <Line number="13864">static unsigned int savedWhereTrace;</Line>
  <Line number="13865">static void disable_debug_trace_modes(void){</Line>
  <Line number="13866">  unsigned int zero = <CheckRefs ids="2828">0</CheckRefs>;</Line>
  <Line number="13867">  sqlite3_test_control(SQLITE_TESTCTRL_TRACEFLAGS, 0, &amp;savedSelectTrace);</Line>
  <Line number="13868">  sqlite3_test_control(SQLITE_TESTCTRL_TRACEFLAGS, 1, &amp;zero);</Line>
  <Line number="13869">  sqlite3_test_control(SQLITE_TESTCTRL_TRACEFLAGS, 2, &amp;savedWhereTrace);</Line>
  <Line number="13870">  sqlite3_test_control(SQLITE_TESTCTRL_TRACEFLAGS, 3, &amp;zero);</Line>
  <Line number="13871">}</Line>
  <Line number="13872">static void restore_debug_trace_modes(void){</Line>
  <Line number="13873">  sqlite3_test_control(SQLITE_TESTCTRL_TRACEFLAGS, 1, &amp;savedSelectTrace);</Line>
  <Line number="13874">  sqlite3_test_control(SQLITE_TESTCTRL_TRACEFLAGS, 3, &amp;savedWhereTrace);</Line>
  <Line number="13875">}</Line>
  <Line number="13876"></Line>
  <Line number="13877">/* Create the TEMP table used to store parameter bindings */</Line>
  <Line number="13878">static void bind_table_init(ShellState *p){</Line>
  <Line number="13879">  int wrSchema = 0;</Line>
  <Line number="13880">  int defensiveMode = 0;</Line>
  <Line number="13881">  sqlite3_db_config(p-&gt;db, SQLITE_DBCONFIG_DEFENSIVE, <CheckRefs ids="2829">-</CheckRefs>1, &amp;defensiveMode);</Line>
  <Line number="13882">  sqlite3_db_config(p-&gt;db, SQLITE_DBCONFIG_DEFENSIVE, 0, 0);</Line>
  <Line number="13883">  sqlite3_db_config(p-&gt;db, SQLITE_DBCONFIG_WRITABLE_SCHEMA, <CheckRefs ids="2830">-</CheckRefs>1, &amp;wrSchema);</Line>
  <Line number="13884">  sqlite3_db_config(p-&gt;db, SQLITE_DBCONFIG_WRITABLE_SCHEMA, 1, 0);</Line>
  <Line number="13885">  sqlite3_exec(p-&gt;db,</Line>
  <Line number="13886">    &quot;CREATE TABLE IF NOT EXISTS temp.sqlite_parameters(\n&quot;</Line>
  <Line number="13887">    &quot;  key TEXT PRIMARY KEY,\n&quot;</Line>
  <Line number="13888">    &quot;  value\n&quot;</Line>
  <Line number="13889">    &quot;) WITHOUT ROWID;&quot;,</Line>
  <Line number="13890">    0, 0, 0);</Line>
  <Line number="13891">  sqlite3_db_config(p-&gt;db, SQLITE_DBCONFIG_WRITABLE_SCHEMA, wrSchema, 0);</Line>
  <Line number="13892">  sqlite3_db_config(p-&gt;db, SQLITE_DBCONFIG_DEFENSIVE, defensiveMode, 0);</Line>
  <Line number="13893">}</Line>
  <Line number="13894"></Line>
  <Line number="13895">/*</Line>
  <Line number="13896">** Bind parameters on a prepared statement.</Line>
  <Line number="13897">**</Line>
  <Line number="13898">** Parameter bindings are taken from a TEMP table of the form:</Line>
  <Line number="13899">**</Line>
  <Line number="13900">**    CREATE TEMP TABLE sqlite_parameters(key TEXT PRIMARY KEY, value)</Line>
  <Line number="13901">**    WITHOUT ROWID;</Line>
  <Line number="13902">**</Line>
  <Line number="13903">** No bindings occur if this table does not exist.  The name of the table</Line>
  <Line number="13904">** begins with &quot;sqlite_&quot; so that it will not collide with ordinary application</Line>
  <Line number="13905">** tables.  The table must be in the TEMP schema.</Line>
  <Line number="13906">*/</Line>
  <Line number="13907">static void bind_prepared_stmt(ShellState *pArg, sqlite3_stmt *pStmt){</Line>
  <Line number="13908">  int nVar;</Line>
  <Line number="13909">  int i;</Line>
  <Line number="13910">  int rc;</Line>
  <Line number="13911">  sqlite3_stmt *pQ = 0;</Line>
  <Line number="13912"></Line>
  <Line number="13913">  nVar = sqlite3_bind_parameter_count(pStmt);</Line>
  <Line number="13914">  if( nVar==0 ) return;  /* Nothing to do */</Line>
  <Line number="13915">  if( sqlite3_table_column_metadata(pArg-&gt;db, &quot;TEMP&quot;, &quot;sqlite_parameters&quot;,</Line>
  <Line number="13916">                                    &quot;key&quot;, 0, 0, 0, 0, 0)!=SQLITE_OK ){</Line>
  <Line number="13917">    return; /* Parameter table does not exist */</Line>
  <Line number="13918">  }</Line>
  <Line number="13919">  rc = sqlite3_prepare_v2(pArg-&gt;db,</Line>
  <Line number="13920">          &quot;SELECT value FROM temp.sqlite_parameters&quot;</Line>
  <Line number="13921">          &quot; WHERE key=?1&quot;, <CheckRefs ids="2831">-</CheckRefs>1, &amp;pQ, 0);</Line>
  <Line number="13922">  if( rc || pQ==0 ) return;</Line>
  <Line number="13923">  for(i=1; i&lt;=nVar; i<CheckRefs ids="2832">++</CheckRefs>){</Line>
  <Line number="13924">    char zNum[30];</Line>
  <Line number="13925">    const char *zVar = sqlite3_bind_parameter_name(pStmt, i);</Line>
  <Line number="13926">    if( zVar==0 ){</Line>
  <Line number="13927">      sqlite3_snprintf(<CheckRefs ids="2833">sizeof</CheckRefs>(zNum),zNum,&quot;?%d&quot;,i);</Line>
  <Line number="13928">      zVar = zNum;</Line>
  <Line number="13929">    }</Line>
  <Line number="13930">    sqlite3_bind_text(pQ, 1, zVar, <CheckRefs ids="2834">-</CheckRefs>1, SQLITE_STATIC);</Line>
  <Line number="13931">    if( sqlite3_step(pQ)==SQLITE_ROW ){</Line>
  <Line number="13932">      sqlite3_bind_value(pStmt, i, sqlite3_column_value(pQ, 0));</Line>
  <Line number="13933">    }else{</Line>
  <Line number="13934">      sqlite3_bind_null(pStmt, i);</Line>
  <Line number="13935">    }</Line>
  <Line number="13936">    sqlite3_reset(pQ);</Line>
  <Line number="13937">  }</Line>
  <Line number="13938">  sqlite3_finalize(pQ);</Line>
  <Line number="13939">}</Line>
  <Line number="13940"></Line>
  <Line number="13941">/*</Line>
  <Line number="13942">** UTF8 box-drawing characters.  Imagine box lines like this:</Line>
  <Line number="13943">**</Line>
  <Line number="13944">**           1</Line>
  <Line number="13945">**           |</Line>
  <Line number="13946">**       4 --+-- 2</Line>
  <Line number="13947">**           |</Line>
  <Line number="13948">**           3</Line>
  <Line number="13949">**</Line>
  <Line number="13950">** Each box characters has between 2 and 4 of the lines leading from</Line>
  <Line number="13951">** the center.  The characters are here identified by the numbers of</Line>
  <Line number="13952">** their corresponding lines.</Line>
  <Line number="13953">*/</Line>
  <Line number="13954">#define BOX_24   &quot;\342\224\200&quot;  /* U+2500 --- */</Line>
  <Line number="13955">#define BOX_13   &quot;\342\224\202&quot;  /* U+2502  |  */</Line>
  <Line number="13956">#define BOX_23   &quot;\342\224\214&quot;  /* U+250c  ,- */</Line>
  <Line number="13957">#define BOX_34   &quot;\342\224\220&quot;  /* U+2510 -,  */</Line>
  <Line number="13958">#define BOX_12   &quot;\342\224\224&quot;  /* U+2514  &apos;- */</Line>
  <Line number="13959">#define BOX_14   &quot;\342\224\230&quot;  /* U+2518 -&apos;  */</Line>
  <Line number="13960">#define BOX_123  &quot;\342\224\234&quot;  /* U+251c  |- */</Line>
  <Line number="13961">#define BOX_134  &quot;\342\224\244&quot;  /* U+2524 -|  */</Line>
  <Line number="13962">#define BOX_234  &quot;\342\224\254&quot;  /* U+252c -,- */</Line>
  <Line number="13963">#define BOX_124  &quot;\342\224\264&quot;  /* U+2534 -&apos;- */</Line>
  <Line number="13964">#define BOX_1234 &quot;\342\224\274&quot;  /* U+253c -|- */</Line>
  <Line number="13965"></Line>
  <Line number="13966">/* Draw horizontal line N characters long using unicode box</Line>
  <Line number="13967">** characters</Line>
  <Line number="13968">*/</Line>
  <Line number="13969">static void print_box_line(FILE *out, int N){</Line>
  <Line number="13970">  const char zDash[] = </Line>
  <Line number="13971">      BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24</Line>
  <Line number="13972">      BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24;</Line>
  <Line number="13973">  const int nDash = sizeof(zDash) <CheckRefs ids="2835,2836">-</CheckRefs> <CheckRefs ids="2837">1</CheckRefs>;</Line>
  <Line number="13974">  N <CheckRefs ids="2838">*=</CheckRefs> 3;</Line>
  <Line number="13975">  while( N&gt;nDash ){</Line>
  <Line number="13976">    utf8_printf(out, zDash);</Line>
  <Line number="13977">    N <CheckRefs ids="2839">-=</CheckRefs> nDash;</Line>
  <Line number="13978">  }</Line>
  <Line number="13979">  utf8_printf(out, &quot;%.*s&quot;, N, zDash);</Line>
  <Line number="13980">}</Line>
  <Line number="13981"></Line>
  <Line number="13982">/*</Line>
  <Line number="13983">** Draw a horizontal separator for a MODE_Box table.</Line>
  <Line number="13984">*/</Line>
  <Line number="13985">static void print_box_row_separator(</Line>
  <Line number="13986">  ShellState *p,</Line>
  <Line number="13987">  int nArg,</Line>
  <Line number="13988">  const char *zSep1,</Line>
  <Line number="13989">  const char *zSep2,</Line>
  <Line number="13990">  const char *zSep3</Line>
  <Line number="13991">){</Line>
  <Line number="13992">  int i;</Line>
  <Line number="13993">  if( nArg&gt;0 ){</Line>
  <Line number="13994">    utf8_printf(p-&gt;out, &quot;%s&quot;, zSep1);</Line>
  <Line number="13995">    print_box_line(p-&gt;out, p-&gt;actualWidth[0]<CheckRefs ids="2840">+</CheckRefs>2);</Line>
  <Line number="13996">    for(i=1; i&lt;nArg; i<CheckRefs ids="2841">++</CheckRefs>){</Line>
  <Line number="13997">      utf8_printf(p-&gt;out, &quot;%s&quot;, zSep2);</Line>
  <Line number="13998">      print_box_line(p-&gt;out, p-&gt;actualWidth[i]<CheckRefs ids="2842">+</CheckRefs>2);</Line>
  <Line number="13999">    }</Line>
  <Line number="14000">    utf8_printf(p-&gt;out, &quot;%s&quot;, zSep3);</Line>
  <Line number="14001">  }</Line>
  <Line number="14002">  fputs(&quot;\n&quot;, p-&gt;out);</Line>
  <Line number="14003">}</Line>
  <Line number="14004"></Line>
  <Line number="14005"></Line>
  <Line number="14006"></Line>
  <Line number="14007">/*</Line>
  <Line number="14008">** Run a prepared statement and output the result in one of the</Line>
  <Line number="14009">** table-oriented formats: MODE_Column, MODE_Markdown, MODE_Table,</Line>
  <Line number="14010">** or MODE_Box.</Line>
  <Line number="14011">**</Line>
  <Line number="14012">** This is different from ordinary exec_prepared_stmt() in that</Line>
  <Line number="14013">** it has to run the entire query and gather the results into memory</Line>
  <Line number="14014">** first, in order to determine column widths, before providing</Line>
  <Line number="14015">** any output.</Line>
  <Line number="14016">*/</Line>
  <Line number="14017">static void exec_prepared_stmt_columnar(</Line>
  <Line number="14018">  ShellState *p,                        /* Pointer to ShellState */</Line>
  <Line number="14019">  sqlite3_stmt *pStmt                   /* Statment to run */</Line>
  <Line number="14020">){</Line>
  <Line number="14021">  sqlite3_int64 nRow = <CheckRefs ids="2843">0</CheckRefs>;</Line>
  <Line number="14022">  int nColumn = 0;</Line>
  <Line number="14023">  char **azData = 0;</Line>
  <Line number="14024">  sqlite3_int64 nAlloc = <CheckRefs ids="2844">0</CheckRefs>;</Line>
  <Line number="14025">  const char *z;</Line>
  <Line number="14026">  int rc;</Line>
  <Line number="14027">  sqlite3_int64 i, nData;</Line>
  <Line number="14028">  int j, nTotal, w, n;</Line>
  <Line number="14029">  const char *colSep = 0;</Line>
  <Line number="14030">  const char *rowSep = 0;</Line>
  <Line number="14031"></Line>
  <Line number="14032">  rc = sqlite3_step(pStmt);</Line>
  <Line number="14033">  if( rc!=SQLITE_ROW ) return;</Line>
  <Line number="14034">  nColumn = sqlite3_column_count(pStmt);</Line>
  <Line number="14035">  nAlloc = nColumn<CheckRefs ids="2845,2846">*</CheckRefs>4;</Line>
  <Line number="14036">  if( nAlloc&lt;=<CheckRefs ids="2847">0</CheckRefs> ) nAlloc = <CheckRefs ids="2848">1</CheckRefs>;</Line>
  <Line number="14037">  azData = sqlite3_malloc64( <CheckRefs ids="2850">nAlloc</CheckRefs><CheckRefs ids="2849">*</CheckRefs><CheckRefs ids="2851">sizeof</CheckRefs>(char*) );</Line>
  <Line number="14038">  if( azData==0 ) shell_out_of_memory();</Line>
  <Line number="14039">  for(i=<CheckRefs ids="2852">0</CheckRefs>; i&lt;<CheckRefs ids="2853">nColumn</CheckRefs>; i<CheckRefs ids="2854">++</CheckRefs>){</Line>
  <Line number="14040">    azData[i] = strdup(sqlite3_column_name(pStmt,<CheckRefs ids="2855">i</CheckRefs>));</Line>
  <Line number="14041">  }</Line>
  <Line number="14042">  do{</Line>
  <Line number="14043">    if( (nRow<CheckRefs ids="2857">+</CheckRefs><CheckRefs ids="2858">2</CheckRefs>)<CheckRefs ids="2856">*</CheckRefs><CheckRefs ids="2859">nColumn</CheckRefs> &gt;= nAlloc ){</Line>
  <Line number="14044">      nAlloc <CheckRefs ids="2860">*=</CheckRefs> <CheckRefs ids="2861">2</CheckRefs>;</Line>
  <Line number="14045">      azData = sqlite3_realloc64(azData, <CheckRefs ids="2863">nAlloc</CheckRefs><CheckRefs ids="2862">*</CheckRefs><CheckRefs ids="2864">sizeof</CheckRefs>(char*));</Line>
  <Line number="14046">      if( azData==0 ) shell_out_of_memory();</Line>
  <Line number="14047">    }</Line>
  <Line number="14048">    nRow<CheckRefs ids="2865">++</CheckRefs>;</Line>
  <Line number="14049">    for(i=<CheckRefs ids="2866">0</CheckRefs>; i&lt;<CheckRefs ids="2867">nColumn</CheckRefs>; i<CheckRefs ids="2868">++</CheckRefs>){</Line>
  <Line number="14050">      z = (const char*)sqlite3_column_text(pStmt,<CheckRefs ids="2869">i</CheckRefs>);</Line>
  <Line number="14051">      azData[nRow<CheckRefs ids="2871">*</CheckRefs><CheckRefs ids="2872">nColumn</CheckRefs> <CheckRefs ids="2870">+</CheckRefs> i] = z ? strdup(z) : 0;</Line>
  <Line number="14052">    }</Line>
  <Line number="14053">  }while( (rc = sqlite3_step(pStmt))==SQLITE_ROW );</Line>
  <Line number="14054">  if( nColumn&gt;p-&gt;nWidth ){</Line>
  <Line number="14055">    p-&gt;colWidth = realloc(p-&gt;colWidth, nColumn<CheckRefs ids="2874,2875">*</CheckRefs>2<CheckRefs ids="2873">*</CheckRefs>sizeof(int));</Line>
  <Line number="14056">    if( p-&gt;colWidth==0 ) shell_out_of_memory();</Line>
  <Line number="14057">    for(i=<CheckRefs ids="2876">p</CheckRefs>-&gt;nWidth; i&lt;<CheckRefs ids="2877">nColumn</CheckRefs>; i<CheckRefs ids="2878">++</CheckRefs>) p-&gt;colWidth[i] = 0;</Line>
  <Line number="14058">    p-&gt;nWidth = nColumn;</Line>
  <Line number="14059">    p-&gt;actualWidth = &amp;p-&gt;colWidth[nColumn];</Line>
  <Line number="14060">  }</Line>
  <Line number="14061">  memset(p-&gt;actualWidth, 0, <CheckRefs ids="2880">nColumn</CheckRefs><CheckRefs ids="2879">*</CheckRefs>sizeof(int));</Line>
  <Line number="14062">  for(i=<CheckRefs ids="2881">0</CheckRefs>; i&lt;<CheckRefs ids="2882">nColumn</CheckRefs>; i<CheckRefs ids="2883">++</CheckRefs>){</Line>
  <Line number="14063">    w = p-&gt;colWidth[i];</Line>
  <Line number="14064">    if( w&lt;0 ) w = <CheckRefs ids="2884">-</CheckRefs>w;</Line>
  <Line number="14065">    p-&gt;actualWidth[i] = w;</Line>
  <Line number="14066">  }</Line>
  <Line number="14067">  nTotal = <CheckRefs ids="2887">nColumn</CheckRefs><CheckRefs ids="2885,2886">*</CheckRefs>(nRow<CheckRefs ids="2888">+</CheckRefs><CheckRefs ids="2889">1</CheckRefs>);</Line>
  <Line number="14068">  for(i=<CheckRefs ids="2890">0</CheckRefs>; i&lt;<CheckRefs ids="2891">nTotal</CheckRefs>; i<CheckRefs ids="2892">++</CheckRefs>){</Line>
  <Line number="14069">    z = azData[i];</Line>
  <Line number="14070">    if( z==0 ) z = p-&gt;nullValue;</Line>
  <Line number="14071">    n = strlenChar(z);</Line>
  <Line number="14072">    j = i<CheckRefs ids="2893,2894">%</CheckRefs><CheckRefs ids="2895">nColumn</CheckRefs>;</Line>
  <Line number="14073">    if( n&gt;p-&gt;actualWidth[j] ) p-&gt;actualWidth[j] = n;</Line>
  <Line number="14074">  }</Line>
  <Line number="14075">  if( seenInterrupt ) goto columnar_end;</Line>
  <Line number="14076">  if( nColumn==0 ) goto columnar_end;</Line>
  <Line number="14077">  switch( p-&gt;cMode ){</Line>
  <Line number="14078">    case MODE_Column: {</Line>
  <Line number="14079">      colSep = &quot;  &quot;;</Line>
  <Line number="14080">      rowSep = &quot;\n&quot;;</Line>
  <Line number="14081">      if( p-&gt;showHeader ){</Line>
  <Line number="14082">        for(i=<CheckRefs ids="2896">0</CheckRefs>; i&lt;<CheckRefs ids="2897">nColumn</CheckRefs>; i<CheckRefs ids="2898">++</CheckRefs>){</Line>
  <Line number="14083">          w = p-&gt;actualWidth[i];</Line>
  <Line number="14084">          if( p-&gt;colWidth[i]&lt;0 ) w = <CheckRefs ids="2899">-</CheckRefs>w;</Line>
  <Line number="14085">          utf8_width_print(p-&gt;out, w, azData[i]);</Line>
  <Line number="14086">          fputs(i==nColumn<CheckRefs ids="2900,2901">-</CheckRefs>1?&quot;\n&quot;:&quot;  &quot;, p-&gt;out);</Line>
  <Line number="14087">        }</Line>
  <Line number="14088">        for(i=<CheckRefs ids="2902">0</CheckRefs>; i&lt;<CheckRefs ids="2903">nColumn</CheckRefs>; i<CheckRefs ids="2904">++</CheckRefs>){</Line>
  <Line number="14089">          print_dashes(p-&gt;out, p-&gt;actualWidth[i]);</Line>
  <Line number="14090">          fputs(i==nColumn<CheckRefs ids="2905,2906">-</CheckRefs>1?&quot;\n&quot;:&quot;  &quot;, p-&gt;out);</Line>
  <Line number="14091">        }</Line>
  <Line number="14092">      }</Line>
  <Line number="14093">      break;</Line>
  <Line number="14094">    }</Line>
  <Line number="14095">    case MODE_Table: {</Line>
  <Line number="14096">      colSep = &quot; | &quot;;</Line>
  <Line number="14097">      rowSep = &quot; |\n&quot;;</Line>
  <Line number="14098">      print_row_separator(p, nColumn, &quot;+&quot;);</Line>
  <Line number="14099">      fputs(&quot;| &quot;, p-&gt;out);</Line>
  <Line number="14100">      for(i=<CheckRefs ids="2907">0</CheckRefs>; i&lt;<CheckRefs ids="2908">nColumn</CheckRefs>; i<CheckRefs ids="2909">++</CheckRefs>){</Line>
  <Line number="14101">        w = p-&gt;actualWidth[i];</Line>
  <Line number="14102">        n = strlenChar(azData[i]);</Line>
  <Line number="14103">        utf8_printf(p-&gt;out, &quot;%*s%s%*s&quot;, (w<CheckRefs ids="2912">-</CheckRefs>n)<CheckRefs ids="2910,2911">/</CheckRefs>2, &quot;&quot;, azData[i], (w<CheckRefs ids="2916">-</CheckRefs>n<CheckRefs ids="2915">+</CheckRefs>1)<CheckRefs ids="2913,2914">/</CheckRefs>2, &quot;&quot;);</Line>
  <Line number="14104">        fputs(i==nColumn<CheckRefs ids="2917,2918">-</CheckRefs>1?&quot; |\n&quot;:&quot; | &quot;, p-&gt;out);</Line>
  <Line number="14105">      }</Line>
  <Line number="14106">      print_row_separator(p, nColumn, &quot;+&quot;);</Line>
  <Line number="14107">      break;</Line>
  <Line number="14108">    }</Line>
  <Line number="14109">    case MODE_Markdown: {</Line>
  <Line number="14110">      colSep = &quot; | &quot;;</Line>
  <Line number="14111">      rowSep = &quot; |\n&quot;;</Line>
  <Line number="14112">      fputs(&quot;| &quot;, p-&gt;out);</Line>
  <Line number="14113">      for(i=<CheckRefs ids="2919">0</CheckRefs>; i&lt;<CheckRefs ids="2920">nColumn</CheckRefs>; i<CheckRefs ids="2921">++</CheckRefs>){</Line>
  <Line number="14114">        w = p-&gt;actualWidth[i];</Line>
  <Line number="14115">        n = strlenChar(azData[i]);</Line>
  <Line number="14116">        utf8_printf(p-&gt;out, &quot;%*s%s%*s&quot;, (w<CheckRefs ids="2924">-</CheckRefs>n)<CheckRefs ids="2923,2922">/</CheckRefs>2, &quot;&quot;, azData[i], (w<CheckRefs ids="2928">-</CheckRefs>n<CheckRefs ids="2927">+</CheckRefs>1)<CheckRefs ids="2925,2926">/</CheckRefs>2, &quot;&quot;);</Line>
  <Line number="14117">        fputs(i==nColumn<CheckRefs ids="2929,2930">-</CheckRefs>1?&quot; |\n&quot;:&quot; | &quot;, p-&gt;out);</Line>
  <Line number="14118">      }</Line>
  <Line number="14119">      print_row_separator(p, nColumn, &quot;|&quot;);</Line>
  <Line number="14120">      break;</Line>
  <Line number="14121">    }</Line>
  <Line number="14122">    case MODE_Box: {</Line>
  <Line number="14123">      colSep = &quot; &quot; BOX_13 &quot; &quot;;</Line>
  <Line number="14124">      rowSep = &quot; &quot; BOX_13 &quot;\n&quot;;</Line>
  <Line number="14125">      print_box_row_separator(p, nColumn, BOX_23, BOX_234, BOX_34);</Line>
  <Line number="14126">      utf8_printf(p-&gt;out, BOX_13 &quot; &quot;);</Line>
  <Line number="14127">      for(i=<CheckRefs ids="2931">0</CheckRefs>; i&lt;<CheckRefs ids="2932">nColumn</CheckRefs>; i<CheckRefs ids="2933">++</CheckRefs>){</Line>
  <Line number="14128">        w = p-&gt;actualWidth[i];</Line>
  <Line number="14129">        n = strlenChar(azData[i]);</Line>
  <Line number="14130">        utf8_printf(p-&gt;out, &quot;%*s%s%*s%s&quot;,</Line>
  <Line number="14131">            (w<CheckRefs ids="2936">-</CheckRefs>n)<CheckRefs ids="2934,2935">/</CheckRefs>2, &quot;&quot;, azData[i], (w<CheckRefs ids="2940">-</CheckRefs>n<CheckRefs ids="2939">+</CheckRefs>1)<CheckRefs ids="2937,2938">/</CheckRefs>2, &quot;&quot;,</Line>
  <Line number="14132">            i==nColumn<CheckRefs ids="2941,2942">-</CheckRefs>1?&quot; &quot;BOX_13&quot;\n&quot;:&quot; &quot;BOX_13&quot; &quot;);</Line>
  <Line number="14133">      }</Line>
  <Line number="14134">      print_box_row_separator(p, nColumn, BOX_123, BOX_1234, BOX_134);</Line>
  <Line number="14135">      break;</Line>
  <Line number="14136">    }</Line>
  <Line number="14137">  }</Line>
  <Line number="14138">  for(i=<CheckRefs ids="2943">nColumn</CheckRefs>, j=0; i&lt;<CheckRefs ids="2944">nTotal</CheckRefs>; i<CheckRefs ids="2945">++</CheckRefs>, j<CheckRefs ids="2946">++</CheckRefs>){</Line>
  <Line number="14139">    if( j==0 &amp;&amp; p-&gt;cMode!=MODE_Column ){</Line>
  <Line number="14140">      utf8_printf(p-&gt;out, &quot;%s&quot;, p-&gt;cMode==MODE_Box?BOX_13&quot; &quot;:&quot;| &quot;);</Line>
  <Line number="14141">    }</Line>
  <Line number="14142">    z = azData[i];</Line>
  <Line number="14143">    if( z==0 ) z = p-&gt;nullValue;</Line>
  <Line number="14144">    w = p-&gt;actualWidth[j];</Line>
  <Line number="14145">    if( p-&gt;colWidth[j]&lt;0 ) w = <CheckRefs ids="2947">-</CheckRefs>w;</Line>
  <Line number="14146">    utf8_width_print(p-&gt;out, w, z);</Line>
  <Line number="14147">    if( j==nColumn<CheckRefs ids="2948">-</CheckRefs>1 ){</Line>
  <Line number="14148">      utf8_printf(p-&gt;out, &quot;%s&quot;, rowSep);</Line>
  <Line number="14149">      j = <CheckRefs ids="2949">-</CheckRefs>1;</Line>
  <Line number="14150">      if( seenInterrupt ) goto columnar_end;</Line>
  <Line number="14151">    }else{</Line>
  <Line number="14152">      utf8_printf(p-&gt;out, &quot;%s&quot;, colSep);</Line>
  <Line number="14153">    }</Line>
  <Line number="14154">  }</Line>
  <Line number="14155">  if( p-&gt;cMode==MODE_Table ){</Line>
  <Line number="14156">    print_row_separator(p, nColumn, &quot;+&quot;);</Line>
  <Line number="14157">  }else if( p-&gt;cMode==MODE_Box ){</Line>
  <Line number="14158">    print_box_row_separator(p, nColumn, BOX_12, BOX_124, BOX_14);</Line>
  <Line number="14159">  }</Line>
  <Line number="14160">columnar_end:</Line>
  <Line number="14161">  if( seenInterrupt ){</Line>
  <Line number="14162">    utf8_printf(p-&gt;out, &quot;Interrupt\n&quot;);</Line>
  <Line number="14163">  }</Line>
  <Line number="14164">  nData = (nRow<CheckRefs ids="2951">+</CheckRefs><CheckRefs ids="2952">1</CheckRefs>)<CheckRefs ids="2950">*</CheckRefs><CheckRefs ids="2953">nColumn</CheckRefs>;</Line>
  <Line number="14165">  for(i=<CheckRefs ids="2954">0</CheckRefs>; i&lt;nData; i<CheckRefs ids="2955">++</CheckRefs>) free(azData[i]);</Line>
  <Line number="14166">  sqlite3_free(azData);</Line>
  <Line number="14167">}</Line>
  <Line number="14168"></Line>
  <Line number="14169">/*</Line>
  <Line number="14170">** Run a prepared statement</Line>
  <Line number="14171">*/</Line>
  <Line number="14172">static void exec_prepared_stmt(</Line>
  <Line number="14173">  ShellState *pArg,                                /* Pointer to ShellState */</Line>
  <Line number="14174">  sqlite3_stmt *pStmt                              /* Statment to run */</Line>
  <Line number="14175">){</Line>
  <Line number="14176">  int rc;</Line>
  <Line number="14177"></Line>
  <Line number="14178">  if( pArg-&gt;cMode==MODE_Column</Line>
  <Line number="14179">   || pArg-&gt;cMode==MODE_Table</Line>
  <Line number="14180">   || pArg-&gt;cMode==MODE_Box</Line>
  <Line number="14181">   || pArg-&gt;cMode==MODE_Markdown</Line>
  <Line number="14182">  ){</Line>
  <Line number="14183">    exec_prepared_stmt_columnar(pArg, pStmt);</Line>
  <Line number="14184">    return;</Line>
  <Line number="14185">  }</Line>
  <Line number="14186"></Line>
  <Line number="14187">  /* perform the first step.  this will tell us if we</Line>
  <Line number="14188">  ** have a result set or not and how wide it is.</Line>
  <Line number="14189">  */</Line>
  <Line number="14190">  rc = sqlite3_step(pStmt);</Line>
  <Line number="14191">  /* if we have a result set... */</Line>
  <Line number="14192">  if( SQLITE_ROW == rc ){</Line>
  <Line number="14193">    /* allocate space for col name ptr, value ptr, and type */</Line>
  <Line number="14194">    int nCol = sqlite3_column_count(pStmt);</Line>
  <Line number="14195">    void *pData = sqlite3_malloc64(3<CheckRefs ids="2959,2960">*</CheckRefs>nCol<CheckRefs ids="2958">*</CheckRefs>sizeof(const char*) <CheckRefs ids="2956,2957">+</CheckRefs> <CheckRefs ids="2961">1</CheckRefs>);</Line>
  <Line number="14196">    if( !pData ){</Line>
  <Line number="14197">      rc = SQLITE_NOMEM;</Line>
  <Line number="14198">    }else{</Line>
  <Line number="14199">      char **azCols = (char **)pData;      /* Names of result columns */</Line>
  <Line number="14200">      char **azVals = &amp;azCols[nCol];       /* Results */</Line>
  <Line number="14201">      int *aiTypes = (int *)&amp;azVals[nCol]; /* Result types */</Line>
  <Line number="14202">      int i, x;</Line>
  <Line number="14203">      <CheckRefs ids="2962">assert</CheckRefs>(sizeof(int) &lt;= sizeof(char *));</Line>
  <Line number="14204">      /* save off ptrs to column names */</Line>
  <Line number="14205">      for(i=0; i&lt;nCol; i<CheckRefs ids="2963">++</CheckRefs>){</Line>
  <Line number="14206">        azCols[i] = (char *)sqlite3_column_name(pStmt, i);</Line>
  <Line number="14207">      }</Line>
  <Line number="14208">      do{</Line>
  <Line number="14209">        /* extract the data and data types */</Line>
  <Line number="14210">        for(i=0; i&lt;nCol; i<CheckRefs ids="2964">++</CheckRefs>){</Line>
  <Line number="14211">          aiTypes[i] = x = sqlite3_column_type(pStmt, i);</Line>
  <Line number="14212">          if( x==SQLITE_BLOB &amp;&amp; pArg &amp;&amp; pArg-&gt;cMode==MODE_Insert ){</Line>
  <Line number="14213">            azVals[i] = &quot;&quot;;</Line>
  <Line number="14214">          }else{</Line>
  <Line number="14215">            azVals[i] = (char*)sqlite3_column_text(pStmt, i);</Line>
  <Line number="14216">          }</Line>
  <Line number="14217">          if( !azVals[i] &amp;&amp; (aiTypes[i]!=SQLITE_NULL) ){</Line>
  <Line number="14218">            rc = SQLITE_NOMEM;</Line>
  <Line number="14219">            break; /* from for */</Line>
  <Line number="14220">          }</Line>
  <Line number="14221">        } /* end for */</Line>
  <Line number="14222"></Line>
  <Line number="14223">        /* if data and types extracted successfully... */</Line>
  <Line number="14224">        if( SQLITE_ROW == rc ){</Line>
  <Line number="14225">          /* call the supplied callback with the result row data */</Line>
  <Line number="14226">          if( shell_callback(pArg, nCol, azVals, azCols, aiTypes) ){</Line>
  <Line number="14227">            rc = SQLITE_ABORT;</Line>
  <Line number="14228">          }else{</Line>
  <Line number="14229">            rc = sqlite3_step(pStmt);</Line>
  <Line number="14230">          }</Line>
  <Line number="14231">        }</Line>
  <Line number="14232">      } while( SQLITE_ROW == rc );</Line>
  <Line number="14233">      sqlite3_free(pData);</Line>
  <Line number="14234">      if( pArg-&gt;cMode==MODE_Json ){</Line>
  <Line number="14235">        fputs(&quot;]\n&quot;, pArg-&gt;out);</Line>
  <Line number="14236">      }</Line>
  <Line number="14237">    }</Line>
  <Line number="14238">  }</Line>
  <Line number="14239">}</Line>
  <Line number="14240"></Line>
  <Line number="14241">#ifndef SQLITE_OMIT_VIRTUALTABLE</Line>
  <Line number="14242">/*</Line>
  <Line number="14243">** This function is called to process SQL if the previous shell command</Line>
  <Line number="14244">** was &quot;.expert&quot;. It passes the SQL in the second argument directly to</Line>
  <Line number="14245">** the sqlite3expert object.</Line>
  <Line number="14246">**</Line>
  <Line number="14247">** If successful, SQLITE_OK is returned. Otherwise, an SQLite error</Line>
  <Line number="14248">** code. In this case, (*pzErr) may be set to point to a buffer containing</Line>
  <Line number="14249">** an English language error message. It is the responsibility of the</Line>
  <Line number="14250">** caller to eventually free this buffer using sqlite3_free().</Line>
  <Line number="14251">*/</Line>
  <Line number="14252">static int expertHandleSQL(</Line>
  <Line number="14253">  ShellState *pState, </Line>
  <Line number="14254">  const char *zSql, </Line>
  <Line number="14255">  char **pzErr</Line>
  <Line number="14256">){</Line>
  <Line number="14257">  <CheckRefs ids="2965">assert</CheckRefs>( pState-&gt;expert.pExpert );</Line>
  <Line number="14258">  <CheckRefs ids="2966">assert</CheckRefs>( pzErr==0 || *pzErr==0 );</Line>
  <Line number="14259">  return sqlite3_expert_sql(pState-&gt;expert.pExpert, zSql, pzErr);</Line>
  <Line number="14260">}</Line>
  <Line number="14261"></Line>
  <Line number="14262">/*</Line>
  <Line number="14263">** This function is called either to silently clean up the object</Line>
  <Line number="14264">** created by the &quot;.expert&quot; command (if bCancel==1), or to generate a </Line>
  <Line number="14265">** report from it and then clean it up (if bCancel==0).</Line>
  <Line number="14266">**</Line>
  <Line number="14267">** If successful, SQLITE_OK is returned. Otherwise, an SQLite error</Line>
  <Line number="14268">** code. In this case, (*pzErr) may be set to point to a buffer containing</Line>
  <Line number="14269">** an English language error message. It is the responsibility of the</Line>
  <Line number="14270">** caller to eventually free this buffer using sqlite3_free().</Line>
  <Line number="14271">*/</Line>
  <Line number="14272">static int expertFinish(</Line>
  <Line number="14273">  ShellState *pState,</Line>
  <Line number="14274">  int bCancel,</Line>
  <Line number="14275">  char **pzErr</Line>
  <Line number="14276">){</Line>
  <Line number="14277">  int rc = SQLITE_OK;</Line>
  <Line number="14278">  sqlite3expert *p = pState-&gt;expert.pExpert;</Line>
  <Line number="14279">  <CheckRefs ids="2967">assert</CheckRefs>( p );</Line>
  <Line number="14280">  <CheckRefs ids="2968">assert</CheckRefs>( bCancel || pzErr==0 || *pzErr==0 );</Line>
  <Line number="14281">  if( bCancel==0 ){</Line>
  <Line number="14282">    FILE *out = pState-&gt;out;</Line>
  <Line number="14283">    int bVerbose = pState-&gt;expert.bVerbose;</Line>
  <Line number="14284"></Line>
  <Line number="14285">    rc = sqlite3_expert_analyze(p, pzErr);</Line>
  <Line number="14286">    if( rc==SQLITE_OK ){</Line>
  <Line number="14287">      int nQuery = sqlite3_expert_count(p);</Line>
  <Line number="14288">      int i;</Line>
  <Line number="14289"></Line>
  <Line number="14290">      if( bVerbose ){</Line>
  <Line number="14291">        const char *zCand = sqlite3_expert_report(p,0,EXPERT_REPORT_CANDIDATES);</Line>
  <Line number="14292">        raw_printf(out, &quot;-- Candidates -----------------------------\n&quot;);</Line>
  <Line number="14293">        raw_printf(out, &quot;%s\n&quot;, zCand);</Line>
  <Line number="14294">      }</Line>
  <Line number="14295">      for(i=0; i&lt;nQuery; i<CheckRefs ids="2969">++</CheckRefs>){</Line>
  <Line number="14296">        const char *zSql = sqlite3_expert_report(p, i, EXPERT_REPORT_SQL);</Line>
  <Line number="14297">        const char *zIdx = sqlite3_expert_report(p, i, EXPERT_REPORT_INDEXES);</Line>
  <Line number="14298">        const char *zEQP = sqlite3_expert_report(p, i, EXPERT_REPORT_PLAN);</Line>
  <Line number="14299">        if( zIdx==0 ) zIdx = &quot;(no new indexes)\n&quot;;</Line>
  <Line number="14300">        if( bVerbose ){</Line>
  <Line number="14301">          raw_printf(out, &quot;-- Query %d --------------------------------\n&quot;,i<CheckRefs ids="2970">+</CheckRefs>1);</Line>
  <Line number="14302">          raw_printf(out, &quot;%s\n\n&quot;, zSql);</Line>
  <Line number="14303">        }</Line>
  <Line number="14304">        raw_printf(out, &quot;%s\n&quot;, zIdx);</Line>
  <Line number="14305">        raw_printf(out, &quot;%s\n&quot;, zEQP);</Line>
  <Line number="14306">      }</Line>
  <Line number="14307">    }</Line>
  <Line number="14308">  }</Line>
  <Line number="14309">  sqlite3_expert_destroy(p);</Line>
  <Line number="14310">  pState-&gt;expert.pExpert = 0;</Line>
  <Line number="14311">  return rc;</Line>
  <Line number="14312">}</Line>
  <Line number="14313"></Line>
  <Line number="14314">/*</Line>
  <Line number="14315">** Implementation of &quot;.expert&quot; dot command.</Line>
  <Line number="14316">*/</Line>
  <Line number="14317">static int expertDotCommand(</Line>
  <Line number="14318">  ShellState *pState,             /* Current shell tool state */</Line>
  <Line number="14319">  char **azArg,                   /* Array of arguments passed to dot command */</Line>
  <Line number="14320">  int nArg                        /* Number of entries in azArg[] */</Line>
  <Line number="14321">){</Line>
  <Line number="14322">  int rc = SQLITE_OK;</Line>
  <Line number="14323">  char *zErr = 0;</Line>
  <Line number="14324">  int i;</Line>
  <Line number="14325">  int iSample = 0;</Line>
  <Line number="14326"></Line>
  <Line number="14327">  <CheckRefs ids="2971">assert</CheckRefs>( pState-&gt;expert.pExpert==0 );</Line>
  <Line number="14328">  memset(&amp;pState-&gt;expert, 0, sizeof(ExpertInfo));</Line>
  <Line number="14329"></Line>
  <Line number="14330">  for(i=1; rc==SQLITE_OK &amp;&amp; i&lt;nArg; i<CheckRefs ids="2972">++</CheckRefs>){</Line>
  <Line number="14331">    char *z = azArg[i];</Line>
  <Line number="14332">    int n;</Line>
  <Line number="14333">    if( <CheckRefs ids="2973">z</CheckRefs>[0]==&apos;-&apos; &amp;&amp; <CheckRefs ids="2974">z</CheckRefs>[1]==&apos;-&apos; ) z++;</Line>
  <Line number="14334">    n = strlen30(z);</Line>
  <Line number="14335">    if( n&gt;=2 &amp;&amp; 0==strncmp(z, &quot;-verbose&quot;, <CheckRefs ids="2975">n</CheckRefs>) ){</Line>
  <Line number="14336">      pState-&gt;expert.bVerbose = 1;</Line>
  <Line number="14337">    }</Line>
  <Line number="14338">    else if( n&gt;=2 &amp;&amp; 0==strncmp(z, &quot;-sample&quot;, <CheckRefs ids="2976">n</CheckRefs>) ){</Line>
  <Line number="14339">      if( i==(nArg<CheckRefs ids="2977">-</CheckRefs>1) ){</Line>
  <Line number="14340">        raw_printf(stderr, &quot;option requires an argument: %s\n&quot;, z);</Line>
  <Line number="14341">        rc = SQLITE_ERROR;</Line>
  <Line number="14342">      }else{</Line>
  <Line number="14343">        iSample = <CheckRefs ids="2978">(</CheckRefs>int)integerValue(azArg[<CheckRefs ids="2979">++</CheckRefs>i]);</Line>
  <Line number="14344">        if( iSample&lt;0 || iSample&gt;100 ){</Line>
  <Line number="14345">          raw_printf(stderr, &quot;value out of range: %s\n&quot;, azArg[i]);</Line>
  <Line number="14346">          rc = SQLITE_ERROR;</Line>
  <Line number="14347">        }</Line>
  <Line number="14348">      }</Line>
  <Line number="14349">    }</Line>
  <Line number="14350">    else{</Line>
  <Line number="14351">      raw_printf(stderr, &quot;unknown option: %s\n&quot;, z);</Line>
  <Line number="14352">      rc = SQLITE_ERROR;</Line>
  <Line number="14353">    }</Line>
  <Line number="14354">  }</Line>
  <Line number="14355"></Line>
  <Line number="14356">  if( rc==SQLITE_OK ){</Line>
  <Line number="14357">    pState-&gt;expert.pExpert = sqlite3_expert_new(pState-&gt;db, &amp;zErr);</Line>
  <Line number="14358">    if( pState-&gt;expert.pExpert==0 ){</Line>
  <Line number="14359">      raw_printf(stderr, &quot;sqlite3_expert_new: %s\n&quot;, zErr);</Line>
  <Line number="14360">      rc = SQLITE_ERROR;</Line>
  <Line number="14361">    }else{</Line>
  <Line number="14362">      sqlite3_expert_config(</Line>
  <Line number="14363">          pState-&gt;expert.pExpert, EXPERT_CONFIG_SAMPLE, iSample</Line>
  <Line number="14364">      );</Line>
  <Line number="14365">    }</Line>
  <Line number="14366">  }</Line>
  <Line number="14367"></Line>
  <Line number="14368">  return rc;</Line>
  <Line number="14369">}</Line>
  <Line number="14370">#endif /* ifndef SQLITE_OMIT_VIRTUALTABLE */</Line>
  <Line number="14371"></Line>
  <Line number="14372">/*</Line>
  <Line number="14373">** Execute a statement or set of statements.  Print</Line>
  <Line number="14374">** any result rows/columns depending on the current mode</Line>
  <Line number="14375">** set via the supplied callback.</Line>
  <Line number="14376">**</Line>
  <Line number="14377">** This is very similar to SQLite&apos;s built-in sqlite3_exec()</Line>
  <Line number="14378">** function except it takes a slightly different callback</Line>
  <Line number="14379">** and callback data argument.</Line>
  <Line number="14380">*/</Line>
  <Line number="14381">static int shell_exec(</Line>
  <Line number="14382">  ShellState *pArg,                         /* Pointer to ShellState */</Line>
  <Line number="14383">  const char *zSql,                         /* SQL to be evaluated */</Line>
  <Line number="14384">  char **pzErrMsg                           /* Error msg written here */</Line>
  <Line number="14385">){</Line>
  <Line number="14386">  sqlite3_stmt *pStmt = NULL;     /* Statement to execute. */</Line>
  <Line number="14387">  int rc = SQLITE_OK;             /* Return Code */</Line>
  <Line number="14388">  int rc2;</Line>
  <Line number="14389">  const char *zLeftover;          /* Tail of unprocessed SQL */</Line>
  <Line number="14390">  sqlite3 *db = pArg-&gt;db;</Line>
  <Line number="14391"></Line>
  <Line number="14392">  if( pzErrMsg ){</Line>
  <Line number="14393">    *pzErrMsg = NULL;</Line>
  <Line number="14394">  }</Line>
  <Line number="14395"></Line>
  <Line number="14396">#ifndef SQLITE_OMIT_VIRTUALTABLE</Line>
  <Line number="14397">  if( pArg-&gt;expert.pExpert ){</Line>
  <Line number="14398">    rc = expertHandleSQL(pArg, zSql, pzErrMsg);</Line>
  <Line number="14399">    return expertFinish(pArg, (rc!=SQLITE_OK), pzErrMsg);</Line>
  <Line number="14400">  }</Line>
  <Line number="14401">#endif</Line>
  <Line number="14402"></Line>
  <Line number="14403">  while( <CheckRefs ids="2980">zSql</CheckRefs>[0] &amp;&amp; (SQLITE_OK == rc) ){</Line>
  <Line number="14404">    static const char *zStmtSql;</Line>
  <Line number="14405">    rc = sqlite3_prepare_v2(db, zSql, <CheckRefs ids="2981">-</CheckRefs>1, &amp;pStmt, &amp;zLeftover);</Line>
  <Line number="14406">    if( SQLITE_OK != rc ){</Line>
  <Line number="14407">      if( pzErrMsg ){</Line>
  <Line number="14408">        *pzErrMsg = save_err_msg(db);</Line>
  <Line number="14409">      }</Line>
  <Line number="14410">    }else{</Line>
  <Line number="14411">      if( !pStmt ){</Line>
  <Line number="14412">        /* this happens for a comment or white-space */</Line>
  <Line number="14413">        zSql = zLeftover;</Line>
  <Line number="14414">        while( <CheckRefs ids="2982,2983,2985,2986,2984">IsSpace</CheckRefs>(zSql[0]) ) zSql++;</Line>
  <Line number="14415">        continue;</Line>
  <Line number="14416">      }</Line>
  <Line number="14417">      zStmtSql = sqlite3_sql(pStmt);</Line>
  <Line number="14418">      if( zStmtSql==0 ) zStmtSql = &quot;&quot;;</Line>
  <Line number="14419">      while( <CheckRefs ids="2987,2991,2990,2988,2989">IsSpace</CheckRefs>(zStmtSql[0]) ) zStmtSql++;</Line>
  <Line number="14420"></Line>
  <Line number="14421">      /* save off the prepared statment handle and reset row count */</Line>
  <Line number="14422">      if( pArg ){</Line>
  <Line number="14423">        pArg-&gt;pStmt = pStmt;</Line>
  <Line number="14424">        pArg-&gt;cnt = 0;</Line>
  <Line number="14425">      }</Line>
  <Line number="14426"></Line>
  <Line number="14427">      /* echo the sql statement if echo on */</Line>
  <Line number="14428">      if( pArg &amp;&amp; <CheckRefs ids="2992,2993">ShellHasFlag</CheckRefs>(pArg, SHFLG_Echo) ){</Line>
  <Line number="14429">        utf8_printf(pArg-&gt;out, &quot;%s\n&quot;, zStmtSql ? zStmtSql : zSql);</Line>
  <Line number="14430">      }</Line>
  <Line number="14431"></Line>
  <Line number="14432">      /* Show the EXPLAIN QUERY PLAN if .eqp is on */</Line>
  <Line number="14433">      if( pArg &amp;&amp; <CheckRefs ids="2994">pArg</CheckRefs>-&gt;autoEQP &amp;&amp; sqlite3_stmt_isexplain(pStmt)==0 ){</Line>
  <Line number="14434">        sqlite3_stmt *pExplain;</Line>
  <Line number="14435">        char *zEQP;</Line>
  <Line number="14436">        int triggerEQP = 0;</Line>
  <Line number="14437">        disable_debug_trace_modes();</Line>
  <Line number="14438">        sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, <CheckRefs ids="2995">-</CheckRefs>1, &amp;triggerEQP);</Line>
  <Line number="14439">        if( <CheckRefs ids="2996">pArg</CheckRefs>-&gt;autoEQP&gt;=AUTOEQP_trigger ){</Line>
  <Line number="14440">          sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, 1, 0);</Line>
  <Line number="14441">        }</Line>
  <Line number="14442">        zEQP = sqlite3_mprintf(&quot;EXPLAIN QUERY PLAN %s&quot;, zStmtSql);</Line>
  <Line number="14443">        rc = sqlite3_prepare_v2(db, zEQP, <CheckRefs ids="2997">-</CheckRefs>1, &amp;pExplain, 0);</Line>
  <Line number="14444">        if( rc==SQLITE_OK ){</Line>
  <Line number="14445">          while( sqlite3_step(pExplain)==SQLITE_ROW ){</Line>
  <Line number="14446">            const char *zEQPLine = (const char*)sqlite3_column_text(pExplain,3);</Line>
  <Line number="14447">            int iEqpId = sqlite3_column_int(pExplain, 0);</Line>
  <Line number="14448">            int iParentId = sqlite3_column_int(pExplain, 1);</Line>
  <Line number="14449">            if( zEQPLine==0 ) zEQPLine = &quot;&quot;;</Line>
  <Line number="14450">            if( <CheckRefs ids="2998">zEQPLine</CheckRefs>[0]==&apos;-&apos; ) eqp_render(pArg);</Line>
  <Line number="14451">            eqp_append(pArg, iEqpId, iParentId, zEQPLine);</Line>
  <Line number="14452">          }</Line>
  <Line number="14453">          eqp_render(pArg);</Line>
  <Line number="14454">        }</Line>
  <Line number="14455">        sqlite3_finalize(pExplain);</Line>
  <Line number="14456">        sqlite3_free(zEQP);</Line>
  <Line number="14457">        if( <CheckRefs ids="2999">pArg</CheckRefs>-&gt;autoEQP&gt;=AUTOEQP_full ){</Line>
  <Line number="14458">          /* Also do an EXPLAIN for &quot;.eqp full&quot; mode */</Line>
  <Line number="14459">          zEQP = sqlite3_mprintf(&quot;EXPLAIN %s&quot;, zStmtSql);</Line>
  <Line number="14460">          rc = sqlite3_prepare_v2(db, zEQP, <CheckRefs ids="3000">-</CheckRefs>1, &amp;pExplain, 0);</Line>
  <Line number="14461">          if( rc==SQLITE_OK ){</Line>
  <Line number="14462">            pArg-&gt;cMode = MODE_Explain;</Line>
  <Line number="14463">            explain_data_prepare(pArg, pExplain);</Line>
  <Line number="14464">            exec_prepared_stmt(pArg, pExplain);</Line>
  <Line number="14465">            explain_data_delete(pArg);</Line>
  <Line number="14466">          }</Line>
  <Line number="14467">          sqlite3_finalize(pExplain);</Line>
  <Line number="14468">          sqlite3_free(zEQP);</Line>
  <Line number="14469">        }</Line>
  <Line number="14470">        if( <CheckRefs ids="3001">pArg</CheckRefs>-&gt;autoEQP&gt;=AUTOEQP_trigger &amp;&amp; triggerEQP==0 ){</Line>
  <Line number="14471">          sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, 0, 0);</Line>
  <Line number="14472">          /* Reprepare pStmt before reactiving trace modes */</Line>
  <Line number="14473">          sqlite3_finalize(pStmt);</Line>
  <Line number="14474">          sqlite3_prepare_v2(db, zSql, <CheckRefs ids="3002">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="14475">          if( pArg ) pArg-&gt;pStmt = pStmt;</Line>
  <Line number="14476">        }</Line>
  <Line number="14477">        restore_debug_trace_modes();</Line>
  <Line number="14478">      }</Line>
  <Line number="14479"></Line>
  <Line number="14480">      if( pArg ){</Line>
  <Line number="14481">        pArg-&gt;cMode = pArg-&gt;mode;</Line>
  <Line number="14482">        if( pArg-&gt;autoExplain ){</Line>
  <Line number="14483">          if( sqlite3_stmt_isexplain(pStmt)==1 ){</Line>
  <Line number="14484">            pArg-&gt;cMode = MODE_Explain;</Line>
  <Line number="14485">          }</Line>
  <Line number="14486">          if( sqlite3_stmt_isexplain(pStmt)==2 ){</Line>
  <Line number="14487">            pArg-&gt;cMode = MODE_EQP;</Line>
  <Line number="14488">          }</Line>
  <Line number="14489">        }</Line>
  <Line number="14490"></Line>
  <Line number="14491">        /* If the shell is currently in &quot;.explain&quot; mode, gather the extra</Line>
  <Line number="14492">        ** data required to add indents to the output.*/</Line>
  <Line number="14493">        if( pArg-&gt;cMode==MODE_Explain ){</Line>
  <Line number="14494">          explain_data_prepare(pArg, pStmt);</Line>
  <Line number="14495">        }</Line>
  <Line number="14496">      }</Line>
  <Line number="14497"></Line>
  <Line number="14498">      bind_prepared_stmt(pArg, pStmt);</Line>
  <Line number="14499">      exec_prepared_stmt(pArg, pStmt);</Line>
  <Line number="14500">      explain_data_delete(pArg);</Line>
  <Line number="14501">      eqp_render(pArg);</Line>
  <Line number="14502"></Line>
  <Line number="14503">      /* print usage stats if stats on */</Line>
  <Line number="14504">      if( pArg &amp;&amp; pArg-&gt;statsOn ){</Line>
  <Line number="14505">        display_stats(db, pArg, 0);</Line>
  <Line number="14506">      }</Line>
  <Line number="14507"></Line>
  <Line number="14508">      /* print loop-counters if required */</Line>
  <Line number="14509">      if( pArg &amp;&amp; <CheckRefs ids="3003">pArg</CheckRefs>-&gt;scanstatsOn ){</Line>
  <Line number="14510">        display_scanstats(db, pArg);</Line>
  <Line number="14511">      }</Line>
  <Line number="14512"></Line>
  <Line number="14513">      /* Finalize the statement just executed. If this fails, save a</Line>
  <Line number="14514">      ** copy of the error message. Otherwise, set zSql to point to the</Line>
  <Line number="14515">      ** next statement to execute. */</Line>
  <Line number="14516">      rc2 = sqlite3_finalize(pStmt);</Line>
  <Line number="14517">      if( rc!=SQLITE_NOMEM ) rc = rc2;</Line>
  <Line number="14518">      if( rc==SQLITE_OK ){</Line>
  <Line number="14519">        zSql = zLeftover;</Line>
  <Line number="14520">        while( <CheckRefs ids="3005,3004,3008,3007,3006">IsSpace</CheckRefs>(zSql[0]) ) zSql++;</Line>
  <Line number="14521">      }else if( pzErrMsg ){</Line>
  <Line number="14522">        *pzErrMsg = save_err_msg(db);</Line>
  <Line number="14523">      }</Line>
  <Line number="14524"></Line>
  <Line number="14525">      /* clear saved stmt handle */</Line>
  <Line number="14526">      if( pArg ){</Line>
  <Line number="14527">        pArg-&gt;pStmt = NULL;</Line>
  <Line number="14528">      }</Line>
  <Line number="14529">    }</Line>
  <Line number="14530">  } /* end while */</Line>
  <Line number="14531"></Line>
  <Line number="14532">  return rc;</Line>
  <Line number="14533">}</Line>
  <Line number="14534"></Line>
  <Line number="14535">/*</Line>
  <Line number="14536">** Release memory previously allocated by tableColumnList().</Line>
  <Line number="14537">*/</Line>
  <Line number="14538">static void freeColumnList(char **azCol){</Line>
  <Line number="14539">  int i;</Line>
  <Line number="14540">  for(i=1; azCol[i]; i<CheckRefs ids="3009">++</CheckRefs>){</Line>
  <Line number="14541">    sqlite3_free(azCol[i]);</Line>
  <Line number="14542">  }</Line>
  <Line number="14543">  /* azCol[0] is a static string */</Line>
  <Line number="14544">  sqlite3_free(azCol);</Line>
  <Line number="14545">}</Line>
  <Line number="14546"></Line>
  <Line number="14547">/*</Line>
  <Line number="14548">** Return a list of pointers to strings which are the names of all</Line>
  <Line number="14549">** columns in table zTab.   The memory to hold the names is dynamically</Line>
  <Line number="14550">** allocated and must be released by the caller using a subsequent call</Line>
  <Line number="14551">** to freeColumnList().</Line>
  <Line number="14552">**</Line>
  <Line number="14553">** The azCol[0] entry is usually NULL.  However, if zTab contains a rowid</Line>
  <Line number="14554">** value that needs to be preserved, then azCol[0] is filled in with the</Line>
  <Line number="14555">** name of the rowid column.</Line>
  <Line number="14556">**</Line>
  <Line number="14557">** The first regular column in the table is azCol[1].  The list is terminated</Line>
  <Line number="14558">** by an entry with azCol[i]==0.</Line>
  <Line number="14559">*/</Line>
  <Line number="14560">static char **tableColumnList(ShellState *p, const char *zTab){</Line>
  <Line number="14561">  char **azCol = 0;</Line>
  <Line number="14562">  sqlite3_stmt *pStmt;</Line>
  <Line number="14563">  char *zSql;</Line>
  <Line number="14564">  int nCol = 0;</Line>
  <Line number="14565">  int nAlloc = 0;</Line>
  <Line number="14566">  int nPK = 0;       /* Number of PRIMARY KEY columns seen */</Line>
  <Line number="14567">  int isIPK = 0;     /* True if one PRIMARY KEY column of type INTEGER */</Line>
  <Line number="14568">  int preserveRowid = <CheckRefs ids="3010,3011">ShellHasFlag</CheckRefs>(p, SHFLG_PreserveRowid);</Line>
  <Line number="14569">  int rc;</Line>
  <Line number="14570"></Line>
  <Line number="14571">  zSql = sqlite3_mprintf(&quot;PRAGMA table_info=%Q&quot;, zTab);</Line>
  <Line number="14572">  rc = sqlite3_prepare_v2(p-&gt;db, zSql, <CheckRefs ids="3012">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="14573">  sqlite3_free(zSql);</Line>
  <Line number="14574">  if( rc ) return 0;</Line>
  <Line number="14575">  while( sqlite3_step(pStmt)==SQLITE_ROW ){</Line>
  <Line number="14576">    if( nCol&gt;=nAlloc<CheckRefs ids="3013">-</CheckRefs>2 ){</Line>
  <Line number="14577">      nAlloc = nAlloc<CheckRefs ids="3016">*</CheckRefs>2 <CheckRefs ids="3015">+</CheckRefs> nCol <CheckRefs ids="3014">+</CheckRefs> 10;</Line>
  <Line number="14578">      azCol = sqlite3_realloc(azCol, <CheckRefs ids="3019">nAlloc</CheckRefs><CheckRefs ids="3017,3018">*</CheckRefs>sizeof(azCol[0]));</Line>
  <Line number="14579">      if( azCol==0 ) shell_out_of_memory();</Line>
  <Line number="14580">    }</Line>
  <Line number="14581">    azCol[<CheckRefs ids="3020">++</CheckRefs>nCol] = sqlite3_mprintf(&quot;%s&quot;, sqlite3_column_text(pStmt, 1));</Line>
  <Line number="14582">    if( sqlite3_column_int(pStmt, 5) ){</Line>
  <Line number="14583">      nPK<CheckRefs ids="3021">++</CheckRefs>;</Line>
  <Line number="14584">      if( nPK==1</Line>
  <Line number="14585">       &amp;&amp; sqlite3_stricmp((const char*)sqlite3_column_text(pStmt,2),</Line>
  <Line number="14586">                          &quot;INTEGER&quot;)==0</Line>
  <Line number="14587">      ){</Line>
  <Line number="14588">        isIPK = 1;</Line>
  <Line number="14589">      }else{</Line>
  <Line number="14590">        isIPK = 0;</Line>
  <Line number="14591">      }</Line>
  <Line number="14592">    }</Line>
  <Line number="14593">  }</Line>
  <Line number="14594">  sqlite3_finalize(pStmt);</Line>
  <Line number="14595">  if( azCol==0 ) return 0;</Line>
  <Line number="14596">  azCol[0] = 0;</Line>
  <Line number="14597">  azCol[nCol<CheckRefs ids="3022">+</CheckRefs>1] = 0;</Line>
  <Line number="14598"></Line>
  <Line number="14599">  /* The decision of whether or not a rowid really needs to be preserved</Line>
  <Line number="14600">  ** is tricky.  We never need to preserve a rowid for a WITHOUT ROWID table</Line>
  <Line number="14601">  ** or a table with an INTEGER PRIMARY KEY.  We are unable to preserve</Line>
  <Line number="14602">  ** rowids on tables where the rowid is inaccessible because there are other</Line>
  <Line number="14603">  ** columns in the table named &quot;rowid&quot;, &quot;_rowid_&quot;, and &quot;oid&quot;.</Line>
  <Line number="14604">  */</Line>
  <Line number="14605">  if( preserveRowid &amp;&amp; isIPK ){</Line>
  <Line number="14606">    /* If a single PRIMARY KEY column with type INTEGER was seen, then it</Line>
  <Line number="14607">    ** might be an alise for the ROWID.  But it might also be a WITHOUT ROWID</Line>
  <Line number="14608">    ** table or a INTEGER PRIMARY KEY DESC column, neither of which are</Line>
  <Line number="14609">    ** ROWID aliases.  To distinguish these cases, check to see if</Line>
  <Line number="14610">    ** there is a &quot;pk&quot; entry in &quot;PRAGMA index_list&quot;.  There will be</Line>
  <Line number="14611">    ** no &quot;pk&quot; index if the PRIMARY KEY really is an alias for the ROWID.</Line>
  <Line number="14612">    */</Line>
  <Line number="14613">    zSql = sqlite3_mprintf(&quot;SELECT 1 FROM pragma_index_list(%Q)&quot;</Line>
  <Line number="14614">                           &quot; WHERE origin=&apos;pk&apos;&quot;, zTab);</Line>
  <Line number="14615">    rc = sqlite3_prepare_v2(p-&gt;db, zSql, <CheckRefs ids="3023">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="14616">    sqlite3_free(zSql);</Line>
  <Line number="14617">    if( rc ){</Line>
  <Line number="14618">      freeColumnList(azCol);</Line>
  <Line number="14619">      return 0;</Line>
  <Line number="14620">    }</Line>
  <Line number="14621">    rc = sqlite3_step(pStmt);</Line>
  <Line number="14622">    sqlite3_finalize(pStmt);</Line>
  <Line number="14623">    preserveRowid = rc==SQLITE_ROW;</Line>
  <Line number="14624">  }</Line>
  <Line number="14625">  if( preserveRowid ){</Line>
  <Line number="14626">    /* Only preserve the rowid if we can find a name to use for the</Line>
  <Line number="14627">    ** rowid */</Line>
  <Line number="14628">    static char *azRowid[] = { &quot;rowid&quot;, &quot;_rowid_&quot;, &quot;oid&quot; };</Line>
  <Line number="14629">    int i, j;</Line>
  <Line number="14630">    for(j=0; j&lt;3; j<CheckRefs ids="3024">++</CheckRefs>){</Line>
  <Line number="14631">      for(i=1; i&lt;=nCol; i<CheckRefs ids="3025">++</CheckRefs>){</Line>
  <Line number="14632">        if( sqlite3_stricmp(azRowid[j<CheckRefs ids="3026">]</CheckRefs>,azCol[i])==0 ) break;</Line>
  <Line number="14633">      }</Line>
  <Line number="14634">      if( i&gt;nCol ){</Line>
  <Line number="14635">        /* At this point, we know that azRowid[j] is not the name of any</Line>
  <Line number="14636">        ** ordinary column in the table.  Verify that azRowid[j] is a valid</Line>
  <Line number="14637">        ** name for the rowid before adding it to azCol[0].  WITHOUT ROWID</Line>
  <Line number="14638">        ** tables will fail this last check */</Line>
  <Line number="14639">        rc = sqlite3_table_column_metadata(p-&gt;db,0,zTab,azRowid[j<CheckRefs ids="3027">]</CheckRefs>,0,0,0,0,0);</Line>
  <Line number="14640">        if( rc==SQLITE_OK ) azCol[0] = azRowid[j<CheckRefs ids="3028">]</CheckRefs>;</Line>
  <Line number="14641">        break;</Line>
  <Line number="14642">      }</Line>
  <Line number="14643">    }</Line>
  <Line number="14644">  }</Line>
  <Line number="14645">  return azCol;</Line>
  <Line number="14646">}</Line>
  <Line number="14647"></Line>
  <Line number="14648">/*</Line>
  <Line number="14649">** Toggle the reverse_unordered_selects setting.</Line>
  <Line number="14650">*/</Line>
  <Line number="14651">static void toggleSelectOrder(sqlite3 *db){</Line>
  <Line number="14652">  sqlite3_stmt *pStmt = 0;</Line>
  <Line number="14653">  int iSetting = 0;</Line>
  <Line number="14654">  char zStmt[100];</Line>
  <Line number="14655">  sqlite3_prepare_v2(db, &quot;PRAGMA reverse_unordered_selects&quot;, <CheckRefs ids="3029">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="14656">  if( sqlite3_step(pStmt)==SQLITE_ROW ){</Line>
  <Line number="14657">    iSetting = sqlite3_column_int(pStmt, 0);</Line>
  <Line number="14658">  }</Line>
  <Line number="14659">  sqlite3_finalize(pStmt);</Line>
  <Line number="14660">  sqlite3_snprintf(<CheckRefs ids="3030">sizeof</CheckRefs>(zStmt), zStmt,</Line>
  <Line number="14661">       &quot;PRAGMA reverse_unordered_selects(%d)&quot;, !iSetting);</Line>
  <Line number="14662">  sqlite3_exec(db, zStmt, 0, 0, 0);</Line>
  <Line number="14663">}</Line>
  <Line number="14664"></Line>
  <Line number="14665">/*</Line>
  <Line number="14666">** This is a different callback routine used for dumping the database.</Line>
  <Line number="14667">** Each row received by this callback consists of a table name,</Line>
  <Line number="14668">** the table type (&quot;index&quot; or &quot;table&quot;) and SQL to create the table.</Line>
  <Line number="14669">** This routine should print text sufficient to recreate the table.</Line>
  <Line number="14670">*/</Line>
  <Line number="14671">static int dump_callback(void *pArg, int nArg, char **azArg, char **azNotUsed){</Line>
  <Line number="14672">  int rc;</Line>
  <Line number="14673">  const char *zTable;</Line>
  <Line number="14674">  const char *zType;</Line>
  <Line number="14675">  const char *zSql;</Line>
  <Line number="14676">  ShellState *p = (ShellState *)pArg;</Line>
  <Line number="14677">  int dataOnly;</Line>
  <Line number="14678">  int noSys;</Line>
  <Line number="14679"></Line>
  <Line number="14680">  UNUSED_PARAMETER(azNotUsed);</Line>
  <Line number="14681">  if( nArg!=3 || azArg==0 ) return 0;</Line>
  <Line number="14682">  zTable = azArg[0];</Line>
  <Line number="14683">  zType = azArg[1];</Line>
  <Line number="14684">  zSql = azArg[2];</Line>
  <Line number="14685">  dataOnly = (p-&gt;shellFlgs &amp; <CheckRefs ids="3031">SHFLG_DumpDataOnly</CheckRefs>)!=<CheckRefs ids="3032">0</CheckRefs>;</Line>
  <Line number="14686">  noSys    = (p-&gt;shellFlgs &amp; <CheckRefs ids="3033">SHFLG_DumpNoSys</CheckRefs>)!=<CheckRefs ids="3034">0</CheckRefs>;</Line>
  <Line number="14687"></Line>
  <Line number="14688">  if( strcmp(zTable, &quot;sqlite_sequence&quot;)==0 &amp;&amp; !noSys ){</Line>
  <Line number="14689">    if( !dataOnly ) raw_printf(p-&gt;out, &quot;DELETE FROM sqlite_sequence;\n&quot;);</Line>
  <Line number="14690">  }else if( sqlite3_strglob(&quot;sqlite_stat?&quot;, zTable)==0 &amp;&amp; !noSys ){</Line>
  <Line number="14691">    if( !dataOnly ) raw_printf(p-&gt;out, &quot;ANALYZE sqlite_schema;\n&quot;);</Line>
  <Line number="14692">  }else if( strncmp(zTable, &quot;sqlite_&quot;, <CheckRefs ids="3035">7</CheckRefs>)==0 ){</Line>
  <Line number="14693">    return 0;</Line>
  <Line number="14694">  }else if( dataOnly ){</Line>
  <Line number="14695">    /* no-op */</Line>
  <Line number="14696">  }else if( strncmp(zSql, &quot;CREATE VIRTUAL TABLE&quot;, <CheckRefs ids="3036">20</CheckRefs>)==0 ){</Line>
  <Line number="14697">    char *zIns;</Line>
  <Line number="14698">    if( !p-&gt;writableSchema ){</Line>
  <Line number="14699">      raw_printf(p-&gt;out, &quot;PRAGMA writable_schema=ON;\n&quot;);</Line>
  <Line number="14700">      p-&gt;writableSchema = 1;</Line>
  <Line number="14701">    }</Line>
  <Line number="14702">    zIns = sqlite3_mprintf(</Line>
  <Line number="14703">       &quot;INSERT INTO sqlite_schema(type,name,tbl_name,rootpage,sql)&quot;</Line>
  <Line number="14704">       &quot;VALUES(&apos;table&apos;,&apos;%q&apos;,&apos;%q&apos;,0,&apos;%q&apos;);&quot;,</Line>
  <Line number="14705">       zTable, zTable, zSql);</Line>
  <Line number="14706">    utf8_printf(p-&gt;out, &quot;%s\n&quot;, zIns);</Line>
  <Line number="14707">    sqlite3_free(zIns);</Line>
  <Line number="14708">    return 0;</Line>
  <Line number="14709">  }else{</Line>
  <Line number="14710">    printSchemaLine(p-&gt;out, zSql, &quot;;\n&quot;);</Line>
  <Line number="14711">  }</Line>
  <Line number="14712"></Line>
  <Line number="14713">  if( strcmp(zType, &quot;table&quot;)==0 ){</Line>
  <Line number="14714">    ShellText sSelect;</Line>
  <Line number="14715">    ShellText sTable;</Line>
  <Line number="14716">    char **azCol;</Line>
  <Line number="14717">    int i;</Line>
  <Line number="14718">    char *savedDestTable;</Line>
  <Line number="14719">    int savedMode;</Line>
  <Line number="14720"></Line>
  <Line number="14721">    azCol = tableColumnList(p, zTable);</Line>
  <Line number="14722">    if( azCol==0 ){</Line>
  <Line number="14723">      p-&gt;nErr<CheckRefs ids="3037">++</CheckRefs>;</Line>
  <Line number="14724">      return 0;</Line>
  <Line number="14725">    }</Line>
  <Line number="14726"></Line>
  <Line number="14727">    /* Always quote the table name, even if it appears to be pure ascii,</Line>
  <Line number="14728">    ** in case it is a keyword. Ex:  INSERT INTO &quot;table&quot; ... */</Line>
  <Line number="14729">    initText(&amp;sTable);</Line>
  <Line number="14730">    appendText(&amp;sTable, zTable, quoteChar(zTable));</Line>
  <Line number="14731">    /* If preserving the rowid, add a column list after the table name.</Line>
  <Line number="14732">    ** In other words:  &quot;INSERT INTO tab(rowid,a,b,c,...) VALUES(...)&quot;</Line>
  <Line number="14733">    ** instead of the usual &quot;INSERT INTO tab VALUES(...)&quot;.</Line>
  <Line number="14734">    */</Line>
  <Line number="14735">    if( azCol[0] ){</Line>
  <Line number="14736">      appendText(&amp;sTable, &quot;(&quot;, <CheckRefs ids="3038">0</CheckRefs>);</Line>
  <Line number="14737">      appendText(&amp;sTable, azCol[0], <CheckRefs ids="3039">0</CheckRefs>);</Line>
  <Line number="14738">      for(i=1; azCol[i]; i<CheckRefs ids="3040">++</CheckRefs>){</Line>
  <Line number="14739">        appendText(&amp;sTable, &quot;,&quot;, <CheckRefs ids="3041">0</CheckRefs>);</Line>
  <Line number="14740">        appendText(&amp;sTable, azCol[i], quoteChar(azCol[i]));</Line>
  <Line number="14741">      }</Line>
  <Line number="14742">      appendText(&amp;sTable, &quot;)&quot;, <CheckRefs ids="3042">0</CheckRefs>);</Line>
  <Line number="14743">    }</Line>
  <Line number="14744"></Line>
  <Line number="14745">    /* Build an appropriate SELECT statement */</Line>
  <Line number="14746">    initText(&amp;sSelect);</Line>
  <Line number="14747">    appendText(&amp;sSelect, &quot;SELECT &quot;, <CheckRefs ids="3043">0</CheckRefs>);</Line>
  <Line number="14748">    if( azCol[0] ){</Line>
  <Line number="14749">      appendText(&amp;sSelect, azCol[0], <CheckRefs ids="3044">0</CheckRefs>);</Line>
  <Line number="14750">      appendText(&amp;sSelect, &quot;,&quot;, <CheckRefs ids="3045">0</CheckRefs>);</Line>
  <Line number="14751">    }</Line>
  <Line number="14752">    for(i=1; azCol[i]; i<CheckRefs ids="3046">++</CheckRefs>){</Line>
  <Line number="14753">      appendText(&amp;sSelect, azCol[i], quoteChar(azCol[i]));</Line>
  <Line number="14754">      if( azCol[i<CheckRefs ids="3047">+</CheckRefs>1] ){</Line>
  <Line number="14755">        appendText(&amp;sSelect, &quot;,&quot;, <CheckRefs ids="3048">0</CheckRefs>);</Line>
  <Line number="14756">      }</Line>
  <Line number="14757">    }</Line>
  <Line number="14758">    freeColumnList(azCol);</Line>
  <Line number="14759">    appendText(&amp;sSelect, &quot; FROM &quot;, <CheckRefs ids="3049">0</CheckRefs>);</Line>
  <Line number="14760">    appendText(&amp;sSelect, zTable, quoteChar(zTable));</Line>
  <Line number="14761"></Line>
  <Line number="14762">    savedDestTable = p-&gt;zDestTable;</Line>
  <Line number="14763">    savedMode = p-&gt;mode;</Line>
  <Line number="14764">    p-&gt;zDestTable = sTable.z;</Line>
  <Line number="14765">    p-&gt;mode = p-&gt;cMode = MODE_Insert;</Line>
  <Line number="14766">    rc = shell_exec(p, sSelect.z, 0);</Line>
  <Line number="14767">    if( (rc&amp;0xff)==SQLITE_CORRUPT ){</Line>
  <Line number="14768">      raw_printf(p-&gt;out, &quot;/****** CORRUPTION ERROR *******/\n&quot;);</Line>
  <Line number="14769">      toggleSelectOrder(p-&gt;db);</Line>
  <Line number="14770">      shell_exec(p, sSelect.z, 0);</Line>
  <Line number="14771">      toggleSelectOrder(p-&gt;db);</Line>
  <Line number="14772">    }</Line>
  <Line number="14773">    p-&gt;zDestTable = savedDestTable;</Line>
  <Line number="14774">    p-&gt;mode = savedMode;</Line>
  <Line number="14775">    freeText(&amp;sTable);</Line>
  <Line number="14776">    freeText(&amp;sSelect);</Line>
  <Line number="14777">    if( rc ) p-&gt;nErr<CheckRefs ids="3050">++</CheckRefs>;</Line>
  <Line number="14778">  }</Line>
  <Line number="14779">  return 0;</Line>
  <Line number="14780">}</Line>
  <Line number="14781"></Line>
  <Line number="14782">/*</Line>
  <Line number="14783">** Run zQuery.  Use dump_callback() as the callback routine so that</Line>
  <Line number="14784">** the contents of the query are output as SQL statements.</Line>
  <Line number="14785">**</Line>
  <Line number="14786">** If we get a SQLITE_CORRUPT error, rerun the query after appending</Line>
  <Line number="14787">** &quot;ORDER BY rowid DESC&quot; to the end.</Line>
  <Line number="14788">*/</Line>
  <Line number="14789">static int run_schema_dump_query(</Line>
  <Line number="14790">  ShellState *p,</Line>
  <Line number="14791">  const char *zQuery</Line>
  <Line number="14792">){</Line>
  <Line number="14793">  int rc;</Line>
  <Line number="14794">  char *zErr = 0;</Line>
  <Line number="14795">  rc = sqlite3_exec(p-&gt;db, zQuery, dump_callback, p, &amp;zErr);</Line>
  <Line number="14796">  if( rc==SQLITE_CORRUPT ){</Line>
  <Line number="14797">    char *zQ2;</Line>
  <Line number="14798">    int len = strlen30(zQuery);</Line>
  <Line number="14799">    raw_printf(p-&gt;out, &quot;/****** CORRUPTION ERROR *******/\n&quot;);</Line>
  <Line number="14800">    if( zErr ){</Line>
  <Line number="14801">      utf8_printf(p-&gt;out, &quot;/****** %s ******/\n&quot;, zErr);</Line>
  <Line number="14802">      sqlite3_free(zErr);</Line>
  <Line number="14803">      zErr = 0;</Line>
  <Line number="14804">    }</Line>
  <Line number="14805">    zQ2 = malloc( len<CheckRefs ids="3051,3052">+</CheckRefs>100 );</Line>
  <Line number="14806">    if( zQ2==0 ) return rc;</Line>
  <Line number="14807">    sqlite3_snprintf(len<CheckRefs ids="3053">+</CheckRefs>100, zQ2, &quot;%s ORDER BY rowid DESC&quot;, zQuery);</Line>
  <Line number="14808">    rc = sqlite3_exec(p-&gt;db, zQ2, dump_callback, p, &amp;zErr);</Line>
  <Line number="14809">    if( rc ){</Line>
  <Line number="14810">      utf8_printf(p-&gt;out, &quot;/****** ERROR: %s ******/\n&quot;, zErr);</Line>
  <Line number="14811">    }else{</Line>
  <Line number="14812">      rc = SQLITE_CORRUPT;</Line>
  <Line number="14813">    }</Line>
  <Line number="14814">    sqlite3_free(zErr);</Line>
  <Line number="14815">    free(zQ2);</Line>
  <Line number="14816">  }</Line>
  <Line number="14817">  return rc;</Line>
  <Line number="14818">}</Line>
  <Line number="14819"></Line>
  <Line number="14820">/*</Line>
  <Line number="14821">** Text of help messages.</Line>
  <Line number="14822">**</Line>
  <Line number="14823">** The help text for each individual command begins with a line that starts</Line>
  <Line number="14824">** with &quot;.&quot;.  Subsequent lines are supplimental information.</Line>
  <Line number="14825">**</Line>
  <Line number="14826">** There must be two or more spaces between the end of the command and the</Line>
  <Line number="14827">** start of the description of what that command does.</Line>
  <Line number="14828">*/</Line>
  <Line number="14829">static const char *(azHelp[]) = {</Line>
  <Line number="14830">#if defined(SQLITE_HAVE_ZLIB) &amp;&amp; !defined(SQLITE_OMIT_VIRTUALTABLE)</Line>
  <Line number="14831">  &quot;.archive ...             Manage SQL archives&quot;,</Line>
  <Line number="14832">  &quot;   Each command must have exactly one of the following options:&quot;,</Line>
  <Line number="14833">  &quot;     -c, --create               Create a new archive&quot;,</Line>
  <Line number="14834">  &quot;     -u, --update               Add or update files with changed mtime&quot;,</Line>
  <Line number="14835">  &quot;     -i, --insert               Like -u but always add even if unchanged&quot;,</Line>
  <Line number="14836">  &quot;     -t, --list                 List contents of archive&quot;,</Line>
  <Line number="14837">  &quot;     -x, --extract              Extract files from archive&quot;,</Line>
  <Line number="14838">  &quot;   Optional arguments:&quot;,</Line>
  <Line number="14839">  &quot;     -v, --verbose              Print each filename as it is processed&quot;,</Line>
  <Line number="14840">  &quot;     -f FILE, --file FILE       Use archive FILE (default is current db)&quot;,</Line>
  <Line number="14841">  &quot;     -a FILE, --append FILE     Open FILE using the apndvfs VFS&quot;,</Line>
  <Line number="14842">  &quot;     -C DIR, --directory DIR    Read/extract files from directory DIR&quot;,</Line>
  <Line number="14843">  &quot;     -n, --dryrun               Show the SQL that would have occurred&quot;,</Line>
  <Line number="14844">  &quot;   Examples:&quot;,</Line>
  <Line number="14845">  &quot;     .ar -cf ARCHIVE foo bar  # Create ARCHIVE from files foo and bar&quot;,</Line>
  <Line number="14846">  &quot;     .ar -tf ARCHIVE          # List members of ARCHIVE&quot;,</Line>
  <Line number="14847">  &quot;     .ar -xvf ARCHIVE         # Verbosely extract files from ARCHIVE&quot;,</Line>
  <Line number="14848">  &quot;   See also:&quot;,</Line>
  <Line number="14849">  &quot;      http://sqlite.org/cli.html#sqlite_archive_support&quot;,</Line>
  <Line number="14850">#endif</Line>
  <Line number="14851">#ifndef SQLITE_OMIT_AUTHORIZATION</Line>
  <Line number="14852">  &quot;.auth ON|OFF             Show authorizer callbacks&quot;,</Line>
  <Line number="14853">#endif</Line>
  <Line number="14854">  &quot;.backup ?DB? FILE        Backup DB (default \&quot;main\&quot;) to FILE&quot;,</Line>
  <Line number="14855">  &quot;       --append            Use the appendvfs&quot;,</Line>
  <Line number="14856">  &quot;       --async             Write to FILE without journal and fsync()&quot;,</Line>
  <Line number="14857">  &quot;.bail on|off             Stop after hitting an error.  Default OFF&quot;,</Line>
  <Line number="14858">  &quot;.binary on|off           Turn binary output on or off.  Default OFF&quot;,</Line>
  <Line number="14859">  &quot;.cd DIRECTORY            Change the working directory to DIRECTORY&quot;,</Line>
  <Line number="14860">  &quot;.changes on|off          Show number of rows changed by SQL&quot;,</Line>
  <Line number="14861">  &quot;.check GLOB              Fail if output since .testcase does not match&quot;,</Line>
  <Line number="14862">  &quot;.clone NEWDB             Clone data into NEWDB from the existing database&quot;,</Line>
  <Line number="14863">  &quot;.databases               List names and files of attached databases&quot;,</Line>
  <Line number="14864">  &quot;.dbconfig ?op? ?val?     List or change sqlite3_db_config() options&quot;,</Line>
  <Line number="14865">  &quot;.dbinfo ?DB?             Show status information about the database&quot;,</Line>
  <Line number="14866">  &quot;.dump ?OBJECTS?          Render database content as SQL&quot;,</Line>
  <Line number="14867">  &quot;   Options:&quot;,</Line>
  <Line number="14868">  &quot;     --data-only            Output only INSERT statements&quot;,</Line>
  <Line number="14869">  &quot;     --newlines             Allow unescaped newline characters in output&quot;,</Line>
  <Line number="14870">  &quot;     --nosys                Omit system tables (ex: \&quot;sqlite_stat1\&quot;)&quot;,</Line>
  <Line number="14871">  &quot;     --preserve-rowids      Include ROWID values in the output&quot;,</Line>
  <Line number="14872">  &quot;   OBJECTS is a LIKE pattern for tables, indexes, triggers or views to dump&quot;,</Line>
  <Line number="14873">  &quot;   Additional LIKE patterns can be given in subsequent arguments&quot;,</Line>
  <Line number="14874">  &quot;.echo on|off             Turn command echo on or off&quot;,</Line>
  <Line number="14875">  &quot;.eqp on|off|full|...     Enable or disable automatic EXPLAIN QUERY PLAN&quot;,</Line>
  <Line number="14876">  &quot;   Other Modes:&quot;,</Line>
  <Line number="14877">#ifdef SQLITE_DEBUG</Line>
  <Line number="14878">  &quot;      test                  Show raw EXPLAIN QUERY PLAN output&quot;,</Line>
  <Line number="14879">  &quot;      trace                 Like \&quot;full\&quot; but enable \&quot;PRAGMA vdbe_trace\&quot;&quot;,</Line>
  <Line number="14880">#endif</Line>
  <Line number="14881">  &quot;      trigger               Like \&quot;full\&quot; but also show trigger bytecode&quot;,</Line>
  <Line number="14882">  &quot;.excel                   Display the output of next command in spreadsheet&quot;,</Line>
  <Line number="14883">  &quot;   --bom                   Put a UTF8 byte-order mark on intermediate file&quot;,</Line>
  <Line number="14884">  &quot;.exit ?CODE?             Exit this program with return-code CODE&quot;,</Line>
  <Line number="14885">  &quot;.expert                  EXPERIMENTAL. Suggest indexes for queries&quot;,</Line>
  <Line number="14886">  &quot;.explain ?on|off|auto?   Change the EXPLAIN formatting mode.  Default: auto&quot;,</Line>
  <Line number="14887">  &quot;.filectrl CMD ...        Run various sqlite3_file_control() operations&quot;,</Line>
  <Line number="14888">  &quot;   --schema SCHEMA         Use SCHEMA instead of \&quot;main\&quot;&quot;,</Line>
  <Line number="14889">  &quot;   --help                  Show CMD details&quot;,</Line>
  <Line number="14890">  &quot;.fullschema ?--indent?   Show schema and the content of sqlite_stat tables&quot;,</Line>
  <Line number="14891">  &quot;.headers on|off          Turn display of headers on or off&quot;,</Line>
  <Line number="14892">  &quot;.help ?-all? ?PATTERN?   Show help text for PATTERN&quot;,</Line>
  <Line number="14893">  &quot;.import FILE TABLE       Import data from FILE into TABLE&quot;,</Line>
  <Line number="14894">  &quot;   Options:&quot;,</Line>
  <Line number="14895">  &quot;     --ascii               Use \\037 and \\036 as column and row separators&quot;,</Line>
  <Line number="14896">  &quot;     --csv                 Use , and \\n as column and row separators&quot;,</Line>
  <Line number="14897">  &quot;     --skip N              Skip the first N rows of input&quot;,</Line>
  <Line number="14898">  &quot;     -v                    \&quot;Verbose\&quot; - increase auxiliary output&quot;,</Line>
  <Line number="14899">  &quot;   Notes:&quot;,</Line>
  <Line number="14900">  &quot;     *  If TABLE does not exist, it is created.  The first row of input&quot;,</Line>
  <Line number="14901">  &quot;        determines the column names.&quot;,</Line>
  <Line number="14902">  &quot;     *  If neither --csv or --ascii are used, the input mode is derived&quot;,</Line>
  <Line number="14903">  &quot;        from the \&quot;.mode\&quot; output mode&quot;,</Line>
  <Line number="14904">  &quot;     *  If FILE begins with \&quot;|\&quot; then it is a command that generates the&quot;,</Line>
  <Line number="14905">  &quot;        input text.&quot;,</Line>
  <Line number="14906">#ifndef SQLITE_OMIT_TEST_CONTROL</Line>
  <Line number="14907">  &quot;.imposter INDEX TABLE    Create imposter table TABLE on index INDEX&quot;,</Line>
  <Line number="14908">#endif</Line>
  <Line number="14909">  &quot;.indexes ?TABLE?         Show names of indexes&quot;,</Line>
  <Line number="14910">  &quot;                           If TABLE is specified, only show indexes for&quot;,</Line>
  <Line number="14911">  &quot;                           tables matching TABLE using the LIKE operator.&quot;,</Line>
  <Line number="14912">#ifdef SQLITE_ENABLE_IOTRACE</Line>
  <Line number="14913">  &quot;.iotrace FILE            Enable I/O diagnostic logging to FILE&quot;,</Line>
  <Line number="14914">#endif</Line>
  <Line number="14915">  &quot;.limit ?LIMIT? ?VAL?     Display or change the value of an SQLITE_LIMIT&quot;,</Line>
  <Line number="14916">  &quot;.lint OPTIONS            Report potential schema issues.&quot;,</Line>
  <Line number="14917">  &quot;     Options:&quot;,</Line>
  <Line number="14918">  &quot;        fkey-indexes     Find missing foreign key indexes&quot;,</Line>
  <Line number="14919">#ifndef SQLITE_OMIT_LOAD_EXTENSION</Line>
  <Line number="14920">  &quot;.load FILE ?ENTRY?       Load an extension library&quot;,</Line>
  <Line number="14921">#endif</Line>
  <Line number="14922">  &quot;.log FILE|off            Turn logging on or off.  FILE can be stderr/stdout&quot;,</Line>
  <Line number="14923">  &quot;.mode MODE ?TABLE?       Set output mode&quot;,</Line>
  <Line number="14924">  &quot;   MODE is one of:&quot;,</Line>
  <Line number="14925">  &quot;     ascii     Columns/rows delimited by 0x1F and 0x1E&quot;,</Line>
  <Line number="14926">  &quot;     box       Tables using unicode box-drawing characters&quot;,</Line>
  <Line number="14927">  &quot;     csv       Comma-separated values&quot;,</Line>
  <Line number="14928">  &quot;     column    Output in columns.  (See .width)&quot;,</Line>
  <Line number="14929">  &quot;     html      HTML &lt;table&gt; code&quot;,</Line>
  <Line number="14930">  &quot;     insert    SQL insert statements for TABLE&quot;,</Line>
  <Line number="14931">  &quot;     json      Results in a JSON array&quot;,</Line>
  <Line number="14932">  &quot;     line      One value per line&quot;,</Line>
  <Line number="14933">  &quot;     list      Values delimited by \&quot;|\&quot;&quot;,</Line>
  <Line number="14934">  &quot;     markdown  Markdown table format&quot;,</Line>
  <Line number="14935">  &quot;     quote     Escape answers as for SQL&quot;,</Line>
  <Line number="14936">  &quot;     table     ASCII-art table&quot;,</Line>
  <Line number="14937">  &quot;     tabs      Tab-separated values&quot;,</Line>
  <Line number="14938">  &quot;     tcl       TCL list elements&quot;,</Line>
  <Line number="14939">  &quot;.nullvalue STRING        Use STRING in place of NULL values&quot;,</Line>
  <Line number="14940">  &quot;.once ?OPTIONS? ?FILE?   Output for the next SQL command only to FILE&quot;,</Line>
  <Line number="14941">  &quot;     If FILE begins with &apos;|&apos; then open as a pipe&quot;,</Line>
  <Line number="14942">  &quot;       --bom  Put a UTF8 byte-order mark at the beginning&quot;,</Line>
  <Line number="14943">  &quot;       -e     Send output to the system text editor&quot;,</Line>
  <Line number="14944">  &quot;       -x     Send output as CSV to a spreadsheet (same as \&quot;.excel\&quot;)&quot;,</Line>
  <Line number="14945">#ifdef SQLITE_DEBUG</Line>
  <Line number="14946">  &quot;.oom ?--repeat M? ?N?    Simulate an OOM error on the N-th allocation&quot;,</Line>
  <Line number="14947">#endif </Line>
  <Line number="14948">  &quot;.open ?OPTIONS? ?FILE?   Close existing database and reopen FILE&quot;,</Line>
  <Line number="14949">  &quot;     Options:&quot;,</Line>
  <Line number="14950">  &quot;        --append        Use appendvfs to append database to the end of FILE&quot;,</Line>
  <Line number="14951">#ifndef SQLITE_OMIT_DESERIALIZE</Line>
  <Line number="14952">  &quot;        --deserialize   Load into memory using sqlite3_deserialize()&quot;,</Line>
  <Line number="14953">  &quot;        --hexdb         Load the output of \&quot;dbtotxt\&quot; as an in-memory db&quot;,</Line>
  <Line number="14954">  &quot;        --maxsize N     Maximum size for --hexdb or --deserialized database&quot;,</Line>
  <Line number="14955">#endif</Line>
  <Line number="14956">  &quot;        --new           Initialize FILE to an empty database&quot;,</Line>
  <Line number="14957">  &quot;        --nofollow      Do not follow symbolic links&quot;,</Line>
  <Line number="14958">  &quot;        --readonly      Open FILE readonly&quot;,</Line>
  <Line number="14959">  &quot;        --zip           FILE is a ZIP archive&quot;,</Line>
  <Line number="14960">  &quot;.output ?FILE?           Send output to FILE or stdout if FILE is omitted&quot;,</Line>
  <Line number="14961">  &quot;   If FILE begins with &apos;|&apos; then open it as a pipe.&quot;,</Line>
  <Line number="14962">  &quot;   Options:&quot;,</Line>
  <Line number="14963">  &quot;     --bom                 Prefix output with a UTF8 byte-order mark&quot;,</Line>
  <Line number="14964">  &quot;     -e                    Send output to the system text editor&quot;,</Line>
  <Line number="14965">  &quot;     -x                    Send output as CSV to a spreadsheet&quot;,</Line>
  <Line number="14966">  &quot;.parameter CMD ...       Manage SQL parameter bindings&quot;,</Line>
  <Line number="14967">  &quot;   clear                   Erase all bindings&quot;,</Line>
  <Line number="14968">  &quot;   init                    Initialize the TEMP table that holds bindings&quot;,</Line>
  <Line number="14969">  &quot;   list                    List the current parameter bindings&quot;,</Line>
  <Line number="14970">  &quot;   set PARAMETER VALUE     Given SQL parameter PARAMETER a value of VALUE&quot;,</Line>
  <Line number="14971">  &quot;                           PARAMETER should start with one of: $ : @ ?&quot;,</Line>
  <Line number="14972">  &quot;   unset PARAMETER         Remove PARAMETER from the binding table&quot;,</Line>
  <Line number="14973">  &quot;.print STRING...         Print literal STRING&quot;,</Line>
  <Line number="14974">#ifndef SQLITE_OMIT_PROGRESS_CALLBACK</Line>
  <Line number="14975">  &quot;.progress N              Invoke progress handler after every N opcodes&quot;,</Line>
  <Line number="14976">  &quot;   --limit N                 Interrupt after N progress callbacks&quot;,</Line>
  <Line number="14977">  &quot;   --once                    Do no more than one progress interrupt&quot;,</Line>
  <Line number="14978">  &quot;   --quiet|-q                No output except at interrupts&quot;,</Line>
  <Line number="14979">  &quot;   --reset                   Reset the count for each input and interrupt&quot;,</Line>
  <Line number="14980">#endif</Line>
  <Line number="14981">  &quot;.prompt MAIN CONTINUE    Replace the standard prompts&quot;,</Line>
  <Line number="14982">  &quot;.quit                    Exit this program&quot;,</Line>
  <Line number="14983">  &quot;.read FILE               Read input from FILE&quot;,</Line>
  <Line number="14984">#if !defined(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; defined(SQLITE_ENABLE_DBPAGE_VTAB)</Line>
  <Line number="14985">  &quot;.recover                 Recover as much data as possible from corrupt db.&quot;,</Line>
  <Line number="14986">  &quot;   --freelist-corrupt       Assume the freelist is corrupt&quot;,</Line>
  <Line number="14987">  &quot;   --recovery-db NAME       Store recovery metadata in database file NAME&quot;,</Line>
  <Line number="14988">  &quot;   --lost-and-found TABLE   Alternative name for the lost-and-found table&quot;,</Line>
  <Line number="14989">  &quot;   --no-rowids              Do not attempt to recover rowid values&quot;,</Line>
  <Line number="14990">  &quot;                            that are not also INTEGER PRIMARY KEYs&quot;,</Line>
  <Line number="14991">#endif</Line>
  <Line number="14992">  &quot;.restore ?DB? FILE       Restore content of DB (default \&quot;main\&quot;) from FILE&quot;,</Line>
  <Line number="14993">  &quot;.save FILE               Write in-memory database into FILE&quot;,</Line>
  <Line number="14994">  &quot;.scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off&quot;,</Line>
  <Line number="14995">  &quot;.schema ?PATTERN?        Show the CREATE statements matching PATTERN&quot;,</Line>
  <Line number="14996">  &quot;   Options:&quot;,</Line>
  <Line number="14997">  &quot;      --indent             Try to pretty-print the schema&quot;,</Line>
  <Line number="14998">  &quot;      --nosys              Omit objects whose names start with \&quot;sqlite_\&quot;&quot;,</Line>
  <Line number="14999">  &quot;.selftest ?OPTIONS?      Run tests defined in the SELFTEST table&quot;,</Line>
  <Line number="15000">  &quot;    Options:&quot;,</Line>
  <Line number="15001">  &quot;       --init               Create a new SELFTEST table&quot;,</Line>
  <Line number="15002">  &quot;       -v                   Verbose output&quot;,</Line>
  <Line number="15003">  &quot;.separator COL ?ROW?     Change the column and row separators&quot;,</Line>
  <Line number="15004">#if defined(SQLITE_ENABLE_SESSION)</Line>
  <Line number="15005">  &quot;.session ?NAME? CMD ...  Create or control sessions&quot;,</Line>
  <Line number="15006">  &quot;   Subcommands:&quot;,</Line>
  <Line number="15007">  &quot;     attach TABLE             Attach TABLE&quot;,</Line>
  <Line number="15008">  &quot;     changeset FILE           Write a changeset into FILE&quot;,</Line>
  <Line number="15009">  &quot;     close                    Close one session&quot;,</Line>
  <Line number="15010">  &quot;     enable ?BOOLEAN?         Set or query the enable bit&quot;,</Line>
  <Line number="15011">  &quot;     filter GLOB...           Reject tables matching GLOBs&quot;,</Line>
  <Line number="15012">  &quot;     indirect ?BOOLEAN?       Mark or query the indirect status&quot;,</Line>
  <Line number="15013">  &quot;     isempty                  Query whether the session is empty&quot;,</Line>
  <Line number="15014">  &quot;     list                     List currently open session names&quot;,</Line>
  <Line number="15015">  &quot;     open DB NAME             Open a new session on DB&quot;,</Line>
  <Line number="15016">  &quot;     patchset FILE            Write a patchset into FILE&quot;,</Line>
  <Line number="15017">  &quot;   If ?NAME? is omitted, the first defined session is used.&quot;,</Line>
  <Line number="15018">#endif</Line>
  <Line number="15019">  &quot;.sha3sum ...             Compute a SHA3 hash of database content&quot;,</Line>
  <Line number="15020">  &quot;    Options:&quot;,</Line>
  <Line number="15021">  &quot;      --schema              Also hash the sqlite_schema table&quot;,</Line>
  <Line number="15022">  &quot;      --sha3-224            Use the sha3-224 algorithm&quot;,</Line>
  <Line number="15023">  &quot;      --sha3-256            Use the sha3-256 algorithm (default)&quot;,</Line>
  <Line number="15024">  &quot;      --sha3-384            Use the sha3-384 algorithm&quot;,</Line>
  <Line number="15025">  &quot;      --sha3-512            Use the sha3-512 algorithm&quot;,</Line>
  <Line number="15026">  &quot;    Any other argument is a LIKE pattern for tables to hash&quot;,</Line>
  <Line number="15027">#ifndef SQLITE_NOHAVE_SYSTEM</Line>
  <Line number="15028">  &quot;.shell CMD ARGS...       Run CMD ARGS... in a system shell&quot;,</Line>
  <Line number="15029">#endif</Line>
  <Line number="15030">  &quot;.show                    Show the current values for various settings&quot;,</Line>
  <Line number="15031">  &quot;.stats ?ARG?             Show stats or turn stats on or off&quot;,</Line>
  <Line number="15032">  &quot;   off                      Turn off automatic stat display&quot;,</Line>
  <Line number="15033">  &quot;   on                       Turn on automatic stat display&quot;,</Line>
  <Line number="15034">  &quot;   stmt                     Show statement stats&quot;,</Line>
  <Line number="15035">  &quot;   vmstep                   Show the virtual machine step count only&quot;,</Line>
  <Line number="15036">#ifndef SQLITE_NOHAVE_SYSTEM</Line>
  <Line number="15037">  &quot;.system CMD ARGS...      Run CMD ARGS... in a system shell&quot;,</Line>
  <Line number="15038">#endif</Line>
  <Line number="15039">  &quot;.tables ?TABLE?          List names of tables matching LIKE pattern TABLE&quot;,</Line>
  <Line number="15040">  &quot;.testcase NAME           Begin redirecting output to &apos;testcase-out.txt&apos;&quot;,</Line>
  <Line number="15041">  &quot;.testctrl CMD ...        Run various sqlite3_test_control() operations&quot;,</Line>
  <Line number="15042">  &quot;                           Run \&quot;.testctrl\&quot; with no arguments for details&quot;,</Line>
  <Line number="15043">  &quot;.timeout MS              Try opening locked tables for MS milliseconds&quot;,</Line>
  <Line number="15044">  &quot;.timer on|off            Turn SQL timer on or off&quot;,</Line>
  <Line number="15045">#ifndef SQLITE_OMIT_TRACE</Line>
  <Line number="15046">  &quot;.trace ?OPTIONS?         Output each SQL statement as it is run&quot;,</Line>
  <Line number="15047">  &quot;    FILE                    Send output to FILE&quot;,</Line>
  <Line number="15048">  &quot;    stdout                  Send output to stdout&quot;,</Line>
  <Line number="15049">  &quot;    stderr                  Send output to stderr&quot;,</Line>
  <Line number="15050">  &quot;    off                     Disable tracing&quot;,</Line>
  <Line number="15051">  &quot;    --expanded              Expand query parameters&quot;,</Line>
  <Line number="15052">#ifdef SQLITE_ENABLE_NORMALIZE</Line>
  <Line number="15053">  &quot;    --normalized            Normal the SQL statements&quot;,</Line>
  <Line number="15054">#endif</Line>
  <Line number="15055">  &quot;    --plain                 Show SQL as it is input&quot;,</Line>
  <Line number="15056">  &quot;    --stmt                  Trace statement execution (SQLITE_TRACE_STMT)&quot;,</Line>
  <Line number="15057">  &quot;    --profile               Profile statements (SQLITE_TRACE_PROFILE)&quot;,</Line>
  <Line number="15058">  &quot;    --row                   Trace each row (SQLITE_TRACE_ROW)&quot;,</Line>
  <Line number="15059">  &quot;    --close                 Trace connection close (SQLITE_TRACE_CLOSE)&quot;,</Line>
  <Line number="15060">#endif /* SQLITE_OMIT_TRACE */</Line>
  <Line number="15061">#ifdef SQLITE_DEBUG</Line>
  <Line number="15062">  &quot;.unmodule NAME ...       Unregister virtual table modules&quot;,</Line>
  <Line number="15063">  &quot;    --allexcept             Unregister everything except those named&quot;,</Line>
  <Line number="15064">#endif</Line>
  <Line number="15065">  &quot;.vfsinfo ?AUX?           Information about the top-level VFS&quot;,</Line>
  <Line number="15066">  &quot;.vfslist                 List all available VFSes&quot;,</Line>
  <Line number="15067">  &quot;.vfsname ?AUX?           Print the name of the VFS stack&quot;,</Line>
  <Line number="15068">  &quot;.width NUM1 NUM2 ...     Set minimum column widths for columnar output&quot;,</Line>
  <Line number="15069">  &quot;     Negative values right-justify&quot;,</Line>
  <Line number="15070">};</Line>
  <Line number="15071"></Line>
  <Line number="15072">/*</Line>
  <Line number="15073">** Output help text.</Line>
  <Line number="15074">**</Line>
  <Line number="15075">** zPattern describes the set of commands for which help text is provided.</Line>
  <Line number="15076">** If zPattern is NULL, then show all commands, but only give a one-line</Line>
  <Line number="15077">** description of each.</Line>
  <Line number="15078">**</Line>
  <Line number="15079">** Return the number of matches.</Line>
  <Line number="15080">*/</Line>
  <Line number="15081">static int showHelp(FILE *out, const char *zPattern){</Line>
  <Line number="15082">  int i = 0;</Line>
  <Line number="15083">  int j = 0;</Line>
  <Line number="15084">  int n = 0;</Line>
  <Line number="15085">  char *zPat;</Line>
  <Line number="15086">  if( zPattern==0</Line>
  <Line number="15087">   || <CheckRefs ids="3054">zPattern</CheckRefs>[0]==&apos;0&apos;</Line>
  <Line number="15088">   || strcmp(zPattern,&quot;-a&quot;)==0</Line>
  <Line number="15089">   || strcmp(zPattern,&quot;-all&quot;)==0</Line>
  <Line number="15090">   || strcmp(zPattern,&quot;--all&quot;)==0</Line>
  <Line number="15091">  ){</Line>
  <Line number="15092">    /* Show all commands, but only one line per command */</Line>
  <Line number="15093">    if( zPattern==0 ) zPattern = &quot;&quot;;</Line>
  <Line number="15094">    for(i=0; i&lt;<CheckRefs ids="3055,3056,3057">ArraySize</CheckRefs>(azHelp); i<CheckRefs ids="3058">++</CheckRefs>){</Line>
  <Line number="15095">      if( <CheckRefs ids="3059">azHelp</CheckRefs>[i<CheckRefs ids="3060">]</CheckRefs>[0]==&apos;.&apos; || <CheckRefs ids="3061">zPattern</CheckRefs>[0] ){</Line>
  <Line number="15096">        utf8_printf(out, &quot;%s\n&quot;, azHelp[i<CheckRefs ids="3062">]</CheckRefs>);</Line>
  <Line number="15097">        n<CheckRefs ids="3063">++</CheckRefs>;</Line>
  <Line number="15098">      }</Line>
  <Line number="15099">    }</Line>
  <Line number="15100">  }else{</Line>
  <Line number="15101">    /* Look for commands that for which zPattern is an exact prefix */</Line>
  <Line number="15102">    zPat = sqlite3_mprintf(&quot;.%s*&quot;, zPattern);</Line>
  <Line number="15103">    for(i=0; i&lt;<CheckRefs ids="3064,3065,3066">ArraySize</CheckRefs>(azHelp); i<CheckRefs ids="3067">++</CheckRefs>){</Line>
  <Line number="15104">      if( sqlite3_strglob(zPat, azHelp[i<CheckRefs ids="3068">]</CheckRefs>)==0 ){</Line>
  <Line number="15105">        utf8_printf(out, &quot;%s\n&quot;, azHelp[i<CheckRefs ids="3069">]</CheckRefs>);</Line>
  <Line number="15106">        j = i<CheckRefs ids="3070">+</CheckRefs>1;</Line>
  <Line number="15107">        n<CheckRefs ids="3071">++</CheckRefs>;</Line>
  <Line number="15108">      }</Line>
  <Line number="15109">    }</Line>
  <Line number="15110">    sqlite3_free(zPat);</Line>
  <Line number="15111">    if( n ){</Line>
  <Line number="15112">      if( n==1 ){</Line>
  <Line number="15113">        /* when zPattern is a prefix of exactly one command, then include the</Line>
  <Line number="15114">        ** details of that command, which should begin at offset j */</Line>
  <Line number="15115">        while( j&lt;<CheckRefs ids="3073,3074,3075">ArraySize</CheckRefs>(azHelp)<CheckRefs ids="3072">-</CheckRefs>1 &amp;&amp; <CheckRefs ids="3076">azHelp</CheckRefs>[j<CheckRefs ids="3077">]</CheckRefs>[0]!=&apos;.&apos; ){</Line>
  <Line number="15116">          utf8_printf(out, &quot;%s\n&quot;, azHelp[j<CheckRefs ids="3078">]</CheckRefs>);</Line>
  <Line number="15117">          j<CheckRefs ids="3079">++</CheckRefs>;</Line>
  <Line number="15118">        }</Line>
  <Line number="15119">      }</Line>
  <Line number="15120">      return n;</Line>
  <Line number="15121">    }</Line>
  <Line number="15122">    /* Look for commands that contain zPattern anywhere.  Show the complete</Line>
  <Line number="15123">    ** text of all commands that match. */</Line>
  <Line number="15124">    zPat = sqlite3_mprintf(&quot;%%%s%%&quot;, zPattern);</Line>
  <Line number="15125">    for(i=0; i&lt;<CheckRefs ids="3080,3081,3082">ArraySize</CheckRefs>(azHelp); i<CheckRefs ids="3083">++</CheckRefs>){</Line>
  <Line number="15126">      if( <CheckRefs ids="3084">azHelp</CheckRefs>[i<CheckRefs ids="3085">]</CheckRefs>[0]==&apos;.&apos; ) j = i;</Line>
  <Line number="15127">      if( sqlite3_strlike(zPat, azHelp[i<CheckRefs ids="3086">]</CheckRefs>, <CheckRefs ids="3087">0</CheckRefs>)==0 ){</Line>
  <Line number="15128">        utf8_printf(out, &quot;%s\n&quot;, azHelp[j<CheckRefs ids="3088">]</CheckRefs>);</Line>
  <Line number="15129">        while( j&lt;<CheckRefs ids="3090,3091,3092">ArraySize</CheckRefs>(azHelp)<CheckRefs ids="3089">-</CheckRefs>1 &amp;&amp; <CheckRefs ids="3093">azHelp</CheckRefs>[j<CheckRefs ids="3095">+</CheckRefs>1<CheckRefs ids="3094">]</CheckRefs>[0]!=&apos;.&apos; ){</Line>
  <Line number="15130">          j<CheckRefs ids="3096">++</CheckRefs>;</Line>
  <Line number="15131">          utf8_printf(out, &quot;%s\n&quot;, azHelp[j<CheckRefs ids="3097">]</CheckRefs>);</Line>
  <Line number="15132">        }</Line>
  <Line number="15133">        i = j;</Line>
  <Line number="15134">        n<CheckRefs ids="3098">++</CheckRefs>;</Line>
  <Line number="15135">      }</Line>
  <Line number="15136">    }</Line>
  <Line number="15137">    sqlite3_free(zPat);</Line>
  <Line number="15138">  }</Line>
  <Line number="15139">  return n;</Line>
  <Line number="15140">}</Line>
  <Line number="15141"></Line>
  <Line number="15142">/* Forward reference */</Line>
  <Line number="15143">static int process_input(ShellState *p);</Line>
  <Line number="15144"></Line>
  <Line number="15145">/*</Line>
  <Line number="15146">** Read the content of file zName into memory obtained from sqlite3_malloc64()</Line>
  <Line number="15147">** and return a pointer to the buffer. The caller is responsible for freeing</Line>
  <Line number="15148">** the memory.</Line>
  <Line number="15149">**</Line>
  <Line number="15150">** If parameter pnByte is not NULL, (*pnByte) is set to the number of bytes</Line>
  <Line number="15151">** read.</Line>
  <Line number="15152">**</Line>
  <Line number="15153">** For convenience, a nul-terminator byte is always appended to the data read</Line>
  <Line number="15154">** from the file before the buffer is returned. This byte is not included in</Line>
  <Line number="15155">** the final value of (*pnByte), if applicable.</Line>
  <Line number="15156">**</Line>
  <Line number="15157">** NULL is returned if any error is encountered. The final value of *pnByte</Line>
  <Line number="15158">** is undefined in this case.</Line>
  <Line number="15159">*/</Line>
  <Line number="15160">static char *readFile(const char *zName, int *pnByte){</Line>
  <Line number="15161">  FILE *in = fopen(zName, &quot;rb&quot;);</Line>
  <Line number="15162">  long nIn;</Line>
  <Line number="15163">  size_t nRead;</Line>
  <Line number="15164">  char *pBuf;</Line>
  <Line number="15165">  if( in==0 ) return 0;</Line>
  <Line number="15166">  fseek(in, <CheckRefs ids="3099">0</CheckRefs>, SEEK_END);</Line>
  <Line number="15167">  nIn = ftell(in);</Line>
  <Line number="15168">  rewind(in);</Line>
  <Line number="15169">  pBuf = sqlite3_malloc64( nIn<CheckRefs ids="3100,3101">+</CheckRefs><CheckRefs ids="3102">1</CheckRefs> );</Line>
  <Line number="15170">  if( pBuf==0 ){ fclose(in); return 0; }</Line>
  <Line number="15171">  nRead = fread(pBuf, <CheckRefs ids="3103">nIn</CheckRefs>, <CheckRefs ids="3104">1</CheckRefs>, in);</Line>
  <Line number="15172">  fclose(in);</Line>
  <Line number="15173">  if( nRead!=<CheckRefs ids="3105">1</CheckRefs> ){</Line>
  <Line number="15174">    sqlite3_free(pBuf);</Line>
  <Line number="15175">    return 0;</Line>
  <Line number="15176">  }</Line>
  <Line number="15177">  pBuf[nIn] = <CheckRefs ids="3106">0</CheckRefs>;</Line>
  <Line number="15178">  if( pnByte ) *pnByte = <CheckRefs ids="3107">nIn</CheckRefs>;</Line>
  <Line number="15179">  return pBuf;</Line>
  <Line number="15180">}</Line>
  <Line number="15181"></Line>
  <Line number="15182">#if defined(SQLITE_ENABLE_SESSION)</Line>
  <Line number="15183">/*</Line>
  <Line number="15184">** Close a single OpenSession object and release all of its associated</Line>
  <Line number="15185">** resources.</Line>
  <Line number="15186">*/</Line>
  <Line number="15187">static void session_close(OpenSession *pSession){</Line>
  <Line number="15188">  int i;</Line>
  <Line number="15189">  sqlite3session_delete(pSession-&gt;p);</Line>
  <Line number="15190">  sqlite3_free(pSession-&gt;zName);</Line>
  <Line number="15191">  for(i=0; i&lt;pSession-&gt;nFilter; i++){</Line>
  <Line number="15192">    sqlite3_free(pSession-&gt;azFilter[i]);</Line>
  <Line number="15193">  }</Line>
  <Line number="15194">  sqlite3_free(pSession-&gt;azFilter);</Line>
  <Line number="15195">  memset(pSession, 0, sizeof(OpenSession));</Line>
  <Line number="15196">}</Line>
  <Line number="15197">#endif</Line>
  <Line number="15198"></Line>
  <Line number="15199">/*</Line>
  <Line number="15200">** Close all OpenSession objects and release all associated resources.</Line>
  <Line number="15201">*/</Line>
  <Line number="15202">#if defined(SQLITE_ENABLE_SESSION)</Line>
  <Line number="15203">static void session_close_all(ShellState *p){</Line>
  <Line number="15204">  int i;</Line>
  <Line number="15205">  for(i=0; i&lt;p-&gt;nSession; i++){</Line>
  <Line number="15206">    session_close(&amp;p-&gt;aSession[i]);</Line>
  <Line number="15207">  }</Line>
  <Line number="15208">  p-&gt;nSession = 0;</Line>
  <Line number="15209">}</Line>
  <Line number="15210">#else</Line>
  <Line number="15211"># define session_close_all(X)</Line>
  <Line number="15212">#endif</Line>
  <Line number="15213"></Line>
  <Line number="15214">/*</Line>
  <Line number="15215">** Implementation of the xFilter function for an open session.  Omit</Line>
  <Line number="15216">** any tables named by &quot;.session filter&quot; but let all other table through.</Line>
  <Line number="15217">*/</Line>
  <Line number="15218">#if defined(SQLITE_ENABLE_SESSION)</Line>
  <Line number="15219">static int session_filter(void *pCtx, const char *zTab){</Line>
  <Line number="15220">  OpenSession *pSession = (OpenSession*)pCtx;</Line>
  <Line number="15221">  int i;</Line>
  <Line number="15222">  for(i=0; i&lt;pSession-&gt;nFilter; i++){</Line>
  <Line number="15223">    if( sqlite3_strglob(pSession-&gt;azFilter[i], zTab)==0 ) return 0;</Line>
  <Line number="15224">  }</Line>
  <Line number="15225">  return 1;</Line>
  <Line number="15226">}</Line>
  <Line number="15227">#endif</Line>
  <Line number="15228"></Line>
  <Line number="15229">/*</Line>
  <Line number="15230">** Try to deduce the type of file for zName based on its content.  Return</Line>
  <Line number="15231">** one of the SHELL_OPEN_* constants.</Line>
  <Line number="15232">**</Line>
  <Line number="15233">** If the file does not exist or is empty but its name looks like a ZIP</Line>
  <Line number="15234">** archive and the dfltZip flag is true, then assume it is a ZIP archive.</Line>
  <Line number="15235">** Otherwise, assume an ordinary database regardless of the filename if</Line>
  <Line number="15236">** the type cannot be determined from content.</Line>
  <Line number="15237">*/</Line>
  <Line number="15238">int deduceDatabaseType(const char *zName, int dfltZip){</Line>
  <Line number="15239">  FILE *f = fopen(zName, &quot;rb&quot;);</Line>
  <Line number="15240">  size_t n;</Line>
  <Line number="15241">  int rc = SHELL_OPEN_UNSPEC;</Line>
  <Line number="15242">  char zBuf[100];</Line>
  <Line number="15243">  if( f==0 ){</Line>
  <Line number="15244">    if( dfltZip &amp;&amp; sqlite3_strlike(&quot;%.zip&quot;,zName,<CheckRefs ids="3108">0</CheckRefs>)==0 ){</Line>
  <Line number="15245">       return SHELL_OPEN_ZIPFILE;</Line>
  <Line number="15246">    }else{</Line>
  <Line number="15247">       return SHELL_OPEN_NORMAL;</Line>
  <Line number="15248">    }</Line>
  <Line number="15249">  }</Line>
  <Line number="15250">  n = fread(zBuf, <CheckRefs ids="3109">16</CheckRefs>, <CheckRefs ids="3110">1</CheckRefs>, f);</Line>
  <Line number="15251">  if( n==<CheckRefs ids="3111">1</CheckRefs> &amp;&amp; memcmp(zBuf, &quot;SQLite format 3&quot;, <CheckRefs ids="3112">16</CheckRefs>)==0 ){</Line>
  <Line number="15252">    fclose(f);</Line>
  <Line number="15253">    return SHELL_OPEN_NORMAL;</Line>
  <Line number="15254">  }</Line>
  <Line number="15255">  fseek(f, <CheckRefs ids="3113,3114">-</CheckRefs>25, SEEK_END);</Line>
  <Line number="15256">  n = fread(zBuf, <CheckRefs ids="3115">25</CheckRefs>, <CheckRefs ids="3116">1</CheckRefs>, f);</Line>
  <Line number="15257">  if( n==<CheckRefs ids="3117">1</CheckRefs> &amp;&amp; memcmp(zBuf, &quot;Start-Of-SQLite3-&quot;, <CheckRefs ids="3118">17</CheckRefs>)==0 ){</Line>
  <Line number="15258">    rc = SHELL_OPEN_APPENDVFS;</Line>
  <Line number="15259">  }else{</Line>
  <Line number="15260">    fseek(f, <CheckRefs ids="3119,3120">-</CheckRefs>22, SEEK_END);</Line>
  <Line number="15261">    n = fread(zBuf, <CheckRefs ids="3121">22</CheckRefs>, <CheckRefs ids="3122">1</CheckRefs>, f);</Line>
  <Line number="15262">    if( n==<CheckRefs ids="3123">1</CheckRefs> &amp;&amp; <CheckRefs ids="3124">zBuf</CheckRefs>[0<CheckRefs ids="3125">]</CheckRefs>==0x50 &amp;&amp; <CheckRefs ids="3126">zBuf</CheckRefs>[1<CheckRefs ids="3127">]</CheckRefs>==0x4b &amp;&amp; <CheckRefs ids="3128">zBuf</CheckRefs>[2<CheckRefs ids="3129">]</CheckRefs>==0x05</Line>
  <Line number="15263">       &amp;&amp; <CheckRefs ids="3130">zBuf</CheckRefs>[3<CheckRefs ids="3131">]</CheckRefs>==0x06 ){</Line>
  <Line number="15264">      rc = SHELL_OPEN_ZIPFILE;</Line>
  <Line number="15265">    }else if( n==<CheckRefs ids="3132">0</CheckRefs> &amp;&amp; dfltZip &amp;&amp; sqlite3_strlike(&quot;%.zip&quot;,zName,<CheckRefs ids="3133">0</CheckRefs>)==0 ){</Line>
  <Line number="15266">      rc = SHELL_OPEN_ZIPFILE;</Line>
  <Line number="15267">    }</Line>
  <Line number="15268">  }</Line>
  <Line number="15269">  fclose(f);</Line>
  <Line number="15270">  return rc;  </Line>
  <Line number="15271">}</Line>
  <Line number="15272"></Line>
  <Line number="15273">#ifndef SQLITE_OMIT_DESERIALIZE</Line>
  <Line number="15274">/*</Line>
  <Line number="15275">** Reconstruct an in-memory database using the output from the &quot;dbtotxt&quot;</Line>
  <Line number="15276">** program.  Read content from the file in p-&gt;zDbFilename.  If p-&gt;zDbFilename</Line>
  <Line number="15277">** is 0, then read from standard input.</Line>
  <Line number="15278">*/</Line>
  <Line number="15279">static unsigned char *readHexDb(ShellState *p, int *pnData){</Line>
  <Line number="15280">  unsigned char *a = 0;</Line>
  <Line number="15281">  int nLine;</Line>
  <Line number="15282">  int n = 0;</Line>
  <Line number="15283">  int pgsz = 0;</Line>
  <Line number="15284">  int iOffset = 0;</Line>
  <Line number="15285">  int j, k;</Line>
  <Line number="15286">  int rc;</Line>
  <Line number="15287">  FILE *in;</Line>
  <Line number="15288">  unsigned int x[16];</Line>
  <Line number="15289">  char zLine[1000];</Line>
  <Line number="15290">  if( p-&gt;zDbFilename ){</Line>
  <Line number="15291">    in = fopen(p-&gt;zDbFilename, &quot;r&quot;);</Line>
  <Line number="15292">    if( in==0 ){</Line>
  <Line number="15293">      utf8_printf(stderr, &quot;cannot open \&quot;%s\&quot; for reading\n&quot;, p-&gt;zDbFilename);</Line>
  <Line number="15294">      return 0;</Line>
  <Line number="15295">    }</Line>
  <Line number="15296">    nLine = 0;</Line>
  <Line number="15297">  }else{</Line>
  <Line number="15298">    in = p-&gt;in;</Line>
  <Line number="15299">    nLine = p-&gt;lineno;</Line>
  <Line number="15300">    if( in==0 ) in = stdin;</Line>
  <Line number="15301">  }</Line>
  <Line number="15302">  *pnData = 0;</Line>
  <Line number="15303">  nLine<CheckRefs ids="3134">++</CheckRefs>;</Line>
  <Line number="15304">  if( fgets(zLine, <CheckRefs ids="3135">sizeof</CheckRefs>(zLine), in)==0 ) goto readHexDb_error;</Line>
  <Line number="15305">  rc = sscanf(zLine, &quot;| size %d pagesize %d&quot;, &amp;n, &amp;pgsz);</Line>
  <Line number="15306">  if( rc!=2 ) goto readHexDb_error;</Line>
  <Line number="15307">  if( n&lt;0 ) goto readHexDb_error;</Line>
  <Line number="15308">  if( pgsz&lt;512 || pgsz&gt;65536 || (pgsz&amp;(pgsz<CheckRefs ids="3136">-</CheckRefs>1))!=0 ) goto readHexDb_error;</Line>
  <Line number="15309">  n = (n<CheckRefs ids="3138">+</CheckRefs>pgsz<CheckRefs ids="3137">-</CheckRefs>1)&amp;~(pgsz<CheckRefs ids="3139">-</CheckRefs>1);  /* Round n up to the next multiple of pgsz */</Line>
  <Line number="15310">  a = sqlite3_malloc( n ? n : 1 );</Line>
  <Line number="15311">  if( a==0 ){</Line>
  <Line number="15312">    utf8_printf(stderr, &quot;Out of memory!\n&quot;);</Line>
  <Line number="15313">    goto readHexDb_error;</Line>
  <Line number="15314">  }</Line>
  <Line number="15315">  memset(a, 0, <CheckRefs ids="3140">n</CheckRefs>);</Line>
  <Line number="15316">  if( pgsz&lt;512 || pgsz&gt;65536 || (pgsz &amp; (pgsz<CheckRefs ids="3141">-</CheckRefs>1))!=0 ){</Line>
  <Line number="15317">    utf8_printf(stderr, &quot;invalid pagesize\n&quot;);</Line>
  <Line number="15318">    goto readHexDb_error;</Line>
  <Line number="15319">  }</Line>
  <Line number="15320">  for(nLine<CheckRefs ids="3142">++</CheckRefs>; fgets(zLine, <CheckRefs ids="3143">sizeof</CheckRefs>(zLine), in)!=0; nLine<CheckRefs ids="3144">++</CheckRefs>){</Line>
  <Line number="15321">    rc = sscanf(zLine, &quot;| page %d offset %d&quot;, &amp;j, &amp;k);</Line>
  <Line number="15322">    if( rc==2 ){</Line>
  <Line number="15323">      iOffset = k;</Line>
  <Line number="15324">      continue;</Line>
  <Line number="15325">    }</Line>
  <Line number="15326">    if( strncmp(zLine, &quot;| end &quot;, <CheckRefs ids="3145">6</CheckRefs>)==0 ){</Line>
  <Line number="15327">      break;</Line>
  <Line number="15328">    }</Line>
  <Line number="15329">    rc = sscanf(zLine,&quot;| %d: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x&quot;,</Line>
  <Line number="15330">                &amp;j, &amp;x[0<CheckRefs ids="3146">]</CheckRefs>, &amp;x[1<CheckRefs ids="3147">]</CheckRefs>, &amp;x[2<CheckRefs ids="3148">]</CheckRefs>, &amp;x[3<CheckRefs ids="3149">]</CheckRefs>, &amp;x[4<CheckRefs ids="3150">]</CheckRefs>, &amp;x[5<CheckRefs ids="3151">]</CheckRefs>, &amp;x[6<CheckRefs ids="3152">]</CheckRefs>, &amp;x[7<CheckRefs ids="3153">]</CheckRefs>,</Line>
  <Line number="15331">                &amp;x[8<CheckRefs ids="3154">]</CheckRefs>, &amp;x[9<CheckRefs ids="3155">]</CheckRefs>, &amp;x[10<CheckRefs ids="3156">]</CheckRefs>, &amp;x[11<CheckRefs ids="3157">]</CheckRefs>, &amp;x[12<CheckRefs ids="3158">]</CheckRefs>, &amp;x[13<CheckRefs ids="3159">]</CheckRefs>, &amp;x[14<CheckRefs ids="3160">]</CheckRefs>, &amp;x[15<CheckRefs ids="3161">]</CheckRefs>);</Line>
  <Line number="15332">    if( rc==17 ){</Line>
  <Line number="15333">      k = iOffset<CheckRefs ids="3162">+</CheckRefs>j;</Line>
  <Line number="15334">      if( k<CheckRefs ids="3163">+</CheckRefs>16&lt;=n ){</Line>
  <Line number="15335">        int ii;</Line>
  <Line number="15336">        for(ii=0; ii&lt;16; ii<CheckRefs ids="3164">++</CheckRefs>) a[k<CheckRefs ids="3165">+</CheckRefs>ii] = x[ii<CheckRefs ids="3167">]</CheckRefs><CheckRefs ids="3166">&amp;</CheckRefs><CheckRefs ids="3168">0xff</CheckRefs>;</Line>
  <Line number="15337">      }</Line>
  <Line number="15338">    }</Line>
  <Line number="15339">  }</Line>
  <Line number="15340">  *pnData = n;</Line>
  <Line number="15341">  if( in!=p-&gt;in ){</Line>
  <Line number="15342">    fclose(in);</Line>
  <Line number="15343">  }else{</Line>
  <Line number="15344">    p-&gt;lineno = nLine;</Line>
  <Line number="15345">  }</Line>
  <Line number="15346">  return a;</Line>
  <Line number="15347"></Line>
  <Line number="15348">readHexDb_error:</Line>
  <Line number="15349">  if( in!=p-&gt;in ){</Line>
  <Line number="15350">    fclose(in);</Line>
  <Line number="15351">  }else{</Line>
  <Line number="15352">    while( fgets(zLine, <CheckRefs ids="3169">sizeof</CheckRefs>(zLine), p-&gt;in)!=0 ){</Line>
  <Line number="15353">      nLine<CheckRefs ids="3170">++</CheckRefs>;</Line>
  <Line number="15354">      if(strncmp(zLine, &quot;| end &quot;, <CheckRefs ids="3171">6</CheckRefs>)==0 ) break;</Line>
  <Line number="15355">    }</Line>
  <Line number="15356">    p-&gt;lineno = nLine;</Line>
  <Line number="15357">  }</Line>
  <Line number="15358">  sqlite3_free(a);</Line>
  <Line number="15359">  utf8_printf(stderr,&quot;Error on line %d of --hexdb input\n&quot;, nLine);</Line>
  <Line number="15360">  return 0;</Line>
  <Line number="15361">}</Line>
  <Line number="15362">#endif /* SQLITE_OMIT_DESERIALIZE */</Line>
  <Line number="15363"></Line>
  <Line number="15364">/*</Line>
  <Line number="15365">** Scalar function &quot;shell_int32&quot;. The first argument to this function</Line>
  <Line number="15366">** must be a blob. The second a non-negative integer. This function</Line>
  <Line number="15367">** reads and returns a 32-bit big-endian integer from byte</Line>
  <Line number="15368">** offset (4*&lt;arg2&gt;) of the blob.</Line>
  <Line number="15369">*/</Line>
  <Line number="15370">static void shellInt32(</Line>
  <Line number="15371">  sqlite3_context *context, </Line>
  <Line number="15372">  int argc, </Line>
  <Line number="15373">  sqlite3_value **argv</Line>
  <Line number="15374">){</Line>
  <Line number="15375">  const unsigned char *pBlob;</Line>
  <Line number="15376">  int nBlob;</Line>
  <Line number="15377">  int iInt;</Line>
  <Line number="15378"></Line>
  <Line number="15379">  UNUSED_PARAMETER(argc);</Line>
  <Line number="15380">  nBlob = sqlite3_value_bytes(argv[0]);</Line>
  <Line number="15381">  pBlob = (const unsigned char*)sqlite3_value_blob(argv[0]);</Line>
  <Line number="15382">  iInt = sqlite3_value_int(argv[1]);</Line>
  <Line number="15383"></Line>
  <Line number="15384">  if( iInt&gt;=0 &amp;&amp; (iInt<CheckRefs ids="3173">+</CheckRefs>1)<CheckRefs ids="3172">*</CheckRefs>4&lt;=nBlob ){</Line>
  <Line number="15385">    const unsigned char *a = &amp;pBlob[iInt<CheckRefs ids="3174">*</CheckRefs>4];</Line>
  <Line number="15386">    sqlite3_int64 iVal = (<CheckRefs ids="3181">(</CheckRefs>sqlite3_int64)a[0]<CheckRefs ids="3178,3179,3180">&lt;&lt;</CheckRefs>24)</Line>
  <Line number="15387">                       <CheckRefs ids="3177">+</CheckRefs> (<CheckRefs ids="3185">(</CheckRefs>sqlite3_int64)a[1]<CheckRefs ids="3182,3183,3184">&lt;&lt;</CheckRefs>16)</Line>
  <Line number="15388">                       <CheckRefs ids="3176">+</CheckRefs> (<CheckRefs ids="3189">(</CheckRefs>sqlite3_int64)a[2]<CheckRefs ids="3186,3187,3188">&lt;&lt;</CheckRefs> 8)</Line>
  <Line number="15389">                       <CheckRefs ids="3175">+</CheckRefs> (<CheckRefs ids="3193">(</CheckRefs>sqlite3_int64)a[3]<CheckRefs ids="3191,3190,3192">&lt;&lt;</CheckRefs> 0);</Line>
  <Line number="15390">    sqlite3_result_int64(context, iVal);</Line>
  <Line number="15391">  }</Line>
  <Line number="15392">}</Line>
  <Line number="15393"></Line>
  <Line number="15394">/*</Line>
  <Line number="15395">** Scalar function &quot;shell_idquote(X)&quot; returns string X quoted as an identifier,</Line>
  <Line number="15396">** using &quot;...&quot; with internal double-quote characters doubled.</Line>
  <Line number="15397">*/</Line>
  <Line number="15398">static void shellIdQuote(</Line>
  <Line number="15399">  sqlite3_context *context, </Line>
  <Line number="15400">  int argc, </Line>
  <Line number="15401">  sqlite3_value **argv</Line>
  <Line number="15402">){</Line>
  <Line number="15403">  const char *zName = (const char*)sqlite3_value_text(argv[0]);</Line>
  <Line number="15404">  UNUSED_PARAMETER(argc);</Line>
  <Line number="15405">  if( zName ){</Line>
  <Line number="15406">    char *z = sqlite3_mprintf(&quot;\&quot;%w\&quot;&quot;, zName);</Line>
  <Line number="15407">    sqlite3_result_text(context, z, <CheckRefs ids="3194">-</CheckRefs>1, sqlite3_free);</Line>
  <Line number="15408">  }</Line>
  <Line number="15409">}</Line>
  <Line number="15410"></Line>
  <Line number="15411">/*</Line>
  <Line number="15412">** Scalar function &quot;usleep(X)&quot; invokes sqlite3_sleep(X) and returns X.</Line>
  <Line number="15413">*/</Line>
  <Line number="15414">static void shellUSleepFunc(</Line>
  <Line number="15415">  sqlite3_context *context, </Line>
  <Line number="15416">  int argcUnused, </Line>
  <Line number="15417">  sqlite3_value **argv</Line>
  <Line number="15418">){</Line>
  <Line number="15419">  int sleep = sqlite3_value_int(argv[0]);</Line>
  <Line number="15420">  (void)argcUnused;</Line>
  <Line number="15421">  sqlite3_sleep(sleep<CheckRefs ids="3195,3196">/</CheckRefs>1000);</Line>
  <Line number="15422">  sqlite3_result_int(context, sleep);</Line>
  <Line number="15423">}</Line>
  <Line number="15424"></Line>
  <Line number="15425">/*</Line>
  <Line number="15426">** Scalar function &quot;shell_escape_crnl&quot; used by the .recover command.</Line>
  <Line number="15427">** The argument passed to this function is the output of built-in</Line>
  <Line number="15428">** function quote(). If the first character of the input is &quot;&apos;&quot;, </Line>
  <Line number="15429">** indicating that the value passed to quote() was a text value,</Line>
  <Line number="15430">** then this function searches the input for &quot;\n&quot; and &quot;\r&quot; characters</Line>
  <Line number="15431">** and adds a wrapper similar to the following:</Line>
  <Line number="15432">**</Line>
  <Line number="15433">**   replace(replace(&lt;input&gt;, &apos;\n&apos;, char(10), &apos;\r&apos;, char(13));</Line>
  <Line number="15434">**</Line>
  <Line number="15435">** Or, if the first character of the input is not &quot;&apos;&quot;, then a copy</Line>
  <Line number="15436">** of the input is returned.</Line>
  <Line number="15437">*/</Line>
  <Line number="15438">static void shellEscapeCrnl(</Line>
  <Line number="15439">  sqlite3_context *context, </Line>
  <Line number="15440">  int argc, </Line>
  <Line number="15441">  sqlite3_value **argv</Line>
  <Line number="15442">){</Line>
  <Line number="15443">  const char *zText = (const char*)sqlite3_value_text(argv[0]);</Line>
  <Line number="15444">  UNUSED_PARAMETER(argc);</Line>
  <Line number="15445">  if( <CheckRefs ids="3197">zText</CheckRefs>[0]==&apos;\&apos;&apos; ){</Line>
  <Line number="15446">    int nText = sqlite3_value_bytes(argv[0]);</Line>
  <Line number="15447">    int i;</Line>
  <Line number="15448">    char zBuf1[20];</Line>
  <Line number="15449">    char zBuf2[20];</Line>
  <Line number="15450">    const char *zNL = 0;</Line>
  <Line number="15451">    const char *zCR = 0;</Line>
  <Line number="15452">    int nCR = 0;</Line>
  <Line number="15453">    int nNL = 0;</Line>
  <Line number="15454"></Line>
  <Line number="15455">    for(i=0; zText[i]; i<CheckRefs ids="3198">++</CheckRefs>){</Line>
  <Line number="15456">      if( zNL==0 &amp;&amp; <CheckRefs ids="3199">zText</CheckRefs>[i]==&apos;\n&apos; ){</Line>
  <Line number="15457">        zNL = unused_string(zText, &quot;\\n&quot;, &quot;\\012&quot;, zBuf1);</Line>
  <Line number="15458">        nNL = <CheckRefs ids="3200">(</CheckRefs>int)strlen(zNL);</Line>
  <Line number="15459">      }</Line>
  <Line number="15460">      if( zCR==0 &amp;&amp; <CheckRefs ids="3201">zText</CheckRefs>[i]==&apos;\r&apos; ){</Line>
  <Line number="15461">        zCR = unused_string(zText, &quot;\\r&quot;, &quot;\\015&quot;, zBuf2);</Line>
  <Line number="15462">        nCR = <CheckRefs ids="3202">(</CheckRefs>int)strlen(zCR);</Line>
  <Line number="15463">      }</Line>
  <Line number="15464">    }</Line>
  <Line number="15465"></Line>
  <Line number="15466">    if( zNL || zCR ){</Line>
  <Line number="15467">      int iOut = 0;</Line>
  <Line number="15468">      i64 nMax = <CheckRefs ids="3203">(</CheckRefs>nNL &gt; nCR) ? nNL : nCR;</Line>
  <Line number="15469">      i64 nAlloc = nMax <CheckRefs ids="3205">*</CheckRefs> <CheckRefs ids="3206">nText</CheckRefs> <CheckRefs ids="3204">+</CheckRefs> (nMax<CheckRefs ids="3208">+</CheckRefs><CheckRefs ids="3209">64</CheckRefs>)<CheckRefs ids="3207">*</CheckRefs><CheckRefs ids="3210">2</CheckRefs>;</Line>
  <Line number="15470">      char *zOut = (char*)sqlite3_malloc64(<CheckRefs ids="3211">nAlloc</CheckRefs>);</Line>
  <Line number="15471">      if( zOut==0 ){</Line>
  <Line number="15472">        sqlite3_result_error_nomem(context);</Line>
  <Line number="15473">        return;</Line>
  <Line number="15474">      }</Line>
  <Line number="15475"></Line>
  <Line number="15476">      if( zNL &amp;&amp; zCR ){</Line>
  <Line number="15477">        memcpy(&amp;zOut[iOut], &quot;replace(replace(&quot;, <CheckRefs ids="3212">16</CheckRefs>);</Line>
  <Line number="15478">        iOut <CheckRefs ids="3213">+=</CheckRefs> 16;</Line>
  <Line number="15479">      }else{</Line>
  <Line number="15480">        memcpy(&amp;zOut[iOut], &quot;replace(&quot;, <CheckRefs ids="3214">8</CheckRefs>);</Line>
  <Line number="15481">        iOut <CheckRefs ids="3215">+=</CheckRefs> 8;</Line>
  <Line number="15482">      }</Line>
  <Line number="15483">      for(i=0; zText[i]; i<CheckRefs ids="3216">++</CheckRefs>){</Line>
  <Line number="15484">        if( <CheckRefs ids="3217">zText</CheckRefs>[i]==&apos;\n&apos; ){</Line>
  <Line number="15485">          memcpy(&amp;zOut[iOut], zNL, <CheckRefs ids="3218">nNL</CheckRefs>);</Line>
  <Line number="15486">          iOut <CheckRefs ids="3219">+=</CheckRefs> nNL;</Line>
  <Line number="15487">        }else if( <CheckRefs ids="3220">zText</CheckRefs>[i]==&apos;\r&apos; ){</Line>
  <Line number="15488">          memcpy(&amp;zOut[iOut], zCR, <CheckRefs ids="3221">nCR</CheckRefs>);</Line>
  <Line number="15489">          iOut <CheckRefs ids="3222">+=</CheckRefs> nCR;</Line>
  <Line number="15490">        }else{</Line>
  <Line number="15491">          zOut[iOut] = zText[i];</Line>
  <Line number="15492">          iOut<CheckRefs ids="3223">++</CheckRefs>;</Line>
  <Line number="15493">        }</Line>
  <Line number="15494">      }</Line>
  <Line number="15495"></Line>
  <Line number="15496">      if( zNL ){</Line>
  <Line number="15497">        memcpy(&amp;zOut[iOut], &quot;,&apos;&quot;, <CheckRefs ids="3224">2</CheckRefs>); iOut <CheckRefs ids="3225">+=</CheckRefs> 2;</Line>
  <Line number="15498">        memcpy(&amp;zOut[iOut], zNL, <CheckRefs ids="3226">nNL</CheckRefs>); iOut <CheckRefs ids="3227">+=</CheckRefs> nNL;</Line>
  <Line number="15499">        memcpy(&amp;zOut[iOut], &quot;&apos;, char(10))&quot;, <CheckRefs ids="3228">12</CheckRefs>); iOut <CheckRefs ids="3229">+=</CheckRefs> 12;</Line>
  <Line number="15500">      }</Line>
  <Line number="15501">      if( zCR ){</Line>
  <Line number="15502">        memcpy(&amp;zOut[iOut], &quot;,&apos;&quot;, <CheckRefs ids="3230">2</CheckRefs>); iOut <CheckRefs ids="3231">+=</CheckRefs> 2;</Line>
  <Line number="15503">        memcpy(&amp;zOut[iOut], zCR, <CheckRefs ids="3232">nCR</CheckRefs>); iOut <CheckRefs ids="3233">+=</CheckRefs> nCR;</Line>
  <Line number="15504">        memcpy(&amp;zOut[iOut], &quot;&apos;, char(13))&quot;, <CheckRefs ids="3234">12</CheckRefs>); iOut <CheckRefs ids="3235">+=</CheckRefs> 12;</Line>
  <Line number="15505">      }</Line>
  <Line number="15506"></Line>
  <Line number="15507">      sqlite3_result_text(context, zOut, iOut, <CheckRefs ids="3236">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="15508">      sqlite3_free(zOut);</Line>
  <Line number="15509">      return;</Line>
  <Line number="15510">    }</Line>
  <Line number="15511">  }</Line>
  <Line number="15512"></Line>
  <Line number="15513">  sqlite3_result_value(context, argv[0]);</Line>
  <Line number="15514">}</Line>
  <Line number="15515"></Line>
  <Line number="15516">/* Flags for open_db().</Line>
  <Line number="15517">**</Line>
  <Line number="15518">** The default behavior of open_db() is to exit(1) if the database fails to</Line>
  <Line number="15519">** open.  The OPEN_DB_KEEPALIVE flag changes that so that it prints an error</Line>
  <Line number="15520">** but still returns without calling exit.</Line>
  <Line number="15521">**</Line>
  <Line number="15522">** The OPEN_DB_ZIPFILE flag causes open_db() to prefer to open files as a</Line>
  <Line number="15523">** ZIP archive if the file does not exist or is empty and its name matches</Line>
  <Line number="15524">** the *.zip pattern.</Line>
  <Line number="15525">*/</Line>
  <Line number="15526">#define OPEN_DB_KEEPALIVE   0x001   /* Return after error if true */</Line>
  <Line number="15527">#define OPEN_DB_ZIPFILE     0x002   /* Open as ZIP if name matches *.zip */</Line>
  <Line number="15528"></Line>
  <Line number="15529">/*</Line>
  <Line number="15530">** Make sure the database is open.  If it is not, then open it.  If</Line>
  <Line number="15531">** the database fails to open, print an error message and exit.</Line>
  <Line number="15532">*/</Line>
  <Line number="15533">static void open_db(ShellState *p, int openFlags){</Line>
  <Line number="15534">  if( p-&gt;db==0 ){</Line>
  <Line number="15535">    if( <CheckRefs ids="3237">p</CheckRefs>-&gt;openMode==SHELL_OPEN_UNSPEC ){</Line>
  <Line number="15536">      if( p-&gt;zDbFilename==0 || <CheckRefs ids="3238">p</CheckRefs>-&gt;zDbFilename[0]==0 ){</Line>
  <Line number="15537">        p-&gt;openMode = <CheckRefs ids="3239">SHELL_OPEN_NORMAL</CheckRefs>;</Line>
  <Line number="15538">      }else{</Line>
  <Line number="15539">        p-&gt;openMode = <CheckRefs ids="3240">(</CheckRefs>u8)deduceDatabaseType(p-&gt;zDbFilename, </Line>
  <Line number="15540">                             (openFlags &amp; OPEN_DB_ZIPFILE)!=0);</Line>
  <Line number="15541">      }</Line>
  <Line number="15542">    }</Line>
  <Line number="15543">    switch( <CheckRefs ids="3241">p</CheckRefs>-&gt;openMode ){</Line>
  <Line number="15544">      case SHELL_OPEN_APPENDVFS: {</Line>
  <Line number="15545">        sqlite3_open_v2(p-&gt;zDbFilename, &amp;p-&gt;db, </Line>
  <Line number="15546">           SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|p-&gt;openFlags, &quot;apndvfs&quot;);</Line>
  <Line number="15547">        break;</Line>
  <Line number="15548">      }</Line>
  <Line number="15549">      case SHELL_OPEN_HEXDB:</Line>
  <Line number="15550">      case SHELL_OPEN_DESERIALIZE: {</Line>
  <Line number="15551">        sqlite3_open(0, &amp;p-&gt;db);</Line>
  <Line number="15552">        break;</Line>
  <Line number="15553">      }</Line>
  <Line number="15554">      case SHELL_OPEN_ZIPFILE: {</Line>
  <Line number="15555">        sqlite3_open(&quot;:memory:&quot;, &amp;p-&gt;db);</Line>
  <Line number="15556">        break;</Line>
  <Line number="15557">      }</Line>
  <Line number="15558">      case SHELL_OPEN_READONLY: {</Line>
  <Line number="15559">        sqlite3_open_v2(p-&gt;zDbFilename, &amp;p-&gt;db,</Line>
  <Line number="15560">            SQLITE_OPEN_READONLY|p-&gt;openFlags, 0);</Line>
  <Line number="15561">        break;</Line>
  <Line number="15562">      }</Line>
  <Line number="15563">      case SHELL_OPEN_UNSPEC:</Line>
  <Line number="15564">      case SHELL_OPEN_NORMAL: {</Line>
  <Line number="15565">        sqlite3_open_v2(p-&gt;zDbFilename, &amp;p-&gt;db,</Line>
  <Line number="15566">           SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|p-&gt;openFlags, 0);</Line>
  <Line number="15567">        break;</Line>
  <Line number="15568">      }</Line>
  <Line number="15569">    }</Line>
  <Line number="15570">    globalDb = p-&gt;db;</Line>
  <Line number="15571">    if( p-&gt;db==0 || SQLITE_OK!=sqlite3_errcode(p-&gt;db) ){</Line>
  <Line number="15572">      utf8_printf(stderr,&quot;Error: unable to open database \&quot;%s\&quot;: %s\n&quot;,</Line>
  <Line number="15573">          p-&gt;zDbFilename, sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="15574">      if( openFlags &amp; OPEN_DB_KEEPALIVE ){</Line>
  <Line number="15575">        sqlite3_open(&quot;:memory:&quot;, &amp;p-&gt;db);</Line>
  <Line number="15576">        return;</Line>
  <Line number="15577">      }</Line>
  <Line number="15578">      exit(1);</Line>
  <Line number="15579">    }</Line>
  <Line number="15580">#ifndef SQLITE_OMIT_LOAD_EXTENSION</Line>
  <Line number="15581">    sqlite3_enable_load_extension(p-&gt;db, 1);</Line>
  <Line number="15582">#endif</Line>
  <Line number="15583">    sqlite3_fileio_init(p-&gt;db, 0, 0);</Line>
  <Line number="15584">    sqlite3_shathree_init(p-&gt;db, 0, 0);</Line>
  <Line number="15585">    sqlite3_completion_init(p-&gt;db, 0, 0);</Line>
  <Line number="15586">    sqlite3_uint_init(p-&gt;db, 0, 0);</Line>
  <Line number="15587">    sqlite3_decimal_init(p-&gt;db, 0, 0);</Line>
  <Line number="15588">    sqlite3_regexp_init(p-&gt;db, 0, 0);</Line>
  <Line number="15589">    sqlite3_ieee_init(p-&gt;db, 0, 0);</Line>
  <Line number="15590">    sqlite3_series_init(p-&gt;db, 0, 0);</Line>
  <Line number="15591">#if !defined(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; defined(SQLITE_ENABLE_DBPAGE_VTAB)</Line>
  <Line number="15592">    sqlite3_dbdata_init(p-&gt;db, 0, 0);</Line>
  <Line number="15593">#endif</Line>
  <Line number="15594">#ifdef SQLITE_HAVE_ZLIB</Line>
  <Line number="15595">    sqlite3_zipfile_init(p-&gt;db, 0, 0);</Line>
  <Line number="15596">    sqlite3_sqlar_init(p-&gt;db, 0, 0);</Line>
  <Line number="15597">#endif</Line>
  <Line number="15598">    sqlite3_create_function(p-&gt;db, &quot;shell_add_schema&quot;, 3, SQLITE_UTF8, 0,</Line>
  <Line number="15599">                            shellAddSchemaName, 0, 0);</Line>
  <Line number="15600">    sqlite3_create_function(p-&gt;db, &quot;shell_module_schema&quot;, 1, SQLITE_UTF8, 0,</Line>
  <Line number="15601">                            shellModuleSchema, 0, 0);</Line>
  <Line number="15602">    sqlite3_create_function(p-&gt;db, &quot;shell_putsnl&quot;, 1, SQLITE_UTF8, p,</Line>
  <Line number="15603">                            shellPutsFunc, 0, 0);</Line>
  <Line number="15604">    sqlite3_create_function(p-&gt;db, &quot;shell_escape_crnl&quot;, 1, SQLITE_UTF8, 0,</Line>
  <Line number="15605">                            shellEscapeCrnl, 0, 0);</Line>
  <Line number="15606">    sqlite3_create_function(p-&gt;db, &quot;shell_int32&quot;, 2, SQLITE_UTF8, 0,</Line>
  <Line number="15607">                            shellInt32, 0, 0);</Line>
  <Line number="15608">    sqlite3_create_function(p-&gt;db, &quot;shell_idquote&quot;, 1, SQLITE_UTF8, 0,</Line>
  <Line number="15609">                            shellIdQuote, 0, 0);</Line>
  <Line number="15610">    sqlite3_create_function(p-&gt;db, &quot;usleep&quot;,1,SQLITE_UTF8,0,</Line>
  <Line number="15611">                            shellUSleepFunc, 0, 0);</Line>
  <Line number="15612">#ifndef SQLITE_NOHAVE_SYSTEM</Line>
  <Line number="15613">    sqlite3_create_function(p-&gt;db, &quot;edit&quot;, 1, SQLITE_UTF8, 0,</Line>
  <Line number="15614">                            editFunc, 0, 0);</Line>
  <Line number="15615">    sqlite3_create_function(p-&gt;db, &quot;edit&quot;, 2, SQLITE_UTF8, 0,</Line>
  <Line number="15616">                            editFunc, 0, 0);</Line>
  <Line number="15617">#endif</Line>
  <Line number="15618">    if( <CheckRefs ids="3242">p</CheckRefs>-&gt;openMode==SHELL_OPEN_ZIPFILE ){</Line>
  <Line number="15619">      char *zSql = sqlite3_mprintf(</Line>
  <Line number="15620">         &quot;CREATE VIRTUAL TABLE zip USING zipfile(%Q);&quot;, p-&gt;zDbFilename);</Line>
  <Line number="15621">      sqlite3_exec(p-&gt;db, zSql, 0, 0, 0);</Line>
  <Line number="15622">      sqlite3_free(zSql);</Line>
  <Line number="15623">    }</Line>
  <Line number="15624">#ifndef SQLITE_OMIT_DESERIALIZE</Line>
  <Line number="15625">    else</Line>
  <Line number="15626">    if( <CheckRefs ids="3243">p</CheckRefs>-&gt;openMode==SHELL_OPEN_DESERIALIZE || <CheckRefs ids="3244">p</CheckRefs>-&gt;openMode==SHELL_OPEN_HEXDB ){</Line>
  <Line number="15627">      int rc;</Line>
  <Line number="15628">      int nData = 0;</Line>
  <Line number="15629">      unsigned char *aData;</Line>
  <Line number="15630">      if( <CheckRefs ids="3245">p</CheckRefs>-&gt;openMode==SHELL_OPEN_DESERIALIZE ){</Line>
  <Line number="15631">        aData = (unsigned char*)readFile(p-&gt;zDbFilename, &amp;nData);</Line>
  <Line number="15632">      }else{</Line>
  <Line number="15633">        aData = readHexDb(p, &amp;nData);</Line>
  <Line number="15634">        if( aData==0 ){</Line>
  <Line number="15635">          return;</Line>
  <Line number="15636">        }</Line>
  <Line number="15637">      }</Line>
  <Line number="15638">      rc = sqlite3_deserialize(p-&gt;db, &quot;main&quot;, aData, <CheckRefs ids="3246">nData</CheckRefs>, <CheckRefs ids="3247">nData</CheckRefs>,</Line>
  <Line number="15639">                   SQLITE_DESERIALIZE_RESIZEABLE <CheckRefs ids="3248">|</CheckRefs></Line>
  <Line number="15640">                   SQLITE_DESERIALIZE_FREEONCLOSE);</Line>
  <Line number="15641">      if( rc ){</Line>
  <Line number="15642">        utf8_printf(stderr, &quot;Error: sqlite3_deserialize() returns %d\n&quot;, rc);</Line>
  <Line number="15643">      }</Line>
  <Line number="15644">      if( p-&gt;szMax&gt;<CheckRefs ids="3249">0</CheckRefs> ){</Line>
  <Line number="15645">        sqlite3_file_control(p-&gt;db, &quot;main&quot;, SQLITE_FCNTL_SIZE_LIMIT, &amp;p-&gt;szMax);</Line>
  <Line number="15646">      }</Line>
  <Line number="15647">    }</Line>
  <Line number="15648">#endif</Line>
  <Line number="15649">  }</Line>
  <Line number="15650">}</Line>
  <Line number="15651"></Line>
  <Line number="15652">/*</Line>
  <Line number="15653">** Attempt to close the databaes connection.  Report errors.</Line>
  <Line number="15654">*/</Line>
  <Line number="15655">void close_db(sqlite3 *db){</Line>
  <Line number="15656">  int rc = sqlite3_close(db);</Line>
  <Line number="15657">  if( rc ){</Line>
  <Line number="15658">    utf8_printf(stderr, &quot;Error: sqlite3_close() returns %d: %s\n&quot;,</Line>
  <Line number="15659">        rc, sqlite3_errmsg(db));</Line>
  <Line number="15660">  } </Line>
  <Line number="15661">}</Line>
  <Line number="15662"></Line>
  <Line number="15663">#if HAVE_READLINE || HAVE_EDITLINE</Line>
  <Line number="15664">/*</Line>
  <Line number="15665">** Readline completion callbacks</Line>
  <Line number="15666">*/</Line>
  <Line number="15667">static char *readline_completion_generator(const char *text, int state){</Line>
  <Line number="15668">  static sqlite3_stmt *pStmt = 0;</Line>
  <Line number="15669">  char *zRet;</Line>
  <Line number="15670">  if( state==0 ){</Line>
  <Line number="15671">    char *zSql;</Line>
  <Line number="15672">    sqlite3_finalize(pStmt);</Line>
  <Line number="15673">    zSql = sqlite3_mprintf(&quot;SELECT DISTINCT candidate COLLATE nocase&quot;</Line>
  <Line number="15674">                           &quot;  FROM completion(%Q) ORDER BY 1&quot;, text);</Line>
  <Line number="15675">    sqlite3_prepare_v2(globalDb, zSql, -1, &amp;pStmt, 0);</Line>
  <Line number="15676">    sqlite3_free(zSql);</Line>
  <Line number="15677">  }</Line>
  <Line number="15678">  if( sqlite3_step(pStmt)==SQLITE_ROW ){</Line>
  <Line number="15679">    zRet = strdup((const char*)sqlite3_column_text(pStmt, 0));</Line>
  <Line number="15680">  }else{</Line>
  <Line number="15681">    sqlite3_finalize(pStmt);</Line>
  <Line number="15682">    pStmt = 0;</Line>
  <Line number="15683">    zRet = 0;</Line>
  <Line number="15684">  }</Line>
  <Line number="15685">  return zRet;</Line>
  <Line number="15686">}</Line>
  <Line number="15687">static char **readline_completion(const char *zText, int iStart, int iEnd){</Line>
  <Line number="15688">  rl_attempted_completion_over = 1;</Line>
  <Line number="15689">  return rl_completion_matches(zText, readline_completion_generator);</Line>
  <Line number="15690">}</Line>
  <Line number="15691"></Line>
  <Line number="15692">#elif HAVE_LINENOISE</Line>
  <Line number="15693">/*</Line>
  <Line number="15694">** Linenoise completion callback</Line>
  <Line number="15695">*/</Line>
  <Line number="15696">static void linenoise_completion(const char *zLine, linenoiseCompletions *lc){</Line>
  <Line number="15697">  int nLine = strlen30(zLine);</Line>
  <Line number="15698">  int i, iStart;</Line>
  <Line number="15699">  sqlite3_stmt *pStmt = 0;</Line>
  <Line number="15700">  char *zSql;</Line>
  <Line number="15701">  char zBuf[1000];</Line>
  <Line number="15702"></Line>
  <Line number="15703">  if( nLine&gt;sizeof(zBuf)-30 ) return;</Line>
  <Line number="15704">  if( zLine[0]==&apos;.&apos; || zLine[0]==&apos;#&apos;) return;</Line>
  <Line number="15705">  for(i=nLine-1; i&gt;=0 &amp;&amp; (isalnum(zLine[i]) || zLine[i]==&apos;_&apos;); i--){}</Line>
  <Line number="15706">  if( i==nLine-1 ) return;</Line>
  <Line number="15707">  iStart = i+1;</Line>
  <Line number="15708">  memcpy(zBuf, zLine, iStart);</Line>
  <Line number="15709">  zSql = sqlite3_mprintf(&quot;SELECT DISTINCT candidate COLLATE nocase&quot;</Line>
  <Line number="15710">                         &quot;  FROM completion(%Q,%Q) ORDER BY 1&quot;,</Line>
  <Line number="15711">                         &amp;zLine[iStart], zLine);</Line>
  <Line number="15712">  sqlite3_prepare_v2(globalDb, zSql, -1, &amp;pStmt, 0);</Line>
  <Line number="15713">  sqlite3_free(zSql);</Line>
  <Line number="15714">  sqlite3_exec(globalDb, &quot;PRAGMA page_count&quot;, 0, 0, 0); /* Load the schema */</Line>
  <Line number="15715">  while( sqlite3_step(pStmt)==SQLITE_ROW ){</Line>
  <Line number="15716">    const char *zCompletion = (const char*)sqlite3_column_text(pStmt, 0);</Line>
  <Line number="15717">    int nCompletion = sqlite3_column_bytes(pStmt, 0);</Line>
  <Line number="15718">    if( iStart+nCompletion &lt; sizeof(zBuf)-1 ){</Line>
  <Line number="15719">      memcpy(zBuf+iStart, zCompletion, nCompletion+1);</Line>
  <Line number="15720">      linenoiseAddCompletion(lc, zBuf);</Line>
  <Line number="15721">    }</Line>
  <Line number="15722">  }</Line>
  <Line number="15723">  sqlite3_finalize(pStmt);</Line>
  <Line number="15724">}</Line>
  <Line number="15725">#endif</Line>
  <Line number="15726"></Line>
  <Line number="15727">/*</Line>
  <Line number="15728">** Do C-language style dequoting.</Line>
  <Line number="15729">**</Line>
  <Line number="15730">**    \a    -&gt; alarm</Line>
  <Line number="15731">**    \b    -&gt; backspace</Line>
  <Line number="15732">**    \t    -&gt; tab</Line>
  <Line number="15733">**    \n    -&gt; newline</Line>
  <Line number="15734">**    \v    -&gt; vertical tab</Line>
  <Line number="15735">**    \f    -&gt; form feed</Line>
  <Line number="15736">**    \r    -&gt; carriage return</Line>
  <Line number="15737">**    \s    -&gt; space</Line>
  <Line number="15738">**    \&quot;    -&gt; &quot;</Line>
  <Line number="15739">**    \&apos;    -&gt; &apos;</Line>
  <Line number="15740">**    \\    -&gt; backslash</Line>
  <Line number="15741">**    \NNN  -&gt; ascii character NNN in octal</Line>
  <Line number="15742">*/</Line>
  <Line number="15743">static void resolve_backslashes(char *z){</Line>
  <Line number="15744">  int i, j;</Line>
  <Line number="15745">  char c;</Line>
  <Line number="15746">  while( <CheckRefs ids="3250">*</CheckRefs>z &amp;&amp; <CheckRefs ids="3251">*</CheckRefs>z!=&apos;\\&apos; ) z++;</Line>
  <Line number="15747">  for(i=j=0; <CheckRefs ids="3252">(</CheckRefs>c = z[i])!=0; i<CheckRefs ids="3253">++</CheckRefs>, j<CheckRefs ids="3254">++</CheckRefs>){</Line>
  <Line number="15748">    if( <CheckRefs ids="3255">c</CheckRefs>==&apos;\\&apos; &amp;&amp; <CheckRefs ids="3256">z</CheckRefs>[i<CheckRefs ids="3257">+</CheckRefs>1]!=0 ){</Line>
  <Line number="15749">      c = z[<CheckRefs ids="3258">++</CheckRefs>i];</Line>
  <Line number="15750">      if( <CheckRefs ids="3259">c</CheckRefs>==&apos;a&apos; ){</Line>
  <Line number="15751">        c = <CheckRefs ids="3260">&apos;\a&apos;</CheckRefs>;</Line>
  <Line number="15752">      }else if( <CheckRefs ids="3261">c</CheckRefs>==&apos;b&apos; ){</Line>
  <Line number="15753">        c = <CheckRefs ids="3262">&apos;\b&apos;</CheckRefs>;</Line>
  <Line number="15754">      }else if( <CheckRefs ids="3263">c</CheckRefs>==&apos;t&apos; ){</Line>
  <Line number="15755">        c = <CheckRefs ids="3264">&apos;\t&apos;</CheckRefs>;</Line>
  <Line number="15756">      }else if( <CheckRefs ids="3265">c</CheckRefs>==&apos;n&apos; ){</Line>
  <Line number="15757">        c = <CheckRefs ids="3266">&apos;\n&apos;</CheckRefs>;</Line>
  <Line number="15758">      }else if( <CheckRefs ids="3267">c</CheckRefs>==&apos;v&apos; ){</Line>
  <Line number="15759">        c = <CheckRefs ids="3268">&apos;\v&apos;</CheckRefs>;</Line>
  <Line number="15760">      }else if( <CheckRefs ids="3269">c</CheckRefs>==&apos;f&apos; ){</Line>
  <Line number="15761">        c = <CheckRefs ids="3270">&apos;\f&apos;</CheckRefs>;</Line>
  <Line number="15762">      }else if( <CheckRefs ids="3271">c</CheckRefs>==&apos;r&apos; ){</Line>
  <Line number="15763">        c = <CheckRefs ids="3272">&apos;\r&apos;</CheckRefs>;</Line>
  <Line number="15764">      }else if( <CheckRefs ids="3273">c</CheckRefs>==&apos;&quot;&apos; ){</Line>
  <Line number="15765">        c = <CheckRefs ids="3274">&apos;&quot;&apos;</CheckRefs>;</Line>
  <Line number="15766">      }else if( <CheckRefs ids="3275">c</CheckRefs>==&apos;\&apos;&apos; ){</Line>
  <Line number="15767">        c = <CheckRefs ids="3276">&apos;\&apos;&apos;</CheckRefs>;</Line>
  <Line number="15768">      }else if( <CheckRefs ids="3277">c</CheckRefs>==&apos;\\&apos; ){</Line>
  <Line number="15769">        c = <CheckRefs ids="3278">&apos;\\&apos;</CheckRefs>;</Line>
  <Line number="15770">      }else if( <CheckRefs ids="3279">c</CheckRefs>&gt;=&apos;0&apos; &amp;&amp; <CheckRefs ids="3280">c</CheckRefs>&lt;=&apos;7&apos; ){</Line>
  <Line number="15771">        c <CheckRefs ids="3281">-=</CheckRefs> &apos;0&apos;;</Line>
  <Line number="15772">        if( <CheckRefs ids="3282">z</CheckRefs>[i<CheckRefs ids="3283">+</CheckRefs>1]&gt;=&apos;0&apos; &amp;&amp; <CheckRefs ids="3284">z</CheckRefs>[i<CheckRefs ids="3285">+</CheckRefs>1]&lt;=&apos;7&apos; ){</Line>
  <Line number="15773">          i<CheckRefs ids="3286">++</CheckRefs>;</Line>
  <Line number="15774">          c = (<CheckRefs ids="3293">c</CheckRefs><CheckRefs ids="3290,3291,3292">&lt;&lt;</CheckRefs>3) <CheckRefs ids="3289">+</CheckRefs> <CheckRefs ids="3294">z</CheckRefs>[i] <CheckRefs ids="3287,3288">-</CheckRefs> &apos;0&apos;;</Line>
  <Line number="15775">          if( <CheckRefs ids="3295">z</CheckRefs>[i<CheckRefs ids="3296">+</CheckRefs>1]&gt;=&apos;0&apos; &amp;&amp; <CheckRefs ids="3297">z</CheckRefs>[i<CheckRefs ids="3298">+</CheckRefs>1]&lt;=&apos;7&apos; ){</Line>
  <Line number="15776">            i<CheckRefs ids="3299">++</CheckRefs>;</Line>
  <Line number="15777">            c = (<CheckRefs ids="3306">c</CheckRefs><CheckRefs ids="3303,3304,3305">&lt;&lt;</CheckRefs>3) <CheckRefs ids="3302">+</CheckRefs> <CheckRefs ids="3307">z</CheckRefs>[i] <CheckRefs ids="3301,3300">-</CheckRefs> &apos;0&apos;;</Line>
  <Line number="15778">          }</Line>
  <Line number="15779">        }</Line>
  <Line number="15780">      }</Line>
  <Line number="15781">    }</Line>
  <Line number="15782">    z[j] = c;</Line>
  <Line number="15783">  }</Line>
  <Line number="15784">  if( j&lt;i ) z[j] = <CheckRefs ids="3308">0</CheckRefs>;</Line>
  <Line number="15785">}</Line>
  <Line number="15786"></Line>
  <Line number="15787">/*</Line>
  <Line number="15788">** Interpret zArg as either an integer or a boolean value.  Return 1 or 0</Line>
  <Line number="15789">** for TRUE and FALSE.  Return the integer value if appropriate.</Line>
  <Line number="15790">*/</Line>
  <Line number="15791">static int booleanValue(const char *zArg){</Line>
  <Line number="15792">  int i;</Line>
  <Line number="15793">  if( <CheckRefs ids="3309">zArg</CheckRefs>[0]==&apos;0&apos; &amp;&amp; <CheckRefs ids="3310">zArg</CheckRefs>[1]==&apos;x&apos; ){</Line>
  <Line number="15794">    for(i=2; hexDigitValue(zArg[i])&gt;=0; i<CheckRefs ids="3311">++</CheckRefs>){}</Line>
  <Line number="15795">  }else{</Line>
  <Line number="15796">    for(i=0; <CheckRefs ids="3312">zArg</CheckRefs>[i]&gt;=&apos;0&apos; &amp;&amp; <CheckRefs ids="3313">zArg</CheckRefs>[i]&lt;=&apos;9&apos;; i<CheckRefs ids="3314">++</CheckRefs>){}</Line>
  <Line number="15797">  }</Line>
  <Line number="15798">  if( i&gt;0 &amp;&amp; <CheckRefs ids="3315">zArg</CheckRefs>[i]==0 ) return <CheckRefs ids="3316">(</CheckRefs>int)(integerValue(zArg) &amp; <CheckRefs ids="3317">0xffffffff</CheckRefs>);</Line>
  <Line number="15799">  if( sqlite3_stricmp(zArg, &quot;on&quot;)==0 || sqlite3_stricmp(zArg,&quot;yes&quot;)==0 ){</Line>
  <Line number="15800">    return 1;</Line>
  <Line number="15801">  }</Line>
  <Line number="15802">  if( sqlite3_stricmp(zArg, &quot;off&quot;)==0 || sqlite3_stricmp(zArg,&quot;no&quot;)==0 ){</Line>
  <Line number="15803">    return 0;</Line>
  <Line number="15804">  }</Line>
  <Line number="15805">  utf8_printf(stderr, &quot;ERROR: Not a boolean value: \&quot;%s\&quot;. Assuming \&quot;no\&quot;.\n&quot;,</Line>
  <Line number="15806">          zArg);</Line>
  <Line number="15807">  return 0;</Line>
  <Line number="15808">}</Line>
  <Line number="15809"></Line>
  <Line number="15810">/*</Line>
  <Line number="15811">** Set or clear a shell flag according to a boolean value.</Line>
  <Line number="15812">*/</Line>
  <Line number="15813">static void setOrClearFlag(ShellState *p, unsigned mFlag, const char *zArg){</Line>
  <Line number="15814">  if( booleanValue(zArg) ){</Line>
  <Line number="15815">    ShellSetFlag(p, mFlag);</Line>
  <Line number="15816">  }else{</Line>
  <Line number="15817">    ShellClearFlag(p, mFlag);</Line>
  <Line number="15818">  }</Line>
  <Line number="15819">}</Line>
  <Line number="15820"></Line>
  <Line number="15821">/*</Line>
  <Line number="15822">** Close an output file, assuming it is not stderr or stdout</Line>
  <Line number="15823">*/</Line>
  <Line number="15824">static void output_file_close(FILE *f){</Line>
  <Line number="15825">  if( f &amp;&amp; f!=stdout &amp;&amp; f!=stderr ) fclose(f);</Line>
  <Line number="15826">}</Line>
  <Line number="15827"></Line>
  <Line number="15828">/*</Line>
  <Line number="15829">** Try to open an output file.   The names &quot;stdout&quot; and &quot;stderr&quot; are</Line>
  <Line number="15830">** recognized and do the right thing.  NULL is returned if the output</Line>
  <Line number="15831">** filename is &quot;off&quot;.</Line>
  <Line number="15832">*/</Line>
  <Line number="15833">static FILE *output_file_open(const char *zFile, int bTextMode){</Line>
  <Line number="15834">  FILE *f;</Line>
  <Line number="15835">  if( strcmp(zFile,&quot;stdout&quot;)==0 ){</Line>
  <Line number="15836">    f = stdout;</Line>
  <Line number="15837">  }else if( strcmp(zFile, &quot;stderr&quot;)==0 ){</Line>
  <Line number="15838">    f = stderr;</Line>
  <Line number="15839">  }else if( strcmp(zFile, &quot;off&quot;)==0 ){</Line>
  <Line number="15840">    f = 0;</Line>
  <Line number="15841">  }else{</Line>
  <Line number="15842">    f = fopen(zFile, bTextMode ? &quot;w&quot; : &quot;wb&quot;);</Line>
  <Line number="15843">    if( f==0 ){</Line>
  <Line number="15844">      utf8_printf(stderr, &quot;Error: cannot open \&quot;%s\&quot;\n&quot;, zFile);</Line>
  <Line number="15845">    }</Line>
  <Line number="15846">  }</Line>
  <Line number="15847">  return f;</Line>
  <Line number="15848">}</Line>
  <Line number="15849"></Line>
  <Line number="15850">#ifndef SQLITE_OMIT_TRACE</Line>
  <Line number="15851">/*</Line>
  <Line number="15852">** A routine for handling output from sqlite3_trace().</Line>
  <Line number="15853">*/</Line>
  <Line number="15854">static int sql_trace_callback(</Line>
  <Line number="15855">  unsigned mType,         /* The trace type */</Line>
  <Line number="15856">  void *pArg,             /* The ShellState pointer */</Line>
  <Line number="15857">  void *pP,               /* Usually a pointer to sqlite_stmt */</Line>
  <Line number="15858">  void *pX                /* Auxiliary output */</Line>
  <Line number="15859">){</Line>
  <Line number="15860">  ShellState *p = (ShellState*)pArg;</Line>
  <Line number="15861">  sqlite3_stmt *pStmt;</Line>
  <Line number="15862">  const char *zSql;</Line>
  <Line number="15863">  int nSql;</Line>
  <Line number="15864">  if( p-&gt;traceOut==0 ) return 0;</Line>
  <Line number="15865">  if( mType==<CheckRefs ids="3318">SQLITE_TRACE_CLOSE</CheckRefs> ){</Line>
  <Line number="15866">    utf8_printf(p-&gt;traceOut, &quot;-- closing database connection\n&quot;);</Line>
  <Line number="15867">    return 0;</Line>
  <Line number="15868">  }</Line>
  <Line number="15869">  if( mType!=<CheckRefs ids="3319">SQLITE_TRACE_ROW</CheckRefs> &amp;&amp; <CheckRefs ids="3320">(</CheckRefs>(const char*)pX)[0]==&apos;-&apos; ){</Line>
  <Line number="15870">    zSql = (const char*)pX;</Line>
  <Line number="15871">  }else{</Line>
  <Line number="15872">    pStmt = (sqlite3_stmt*)pP;</Line>
  <Line number="15873">    switch( <CheckRefs ids="3321">p</CheckRefs>-&gt;eTraceType ){</Line>
  <Line number="15874">      case SHELL_TRACE_EXPANDED: {</Line>
  <Line number="15875">        zSql = sqlite3_expanded_sql(pStmt);</Line>
  <Line number="15876">        break;</Line>
  <Line number="15877">      }</Line>
  <Line number="15878">#ifdef SQLITE_ENABLE_NORMALIZE</Line>
  <Line number="15879">      case SHELL_TRACE_NORMALIZED: {</Line>
  <Line number="15880">        zSql = sqlite3_normalized_sql(pStmt);</Line>
  <Line number="15881">        break;</Line>
  <Line number="15882">      }</Line>
  <Line number="15883">#endif</Line>
  <Line number="15884">      default: {</Line>
  <Line number="15885">        zSql = sqlite3_sql(pStmt);</Line>
  <Line number="15886">        break;</Line>
  <Line number="15887">      }</Line>
  <Line number="15888">    }</Line>
  <Line number="15889">  }</Line>
  <Line number="15890">  if( zSql==0 ) return 0;</Line>
  <Line number="15891">  nSql = strlen30(zSql);</Line>
  <Line number="15892">  while( nSql&gt;0 &amp;&amp; <CheckRefs ids="3322">zSql</CheckRefs>[nSql<CheckRefs ids="3323">-</CheckRefs>1]==&apos;;&apos; ){ nSql<CheckRefs ids="3324">--</CheckRefs>; }</Line>
  <Line number="15893">  switch( mType ){</Line>
  <Line number="15894">    case <CheckRefs ids="3325">SQLITE_TRACE_ROW</CheckRefs>:</Line>
  <Line number="15895">    case <CheckRefs ids="3326">SQLITE_TRACE_STMT</CheckRefs>: {</Line>
  <Line number="15896">      utf8_printf(p-&gt;traceOut, &quot;%.*s;\n&quot;, nSql, zSql);</Line>
  <Line number="15897">      break;</Line>
  <Line number="15898">    }</Line>
  <Line number="15899">    case <CheckRefs ids="3327">SQLITE_TRACE_PROFILE</CheckRefs>: {</Line>
  <Line number="15900">      sqlite3_int64 nNanosec = *(sqlite3_int64*)pX;</Line>
  <Line number="15901">      utf8_printf(p-&gt;traceOut, &quot;%.*s; -- %lld ns\n&quot;, nSql, zSql, nNanosec);</Line>
  <Line number="15902">      break;</Line>
  <Line number="15903">    }</Line>
  <Line number="15904">  }</Line>
  <Line number="15905">  return 0;</Line>
  <Line number="15906">}</Line>
  <Line number="15907">#endif</Line>
  <Line number="15908"></Line>
  <Line number="15909">/*</Line>
  <Line number="15910">** A no-op routine that runs with the &quot;.breakpoint&quot; doc-command.  This is</Line>
  <Line number="15911">** a useful spot to set a debugger breakpoint.</Line>
  <Line number="15912">*/</Line>
  <Line number="15913">static void test_breakpoint(void){</Line>
  <Line number="15914">  static int nCall = 0;</Line>
  <Line number="15915">  nCall<CheckRefs ids="3328">++</CheckRefs>;</Line>
  <Line number="15916">}</Line>
  <Line number="15917"></Line>
  <Line number="15918">/*</Line>
  <Line number="15919">** An object used to read a CSV and other files for import.</Line>
  <Line number="15920">*/</Line>
  <Line number="15921">typedef struct ImportCtx ImportCtx;</Line>
  <Line number="15922">struct ImportCtx {</Line>
  <Line number="15923">  const char *zFile;  /* Name of the input file */</Line>
  <Line number="15924">  FILE *in;           /* Read the CSV text from this input stream */</Line>
  <Line number="15925">  int (SQLITE_CDECL *xCloser)(FILE*);      /* Func to close in */</Line>
  <Line number="15926">  char *z;            /* Accumulated text for a field */</Line>
  <Line number="15927">  int n;              /* Number of bytes in z */</Line>
  <Line number="15928">  int nAlloc;         /* Space allocated for z[] */</Line>
  <Line number="15929">  int nLine;          /* Current line number */</Line>
  <Line number="15930">  int nRow;           /* Number of rows imported */</Line>
  <Line number="15931">  int nErr;           /* Number of errors encountered */</Line>
  <Line number="15932">  int bNotFirst;      /* True if one or more bytes already read */</Line>
  <Line number="15933">  int cTerm;          /* Character that terminated the most recent field */</Line>
  <Line number="15934">  int cColSep;        /* The column separator character.  (Usually &quot;,&quot;) */</Line>
  <Line number="15935">  int cRowSep;        /* The row separator character.  (Usually &quot;\n&quot;) */</Line>
  <Line number="15936">};</Line>
  <Line number="15937"></Line>
  <Line number="15938">/* Clean up resourced used by an ImportCtx */</Line>
  <Line number="15939">static void import_cleanup(ImportCtx *p){</Line>
  <Line number="15940">  if( p-&gt;in!=0 &amp;&amp; p-&gt;xCloser!=0 ){</Line>
  <Line number="15941">    p-&gt;xCloser(p-&gt;in);</Line>
  <Line number="15942">    p-&gt;in = 0;</Line>
  <Line number="15943">  }</Line>
  <Line number="15944">  sqlite3_free(p-&gt;z);</Line>
  <Line number="15945">  p-&gt;z = 0;</Line>
  <Line number="15946">}</Line>
  <Line number="15947"></Line>
  <Line number="15948">/* Append a single byte to z[] */</Line>
  <Line number="15949">static void import_append_char(ImportCtx *p, int c){</Line>
  <Line number="15950">  if( p-&gt;n<CheckRefs ids="3329">+</CheckRefs>1&gt;=p-&gt;nAlloc ){</Line>
  <Line number="15951">    p-&gt;nAlloc <CheckRefs ids="3330">+=</CheckRefs> p-&gt;nAlloc <CheckRefs ids="3331">+</CheckRefs> 100;</Line>
  <Line number="15952">    p-&gt;z = sqlite3_realloc64(p-&gt;z, <CheckRefs ids="3332">p</CheckRefs>-&gt;nAlloc);</Line>
  <Line number="15953">    if( p-&gt;z==0 ) shell_out_of_memory();</Line>
  <Line number="15954">  }</Line>
  <Line number="15955">  p-&gt;z[p-&gt;n<CheckRefs ids="3333">++</CheckRefs>] = <CheckRefs ids="3334">(</CheckRefs>char)c;</Line>
  <Line number="15956">}</Line>
  <Line number="15957"></Line>
  <Line number="15958">/* Read a single field of CSV text.  Compatible with rfc4180 and extended</Line>
  <Line number="15959">** with the option of having a separator other than &quot;,&quot;.</Line>
  <Line number="15960">**</Line>
  <Line number="15961">**   +  Input comes from p-&gt;in.</Line>
  <Line number="15962">**   +  Store results in p-&gt;z of length p-&gt;n.  Space to hold p-&gt;z comes</Line>
  <Line number="15963">**      from sqlite3_malloc64().</Line>
  <Line number="15964">**   +  Use p-&gt;cSep as the column separator.  The default is &quot;,&quot;.</Line>
  <Line number="15965">**   +  Use p-&gt;rSep as the row separator.  The default is &quot;\n&quot;.</Line>
  <Line number="15966">**   +  Keep track of the line number in p-&gt;nLine.</Line>
  <Line number="15967">**   +  Store the character that terminates the field in p-&gt;cTerm.  Store</Line>
  <Line number="15968">**      EOF on end-of-file.</Line>
  <Line number="15969">**   +  Report syntax errors on stderr</Line>
  <Line number="15970">*/</Line>
  <Line number="15971">static char *SQLITE_CDECL csv_read_one_field(ImportCtx *p){</Line>
  <Line number="15972">  int c;</Line>
  <Line number="15973">  int cSep = p-&gt;cColSep;</Line>
  <Line number="15974">  int rSep = p-&gt;cRowSep;</Line>
  <Line number="15975">  p-&gt;n = 0;</Line>
  <Line number="15976">  c = fgetc(p-&gt;in);</Line>
  <Line number="15977">  if( c==<CheckRefs ids="3335">EOF</CheckRefs> || seenInterrupt ){</Line>
  <Line number="15978">    p-&gt;cTerm = <CheckRefs ids="3336">EOF</CheckRefs>;</Line>
  <Line number="15979">    return 0;</Line>
  <Line number="15980">  }</Line>
  <Line number="15981">  if( c==&apos;&quot;&apos; ){</Line>
  <Line number="15982">    int pc, ppc;</Line>
  <Line number="15983">    int startLine = p-&gt;nLine;</Line>
  <Line number="15984">    int cQuote = c;</Line>
  <Line number="15985">    pc = ppc = 0;</Line>
  <Line number="15986">    while( 1 ){</Line>
  <Line number="15987">      c = fgetc(p-&gt;in);</Line>
  <Line number="15988">      if( c==rSep ) p-&gt;nLine<CheckRefs ids="3337">++</CheckRefs>;</Line>
  <Line number="15989">      if( c==cQuote ){</Line>
  <Line number="15990">        if( pc==cQuote ){</Line>
  <Line number="15991">          pc = 0;</Line>
  <Line number="15992">          continue;</Line>
  <Line number="15993">        }</Line>
  <Line number="15994">      }</Line>
  <Line number="15995">      if( (c==cSep &amp;&amp; pc==cQuote)</Line>
  <Line number="15996">       || (c==rSep &amp;&amp; pc==cQuote)</Line>
  <Line number="15997">       || (c==rSep &amp;&amp; pc==&apos;\r&apos; &amp;&amp; ppc==cQuote)</Line>
  <Line number="15998">       || (c==<CheckRefs ids="3338">EOF</CheckRefs> &amp;&amp; pc==cQuote)</Line>
  <Line number="15999">      ){</Line>
  <Line number="16000">        do{ p-&gt;n<CheckRefs ids="3339">--</CheckRefs>; }while( <CheckRefs ids="3340">p</CheckRefs>-&gt;z[p-&gt;n]!=cQuote );</Line>
  <Line number="16001">        p-&gt;cTerm = c;</Line>
  <Line number="16002">        break;</Line>
  <Line number="16003">      }</Line>
  <Line number="16004">      if( pc==cQuote &amp;&amp; c!=&apos;\r&apos; ){</Line>
  <Line number="16005">        utf8_printf(stderr, &quot;%s:%d: unescaped %c character\n&quot;,</Line>
  <Line number="16006">                p-&gt;zFile, p-&gt;nLine, cQuote);</Line>
  <Line number="16007">      }</Line>
  <Line number="16008">      if( c==<CheckRefs ids="3341">EOF</CheckRefs> ){</Line>
  <Line number="16009">        utf8_printf(stderr, &quot;%s:%d: unterminated %c-quoted field\n&quot;,</Line>
  <Line number="16010">                p-&gt;zFile, startLine, cQuote);</Line>
  <Line number="16011">        p-&gt;cTerm = c;</Line>
  <Line number="16012">        break;</Line>
  <Line number="16013">      }</Line>
  <Line number="16014">      import_append_char(p, c);</Line>
  <Line number="16015">      ppc = pc;</Line>
  <Line number="16016">      pc = c;</Line>
  <Line number="16017">    }</Line>
  <Line number="16018">  }else{</Line>
  <Line number="16019">    /* If this is the first field being parsed and it begins with the</Line>
  <Line number="16020">    ** UTF-8 BOM  (0xEF BB BF) then skip the BOM */</Line>
  <Line number="16021">    if( (c&amp;0xff)==0xef &amp;&amp; p-&gt;bNotFirst==0 ){</Line>
  <Line number="16022">      import_append_char(p, c);</Line>
  <Line number="16023">      c = fgetc(p-&gt;in);</Line>
  <Line number="16024">      if( (c&amp;0xff)==0xbb ){</Line>
  <Line number="16025">        import_append_char(p, c);</Line>
  <Line number="16026">        c = fgetc(p-&gt;in);</Line>
  <Line number="16027">        if( (c&amp;0xff)==0xbf ){</Line>
  <Line number="16028">          p-&gt;bNotFirst = 1;</Line>
  <Line number="16029">          p-&gt;n = 0;</Line>
  <Line number="16030">          return csv_read_one_field(p);</Line>
  <Line number="16031">        }</Line>
  <Line number="16032">      }</Line>
  <Line number="16033">    }</Line>
  <Line number="16034">    while( c!=<CheckRefs ids="3342">EOF</CheckRefs> &amp;&amp; c!=cSep &amp;&amp; c!=rSep ){</Line>
  <Line number="16035">      import_append_char(p, c);</Line>
  <Line number="16036">      c = fgetc(p-&gt;in);</Line>
  <Line number="16037">    }</Line>
  <Line number="16038">    if( c==rSep ){</Line>
  <Line number="16039">      p-&gt;nLine<CheckRefs ids="3343">++</CheckRefs>;</Line>
  <Line number="16040">      if( p-&gt;n&gt;0 &amp;&amp; <CheckRefs ids="3344">p</CheckRefs>-&gt;z[p-&gt;n<CheckRefs ids="3345">-</CheckRefs>1]==&apos;\r&apos; ) p-&gt;n<CheckRefs ids="3346">--</CheckRefs>;</Line>
  <Line number="16041">    }</Line>
  <Line number="16042">    p-&gt;cTerm = c;</Line>
  <Line number="16043">  }</Line>
  <Line number="16044">  if( p-&gt;z ) p-&gt;z[p-&gt;n] = <CheckRefs ids="3347">0</CheckRefs>;</Line>
  <Line number="16045">  p-&gt;bNotFirst = 1;</Line>
  <Line number="16046">  return p-&gt;z;</Line>
  <Line number="16047">}</Line>
  <Line number="16048"></Line>
  <Line number="16049">/* Read a single field of ASCII delimited text.</Line>
  <Line number="16050">**</Line>
  <Line number="16051">**   +  Input comes from p-&gt;in.</Line>
  <Line number="16052">**   +  Store results in p-&gt;z of length p-&gt;n.  Space to hold p-&gt;z comes</Line>
  <Line number="16053">**      from sqlite3_malloc64().</Line>
  <Line number="16054">**   +  Use p-&gt;cSep as the column separator.  The default is &quot;\x1F&quot;.</Line>
  <Line number="16055">**   +  Use p-&gt;rSep as the row separator.  The default is &quot;\x1E&quot;.</Line>
  <Line number="16056">**   +  Keep track of the row number in p-&gt;nLine.</Line>
  <Line number="16057">**   +  Store the character that terminates the field in p-&gt;cTerm.  Store</Line>
  <Line number="16058">**      EOF on end-of-file.</Line>
  <Line number="16059">**   +  Report syntax errors on stderr</Line>
  <Line number="16060">*/</Line>
  <Line number="16061">static char *SQLITE_CDECL ascii_read_one_field(ImportCtx *p){</Line>
  <Line number="16062">  int c;</Line>
  <Line number="16063">  int cSep = p-&gt;cColSep;</Line>
  <Line number="16064">  int rSep = p-&gt;cRowSep;</Line>
  <Line number="16065">  p-&gt;n = 0;</Line>
  <Line number="16066">  c = fgetc(p-&gt;in);</Line>
  <Line number="16067">  if( c==<CheckRefs ids="3348">EOF</CheckRefs> || seenInterrupt ){</Line>
  <Line number="16068">    p-&gt;cTerm = <CheckRefs ids="3349">EOF</CheckRefs>;</Line>
  <Line number="16069">    return 0;</Line>
  <Line number="16070">  }</Line>
  <Line number="16071">  while( c!=<CheckRefs ids="3350">EOF</CheckRefs> &amp;&amp; c!=cSep &amp;&amp; c!=rSep ){</Line>
  <Line number="16072">    import_append_char(p, c);</Line>
  <Line number="16073">    c = fgetc(p-&gt;in);</Line>
  <Line number="16074">  }</Line>
  <Line number="16075">  if( c==rSep ){</Line>
  <Line number="16076">    p-&gt;nLine<CheckRefs ids="3351">++</CheckRefs>;</Line>
  <Line number="16077">  }</Line>
  <Line number="16078">  p-&gt;cTerm = c;</Line>
  <Line number="16079">  if( p-&gt;z ) p-&gt;z[p-&gt;n] = <CheckRefs ids="3352">0</CheckRefs>;</Line>
  <Line number="16080">  return p-&gt;z;</Line>
  <Line number="16081">}</Line>
  <Line number="16082"></Line>
  <Line number="16083">/*</Line>
  <Line number="16084">** Try to transfer data for table zTable.  If an error is seen while</Line>
  <Line number="16085">** moving forward, try to go backwards.  The backwards movement won&apos;t</Line>
  <Line number="16086">** work for WITHOUT ROWID tables.</Line>
  <Line number="16087">*/</Line>
  <Line number="16088">static void tryToCloneData(</Line>
  <Line number="16089">  ShellState *p,</Line>
  <Line number="16090">  sqlite3 *newDb,</Line>
  <Line number="16091">  const char *zTable</Line>
  <Line number="16092">){</Line>
  <Line number="16093">  sqlite3_stmt *pQuery = 0;</Line>
  <Line number="16094">  sqlite3_stmt *pInsert = 0;</Line>
  <Line number="16095">  char *zQuery = 0;</Line>
  <Line number="16096">  char *zInsert = 0;</Line>
  <Line number="16097">  int rc;</Line>
  <Line number="16098">  int i, j, n;</Line>
  <Line number="16099">  int nTable = strlen30(zTable);</Line>
  <Line number="16100">  int k = 0;</Line>
  <Line number="16101">  int cnt = 0;</Line>
  <Line number="16102">  const int spinRate = 10000;</Line>
  <Line number="16103"></Line>
  <Line number="16104">  zQuery = sqlite3_mprintf(&quot;SELECT * FROM \&quot;%w\&quot;&quot;, zTable);</Line>
  <Line number="16105">  rc = sqlite3_prepare_v2(p-&gt;db, zQuery, <CheckRefs ids="3353">-</CheckRefs>1, &amp;pQuery, 0);</Line>
  <Line number="16106">  if( rc ){</Line>
  <Line number="16107">    utf8_printf(stderr, &quot;Error %d: %s on [%s]\n&quot;,</Line>
  <Line number="16108">            sqlite3_extended_errcode(p-&gt;db), sqlite3_errmsg(p-&gt;db),</Line>
  <Line number="16109">            zQuery);</Line>
  <Line number="16110">    goto end_data_xfer;</Line>
  <Line number="16111">  }</Line>
  <Line number="16112">  n = sqlite3_column_count(pQuery);</Line>
  <Line number="16113">  zInsert = sqlite3_malloc64(200 <CheckRefs ids="3356">+</CheckRefs> nTable <CheckRefs ids="3354,3355">+</CheckRefs> n<CheckRefs ids="3357">*</CheckRefs>3);</Line>
  <Line number="16114">  if( zInsert==0 ) shell_out_of_memory();</Line>
  <Line number="16115">  sqlite3_snprintf(200<CheckRefs ids="3358">+</CheckRefs>nTable,zInsert,</Line>
  <Line number="16116">                   &quot;INSERT OR IGNORE INTO \&quot;%s\&quot; VALUES(?&quot;, zTable);</Line>
  <Line number="16117">  i = strlen30(zInsert);</Line>
  <Line number="16118">  for(j=1; j&lt;n; j<CheckRefs ids="3359">++</CheckRefs>){</Line>
  <Line number="16119">    memcpy(zInsert+i, &quot;,?&quot;, <CheckRefs ids="3360">2</CheckRefs>);</Line>
  <Line number="16120">    i <CheckRefs ids="3361">+=</CheckRefs> 2;</Line>
  <Line number="16121">  }</Line>
  <Line number="16122">  memcpy(zInsert+i, &quot;);&quot;, <CheckRefs ids="3362">3</CheckRefs>);</Line>
  <Line number="16123">  rc = sqlite3_prepare_v2(newDb, zInsert, <CheckRefs ids="3363">-</CheckRefs>1, &amp;pInsert, 0);</Line>
  <Line number="16124">  if( rc ){</Line>
  <Line number="16125">    utf8_printf(stderr, &quot;Error %d: %s on [%s]\n&quot;,</Line>
  <Line number="16126">            sqlite3_extended_errcode(newDb), sqlite3_errmsg(newDb),</Line>
  <Line number="16127">            zQuery);</Line>
  <Line number="16128">    goto end_data_xfer;</Line>
  <Line number="16129">  }</Line>
  <Line number="16130">  for(k=0; k&lt;2; k<CheckRefs ids="3364">++</CheckRefs>){</Line>
  <Line number="16131">    while( (rc = sqlite3_step(pQuery))==SQLITE_ROW ){</Line>
  <Line number="16132">      for(i=0; i&lt;n; i<CheckRefs ids="3365">++</CheckRefs>){</Line>
  <Line number="16133">        switch( sqlite3_column_type(pQuery, i) ){</Line>
  <Line number="16134">          case SQLITE_NULL: {</Line>
  <Line number="16135">            sqlite3_bind_null(pInsert, i<CheckRefs ids="3366">+</CheckRefs>1);</Line>
  <Line number="16136">            break;</Line>
  <Line number="16137">          }</Line>
  <Line number="16138">          case SQLITE_INTEGER: {</Line>
  <Line number="16139">            sqlite3_bind_int64(pInsert, i<CheckRefs ids="3367">+</CheckRefs>1, sqlite3_column_int64(pQuery,i));</Line>
  <Line number="16140">            break;</Line>
  <Line number="16141">          }</Line>
  <Line number="16142">          case SQLITE_FLOAT: {</Line>
  <Line number="16143">            sqlite3_bind_double(pInsert, i<CheckRefs ids="3368">+</CheckRefs>1, sqlite3_column_double(pQuery,i));</Line>
  <Line number="16144">            break;</Line>
  <Line number="16145">          }</Line>
  <Line number="16146">          case SQLITE_TEXT: {</Line>
  <Line number="16147">            sqlite3_bind_text(pInsert, i<CheckRefs ids="3369">+</CheckRefs>1,</Line>
  <Line number="16148">                             (const char*)sqlite3_column_text(pQuery,i),</Line>
  <Line number="16149">                             <CheckRefs ids="3370">-</CheckRefs>1, SQLITE_STATIC);</Line>
  <Line number="16150">            break;</Line>
  <Line number="16151">          }</Line>
  <Line number="16152">          case SQLITE_BLOB: {</Line>
  <Line number="16153">            sqlite3_bind_blob(pInsert, i<CheckRefs ids="3371">+</CheckRefs>1, sqlite3_column_blob(pQuery,i),</Line>
  <Line number="16154">                                            sqlite3_column_bytes(pQuery,i),</Line>
  <Line number="16155">                                            SQLITE_STATIC);</Line>
  <Line number="16156">            break;</Line>
  <Line number="16157">          }</Line>
  <Line number="16158">        }</Line>
  <Line number="16159">      } /* End for */</Line>
  <Line number="16160">      rc = sqlite3_step(pInsert);</Line>
  <Line number="16161">      if( rc!=SQLITE_OK &amp;&amp; rc!=SQLITE_ROW &amp;&amp; rc!=SQLITE_DONE ){</Line>
  <Line number="16162">        utf8_printf(stderr, &quot;Error %d: %s\n&quot;, sqlite3_extended_errcode(newDb),</Line>
  <Line number="16163">                        sqlite3_errmsg(newDb));</Line>
  <Line number="16164">      }</Line>
  <Line number="16165">      sqlite3_reset(pInsert);</Line>
  <Line number="16166">      cnt<CheckRefs ids="3372">++</CheckRefs>;</Line>
  <Line number="16167">      if( (cnt<CheckRefs ids="3373">%</CheckRefs>spinRate)==0 ){</Line>
  <Line number="16168">        printf(&quot;%c\b&quot;, <CheckRefs ids="3374">&quot;|/-\\&quot;</CheckRefs>[(cnt<CheckRefs ids="3377,3378">/</CheckRefs>spinRate)<CheckRefs ids="3376">%</CheckRefs>4<CheckRefs ids="3375">]</CheckRefs>);</Line>
  <Line number="16169">        fflush(stdout);</Line>
  <Line number="16170">      }</Line>
  <Line number="16171">    } /* End while */</Line>
  <Line number="16172">    if( rc==SQLITE_DONE ) break;</Line>
  <Line number="16173">    sqlite3_finalize(pQuery);</Line>
  <Line number="16174">    sqlite3_free(zQuery);</Line>
  <Line number="16175">    zQuery = sqlite3_mprintf(&quot;SELECT * FROM \&quot;%w\&quot; ORDER BY rowid DESC;&quot;,</Line>
  <Line number="16176">                             zTable);</Line>
  <Line number="16177">    rc = sqlite3_prepare_v2(p-&gt;db, zQuery, <CheckRefs ids="3379">-</CheckRefs>1, &amp;pQuery, 0);</Line>
  <Line number="16178">    if( rc ){</Line>
  <Line number="16179">      utf8_printf(stderr, &quot;Warning: cannot step \&quot;%s\&quot; backwards&quot;, zTable);</Line>
  <Line number="16180">      break;</Line>
  <Line number="16181">    }</Line>
  <Line number="16182">  } /* End for(k=0...) */</Line>
  <Line number="16183"></Line>
  <Line number="16184">end_data_xfer:</Line>
  <Line number="16185">  sqlite3_finalize(pQuery);</Line>
  <Line number="16186">  sqlite3_finalize(pInsert);</Line>
  <Line number="16187">  sqlite3_free(zQuery);</Line>
  <Line number="16188">  sqlite3_free(zInsert);</Line>
  <Line number="16189">}</Line>
  <Line number="16190"></Line>
  <Line number="16191"></Line>
  <Line number="16192">/*</Line>
  <Line number="16193">** Try to transfer all rows of the schema that match zWhere.  For</Line>
  <Line number="16194">** each row, invoke xForEach() on the object defined by that row.</Line>
  <Line number="16195">** If an error is encountered while moving forward through the</Line>
  <Line number="16196">** sqlite_schema table, try again moving backwards.</Line>
  <Line number="16197">*/</Line>
  <Line number="16198">static void tryToCloneSchema(</Line>
  <Line number="16199">  ShellState *p,</Line>
  <Line number="16200">  sqlite3 *newDb,</Line>
  <Line number="16201">  const char *zWhere,</Line>
  <Line number="16202">  void (*xForEach)(ShellState*,sqlite3*,const char*)</Line>
  <Line number="16203">){</Line>
  <Line number="16204">  sqlite3_stmt *pQuery = 0;</Line>
  <Line number="16205">  char *zQuery = 0;</Line>
  <Line number="16206">  int rc;</Line>
  <Line number="16207">  const unsigned char *zName;</Line>
  <Line number="16208">  const unsigned char *zSql;</Line>
  <Line number="16209">  char *zErrMsg = 0;</Line>
  <Line number="16210"></Line>
  <Line number="16211">  zQuery = sqlite3_mprintf(&quot;SELECT name, sql FROM sqlite_schema&quot;</Line>
  <Line number="16212">                           &quot; WHERE %s&quot;, zWhere);</Line>
  <Line number="16213">  rc = sqlite3_prepare_v2(p-&gt;db, zQuery, <CheckRefs ids="3380">-</CheckRefs>1, &amp;pQuery, 0);</Line>
  <Line number="16214">  if( rc ){</Line>
  <Line number="16215">    utf8_printf(stderr, &quot;Error: (%d) %s on [%s]\n&quot;,</Line>
  <Line number="16216">                    sqlite3_extended_errcode(p-&gt;db), sqlite3_errmsg(p-&gt;db),</Line>
  <Line number="16217">                    zQuery);</Line>
  <Line number="16218">    goto end_schema_xfer;</Line>
  <Line number="16219">  }</Line>
  <Line number="16220">  while( (rc = sqlite3_step(pQuery))==SQLITE_ROW ){</Line>
  <Line number="16221">    zName = sqlite3_column_text(pQuery, 0);</Line>
  <Line number="16222">    zSql = sqlite3_column_text(pQuery, 1);</Line>
  <Line number="16223">    printf(&quot;%s... &quot;, zName); fflush(stdout);</Line>
  <Line number="16224">    sqlite3_exec(newDb, (const char*)zSql, 0, 0, &amp;zErrMsg);</Line>
  <Line number="16225">    if( zErrMsg ){</Line>
  <Line number="16226">      utf8_printf(stderr, &quot;Error: %s\nSQL: [%s]\n&quot;, zErrMsg, zSql);</Line>
  <Line number="16227">      sqlite3_free(zErrMsg);</Line>
  <Line number="16228">      zErrMsg = 0;</Line>
  <Line number="16229">    }</Line>
  <Line number="16230">    if( xForEach ){</Line>
  <Line number="16231">      xForEach(p, newDb, (const char*)zName);</Line>
  <Line number="16232">    }</Line>
  <Line number="16233">    printf(&quot;done\n&quot;);</Line>
  <Line number="16234">  }</Line>
  <Line number="16235">  if( rc!=SQLITE_DONE ){</Line>
  <Line number="16236">    sqlite3_finalize(pQuery);</Line>
  <Line number="16237">    sqlite3_free(zQuery);</Line>
  <Line number="16238">    zQuery = sqlite3_mprintf(&quot;SELECT name, sql FROM sqlite_schema&quot;</Line>
  <Line number="16239">                             &quot; WHERE %s ORDER BY rowid DESC&quot;, zWhere);</Line>
  <Line number="16240">    rc = sqlite3_prepare_v2(p-&gt;db, zQuery, <CheckRefs ids="3381">-</CheckRefs>1, &amp;pQuery, 0);</Line>
  <Line number="16241">    if( rc ){</Line>
  <Line number="16242">      utf8_printf(stderr, &quot;Error: (%d) %s on [%s]\n&quot;,</Line>
  <Line number="16243">                      sqlite3_extended_errcode(p-&gt;db), sqlite3_errmsg(p-&gt;db),</Line>
  <Line number="16244">                      zQuery);</Line>
  <Line number="16245">      goto end_schema_xfer;</Line>
  <Line number="16246">    }</Line>
  <Line number="16247">    while( (rc = sqlite3_step(pQuery))==SQLITE_ROW ){</Line>
  <Line number="16248">      zName = sqlite3_column_text(pQuery, 0);</Line>
  <Line number="16249">      zSql = sqlite3_column_text(pQuery, 1);</Line>
  <Line number="16250">      printf(&quot;%s... &quot;, zName); fflush(stdout);</Line>
  <Line number="16251">      sqlite3_exec(newDb, (const char*)zSql, 0, 0, &amp;zErrMsg);</Line>
  <Line number="16252">      if( zErrMsg ){</Line>
  <Line number="16253">        utf8_printf(stderr, &quot;Error: %s\nSQL: [%s]\n&quot;, zErrMsg, zSql);</Line>
  <Line number="16254">        sqlite3_free(zErrMsg);</Line>
  <Line number="16255">        zErrMsg = 0;</Line>
  <Line number="16256">      }</Line>
  <Line number="16257">      if( xForEach ){</Line>
  <Line number="16258">        xForEach(p, newDb, (const char*)zName);</Line>
  <Line number="16259">      }</Line>
  <Line number="16260">      printf(&quot;done\n&quot;);</Line>
  <Line number="16261">    }</Line>
  <Line number="16262">  }</Line>
  <Line number="16263">end_schema_xfer:</Line>
  <Line number="16264">  sqlite3_finalize(pQuery);</Line>
  <Line number="16265">  sqlite3_free(zQuery);</Line>
  <Line number="16266">}</Line>
  <Line number="16267"></Line>
  <Line number="16268">/*</Line>
  <Line number="16269">** Open a new database file named &quot;zNewDb&quot;.  Try to recover as much information</Line>
  <Line number="16270">** as possible out of the main database (which might be corrupt) and write it</Line>
  <Line number="16271">** into zNewDb.</Line>
  <Line number="16272">*/</Line>
  <Line number="16273">static void tryToClone(ShellState *p, const char *zNewDb){</Line>
  <Line number="16274">  int rc;</Line>
  <Line number="16275">  sqlite3 *newDb = 0;</Line>
  <Line number="16276">  if( access(zNewDb,0)==0 ){</Line>
  <Line number="16277">    utf8_printf(stderr, &quot;File \&quot;%s\&quot; already exists.\n&quot;, zNewDb);</Line>
  <Line number="16278">    return;</Line>
  <Line number="16279">  }</Line>
  <Line number="16280">  rc = sqlite3_open(zNewDb, &amp;newDb);</Line>
  <Line number="16281">  if( rc ){</Line>
  <Line number="16282">    utf8_printf(stderr, &quot;Cannot create output database: %s\n&quot;,</Line>
  <Line number="16283">            sqlite3_errmsg(newDb));</Line>
  <Line number="16284">  }else{</Line>
  <Line number="16285">    sqlite3_exec(p-&gt;db, &quot;PRAGMA writable_schema=ON;&quot;, 0, 0, 0);</Line>
  <Line number="16286">    sqlite3_exec(newDb, &quot;BEGIN EXCLUSIVE;&quot;, 0, 0, 0);</Line>
  <Line number="16287">    tryToCloneSchema(p, newDb, &quot;type=&apos;table&apos;&quot;, tryToCloneData);</Line>
  <Line number="16288">    tryToCloneSchema(p, newDb, &quot;type!=&apos;table&apos;&quot;, 0);</Line>
  <Line number="16289">    sqlite3_exec(newDb, &quot;COMMIT;&quot;, 0, 0, 0);</Line>
  <Line number="16290">    sqlite3_exec(p-&gt;db, &quot;PRAGMA writable_schema=OFF;&quot;, 0, 0, 0);</Line>
  <Line number="16291">  }</Line>
  <Line number="16292">  close_db(newDb);</Line>
  <Line number="16293">}</Line>
  <Line number="16294"></Line>
  <Line number="16295">/*</Line>
  <Line number="16296">** Change the output file back to stdout.</Line>
  <Line number="16297">**</Line>
  <Line number="16298">** If the p-&gt;doXdgOpen flag is set, that means the output was being</Line>
  <Line number="16299">** redirected to a temporary file named by p-&gt;zTempFile.  In that case,</Line>
  <Line number="16300">** launch start/open/xdg-open on that temporary file.</Line>
  <Line number="16301">*/</Line>
  <Line number="16302">static void output_reset(ShellState *p){</Line>
  <Line number="16303">  if( <CheckRefs ids="3382">p</CheckRefs>-&gt;outfile[0<CheckRefs ids="3383">]</CheckRefs>==&apos;|&apos; ){</Line>
  <Line number="16304">#ifndef SQLITE_OMIT_POPEN</Line>
  <Line number="16305">    pclose(p-&gt;out);</Line>
  <Line number="16306">#endif</Line>
  <Line number="16307">  }else{</Line>
  <Line number="16308">    output_file_close(p-&gt;out);</Line>
  <Line number="16309">#ifndef SQLITE_NOHAVE_SYSTEM</Line>
  <Line number="16310">    if( p-&gt;doXdgOpen ){</Line>
  <Line number="16311">      const char *zXdgOpenCmd =</Line>
  <Line number="16312">#if defined(_WIN32)</Line>
  <Line number="16313">      &quot;start&quot;;</Line>
  <Line number="16314">#elif defined(__APPLE__)</Line>
  <Line number="16315">      &quot;open&quot;;</Line>
  <Line number="16316">#else</Line>
  <Line number="16317">      &quot;xdg-open&quot;;</Line>
  <Line number="16318">#endif</Line>
  <Line number="16319">      char *zCmd;</Line>
  <Line number="16320">      zCmd = sqlite3_mprintf(&quot;%s %s&quot;, zXdgOpenCmd, p-&gt;zTempFile);</Line>
  <Line number="16321">      if( system(zCmd) ){</Line>
  <Line number="16322">        utf8_printf(stderr, &quot;Failed: [%s]\n&quot;, zCmd);</Line>
  <Line number="16323">      }else{</Line>
  <Line number="16324">        /* Give the start/open/xdg-open command some time to get</Line>
  <Line number="16325">        ** going before we continue, and potential delete the</Line>
  <Line number="16326">        ** p-&gt;zTempFile data file out from under it */</Line>
  <Line number="16327">        sqlite3_sleep(2000);</Line>
  <Line number="16328">      }</Line>
  <Line number="16329">      sqlite3_free(zCmd);</Line>
  <Line number="16330">      outputModePop(p);</Line>
  <Line number="16331">      p-&gt;doXdgOpen = <CheckRefs ids="3384">0</CheckRefs>;</Line>
  <Line number="16332">    }</Line>
  <Line number="16333">#endif /* !defined(SQLITE_NOHAVE_SYSTEM) */</Line>
  <Line number="16334">  }</Line>
  <Line number="16335">  p-&gt;outfile[0<CheckRefs ids="3385">]</CheckRefs> = <CheckRefs ids="3386">0</CheckRefs>;</Line>
  <Line number="16336">  p-&gt;out = stdout;</Line>
  <Line number="16337">}</Line>
  <Line number="16338"></Line>
  <Line number="16339">/*</Line>
  <Line number="16340">** Run an SQL command and return the single integer result.</Line>
  <Line number="16341">*/</Line>
  <Line number="16342">static int db_int(ShellState *p, const char *zSql){</Line>
  <Line number="16343">  sqlite3_stmt *pStmt;</Line>
  <Line number="16344">  int res = 0;</Line>
  <Line number="16345">  sqlite3_prepare_v2(p-&gt;db, zSql, <CheckRefs ids="3387">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="16346">  if( pStmt &amp;&amp; sqlite3_step(pStmt)==SQLITE_ROW ){</Line>
  <Line number="16347">    res = sqlite3_column_int(pStmt,0);</Line>
  <Line number="16348">  }</Line>
  <Line number="16349">  sqlite3_finalize(pStmt);</Line>
  <Line number="16350">  return res;</Line>
  <Line number="16351">}</Line>
  <Line number="16352"></Line>
  <Line number="16353">/*</Line>
  <Line number="16354">** Convert a 2-byte or 4-byte big-endian integer into a native integer</Line>
  <Line number="16355">*/</Line>
  <Line number="16356">static unsigned int get2byteInt(unsigned char *a){</Line>
  <Line number="16357">  return (<CheckRefs ids="3393">a</CheckRefs>[0]<CheckRefs ids="3390,3391,3392">&lt;&lt;</CheckRefs>8) <CheckRefs ids="3388,3389">+</CheckRefs> <CheckRefs ids="3394">a</CheckRefs>[1];</Line>
  <Line number="16358">}</Line>
  <Line number="16359">static unsigned int get4byteInt(unsigned char *a){</Line>
  <Line number="16360">  return (<CheckRefs ids="3402">a</CheckRefs>[0]<CheckRefs ids="3399,3400,3401">&lt;&lt;</CheckRefs>24) <CheckRefs ids="3398">+</CheckRefs> (<CheckRefs ids="3406">a</CheckRefs>[1]<CheckRefs ids="3403,3404,3405">&lt;&lt;</CheckRefs>16) <CheckRefs ids="3397">+</CheckRefs> (<CheckRefs ids="3410">a</CheckRefs>[2]<CheckRefs ids="3407,3408,3409">&lt;&lt;</CheckRefs>8) <CheckRefs ids="3396,3395">+</CheckRefs> <CheckRefs ids="3411">a</CheckRefs>[3];</Line>
  <Line number="16361">}</Line>
  <Line number="16362"></Line>
  <Line number="16363">/*</Line>
  <Line number="16364">** Implementation of the &quot;.dbinfo&quot; command.</Line>
  <Line number="16365">**</Line>
  <Line number="16366">** Return 1 on error, 2 to exit, and 0 otherwise.</Line>
  <Line number="16367">*/</Line>
  <Line number="16368">static int shell_dbinfo_command(ShellState *p, int nArg, char **azArg){</Line>
  <Line number="16369">  static const struct { const char *zName; int ofst; } aField[] = {</Line>
  <Line number="16370">     { &quot;file change counter:&quot;,  24  },</Line>
  <Line number="16371">     { &quot;database page count:&quot;,  28  },</Line>
  <Line number="16372">     { &quot;freelist page count:&quot;,  36  },</Line>
  <Line number="16373">     { &quot;schema cookie:&quot;,        40  },</Line>
  <Line number="16374">     { &quot;schema format:&quot;,        44  },</Line>
  <Line number="16375">     { &quot;default cache size:&quot;,   48  },</Line>
  <Line number="16376">     { &quot;autovacuum top root:&quot;,  52  },</Line>
  <Line number="16377">     { &quot;incremental vacuum:&quot;,   64  },</Line>
  <Line number="16378">     { &quot;text encoding:&quot;,        56  },</Line>
  <Line number="16379">     { &quot;user version:&quot;,         60  },</Line>
  <Line number="16380">     { &quot;application id:&quot;,       68  },</Line>
  <Line number="16381">     { &quot;software version:&quot;,     96  },</Line>
  <Line number="16382">  };</Line>
  <Line number="16383">  static const struct { const char *zName; const char *zSql; } aQuery[] = {</Line>
  <Line number="16384">     { &quot;number of tables:&quot;,</Line>
  <Line number="16385">       &quot;SELECT count(*) FROM %s WHERE type=&apos;table&apos;&quot; },</Line>
  <Line number="16386">     { &quot;number of indexes:&quot;,</Line>
  <Line number="16387">       &quot;SELECT count(*) FROM %s WHERE type=&apos;index&apos;&quot; },</Line>
  <Line number="16388">     { &quot;number of triggers:&quot;,</Line>
  <Line number="16389">       &quot;SELECT count(*) FROM %s WHERE type=&apos;trigger&apos;&quot; },</Line>
  <Line number="16390">     { &quot;number of views:&quot;,</Line>
  <Line number="16391">       &quot;SELECT count(*) FROM %s WHERE type=&apos;view&apos;&quot; },</Line>
  <Line number="16392">     { &quot;schema size:&quot;,</Line>
  <Line number="16393">       &quot;SELECT total(length(sql)) FROM %s&quot; },</Line>
  <Line number="16394">  };</Line>
  <Line number="16395">  int i, rc;</Line>
  <Line number="16396">  unsigned iDataVersion;</Line>
  <Line number="16397">  char *zSchemaTab;</Line>
  <Line number="16398">  char *zDb = nArg&gt;=2 ? azArg[1] : &quot;main&quot;;</Line>
  <Line number="16399">  sqlite3_stmt *pStmt = 0;</Line>
  <Line number="16400">  unsigned char aHdr[100];</Line>
  <Line number="16401">  open_db(p, 0);</Line>
  <Line number="16402">  if( p-&gt;db==0 ) return 1;</Line>
  <Line number="16403">  rc = sqlite3_prepare_v2(p-&gt;db,</Line>
  <Line number="16404">             &quot;SELECT data FROM sqlite_dbpage(?1) WHERE pgno=1&quot;,</Line>
  <Line number="16405">             <CheckRefs ids="3412">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="16406">  if( rc ){</Line>
  <Line number="16407">    utf8_printf(stderr, &quot;error: %s\n&quot;, sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="16408">    sqlite3_finalize(pStmt);</Line>
  <Line number="16409">    return 1;</Line>
  <Line number="16410">  }</Line>
  <Line number="16411">  sqlite3_bind_text(pStmt, 1, zDb, <CheckRefs ids="3413">-</CheckRefs>1, SQLITE_STATIC);</Line>
  <Line number="16412">  if( sqlite3_step(pStmt)==SQLITE_ROW</Line>
  <Line number="16413">   &amp;&amp; sqlite3_column_bytes(pStmt,0)&gt;100</Line>
  <Line number="16414">  ){</Line>
  <Line number="16415">    memcpy(aHdr, sqlite3_column_blob(pStmt,0), <CheckRefs ids="3414">100</CheckRefs>);</Line>
  <Line number="16416">    sqlite3_finalize(pStmt);</Line>
  <Line number="16417">  }else{</Line>
  <Line number="16418">    raw_printf(stderr, &quot;unable to read database header\n&quot;);</Line>
  <Line number="16419">    sqlite3_finalize(pStmt);</Line>
  <Line number="16420">    return 1;</Line>
  <Line number="16421">  }</Line>
  <Line number="16422">  i = <CheckRefs ids="3415">get2byteInt</CheckRefs>(aHdr+16);</Line>
  <Line number="16423">  if( i==1 ) i = 65536;</Line>
  <Line number="16424">  utf8_printf(p-&gt;out, &quot;%-20s %d\n&quot;, &quot;database page size:&quot;, i);</Line>
  <Line number="16425">  utf8_printf(p-&gt;out, &quot;%-20s %d\n&quot;, &quot;write format:&quot;, <CheckRefs ids="3416">aHdr</CheckRefs>[18<CheckRefs ids="3417">]</CheckRefs>);</Line>
  <Line number="16426">  utf8_printf(p-&gt;out, &quot;%-20s %d\n&quot;, &quot;read format:&quot;, <CheckRefs ids="3418">aHdr</CheckRefs>[19<CheckRefs ids="3419">]</CheckRefs>);</Line>
  <Line number="16427">  utf8_printf(p-&gt;out, &quot;%-20s %d\n&quot;, &quot;reserved bytes:&quot;, <CheckRefs ids="3420">aHdr</CheckRefs>[20<CheckRefs ids="3421">]</CheckRefs>);</Line>
  <Line number="16428">  for(i=0; i&lt;<CheckRefs ids="3422,3423,3424">ArraySize</CheckRefs>(aField); i<CheckRefs ids="3425">++</CheckRefs>){</Line>
  <Line number="16429">    int ofst = aField[i<CheckRefs ids="3426">]</CheckRefs>.ofst;</Line>
  <Line number="16430">    unsigned int val = get4byteInt(aHdr + ofst);</Line>
  <Line number="16431">    utf8_printf(p-&gt;out, &quot;%-20s %u&quot;, aField[i<CheckRefs ids="3427">]</CheckRefs>.zName, val);</Line>
  <Line number="16432">    switch( ofst ){</Line>
  <Line number="16433">      case 56: {</Line>
  <Line number="16434">        if( val==<CheckRefs ids="3428">1</CheckRefs> ) raw_printf(p-&gt;out, &quot; (utf8)&quot;);</Line>
  <Line number="16435">        if( val==<CheckRefs ids="3429">2</CheckRefs> ) raw_printf(p-&gt;out, &quot; (utf16le)&quot;);</Line>
  <Line number="16436">        if( val==<CheckRefs ids="3430">3</CheckRefs> ) raw_printf(p-&gt;out, &quot; (utf16be)&quot;);</Line>
  <Line number="16437">      }</Line>
  <Line number="16438">    }</Line>
  <Line number="16439">    raw_printf(p-&gt;out, &quot;\n&quot;);</Line>
  <Line number="16440">  }</Line>
  <Line number="16441">  if( zDb==0 ){</Line>
  <Line number="16442">    zSchemaTab = sqlite3_mprintf(&quot;main.sqlite_schema&quot;);</Line>
  <Line number="16443">  }else if( strcmp(zDb,&quot;temp&quot;)==0 ){</Line>
  <Line number="16444">    zSchemaTab = sqlite3_mprintf(&quot;%s&quot;, &quot;sqlite_temp_schema&quot;);</Line>
  <Line number="16445">  }else{</Line>
  <Line number="16446">    zSchemaTab = sqlite3_mprintf(&quot;\&quot;%w\&quot;.sqlite_schema&quot;, zDb);</Line>
  <Line number="16447">  }</Line>
  <Line number="16448">  for(i=0; i&lt;<CheckRefs ids="3431,3432,3433">ArraySize</CheckRefs>(aQuery); i<CheckRefs ids="3434">++</CheckRefs>){</Line>
  <Line number="16449">    char *zSql = sqlite3_mprintf(aQuery[i<CheckRefs ids="3435">]</CheckRefs>.zSql, zSchemaTab);</Line>
  <Line number="16450">    int val = db_int(p, zSql);</Line>
  <Line number="16451">    sqlite3_free(zSql);</Line>
  <Line number="16452">    utf8_printf(p-&gt;out, &quot;%-20s %d\n&quot;, aQuery[i<CheckRefs ids="3436">]</CheckRefs>.zName, val);</Line>
  <Line number="16453">  }</Line>
  <Line number="16454">  sqlite3_free(zSchemaTab);</Line>
  <Line number="16455">  sqlite3_file_control(p-&gt;db, zDb, SQLITE_FCNTL_DATA_VERSION, &amp;iDataVersion);</Line>
  <Line number="16456">  utf8_printf(p-&gt;out, &quot;%-20s %u\n&quot;, &quot;data version&quot;, iDataVersion);</Line>
  <Line number="16457">  return 0;</Line>
  <Line number="16458">}</Line>
  <Line number="16459"></Line>
  <Line number="16460">/*</Line>
  <Line number="16461">** Print the current sqlite3_errmsg() value to stderr and return 1.</Line>
  <Line number="16462">*/</Line>
  <Line number="16463">static int shellDatabaseError(sqlite3 *db){</Line>
  <Line number="16464">  const char *zErr = sqlite3_errmsg(db);</Line>
  <Line number="16465">  utf8_printf(stderr, &quot;Error: %s\n&quot;, zErr);</Line>
  <Line number="16466">  return 1;</Line>
  <Line number="16467">}</Line>
  <Line number="16468"></Line>
  <Line number="16469">/*</Line>
  <Line number="16470">** Compare the pattern in zGlob[] against the text in z[].  Return TRUE</Line>
  <Line number="16471">** if they match and FALSE (0) if they do not match.</Line>
  <Line number="16472">**</Line>
  <Line number="16473">** Globbing rules:</Line>
  <Line number="16474">**</Line>
  <Line number="16475">**      &apos;*&apos;       Matches any sequence of zero or more characters.</Line>
  <Line number="16476">**</Line>
  <Line number="16477">**      &apos;?&apos;       Matches exactly one character.</Line>
  <Line number="16478">**</Line>
  <Line number="16479">**     [...]      Matches one character from the enclosed list of</Line>
  <Line number="16480">**                characters.</Line>
  <Line number="16481">**</Line>
  <Line number="16482">**     [^...]     Matches one character not in the enclosed list.</Line>
  <Line number="16483">**</Line>
  <Line number="16484">**      &apos;#&apos;       Matches any sequence of one or more digits with an</Line>
  <Line number="16485">**                optional + or - sign in front</Line>
  <Line number="16486">**</Line>
  <Line number="16487">**      &apos; &apos;       Any span of whitespace matches any other span of</Line>
  <Line number="16488">**                whitespace.</Line>
  <Line number="16489">**</Line>
  <Line number="16490">** Extra whitespace at the end of z[] is ignored.</Line>
  <Line number="16491">*/</Line>
  <Line number="16492">static int testcase_glob(const char *zGlob, const char *z){</Line>
  <Line number="16493">  int c, c2;</Line>
  <Line number="16494">  int invert;</Line>
  <Line number="16495">  int seen;</Line>
  <Line number="16496"></Line>
  <Line number="16497">  while( (c = <CheckRefs ids="3437">(</CheckRefs>*(zGlob++)))!=0 ){</Line>
  <Line number="16498">    if( <CheckRefs ids="3438,3439,3441,3442,3440">IsSpace</CheckRefs>(c) ){</Line>
  <Line number="16499">      if( !<CheckRefs ids="3444,3447,3446,3443,3445">IsSpace</CheckRefs>(*z) ) return 0;</Line>
  <Line number="16500">      while( <CheckRefs ids="3449,3451,3452,3448,3450">IsSpace</CheckRefs>(*zGlob) ) zGlob++;</Line>
  <Line number="16501">      while( <CheckRefs ids="3453,3454,3456,3457,3455">IsSpace</CheckRefs>(*z) ) z++;</Line>
  <Line number="16502">    }else if( c==&apos;*&apos; ){</Line>
  <Line number="16503">      while( (c=<CheckRefs ids="3458">(</CheckRefs>*(zGlob++))) == &apos;*&apos; || c==&apos;?&apos; ){</Line>
  <Line number="16504">        if( c==&apos;?&apos; &amp;&amp; <CheckRefs ids="3459">(</CheckRefs>*(z++))==0 ) return 0;</Line>
  <Line number="16505">      }</Line>
  <Line number="16506">      if( c==0 ){</Line>
  <Line number="16507">        return 1;</Line>
  <Line number="16508">      }else if( c==&apos;[&apos; ){</Line>
  <Line number="16509">        while( <CheckRefs ids="3460">*</CheckRefs>z &amp;&amp; testcase_glob(zGlob-1,z)==0 ){</Line>
  <Line number="16510">          z++;</Line>
  <Line number="16511">        }</Line>
  <Line number="16512">        return <CheckRefs ids="3461">(</CheckRefs>*z)!=0;</Line>
  <Line number="16513">      }</Line>
  <Line number="16514">      while( (c2 = <CheckRefs ids="3462">(</CheckRefs>*(z++)))!=0 ){</Line>
  <Line number="16515">        while( c2!=c ){</Line>
  <Line number="16516">          c2 = <CheckRefs ids="3463">*</CheckRefs>(z++);</Line>
  <Line number="16517">          if( c2==0 ) return 0;</Line>
  <Line number="16518">        }</Line>
  <Line number="16519">        if( testcase_glob(zGlob,z) ) return 1;</Line>
  <Line number="16520">      }</Line>
  <Line number="16521">      return 0;</Line>
  <Line number="16522">    }else if( c==&apos;?&apos; ){</Line>
  <Line number="16523">      if( <CheckRefs ids="3464">(</CheckRefs>*(z++))==0 ) return 0;</Line>
  <Line number="16524">    }else if( c==&apos;[&apos; ){</Line>
  <Line number="16525">      int prior_c = 0;</Line>
  <Line number="16526">      seen = 0;</Line>
  <Line number="16527">      invert = 0;</Line>
  <Line number="16528">      c = <CheckRefs ids="3465">*</CheckRefs>(z++);</Line>
  <Line number="16529">      if( c==0 ) return 0;</Line>
  <Line number="16530">      c2 = <CheckRefs ids="3466">*</CheckRefs>(zGlob++);</Line>
  <Line number="16531">      if( c2==&apos;^&apos; ){</Line>
  <Line number="16532">        invert = 1;</Line>
  <Line number="16533">        c2 = <CheckRefs ids="3467">*</CheckRefs>(zGlob++);</Line>
  <Line number="16534">      }</Line>
  <Line number="16535">      if( c2==&apos;]&apos; ){</Line>
  <Line number="16536">        if( c==&apos;]&apos; ) seen = 1;</Line>
  <Line number="16537">        c2 = <CheckRefs ids="3468">*</CheckRefs>(zGlob++);</Line>
  <Line number="16538">      }</Line>
  <Line number="16539">      while( c2 &amp;&amp; c2!=&apos;]&apos; ){</Line>
  <Line number="16540">        if( c2==&apos;-&apos; &amp;&amp; <CheckRefs ids="3469">zGlob</CheckRefs>[0]!=&apos;]&apos; &amp;&amp; <CheckRefs ids="3470">zGlob</CheckRefs>[0]!=0 &amp;&amp; prior_c&gt;0 ){</Line>
  <Line number="16541">          c2 = <CheckRefs ids="3471">*</CheckRefs>(zGlob++);</Line>
  <Line number="16542">          if( c&gt;=prior_c &amp;&amp; c&lt;=c2 ) seen = 1;</Line>
  <Line number="16543">          prior_c = 0;</Line>
  <Line number="16544">        }else{</Line>
  <Line number="16545">          if( c==c2 ){</Line>
  <Line number="16546">            seen = 1;</Line>
  <Line number="16547">          }</Line>
  <Line number="16548">          prior_c = c2;</Line>
  <Line number="16549">        }</Line>
  <Line number="16550">        c2 = <CheckRefs ids="3472">*</CheckRefs>(zGlob++);</Line>
  <Line number="16551">      }</Line>
  <Line number="16552">      if( c2==0 || (seen ^ invert)==0 ) return 0;</Line>
  <Line number="16553">    }else if( c==&apos;#&apos; ){</Line>
  <Line number="16554">      if( (<CheckRefs ids="3473">z</CheckRefs>[0]==&apos;-&apos; || <CheckRefs ids="3474">z</CheckRefs>[0]==&apos;+&apos;) &amp;&amp; <CheckRefs ids="3479,3478,3475,3476,3477">IsDigit</CheckRefs>(z[1]) ) z++;</Line>
  <Line number="16555">      if( !<CheckRefs ids="3481,3480,3484,3483,3482">IsDigit</CheckRefs>(z[0]) ) return 0;</Line>
  <Line number="16556">      z++;</Line>
  <Line number="16557">      while( <CheckRefs ids="3485,3486,3488,3489,3487">IsDigit</CheckRefs>(z[0]) ){ z++; }</Line>
  <Line number="16558">    }else{</Line>
  <Line number="16559">      if( c!=<CheckRefs ids="3490">(</CheckRefs>*(z++)) ) return 0;</Line>
  <Line number="16560">    }</Line>
  <Line number="16561">  }</Line>
  <Line number="16562">  while( <CheckRefs ids="3491,3492,3494,3495,3493">IsSpace</CheckRefs>(*z) ){ z++; }</Line>
  <Line number="16563">  return <CheckRefs ids="3496">*</CheckRefs>z==0;</Line>
  <Line number="16564">}</Line>
  <Line number="16565"></Line>
  <Line number="16566"></Line>
  <Line number="16567">/*</Line>
  <Line number="16568">** Compare the string as a command-line option with either one or two</Line>
  <Line number="16569">** initial &quot;-&quot; characters.</Line>
  <Line number="16570">*/</Line>
  <Line number="16571">static int optionMatch(const char *zStr, const char *zOpt){</Line>
  <Line number="16572">  if( <CheckRefs ids="3497">zStr</CheckRefs>[0]!=&apos;-&apos; ) return 0;</Line>
  <Line number="16573">  zStr++;</Line>
  <Line number="16574">  if( <CheckRefs ids="3498">zStr</CheckRefs>[0]==&apos;-&apos; ) zStr++;</Line>
  <Line number="16575">  return strcmp(zStr, zOpt)==0;</Line>
  <Line number="16576">}</Line>
  <Line number="16577"></Line>
  <Line number="16578">/*</Line>
  <Line number="16579">** Delete a file.</Line>
  <Line number="16580">*/</Line>
  <Line number="16581">int shellDeleteFile(const char *zFilename){</Line>
  <Line number="16582">  int rc;</Line>
  <Line number="16583">#ifdef _WIN32</Line>
  <Line number="16584">  wchar_t *z = sqlite3_win32_utf8_to_unicode(zFilename);</Line>
  <Line number="16585">  rc = _wunlink(z);</Line>
  <Line number="16586">  sqlite3_free(z);</Line>
  <Line number="16587">#else</Line>
  <Line number="16588">  rc = unlink(zFilename);</Line>
  <Line number="16589">#endif</Line>
  <Line number="16590">  return rc;</Line>
  <Line number="16591">}</Line>
  <Line number="16592"></Line>
  <Line number="16593">/*</Line>
  <Line number="16594">** Try to delete the temporary file (if there is one) and free the</Line>
  <Line number="16595">** memory used to hold the name of the temp file.</Line>
  <Line number="16596">*/</Line>
  <Line number="16597">static void clearTempFile(ShellState *p){</Line>
  <Line number="16598">  if( p-&gt;zTempFile==0 ) return;</Line>
  <Line number="16599">  if( p-&gt;doXdgOpen ) return;</Line>
  <Line number="16600">  if( shellDeleteFile(p-&gt;zTempFile) ) return;</Line>
  <Line number="16601">  sqlite3_free(p-&gt;zTempFile);</Line>
  <Line number="16602">  p-&gt;zTempFile = 0;</Line>
  <Line number="16603">}</Line>
  <Line number="16604"></Line>
  <Line number="16605">/*</Line>
  <Line number="16606">** Create a new temp file name with the given suffix.</Line>
  <Line number="16607">*/</Line>
  <Line number="16608">static void newTempFile(ShellState *p, const char *zSuffix){</Line>
  <Line number="16609">  clearTempFile(p);</Line>
  <Line number="16610">  sqlite3_free(p-&gt;zTempFile);</Line>
  <Line number="16611">  p-&gt;zTempFile = 0;</Line>
  <Line number="16612">  if( p-&gt;db ){</Line>
  <Line number="16613">    sqlite3_file_control(p-&gt;db, 0, SQLITE_FCNTL_TEMPFILENAME, &amp;p-&gt;zTempFile);</Line>
  <Line number="16614">  }</Line>
  <Line number="16615">  if( p-&gt;zTempFile==0 ){</Line>
  <Line number="16616">    /* If p-&gt;db is an in-memory database then the TEMPFILENAME file-control</Line>
  <Line number="16617">    ** will not work and we will need to fallback to guessing */</Line>
  <Line number="16618">    char *zTemp;</Line>
  <Line number="16619">    sqlite3_uint64 r;</Line>
  <Line number="16620">    sqlite3_randomness(<CheckRefs ids="3499">sizeof</CheckRefs>(r), &amp;r);</Line>
  <Line number="16621">    zTemp = getenv(&quot;TEMP&quot;);</Line>
  <Line number="16622">    if( zTemp==0 ) zTemp = getenv(&quot;TMP&quot;);</Line>
  <Line number="16623">    if( zTemp==0 ){</Line>
  <Line number="16624">#ifdef _WIN32</Line>
  <Line number="16625">      zTemp = &quot;\\tmp&quot;;</Line>
  <Line number="16626">#else</Line>
  <Line number="16627">      zTemp = &quot;/tmp&quot;;</Line>
  <Line number="16628">#endif</Line>
  <Line number="16629">    }</Line>
  <Line number="16630">    p-&gt;zTempFile = sqlite3_mprintf(&quot;%s/temp%llx.%s&quot;, zTemp, r, zSuffix);</Line>
  <Line number="16631">  }else{</Line>
  <Line number="16632">    p-&gt;zTempFile = sqlite3_mprintf(&quot;%z.%s&quot;, p-&gt;zTempFile, zSuffix);</Line>
  <Line number="16633">  }</Line>
  <Line number="16634">  if( p-&gt;zTempFile==0 ){</Line>
  <Line number="16635">    raw_printf(stderr, &quot;out of memory\n&quot;);</Line>
  <Line number="16636">    exit(1);</Line>
  <Line number="16637">  }</Line>
  <Line number="16638">}</Line>
  <Line number="16639"></Line>
  <Line number="16640"></Line>
  <Line number="16641">/*</Line>
  <Line number="16642">** The implementation of SQL scalar function fkey_collate_clause(), used</Line>
  <Line number="16643">** by the &quot;.lint fkey-indexes&quot; command. This scalar function is always</Line>
  <Line number="16644">** called with four arguments - the parent table name, the parent column name,</Line>
  <Line number="16645">** the child table name and the child column name.</Line>
  <Line number="16646">**</Line>
  <Line number="16647">**   fkey_collate_clause(&apos;parent-tab&apos;, &apos;parent-col&apos;, &apos;child-tab&apos;, &apos;child-col&apos;)</Line>
  <Line number="16648">**</Line>
  <Line number="16649">** If either of the named tables or columns do not exist, this function</Line>
  <Line number="16650">** returns an empty string. An empty string is also returned if both tables</Line>
  <Line number="16651">** and columns exist but have the same default collation sequence. Or,</Line>
  <Line number="16652">** if both exist but the default collation sequences are different, this</Line>
  <Line number="16653">** function returns the string &quot; COLLATE &lt;parent-collation&gt;&quot;, where</Line>
  <Line number="16654">** &lt;parent-collation&gt; is the default collation sequence of the parent column.</Line>
  <Line number="16655">*/</Line>
  <Line number="16656">static void shellFkeyCollateClause(</Line>
  <Line number="16657">  sqlite3_context *pCtx,</Line>
  <Line number="16658">  int nVal,</Line>
  <Line number="16659">  sqlite3_value **apVal</Line>
  <Line number="16660">){</Line>
  <Line number="16661">  sqlite3 *db = sqlite3_context_db_handle(pCtx);</Line>
  <Line number="16662">  const char *zParent;</Line>
  <Line number="16663">  const char *zParentCol;</Line>
  <Line number="16664">  const char *zParentSeq;</Line>
  <Line number="16665">  const char *zChild;</Line>
  <Line number="16666">  const char *zChildCol;</Line>
  <Line number="16667">  const char *zChildSeq = 0;  /* Initialize to avoid false-positive warning */</Line>
  <Line number="16668">  int rc;</Line>
  <Line number="16669"></Line>
  <Line number="16670">  <CheckRefs ids="3500">assert</CheckRefs>( nVal==4 );</Line>
  <Line number="16671">  zParent = (const char*)sqlite3_value_text(apVal[0]);</Line>
  <Line number="16672">  zParentCol = (const char*)sqlite3_value_text(apVal[1]);</Line>
  <Line number="16673">  zChild = (const char*)sqlite3_value_text(apVal[2]);</Line>
  <Line number="16674">  zChildCol = (const char*)sqlite3_value_text(apVal[3]);</Line>
  <Line number="16675"></Line>
  <Line number="16676">  sqlite3_result_text(pCtx, &quot;&quot;, <CheckRefs ids="3501">-</CheckRefs>1, SQLITE_STATIC);</Line>
  <Line number="16677">  rc = sqlite3_table_column_metadata(</Line>
  <Line number="16678">      db, &quot;main&quot;, zParent, zParentCol, 0, &amp;zParentSeq, 0, 0, 0</Line>
  <Line number="16679">  );</Line>
  <Line number="16680">  if( rc==SQLITE_OK ){</Line>
  <Line number="16681">    rc = sqlite3_table_column_metadata(</Line>
  <Line number="16682">        db, &quot;main&quot;, zChild, zChildCol, 0, &amp;zChildSeq, 0, 0, 0</Line>
  <Line number="16683">    );</Line>
  <Line number="16684">  }</Line>
  <Line number="16685"></Line>
  <Line number="16686">  if( rc==SQLITE_OK &amp;&amp; sqlite3_stricmp(zParentSeq, zChildSeq) ){</Line>
  <Line number="16687">    char *z = sqlite3_mprintf(&quot; COLLATE %s&quot;, zParentSeq);</Line>
  <Line number="16688">    sqlite3_result_text(pCtx, z, <CheckRefs ids="3502">-</CheckRefs>1, <CheckRefs ids="3503">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="16689">    sqlite3_free(z);</Line>
  <Line number="16690">  }</Line>
  <Line number="16691">}</Line>
  <Line number="16692"></Line>
  <Line number="16693"></Line>
  <Line number="16694">/*</Line>
  <Line number="16695">** The implementation of dot-command &quot;.lint fkey-indexes&quot;.</Line>
  <Line number="16696">*/</Line>
  <Line number="16697">static int lintFkeyIndexes(</Line>
  <Line number="16698">  ShellState *pState,             /* Current shell tool state */</Line>
  <Line number="16699">  char **azArg,                   /* Array of arguments passed to dot command */</Line>
  <Line number="16700">  int nArg                        /* Number of entries in azArg[] */</Line>
  <Line number="16701">){</Line>
  <Line number="16702">  sqlite3 *db = pState-&gt;db;       /* Database handle to query &quot;main&quot; db of */</Line>
  <Line number="16703">  FILE *out = pState-&gt;out;        /* Stream to write non-error output to */</Line>
  <Line number="16704">  int bVerbose = 0;               /* If -verbose is present */</Line>
  <Line number="16705">  int bGroupByParent = 0;         /* If -groupbyparent is present */</Line>
  <Line number="16706">  int i;                          /* To iterate through azArg[] */</Line>
  <Line number="16707">  const char *zIndent = &quot;&quot;;       /* How much to indent CREATE INDEX by */</Line>
  <Line number="16708">  int rc;                         /* Return code */</Line>
  <Line number="16709">  sqlite3_stmt *pSql = 0;         /* Compiled version of SQL statement below */</Line>
  <Line number="16710"></Line>
  <Line number="16711">  /*</Line>
  <Line number="16712">  ** This SELECT statement returns one row for each foreign key constraint</Line>
  <Line number="16713">  ** in the schema of the main database. The column values are:</Line>
  <Line number="16714">  **</Line>
  <Line number="16715">  ** 0. The text of an SQL statement similar to:</Line>
  <Line number="16716">  **</Line>
  <Line number="16717">  **      &quot;EXPLAIN QUERY PLAN SELECT 1 FROM child_table WHERE child_key=?&quot;</Line>
  <Line number="16718">  **</Line>
  <Line number="16719">  **    This SELECT is similar to the one that the foreign keys implementation</Line>
  <Line number="16720">  **    needs to run internally on child tables. If there is an index that can</Line>
  <Line number="16721">  **    be used to optimize this query, then it can also be used by the FK</Line>
  <Line number="16722">  **    implementation to optimize DELETE or UPDATE statements on the parent</Line>
  <Line number="16723">  **    table.</Line>
  <Line number="16724">  **</Line>
  <Line number="16725">  ** 1. A GLOB pattern suitable for sqlite3_strglob(). If the plan output by</Line>
  <Line number="16726">  **    the EXPLAIN QUERY PLAN command matches this pattern, then the schema</Line>
  <Line number="16727">  **    contains an index that can be used to optimize the query.</Line>
  <Line number="16728">  **</Line>
  <Line number="16729">  ** 2. Human readable text that describes the child table and columns. e.g.</Line>
  <Line number="16730">  **</Line>
  <Line number="16731">  **       &quot;child_table(child_key1, child_key2)&quot;</Line>
  <Line number="16732">  **</Line>
  <Line number="16733">  ** 3. Human readable text that describes the parent table and columns. e.g.</Line>
  <Line number="16734">  **</Line>
  <Line number="16735">  **       &quot;parent_table(parent_key1, parent_key2)&quot;</Line>
  <Line number="16736">  **</Line>
  <Line number="16737">  ** 4. A full CREATE INDEX statement for an index that could be used to</Line>
  <Line number="16738">  **    optimize DELETE or UPDATE statements on the parent table. e.g.</Line>
  <Line number="16739">  **</Line>
  <Line number="16740">  **       &quot;CREATE INDEX child_table_child_key ON child_table(child_key)&quot;</Line>
  <Line number="16741">  **</Line>
  <Line number="16742">  ** 5. The name of the parent table.</Line>
  <Line number="16743">  **</Line>
  <Line number="16744">  ** These six values are used by the C logic below to generate the report.</Line>
  <Line number="16745">  */</Line>
  <Line number="16746">  const char *zSql =</Line>
  <Line number="16747">  &quot;SELECT &quot;</Line>
  <Line number="16748">    &quot;     &apos;EXPLAIN QUERY PLAN SELECT 1 FROM &apos; || quote(s.name) || &apos; WHERE &apos;&quot;</Line>
  <Line number="16749">    &quot;  || group_concat(quote(s.name) || &apos;.&apos; || quote(f.[from]) || &apos;=?&apos; &quot;</Line>
  <Line number="16750">    &quot;  || fkey_collate_clause(&quot;</Line>
  <Line number="16751">    &quot;       f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]),&apos; AND &apos;)&quot;</Line>
  <Line number="16752">    &quot;, &quot;</Line>
  <Line number="16753">    &quot;     &apos;SEARCH &apos; || s.name || &apos; USING COVERING INDEX*(&apos;&quot;</Line>
  <Line number="16754">    &quot;  || group_concat(&apos;*=?&apos;, &apos; AND &apos;) || &apos;)&apos;&quot;</Line>
  <Line number="16755">    &quot;, &quot;</Line>
  <Line number="16756">    &quot;     s.name  || &apos;(&apos; || group_concat(f.[from],  &apos;, &apos;) || &apos;)&apos;&quot;</Line>
  <Line number="16757">    &quot;, &quot;</Line>
  <Line number="16758">    &quot;     f.[table] || &apos;(&apos; || group_concat(COALESCE(f.[to], p.[name])) || &apos;)&apos;&quot;</Line>
  <Line number="16759">    &quot;, &quot;</Line>
  <Line number="16760">    &quot;     &apos;CREATE INDEX &apos; || quote(s.name ||&apos;_&apos;|| group_concat(f.[from], &apos;_&apos;))&quot;</Line>
  <Line number="16761">    &quot;  || &apos; ON &apos; || quote(s.name) || &apos;(&apos;&quot;</Line>
  <Line number="16762">    &quot;  || group_concat(quote(f.[from]) ||&quot;</Line>
  <Line number="16763">    &quot;        fkey_collate_clause(&quot;</Line>
  <Line number="16764">    &quot;          f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]), &apos;, &apos;)&quot;</Line>
  <Line number="16765">    &quot;  || &apos;);&apos;&quot;</Line>
  <Line number="16766">    &quot;, &quot;</Line>
  <Line number="16767">    &quot;     f.[table] &quot;</Line>
  <Line number="16768">    &quot;FROM sqlite_schema AS s, pragma_foreign_key_list(s.name) AS f &quot;</Line>
  <Line number="16769">    &quot;LEFT JOIN pragma_table_info AS p ON (pk-1=seq AND p.arg=f.[table]) &quot;</Line>
  <Line number="16770">    &quot;GROUP BY s.name, f.id &quot;</Line>
  <Line number="16771">    &quot;ORDER BY (CASE WHEN ? THEN f.[table] ELSE s.name END)&quot;</Line>
  <Line number="16772">  ;</Line>
  <Line number="16773">  const char *zGlobIPK = &quot;SEARCH * USING INTEGER PRIMARY KEY (rowid=?)&quot;;</Line>
  <Line number="16774"></Line>
  <Line number="16775">  for(i=2; i&lt;nArg; i<CheckRefs ids="3504">++</CheckRefs>){</Line>
  <Line number="16776">    int n = strlen30(azArg[i]);</Line>
  <Line number="16777">    if( n&gt;1 &amp;&amp; sqlite3_strnicmp(&quot;-verbose&quot;, azArg[i], n)==0 ){</Line>
  <Line number="16778">      bVerbose = 1;</Line>
  <Line number="16779">    }</Line>
  <Line number="16780">    else if( n&gt;1 &amp;&amp; sqlite3_strnicmp(&quot;-groupbyparent&quot;, azArg[i], n)==0 ){</Line>
  <Line number="16781">      bGroupByParent = 1;</Line>
  <Line number="16782">      zIndent = &quot;    &quot;;</Line>
  <Line number="16783">    }</Line>
  <Line number="16784">    else{</Line>
  <Line number="16785">      raw_printf(stderr, &quot;Usage: %s %s ?-verbose? ?-groupbyparent?\n&quot;,</Line>
  <Line number="16786">          azArg[0], azArg[1]</Line>
  <Line number="16787">      );</Line>
  <Line number="16788">      return SQLITE_ERROR;</Line>
  <Line number="16789">    }</Line>
  <Line number="16790">  }</Line>
  <Line number="16791"></Line>
  <Line number="16792">  /* Register the fkey_collate_clause() SQL function */</Line>
  <Line number="16793">  rc = sqlite3_create_function(db, &quot;fkey_collate_clause&quot;, 4, SQLITE_UTF8,</Line>
  <Line number="16794">      0, shellFkeyCollateClause, 0, 0</Line>
  <Line number="16795">  );</Line>
  <Line number="16796"></Line>
  <Line number="16797"></Line>
  <Line number="16798">  if( rc==SQLITE_OK ){</Line>
  <Line number="16799">    rc = sqlite3_prepare_v2(db, zSql, <CheckRefs ids="3505">-</CheckRefs>1, &amp;pSql, 0);</Line>
  <Line number="16800">  }</Line>
  <Line number="16801">  if( rc==SQLITE_OK ){</Line>
  <Line number="16802">    sqlite3_bind_int(pSql, 1, bGroupByParent);</Line>
  <Line number="16803">  }</Line>
  <Line number="16804"></Line>
  <Line number="16805">  if( rc==SQLITE_OK ){</Line>
  <Line number="16806">    int rc2;</Line>
  <Line number="16807">    char *zPrev = 0;</Line>
  <Line number="16808">    while( SQLITE_ROW==sqlite3_step(pSql) ){</Line>
  <Line number="16809">      int res = <CheckRefs ids="3506">-</CheckRefs>1;</Line>
  <Line number="16810">      sqlite3_stmt *pExplain = 0;</Line>
  <Line number="16811">      const char *zEQP = (const char*)sqlite3_column_text(pSql, 0);</Line>
  <Line number="16812">      const char *zGlob = (const char*)sqlite3_column_text(pSql, 1);</Line>
  <Line number="16813">      const char *zFrom = (const char*)sqlite3_column_text(pSql, 2);</Line>
  <Line number="16814">      const char *zTarget = (const char*)sqlite3_column_text(pSql, 3);</Line>
  <Line number="16815">      const char *zCI = (const char*)sqlite3_column_text(pSql, 4);</Line>
  <Line number="16816">      const char *zParent = (const char*)sqlite3_column_text(pSql, 5);</Line>
  <Line number="16817"></Line>
  <Line number="16818">      rc = sqlite3_prepare_v2(db, zEQP, <CheckRefs ids="3507">-</CheckRefs>1, &amp;pExplain, 0);</Line>
  <Line number="16819">      if( rc!=SQLITE_OK ) break;</Line>
  <Line number="16820">      if( SQLITE_ROW==sqlite3_step(pExplain) ){</Line>
  <Line number="16821">        const char *zPlan = (const char*)sqlite3_column_text(pExplain, 3);</Line>
  <Line number="16822">        res = (</Line>
  <Line number="16823">              0==sqlite3_strglob(zGlob, zPlan)</Line>
  <Line number="16824">           || 0==sqlite3_strglob(zGlobIPK, zPlan)</Line>
  <Line number="16825">        );</Line>
  <Line number="16826">      }</Line>
  <Line number="16827">      rc = sqlite3_finalize(pExplain);</Line>
  <Line number="16828">      if( rc!=SQLITE_OK ) break;</Line>
  <Line number="16829"></Line>
  <Line number="16830">      if( res&lt;0 ){</Line>
  <Line number="16831">        raw_printf(stderr, &quot;Error: internal error&quot;);</Line>
  <Line number="16832">        break;</Line>
  <Line number="16833">      }else{</Line>
  <Line number="16834">        if( bGroupByParent</Line>
  <Line number="16835">        &amp;&amp; (bVerbose || res==0)</Line>
  <Line number="16836">        &amp;&amp; (zPrev==0 || sqlite3_stricmp(zParent, zPrev))</Line>
  <Line number="16837">        ){</Line>
  <Line number="16838">          raw_printf(out, &quot;-- Parent table %s\n&quot;, zParent);</Line>
  <Line number="16839">          sqlite3_free(zPrev);</Line>
  <Line number="16840">          zPrev = sqlite3_mprintf(&quot;%s&quot;, zParent);</Line>
  <Line number="16841">        }</Line>
  <Line number="16842"></Line>
  <Line number="16843">        if( res==0 ){</Line>
  <Line number="16844">          raw_printf(out, &quot;%s%s --&gt; %s\n&quot;, zIndent, zCI, zTarget);</Line>
  <Line number="16845">        }else if( bVerbose ){</Line>
  <Line number="16846">          raw_printf(out, &quot;%s/* no extra indexes required for %s -&gt; %s */\n&quot;,</Line>
  <Line number="16847">              zIndent, zFrom, zTarget</Line>
  <Line number="16848">          );</Line>
  <Line number="16849">        }</Line>
  <Line number="16850">      }</Line>
  <Line number="16851">    }</Line>
  <Line number="16852">    sqlite3_free(zPrev);</Line>
  <Line number="16853"></Line>
  <Line number="16854">    if( rc!=SQLITE_OK ){</Line>
  <Line number="16855">      raw_printf(stderr, &quot;%s\n&quot;, sqlite3_errmsg(db));</Line>
  <Line number="16856">    }</Line>
  <Line number="16857"></Line>
  <Line number="16858">    rc2 = sqlite3_finalize(pSql);</Line>
  <Line number="16859">    if( rc==SQLITE_OK &amp;&amp; rc2!=SQLITE_OK ){</Line>
  <Line number="16860">      rc = rc2;</Line>
  <Line number="16861">      raw_printf(stderr, &quot;%s\n&quot;, sqlite3_errmsg(db));</Line>
  <Line number="16862">    }</Line>
  <Line number="16863">  }else{</Line>
  <Line number="16864">    raw_printf(stderr, &quot;%s\n&quot;, sqlite3_errmsg(db));</Line>
  <Line number="16865">  }</Line>
  <Line number="16866"></Line>
  <Line number="16867">  return rc;</Line>
  <Line number="16868">}</Line>
  <Line number="16869"></Line>
  <Line number="16870">/*</Line>
  <Line number="16871">** Implementation of &quot;.lint&quot; dot command.</Line>
  <Line number="16872">*/</Line>
  <Line number="16873">static int lintDotCommand(</Line>
  <Line number="16874">  ShellState *pState,             /* Current shell tool state */</Line>
  <Line number="16875">  char **azArg,                   /* Array of arguments passed to dot command */</Line>
  <Line number="16876">  int nArg                        /* Number of entries in azArg[] */</Line>
  <Line number="16877">){</Line>
  <Line number="16878">  int n;</Line>
  <Line number="16879">  n = (nArg&gt;=2 ? strlen30(azArg[1]) : 0);</Line>
  <Line number="16880">  if( n&lt;1 || sqlite3_strnicmp(azArg[1], &quot;fkey-indexes&quot;, n) ) goto usage;</Line>
  <Line number="16881">  return lintFkeyIndexes(pState, azArg, nArg);</Line>
  <Line number="16882"></Line>
  <Line number="16883"> usage:</Line>
  <Line number="16884">  raw_printf(stderr, &quot;Usage %s sub-command ?switches...?\n&quot;, azArg[0]);</Line>
  <Line number="16885">  raw_printf(stderr, &quot;Where sub-commands are:\n&quot;);</Line>
  <Line number="16886">  raw_printf(stderr, &quot;    fkey-indexes\n&quot;);</Line>
  <Line number="16887">  return SQLITE_ERROR;</Line>
  <Line number="16888">}</Line>
  <Line number="16889"></Line>
  <Line number="16890">#if !defined SQLITE_OMIT_VIRTUALTABLE</Line>
  <Line number="16891">static void shellPrepare(</Line>
  <Line number="16892">  sqlite3 *db, </Line>
  <Line number="16893">  int *pRc, </Line>
  <Line number="16894">  const char *zSql, </Line>
  <Line number="16895">  sqlite3_stmt **ppStmt</Line>
  <Line number="16896">){</Line>
  <Line number="16897">  *ppStmt = 0;</Line>
  <Line number="16898">  if( *pRc==SQLITE_OK ){</Line>
  <Line number="16899">    int rc = sqlite3_prepare_v2(db, zSql, <CheckRefs ids="3508">-</CheckRefs>1, ppStmt, 0);</Line>
  <Line number="16900">    if( rc!=SQLITE_OK ){</Line>
  <Line number="16901">      raw_printf(stderr, &quot;sql error: %s (%d)\n&quot;, </Line>
  <Line number="16902">          sqlite3_errmsg(db), sqlite3_errcode(db)</Line>
  <Line number="16903">      );</Line>
  <Line number="16904">      *pRc = rc;</Line>
  <Line number="16905">    }</Line>
  <Line number="16906">  }</Line>
  <Line number="16907">}</Line>
  <Line number="16908"></Line>
  <Line number="16909">/*</Line>
  <Line number="16910">** Create a prepared statement using printf-style arguments for the SQL.</Line>
  <Line number="16911">**</Line>
  <Line number="16912">** This routine is could be marked &quot;static&quot;.  But it is not always used,</Line>
  <Line number="16913">** depending on compile-time options.  By omitting the &quot;static&quot;, we avoid</Line>
  <Line number="16914">** nuisance compiler warnings about &quot;defined but not used&quot;.</Line>
  <Line number="16915">*/</Line>
  <Line number="16916">void shellPreparePrintf(</Line>
  <Line number="16917">  sqlite3 *db, </Line>
  <Line number="16918">  int *pRc, </Line>
  <Line number="16919">  sqlite3_stmt **ppStmt,</Line>
  <Line number="16920">  const char *zFmt, </Line>
  <Line number="16921">  ...</Line>
  <Line number="16922">){</Line>
  <Line number="16923">  *ppStmt = 0;</Line>
  <Line number="16924">  if( *pRc==SQLITE_OK ){</Line>
  <Line number="16925">    va_list ap;</Line>
  <Line number="16926">    char *z;</Line>
  <Line number="16927">    va_start(ap, zFmt);</Line>
  <Line number="16928">    z = sqlite3_vmprintf(zFmt, ap);</Line>
  <Line number="16929">    va_end(ap);</Line>
  <Line number="16930">    if( z==0 ){</Line>
  <Line number="16931">      *pRc = SQLITE_NOMEM;</Line>
  <Line number="16932">    }else{</Line>
  <Line number="16933">      shellPrepare(db, pRc, z, ppStmt);</Line>
  <Line number="16934">      sqlite3_free(z);</Line>
  <Line number="16935">    }</Line>
  <Line number="16936">  }</Line>
  <Line number="16937">}</Line>
  <Line number="16938"></Line>
  <Line number="16939">/* Finalize the prepared statement created using shellPreparePrintf().</Line>
  <Line number="16940">**</Line>
  <Line number="16941">** This routine is could be marked &quot;static&quot;.  But it is not always used,</Line>
  <Line number="16942">** depending on compile-time options.  By omitting the &quot;static&quot;, we avoid</Line>
  <Line number="16943">** nuisance compiler warnings about &quot;defined but not used&quot;.</Line>
  <Line number="16944">*/</Line>
  <Line number="16945">void shellFinalize(</Line>
  <Line number="16946">  int *pRc, </Line>
  <Line number="16947">  sqlite3_stmt *pStmt</Line>
  <Line number="16948">){</Line>
  <Line number="16949">  if( pStmt ){</Line>
  <Line number="16950">    sqlite3 *db = sqlite3_db_handle(pStmt);</Line>
  <Line number="16951">    int rc = sqlite3_finalize(pStmt);</Line>
  <Line number="16952">    if( *pRc==SQLITE_OK ){</Line>
  <Line number="16953">      if( rc!=SQLITE_OK ){</Line>
  <Line number="16954">        raw_printf(stderr, &quot;SQL error: %s\n&quot;, sqlite3_errmsg(db));</Line>
  <Line number="16955">      }</Line>
  <Line number="16956">      *pRc = rc;</Line>
  <Line number="16957">    }</Line>
  <Line number="16958">  }</Line>
  <Line number="16959">}</Line>
  <Line number="16960"></Line>
  <Line number="16961">/* Reset the prepared statement created using shellPreparePrintf().</Line>
  <Line number="16962">**</Line>
  <Line number="16963">** This routine is could be marked &quot;static&quot;.  But it is not always used,</Line>
  <Line number="16964">** depending on compile-time options.  By omitting the &quot;static&quot;, we avoid</Line>
  <Line number="16965">** nuisance compiler warnings about &quot;defined but not used&quot;.</Line>
  <Line number="16966">*/</Line>
  <Line number="16967">void shellReset(</Line>
  <Line number="16968">  int *pRc, </Line>
  <Line number="16969">  sqlite3_stmt *pStmt</Line>
  <Line number="16970">){</Line>
  <Line number="16971">  int rc = sqlite3_reset(pStmt);</Line>
  <Line number="16972">  if( *pRc==SQLITE_OK ){</Line>
  <Line number="16973">    if( rc!=SQLITE_OK ){</Line>
  <Line number="16974">      sqlite3 *db = sqlite3_db_handle(pStmt);</Line>
  <Line number="16975">      raw_printf(stderr, &quot;SQL error: %s\n&quot;, sqlite3_errmsg(db));</Line>
  <Line number="16976">    }</Line>
  <Line number="16977">    *pRc = rc;</Line>
  <Line number="16978">  }</Line>
  <Line number="16979">}</Line>
  <Line number="16980">#endif /* !defined SQLITE_OMIT_VIRTUALTABLE */</Line>
  <Line number="16981"></Line>
  <Line number="16982">#if !defined(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; defined(SQLITE_HAVE_ZLIB)</Line>
  <Line number="16983">/******************************************************************************</Line>
  <Line number="16984">** The &quot;.archive&quot; or &quot;.ar&quot; command.</Line>
  <Line number="16985">*/</Line>
  <Line number="16986">/*</Line>
  <Line number="16987">** Structure representing a single &quot;.ar&quot; command.</Line>
  <Line number="16988">*/</Line>
  <Line number="16989">typedef struct ArCommand ArCommand;</Line>
  <Line number="16990">struct ArCommand {</Line>
  <Line number="16991">  u8 eCmd;                        /* An AR_CMD_* value */</Line>
  <Line number="16992">  u8 bVerbose;                    /* True if --verbose */</Line>
  <Line number="16993">  u8 bZip;                        /* True if the archive is a ZIP */</Line>
  <Line number="16994">  u8 bDryRun;                     /* True if --dry-run */</Line>
  <Line number="16995">  u8 bAppend;                     /* True if --append */</Line>
  <Line number="16996">  u8 fromCmdLine;                 /* Run from -A instead of .archive */</Line>
  <Line number="16997">  int nArg;                       /* Number of command arguments */</Line>
  <Line number="16998">  char *zSrcTable;                /* &quot;sqlar&quot;, &quot;zipfile($file)&quot; or &quot;zip&quot; */</Line>
  <Line number="16999">  const char *zFile;              /* --file argument, or NULL */</Line>
  <Line number="17000">  const char *zDir;               /* --directory argument, or NULL */</Line>
  <Line number="17001">  char **azArg;                   /* Array of command arguments */</Line>
  <Line number="17002">  ShellState *p;                  /* Shell state */</Line>
  <Line number="17003">  sqlite3 *db;                    /* Database containing the archive */</Line>
  <Line number="17004">};</Line>
  <Line number="17005"></Line>
  <Line number="17006">/*</Line>
  <Line number="17007">** Print a usage message for the .ar command to stderr and return SQLITE_ERROR.</Line>
  <Line number="17008">*/</Line>
  <Line number="17009">static int arUsage(FILE *f){</Line>
  <Line number="17010">  showHelp(f,&quot;archive&quot;);</Line>
  <Line number="17011">  return SQLITE_ERROR;</Line>
  <Line number="17012">}</Line>
  <Line number="17013"></Line>
  <Line number="17014">/*</Line>
  <Line number="17015">** Print an error message for the .ar command to stderr and return </Line>
  <Line number="17016">** SQLITE_ERROR.</Line>
  <Line number="17017">*/</Line>
  <Line number="17018">static int arErrorMsg(ArCommand *pAr, const char *zFmt, ...){</Line>
  <Line number="17019">  va_list ap;</Line>
  <Line number="17020">  char *z;</Line>
  <Line number="17021">  va_start(ap, zFmt);</Line>
  <Line number="17022">  z = sqlite3_vmprintf(zFmt, ap);</Line>
  <Line number="17023">  va_end(ap);</Line>
  <Line number="17024">  utf8_printf(stderr, &quot;Error: %s\n&quot;, z);</Line>
  <Line number="17025">  if( pAr-&gt;fromCmdLine ){</Line>
  <Line number="17026">    utf8_printf(stderr, &quot;Use \&quot;-A\&quot; for more help\n&quot;);</Line>
  <Line number="17027">  }else{</Line>
  <Line number="17028">    utf8_printf(stderr, &quot;Use \&quot;.archive --help\&quot; for more help\n&quot;);</Line>
  <Line number="17029">  }</Line>
  <Line number="17030">  sqlite3_free(z);</Line>
  <Line number="17031">  return SQLITE_ERROR;</Line>
  <Line number="17032">}</Line>
  <Line number="17033"></Line>
  <Line number="17034">/*</Line>
  <Line number="17035">** Values for ArCommand.eCmd.</Line>
  <Line number="17036">*/</Line>
  <Line number="17037">#define AR_CMD_CREATE       1</Line>
  <Line number="17038">#define AR_CMD_UPDATE       2</Line>
  <Line number="17039">#define AR_CMD_INSERT       3</Line>
  <Line number="17040">#define AR_CMD_EXTRACT      4</Line>
  <Line number="17041">#define AR_CMD_LIST         5</Line>
  <Line number="17042">#define AR_CMD_HELP         6</Line>
  <Line number="17043"></Line>
  <Line number="17044">/*</Line>
  <Line number="17045">** Other (non-command) switches.</Line>
  <Line number="17046">*/</Line>
  <Line number="17047">#define AR_SWITCH_VERBOSE     7</Line>
  <Line number="17048">#define AR_SWITCH_FILE        8</Line>
  <Line number="17049">#define AR_SWITCH_DIRECTORY   9</Line>
  <Line number="17050">#define AR_SWITCH_APPEND     10</Line>
  <Line number="17051">#define AR_SWITCH_DRYRUN     11</Line>
  <Line number="17052"></Line>
  <Line number="17053">static int arProcessSwitch(ArCommand *pAr, int eSwitch, const char *zArg){</Line>
  <Line number="17054">  switch( eSwitch ){</Line>
  <Line number="17055">    case AR_CMD_CREATE:</Line>
  <Line number="17056">    case AR_CMD_EXTRACT:</Line>
  <Line number="17057">    case AR_CMD_LIST:</Line>
  <Line number="17058">    case AR_CMD_UPDATE:</Line>
  <Line number="17059">    case AR_CMD_INSERT:</Line>
  <Line number="17060">    case AR_CMD_HELP:</Line>
  <Line number="17061">      if( pAr-&gt;eCmd ){</Line>
  <Line number="17062">        return arErrorMsg(pAr, &quot;multiple command options&quot;);</Line>
  <Line number="17063">      }</Line>
  <Line number="17064">      pAr-&gt;eCmd = eSwitch;</Line>
  <Line number="17065">      break;</Line>
  <Line number="17066"></Line>
  <Line number="17067">    case AR_SWITCH_DRYRUN:</Line>
  <Line number="17068">      pAr-&gt;bDryRun = 1;</Line>
  <Line number="17069">      break;</Line>
  <Line number="17070">    case AR_SWITCH_VERBOSE:</Line>
  <Line number="17071">      pAr-&gt;bVerbose = 1;</Line>
  <Line number="17072">      break;</Line>
  <Line number="17073">    case AR_SWITCH_APPEND:</Line>
  <Line number="17074">      pAr-&gt;bAppend = 1;</Line>
  <Line number="17075">      /* Fall thru into --file */</Line>
  <Line number="17076">    case AR_SWITCH_FILE:</Line>
  <Line number="17077">      pAr-&gt;zFile = zArg;</Line>
  <Line number="17078">      break;</Line>
  <Line number="17079">    case AR_SWITCH_DIRECTORY:</Line>
  <Line number="17080">      pAr-&gt;zDir = zArg;</Line>
  <Line number="17081">      break;</Line>
  <Line number="17082">  }</Line>
  <Line number="17083"></Line>
  <Line number="17084">  return SQLITE_OK;</Line>
  <Line number="17085">}</Line>
  <Line number="17086"></Line>
  <Line number="17087">/*</Line>
  <Line number="17088">** Parse the command line for an &quot;.ar&quot; command. The results are written into</Line>
  <Line number="17089">** structure (*pAr). SQLITE_OK is returned if the command line is parsed</Line>
  <Line number="17090">** successfully, otherwise an error message is written to stderr and </Line>
  <Line number="17091">** SQLITE_ERROR returned.</Line>
  <Line number="17092">*/</Line>
  <Line number="17093">static int arParseCommand(</Line>
  <Line number="17094">  char **azArg,                   /* Array of arguments passed to dot command */</Line>
  <Line number="17095">  int nArg,                       /* Number of entries in azArg[] */</Line>
  <Line number="17096">  ArCommand *pAr                  /* Populate this object */</Line>
  <Line number="17097">){</Line>
  <Line number="17098">  struct ArSwitch {</Line>
  <Line number="17099">    const char *zLong;</Line>
  <Line number="17100">    char cShort;</Line>
  <Line number="17101">    u8 eSwitch;</Line>
  <Line number="17102">    u8 bArg;</Line>
  <Line number="17103">  } aSwitch[] = {</Line>
  <Line number="17104">    { &quot;create&quot;,    &apos;c&apos;, AR_CMD_CREATE,       0 },</Line>
  <Line number="17105">    { &quot;extract&quot;,   &apos;x&apos;, AR_CMD_EXTRACT,      0 },</Line>
  <Line number="17106">    { &quot;insert&quot;,    &apos;i&apos;, AR_CMD_INSERT,       0 },</Line>
  <Line number="17107">    { &quot;list&quot;,      &apos;t&apos;, AR_CMD_LIST,         0 },</Line>
  <Line number="17108">    { &quot;update&quot;,    &apos;u&apos;, AR_CMD_UPDATE,       0 },</Line>
  <Line number="17109">    { &quot;help&quot;,      &apos;h&apos;, AR_CMD_HELP,         0 },</Line>
  <Line number="17110">    { &quot;verbose&quot;,   &apos;v&apos;, AR_SWITCH_VERBOSE,   0 },</Line>
  <Line number="17111">    { &quot;file&quot;,      &apos;f&apos;, AR_SWITCH_FILE,      1 },</Line>
  <Line number="17112">    { &quot;append&quot;,    &apos;a&apos;, AR_SWITCH_APPEND,    1 },</Line>
  <Line number="17113">    { &quot;directory&quot;, &apos;C&apos;, AR_SWITCH_DIRECTORY, 1 },</Line>
  <Line number="17114">    { &quot;dryrun&quot;,    &apos;n&apos;, AR_SWITCH_DRYRUN,    0 },</Line>
  <Line number="17115">  };</Line>
  <Line number="17116">  int nSwitch = sizeof(aSwitch) / sizeof(struct ArSwitch);</Line>
  <Line number="17117">  struct ArSwitch *pEnd = &amp;aSwitch[nSwitch];</Line>
  <Line number="17118"></Line>
  <Line number="17119">  if( nArg&lt;=1 ){</Line>
  <Line number="17120">    utf8_printf(stderr, &quot;Wrong number of arguments.  Usage:\n&quot;);</Line>
  <Line number="17121">    return arUsage(stderr);</Line>
  <Line number="17122">  }else{</Line>
  <Line number="17123">    char *z = azArg[1];</Line>
  <Line number="17124">    if( z[0]!=&apos;-&apos; ){</Line>
  <Line number="17125">      /* Traditional style [tar] invocation */</Line>
  <Line number="17126">      int i;</Line>
  <Line number="17127">      int iArg = 2;</Line>
  <Line number="17128">      for(i=0; z[i]; i++){</Line>
  <Line number="17129">        const char *zArg = 0;</Line>
  <Line number="17130">        struct ArSwitch *pOpt;</Line>
  <Line number="17131">        for(pOpt=&amp;aSwitch[0]; pOpt&lt;pEnd; pOpt++){</Line>
  <Line number="17132">          if( z[i]==pOpt-&gt;cShort ) break;</Line>
  <Line number="17133">        }</Line>
  <Line number="17134">        if( pOpt==pEnd ){</Line>
  <Line number="17135">          return arErrorMsg(pAr, &quot;unrecognized option: %c&quot;, z[i]);</Line>
  <Line number="17136">        }</Line>
  <Line number="17137">        if( pOpt-&gt;bArg ){</Line>
  <Line number="17138">          if( iArg&gt;=nArg ){</Line>
  <Line number="17139">            return arErrorMsg(pAr, &quot;option requires an argument: %c&quot;,z[i]);</Line>
  <Line number="17140">          }</Line>
  <Line number="17141">          zArg = azArg[iArg++];</Line>
  <Line number="17142">        }</Line>
  <Line number="17143">        if( arProcessSwitch(pAr, pOpt-&gt;eSwitch, zArg) ) return SQLITE_ERROR;</Line>
  <Line number="17144">      }</Line>
  <Line number="17145">      pAr-&gt;nArg = nArg-iArg;</Line>
  <Line number="17146">      if( pAr-&gt;nArg&gt;0 ){</Line>
  <Line number="17147">        pAr-&gt;azArg = &amp;azArg[iArg];</Line>
  <Line number="17148">      }</Line>
  <Line number="17149">    }else{</Line>
  <Line number="17150">      /* Non-traditional invocation */</Line>
  <Line number="17151">      int iArg;</Line>
  <Line number="17152">      for(iArg=1; iArg&lt;nArg; iArg++){</Line>
  <Line number="17153">        int n;</Line>
  <Line number="17154">        z = azArg[iArg];</Line>
  <Line number="17155">        if( z[0]!=&apos;-&apos; ){</Line>
  <Line number="17156">          /* All remaining command line words are command arguments. */</Line>
  <Line number="17157">          pAr-&gt;azArg = &amp;azArg[iArg];</Line>
  <Line number="17158">          pAr-&gt;nArg = nArg-iArg;</Line>
  <Line number="17159">          break;</Line>
  <Line number="17160">        }</Line>
  <Line number="17161">        n = strlen30(z);</Line>
  <Line number="17162"></Line>
  <Line number="17163">        if( z[1]!=&apos;-&apos; ){</Line>
  <Line number="17164">          int i;</Line>
  <Line number="17165">          /* One or more short options */</Line>
  <Line number="17166">          for(i=1; i&lt;n; i++){</Line>
  <Line number="17167">            const char *zArg = 0;</Line>
  <Line number="17168">            struct ArSwitch *pOpt;</Line>
  <Line number="17169">            for(pOpt=&amp;aSwitch[0]; pOpt&lt;pEnd; pOpt++){</Line>
  <Line number="17170">              if( z[i]==pOpt-&gt;cShort ) break;</Line>
  <Line number="17171">            }</Line>
  <Line number="17172">            if( pOpt==pEnd ){</Line>
  <Line number="17173">              return arErrorMsg(pAr, &quot;unrecognized option: %c&quot;, z[i]);</Line>
  <Line number="17174">            }</Line>
  <Line number="17175">            if( pOpt-&gt;bArg ){</Line>
  <Line number="17176">              if( i&lt;(n-1) ){</Line>
  <Line number="17177">                zArg = &amp;z[i+1];</Line>
  <Line number="17178">                i = n;</Line>
  <Line number="17179">              }else{</Line>
  <Line number="17180">                if( iArg&gt;=(nArg-1) ){</Line>
  <Line number="17181">                  return arErrorMsg(pAr, &quot;option requires an argument: %c&quot;,</Line>
  <Line number="17182">                                    z[i]);</Line>
  <Line number="17183">                }</Line>
  <Line number="17184">                zArg = azArg[++iArg];</Line>
  <Line number="17185">              }</Line>
  <Line number="17186">            }</Line>
  <Line number="17187">            if( arProcessSwitch(pAr, pOpt-&gt;eSwitch, zArg) ) return SQLITE_ERROR;</Line>
  <Line number="17188">          }</Line>
  <Line number="17189">        }else if( z[2]==&apos;\0&apos; ){</Line>
  <Line number="17190">          /* A -- option, indicating that all remaining command line words</Line>
  <Line number="17191">          ** are command arguments.  */</Line>
  <Line number="17192">          pAr-&gt;azArg = &amp;azArg[iArg+1];</Line>
  <Line number="17193">          pAr-&gt;nArg = nArg-iArg-1;</Line>
  <Line number="17194">          break;</Line>
  <Line number="17195">        }else{</Line>
  <Line number="17196">          /* A long option */</Line>
  <Line number="17197">          const char *zArg = 0;             /* Argument for option, if any */</Line>
  <Line number="17198">          struct ArSwitch *pMatch = 0;      /* Matching option */</Line>
  <Line number="17199">          struct ArSwitch *pOpt;            /* Iterator */</Line>
  <Line number="17200">          for(pOpt=&amp;aSwitch[0]; pOpt&lt;pEnd; pOpt++){</Line>
  <Line number="17201">            const char *zLong = pOpt-&gt;zLong;</Line>
  <Line number="17202">            if( (n-2)&lt;=strlen30(zLong) &amp;&amp; 0==memcmp(&amp;z[2], zLong, n-2) ){</Line>
  <Line number="17203">              if( pMatch ){</Line>
  <Line number="17204">                return arErrorMsg(pAr, &quot;ambiguous option: %s&quot;,z);</Line>
  <Line number="17205">              }else{</Line>
  <Line number="17206">                pMatch = pOpt;</Line>
  <Line number="17207">              }</Line>
  <Line number="17208">            }</Line>
  <Line number="17209">          }</Line>
  <Line number="17210"></Line>
  <Line number="17211">          if( pMatch==0 ){</Line>
  <Line number="17212">            return arErrorMsg(pAr, &quot;unrecognized option: %s&quot;, z);</Line>
  <Line number="17213">          }</Line>
  <Line number="17214">          if( pMatch-&gt;bArg ){</Line>
  <Line number="17215">            if( iArg&gt;=(nArg-1) ){</Line>
  <Line number="17216">              return arErrorMsg(pAr, &quot;option requires an argument: %s&quot;, z);</Line>
  <Line number="17217">            }</Line>
  <Line number="17218">            zArg = azArg[++iArg];</Line>
  <Line number="17219">          }</Line>
  <Line number="17220">          if( arProcessSwitch(pAr, pMatch-&gt;eSwitch, zArg) ) return SQLITE_ERROR;</Line>
  <Line number="17221">        }</Line>
  <Line number="17222">      }</Line>
  <Line number="17223">    }</Line>
  <Line number="17224">  }</Line>
  <Line number="17225"></Line>
  <Line number="17226">  return SQLITE_OK;</Line>
  <Line number="17227">}</Line>
  <Line number="17228"></Line>
  <Line number="17229">/*</Line>
  <Line number="17230">** This function assumes that all arguments within the ArCommand.azArg[]</Line>
  <Line number="17231">** array refer to archive members, as for the --extract or --list commands. </Line>
  <Line number="17232">** It checks that each of them are present. If any specified file is not</Line>
  <Line number="17233">** present in the archive, an error is printed to stderr and an error</Line>
  <Line number="17234">** code returned. Otherwise, if all specified arguments are present in</Line>
  <Line number="17235">** the archive, SQLITE_OK is returned.</Line>
  <Line number="17236">**</Line>
  <Line number="17237">** This function strips any trailing &apos;/&apos; characters from each argument.</Line>
  <Line number="17238">** This is consistent with the way the [tar] command seems to work on</Line>
  <Line number="17239">** Linux.</Line>
  <Line number="17240">*/</Line>
  <Line number="17241">static int arCheckEntries(ArCommand *pAr){</Line>
  <Line number="17242">  int rc = SQLITE_OK;</Line>
  <Line number="17243">  if( pAr-&gt;nArg ){</Line>
  <Line number="17244">    int i, j;</Line>
  <Line number="17245">    sqlite3_stmt *pTest = 0;</Line>
  <Line number="17246"></Line>
  <Line number="17247">    shellPreparePrintf(pAr-&gt;db, &amp;rc, &amp;pTest,</Line>
  <Line number="17248">        &quot;SELECT name FROM %s WHERE name=$name&quot;, </Line>
  <Line number="17249">        pAr-&gt;zSrcTable</Line>
  <Line number="17250">    );</Line>
  <Line number="17251">    j = sqlite3_bind_parameter_index(pTest, &quot;$name&quot;);</Line>
  <Line number="17252">    for(i=0; i&lt;pAr-&gt;nArg &amp;&amp; rc==SQLITE_OK; i++){</Line>
  <Line number="17253">      char *z = pAr-&gt;azArg[i];</Line>
  <Line number="17254">      int n = strlen30(z);</Line>
  <Line number="17255">      int bOk = 0;</Line>
  <Line number="17256">      while( n&gt;0 &amp;&amp; z[n-1]==&apos;/&apos; ) n--;</Line>
  <Line number="17257">      z[n] = &apos;\0&apos;;</Line>
  <Line number="17258">      sqlite3_bind_text(pTest, j, z, -1, SQLITE_STATIC);</Line>
  <Line number="17259">      if( SQLITE_ROW==sqlite3_step(pTest) ){</Line>
  <Line number="17260">        bOk = 1;</Line>
  <Line number="17261">      }</Line>
  <Line number="17262">      shellReset(&amp;rc, pTest);</Line>
  <Line number="17263">      if( rc==SQLITE_OK &amp;&amp; bOk==0 ){</Line>
  <Line number="17264">        utf8_printf(stderr, &quot;not found in archive: %s\n&quot;, z);</Line>
  <Line number="17265">        rc = SQLITE_ERROR;</Line>
  <Line number="17266">      }</Line>
  <Line number="17267">    }</Line>
  <Line number="17268">    shellFinalize(&amp;rc, pTest);</Line>
  <Line number="17269">  }</Line>
  <Line number="17270">  return rc;</Line>
  <Line number="17271">}</Line>
  <Line number="17272"></Line>
  <Line number="17273">/*</Line>
  <Line number="17274">** Format a WHERE clause that can be used against the &quot;sqlar&quot; table to</Line>
  <Line number="17275">** identify all archive members that match the command arguments held</Line>
  <Line number="17276">** in (*pAr). Leave this WHERE clause in (*pzWhere) before returning.</Line>
  <Line number="17277">** The caller is responsible for eventually calling sqlite3_free() on</Line>
  <Line number="17278">** any non-NULL (*pzWhere) value.</Line>
  <Line number="17279">*/</Line>
  <Line number="17280">static void arWhereClause(</Line>
  <Line number="17281">  int *pRc, </Line>
  <Line number="17282">  ArCommand *pAr, </Line>
  <Line number="17283">  char **pzWhere                  /* OUT: New WHERE clause */</Line>
  <Line number="17284">){</Line>
  <Line number="17285">  char *zWhere = 0;</Line>
  <Line number="17286">  if( *pRc==SQLITE_OK ){</Line>
  <Line number="17287">    if( pAr-&gt;nArg==0 ){</Line>
  <Line number="17288">      zWhere = sqlite3_mprintf(&quot;1&quot;);</Line>
  <Line number="17289">    }else{</Line>
  <Line number="17290">      int i;</Line>
  <Line number="17291">      const char *zSep = &quot;&quot;;</Line>
  <Line number="17292">      for(i=0; i&lt;pAr-&gt;nArg; i++){</Line>
  <Line number="17293">        const char *z = pAr-&gt;azArg[i];</Line>
  <Line number="17294">        zWhere = sqlite3_mprintf(</Line>
  <Line number="17295">          &quot;%z%s name = &apos;%q&apos; OR substr(name,1,%d) = &apos;%q/&apos;&quot;, </Line>
  <Line number="17296">          zWhere, zSep, z, strlen30(z)+1, z</Line>
  <Line number="17297">        );</Line>
  <Line number="17298">        if( zWhere==0 ){</Line>
  <Line number="17299">          *pRc = SQLITE_NOMEM;</Line>
  <Line number="17300">          break;</Line>
  <Line number="17301">        }</Line>
  <Line number="17302">        zSep = &quot; OR &quot;;</Line>
  <Line number="17303">      }</Line>
  <Line number="17304">    }</Line>
  <Line number="17305">  }</Line>
  <Line number="17306">  *pzWhere = zWhere;</Line>
  <Line number="17307">}</Line>
  <Line number="17308"></Line>
  <Line number="17309">/*</Line>
  <Line number="17310">** Implementation of .ar &quot;lisT&quot; command. </Line>
  <Line number="17311">*/</Line>
  <Line number="17312">static int arListCommand(ArCommand *pAr){</Line>
  <Line number="17313">  const char *zSql = &quot;SELECT %s FROM %s WHERE %s&quot;; </Line>
  <Line number="17314">  const char *azCols[] = {</Line>
  <Line number="17315">    &quot;name&quot;,</Line>
  <Line number="17316">    &quot;lsmode(mode), sz, datetime(mtime, &apos;unixepoch&apos;), name&quot;</Line>
  <Line number="17317">  };</Line>
  <Line number="17318"></Line>
  <Line number="17319">  char *zWhere = 0;</Line>
  <Line number="17320">  sqlite3_stmt *pSql = 0;</Line>
  <Line number="17321">  int rc;</Line>
  <Line number="17322"></Line>
  <Line number="17323">  rc = arCheckEntries(pAr);</Line>
  <Line number="17324">  arWhereClause(&amp;rc, pAr, &amp;zWhere);</Line>
  <Line number="17325"></Line>
  <Line number="17326">  shellPreparePrintf(pAr-&gt;db, &amp;rc, &amp;pSql, zSql, azCols[pAr-&gt;bVerbose],</Line>
  <Line number="17327">                     pAr-&gt;zSrcTable, zWhere);</Line>
  <Line number="17328">  if( pAr-&gt;bDryRun ){</Line>
  <Line number="17329">    utf8_printf(pAr-&gt;p-&gt;out, &quot;%s\n&quot;, sqlite3_sql(pSql));</Line>
  <Line number="17330">  }else{</Line>
  <Line number="17331">    while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pSql) ){</Line>
  <Line number="17332">      if( pAr-&gt;bVerbose ){</Line>
  <Line number="17333">        utf8_printf(pAr-&gt;p-&gt;out, &quot;%s % 10d  %s  %s\n&quot;,</Line>
  <Line number="17334">            sqlite3_column_text(pSql, 0),</Line>
  <Line number="17335">            sqlite3_column_int(pSql, 1), </Line>
  <Line number="17336">            sqlite3_column_text(pSql, 2),</Line>
  <Line number="17337">            sqlite3_column_text(pSql, 3)</Line>
  <Line number="17338">        );</Line>
  <Line number="17339">      }else{</Line>
  <Line number="17340">        utf8_printf(pAr-&gt;p-&gt;out, &quot;%s\n&quot;, sqlite3_column_text(pSql, 0));</Line>
  <Line number="17341">      }</Line>
  <Line number="17342">    }</Line>
  <Line number="17343">  }</Line>
  <Line number="17344">  shellFinalize(&amp;rc, pSql);</Line>
  <Line number="17345">  sqlite3_free(zWhere);</Line>
  <Line number="17346">  return rc;</Line>
  <Line number="17347">}</Line>
  <Line number="17348"></Line>
  <Line number="17349"></Line>
  <Line number="17350">/*</Line>
  <Line number="17351">** Implementation of .ar &quot;eXtract&quot; command. </Line>
  <Line number="17352">*/</Line>
  <Line number="17353">static int arExtractCommand(ArCommand *pAr){</Line>
  <Line number="17354">  const char *zSql1 = </Line>
  <Line number="17355">    &quot;SELECT &quot;</Line>
  <Line number="17356">    &quot; ($dir || name),&quot;</Line>
  <Line number="17357">    &quot; writefile(($dir || name), %s, mode, mtime) &quot;</Line>
  <Line number="17358">    &quot;FROM %s WHERE (%s) AND (data IS NULL OR $dirOnly = 0)&quot;</Line>
  <Line number="17359">    &quot; AND name NOT GLOB &apos;*..[/\\]*&apos;&quot;;</Line>
  <Line number="17360"></Line>
  <Line number="17361">  const char *azExtraArg[] = { </Line>
  <Line number="17362">    &quot;sqlar_uncompress(data, sz)&quot;,</Line>
  <Line number="17363">    &quot;data&quot;</Line>
  <Line number="17364">  };</Line>
  <Line number="17365"></Line>
  <Line number="17366">  sqlite3_stmt *pSql = 0;</Line>
  <Line number="17367">  int rc = SQLITE_OK;</Line>
  <Line number="17368">  char *zDir = 0;</Line>
  <Line number="17369">  char *zWhere = 0;</Line>
  <Line number="17370">  int i, j;</Line>
  <Line number="17371"></Line>
  <Line number="17372">  /* If arguments are specified, check that they actually exist within</Line>
  <Line number="17373">  ** the archive before proceeding. And formulate a WHERE clause to</Line>
  <Line number="17374">  ** match them.  */</Line>
  <Line number="17375">  rc = arCheckEntries(pAr);</Line>
  <Line number="17376">  arWhereClause(&amp;rc, pAr, &amp;zWhere);</Line>
  <Line number="17377"></Line>
  <Line number="17378">  if( rc==SQLITE_OK ){</Line>
  <Line number="17379">    if( pAr-&gt;zDir ){</Line>
  <Line number="17380">      zDir = sqlite3_mprintf(&quot;%s/&quot;, pAr-&gt;zDir);</Line>
  <Line number="17381">    }else{</Line>
  <Line number="17382">      zDir = sqlite3_mprintf(&quot;&quot;);</Line>
  <Line number="17383">    }</Line>
  <Line number="17384">    if( zDir==0 ) rc = SQLITE_NOMEM;</Line>
  <Line number="17385">  }</Line>
  <Line number="17386"></Line>
  <Line number="17387">  shellPreparePrintf(pAr-&gt;db, &amp;rc, &amp;pSql, zSql1, </Line>
  <Line number="17388">      azExtraArg[pAr-&gt;bZip], pAr-&gt;zSrcTable, zWhere</Line>
  <Line number="17389">  );</Line>
  <Line number="17390"></Line>
  <Line number="17391">  if( rc==SQLITE_OK ){</Line>
  <Line number="17392">    j = sqlite3_bind_parameter_index(pSql, &quot;$dir&quot;);</Line>
  <Line number="17393">    sqlite3_bind_text(pSql, j, zDir, -1, SQLITE_STATIC);</Line>
  <Line number="17394"></Line>
  <Line number="17395">    /* Run the SELECT statement twice. The first time, writefile() is called</Line>
  <Line number="17396">    ** for all archive members that should be extracted. The second time,</Line>
  <Line number="17397">    ** only for the directories. This is because the timestamps for</Line>
  <Line number="17398">    ** extracted directories must be reset after they are populated (as</Line>
  <Line number="17399">    ** populating them changes the timestamp).  */</Line>
  <Line number="17400">    for(i=0; i&lt;2; i++){</Line>
  <Line number="17401">      j = sqlite3_bind_parameter_index(pSql, &quot;$dirOnly&quot;);</Line>
  <Line number="17402">      sqlite3_bind_int(pSql, j, i);</Line>
  <Line number="17403">      if( pAr-&gt;bDryRun ){</Line>
  <Line number="17404">        utf8_printf(pAr-&gt;p-&gt;out, &quot;%s\n&quot;, sqlite3_sql(pSql));</Line>
  <Line number="17405">      }else{</Line>
  <Line number="17406">        while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pSql) ){</Line>
  <Line number="17407">          if( i==0 &amp;&amp; pAr-&gt;bVerbose ){</Line>
  <Line number="17408">            utf8_printf(pAr-&gt;p-&gt;out, &quot;%s\n&quot;, sqlite3_column_text(pSql, 0));</Line>
  <Line number="17409">          }</Line>
  <Line number="17410">        }</Line>
  <Line number="17411">      }</Line>
  <Line number="17412">      shellReset(&amp;rc, pSql);</Line>
  <Line number="17413">    }</Line>
  <Line number="17414">    shellFinalize(&amp;rc, pSql);</Line>
  <Line number="17415">  }</Line>
  <Line number="17416"></Line>
  <Line number="17417">  sqlite3_free(zDir);</Line>
  <Line number="17418">  sqlite3_free(zWhere);</Line>
  <Line number="17419">  return rc;</Line>
  <Line number="17420">}</Line>
  <Line number="17421"></Line>
  <Line number="17422">/*</Line>
  <Line number="17423">** Run the SQL statement in zSql.  Or if doing a --dryrun, merely print it out.</Line>
  <Line number="17424">*/</Line>
  <Line number="17425">static int arExecSql(ArCommand *pAr, const char *zSql){</Line>
  <Line number="17426">  int rc;</Line>
  <Line number="17427">  if( pAr-&gt;bDryRun ){</Line>
  <Line number="17428">    utf8_printf(pAr-&gt;p-&gt;out, &quot;%s\n&quot;, zSql);</Line>
  <Line number="17429">    rc = SQLITE_OK;</Line>
  <Line number="17430">  }else{</Line>
  <Line number="17431">    char *zErr = 0;</Line>
  <Line number="17432">    rc = sqlite3_exec(pAr-&gt;db, zSql, 0, 0, &amp;zErr);</Line>
  <Line number="17433">    if( zErr ){</Line>
  <Line number="17434">      utf8_printf(stdout, &quot;ERROR: %s\n&quot;, zErr);</Line>
  <Line number="17435">      sqlite3_free(zErr);</Line>
  <Line number="17436">    }</Line>
  <Line number="17437">  }</Line>
  <Line number="17438">  return rc;</Line>
  <Line number="17439">}</Line>
  <Line number="17440"></Line>
  <Line number="17441"></Line>
  <Line number="17442">/*</Line>
  <Line number="17443">** Implementation of .ar &quot;create&quot;, &quot;insert&quot;, and &quot;update&quot; commands.</Line>
  <Line number="17444">**</Line>
  <Line number="17445">**     create    -&gt;     Create a new SQL archive</Line>
  <Line number="17446">**     insert    -&gt;     Insert or reinsert all files listed</Line>
  <Line number="17447">**     update    -&gt;     Insert files that have changed or that were not</Line>
  <Line number="17448">**                      previously in the archive</Line>
  <Line number="17449">**</Line>
  <Line number="17450">** Create the &quot;sqlar&quot; table in the database if it does not already exist.</Line>
  <Line number="17451">** Then add each file in the azFile[] array to the archive. Directories</Line>
  <Line number="17452">** are added recursively. If argument bVerbose is non-zero, a message is</Line>
  <Line number="17453">** printed on stdout for each file archived.</Line>
  <Line number="17454">**</Line>
  <Line number="17455">** The create command is the same as update, except that it drops</Line>
  <Line number="17456">** any existing &quot;sqlar&quot; table before beginning.  The &quot;insert&quot; command</Line>
  <Line number="17457">** always overwrites every file named on the command-line, where as</Line>
  <Line number="17458">** &quot;update&quot; only overwrites if the size or mtime or mode has changed.</Line>
  <Line number="17459">*/</Line>
  <Line number="17460">static int arCreateOrUpdateCommand(</Line>
  <Line number="17461">  ArCommand *pAr,                 /* Command arguments and options */</Line>
  <Line number="17462">  int bUpdate,                    /* true for a --create. */</Line>
  <Line number="17463">  int bOnlyIfChanged              /* Only update if file has changed */</Line>
  <Line number="17464">){</Line>
  <Line number="17465">  const char *zCreate = </Line>
  <Line number="17466">      &quot;CREATE TABLE IF NOT EXISTS sqlar(\n&quot;</Line>
  <Line number="17467">      &quot;  name TEXT PRIMARY KEY,  -- name of the file\n&quot;</Line>
  <Line number="17468">      &quot;  mode INT,               -- access permissions\n&quot;</Line>
  <Line number="17469">      &quot;  mtime INT,              -- last modification time\n&quot;</Line>
  <Line number="17470">      &quot;  sz INT,                 -- original file size\n&quot;</Line>
  <Line number="17471">      &quot;  data BLOB               -- compressed content\n&quot;</Line>
  <Line number="17472">      &quot;)&quot;;</Line>
  <Line number="17473">  const char *zDrop = &quot;DROP TABLE IF EXISTS sqlar&quot;;</Line>
  <Line number="17474">  const char *zInsertFmt[2] = {</Line>
  <Line number="17475">     &quot;REPLACE INTO %s(name,mode,mtime,sz,data)\n&quot;</Line>
  <Line number="17476">     &quot;  SELECT\n&quot;</Line>
  <Line number="17477">     &quot;    %s,\n&quot;</Line>
  <Line number="17478">     &quot;    mode,\n&quot;</Line>
  <Line number="17479">     &quot;    mtime,\n&quot;</Line>
  <Line number="17480">     &quot;    CASE substr(lsmode(mode),1,1)\n&quot;</Line>
  <Line number="17481">     &quot;      WHEN &apos;-&apos; THEN length(data)\n&quot;</Line>
  <Line number="17482">     &quot;      WHEN &apos;d&apos; THEN 0\n&quot;</Line>
  <Line number="17483">     &quot;      ELSE -1 END,\n&quot;</Line>
  <Line number="17484">     &quot;    sqlar_compress(data)\n&quot;</Line>
  <Line number="17485">     &quot;  FROM fsdir(%Q,%Q) AS disk\n&quot;</Line>
  <Line number="17486">     &quot;  WHERE lsmode(mode) NOT LIKE &apos;?%%&apos;%s;&quot;</Line>
  <Line number="17487">     ,</Line>
  <Line number="17488">     &quot;REPLACE INTO %s(name,mode,mtime,data)\n&quot;</Line>
  <Line number="17489">     &quot;  SELECT\n&quot;</Line>
  <Line number="17490">     &quot;    %s,\n&quot;</Line>
  <Line number="17491">     &quot;    mode,\n&quot;</Line>
  <Line number="17492">     &quot;    mtime,\n&quot;</Line>
  <Line number="17493">     &quot;    data\n&quot;</Line>
  <Line number="17494">     &quot;  FROM fsdir(%Q,%Q) AS disk\n&quot;</Line>
  <Line number="17495">     &quot;  WHERE lsmode(mode) NOT LIKE &apos;?%%&apos;%s;&quot;</Line>
  <Line number="17496">  };</Line>
  <Line number="17497">  int i;                          /* For iterating through azFile[] */</Line>
  <Line number="17498">  int rc;                         /* Return code */</Line>
  <Line number="17499">  const char *zTab = 0;           /* SQL table into which to insert */</Line>
  <Line number="17500">  char *zSql;</Line>
  <Line number="17501">  char zTemp[50];</Line>
  <Line number="17502">  char *zExists = 0;</Line>
  <Line number="17503"></Line>
  <Line number="17504">  arExecSql(pAr, &quot;PRAGMA page_size=512&quot;);</Line>
  <Line number="17505">  rc = arExecSql(pAr, &quot;SAVEPOINT ar;&quot;);</Line>
  <Line number="17506">  if( rc!=SQLITE_OK ) return rc;</Line>
  <Line number="17507">  zTemp[0] = 0; </Line>
  <Line number="17508">  if( pAr-&gt;bZip ){</Line>
  <Line number="17509">    /* Initialize the zipfile virtual table, if necessary */</Line>
  <Line number="17510">    if( pAr-&gt;zFile ){</Line>
  <Line number="17511">      sqlite3_uint64 r;</Line>
  <Line number="17512">      sqlite3_randomness(sizeof(r),&amp;r);</Line>
  <Line number="17513">      sqlite3_snprintf(sizeof(zTemp),zTemp,&quot;zip%016llx&quot;,r);</Line>
  <Line number="17514">      zTab = zTemp;</Line>
  <Line number="17515">      zSql = sqlite3_mprintf(</Line>
  <Line number="17516">         &quot;CREATE VIRTUAL TABLE temp.%s USING zipfile(%Q)&quot;,</Line>
  <Line number="17517">         zTab, pAr-&gt;zFile</Line>
  <Line number="17518">      );</Line>
  <Line number="17519">      rc = arExecSql(pAr, zSql);</Line>
  <Line number="17520">      sqlite3_free(zSql);</Line>
  <Line number="17521">    }else{</Line>
  <Line number="17522">      zTab = &quot;zip&quot;;</Line>
  <Line number="17523">    }</Line>
  <Line number="17524">  }else{</Line>
  <Line number="17525">    /* Initialize the table for an SQLAR */</Line>
  <Line number="17526">    zTab = &quot;sqlar&quot;;</Line>
  <Line number="17527">    if( bUpdate==0 ){</Line>
  <Line number="17528">      rc = arExecSql(pAr, zDrop);</Line>
  <Line number="17529">      if( rc!=SQLITE_OK ) goto end_ar_transaction;</Line>
  <Line number="17530">    }</Line>
  <Line number="17531">    rc = arExecSql(pAr, zCreate);</Line>
  <Line number="17532">  }</Line>
  <Line number="17533">  if( bOnlyIfChanged ){</Line>
  <Line number="17534">    zExists = sqlite3_mprintf(</Line>
  <Line number="17535">      &quot; AND NOT EXISTS(&quot;</Line>
  <Line number="17536">          &quot;SELECT 1 FROM %s AS mem&quot;</Line>
  <Line number="17537">          &quot; WHERE mem.name=disk.name&quot;</Line>
  <Line number="17538">          &quot; AND mem.mtime=disk.mtime&quot;</Line>
  <Line number="17539">          &quot; AND mem.mode=disk.mode)&quot;, zTab);</Line>
  <Line number="17540">  }else{</Line>
  <Line number="17541">    zExists = sqlite3_mprintf(&quot;&quot;);</Line>
  <Line number="17542">  }</Line>
  <Line number="17543">  if( zExists==0 ) rc = SQLITE_NOMEM;</Line>
  <Line number="17544">  for(i=0; i&lt;pAr-&gt;nArg &amp;&amp; rc==SQLITE_OK; i++){</Line>
  <Line number="17545">    char *zSql2 = sqlite3_mprintf(zInsertFmt[pAr-&gt;bZip], zTab,</Line>
  <Line number="17546">        pAr-&gt;bVerbose ? &quot;shell_putsnl(name)&quot; : &quot;name&quot;,</Line>
  <Line number="17547">        pAr-&gt;azArg[i], pAr-&gt;zDir, zExists);</Line>
  <Line number="17548">    rc = arExecSql(pAr, zSql2);</Line>
  <Line number="17549">    sqlite3_free(zSql2);</Line>
  <Line number="17550">  }</Line>
  <Line number="17551">end_ar_transaction:</Line>
  <Line number="17552">  if( rc!=SQLITE_OK ){</Line>
  <Line number="17553">    sqlite3_exec(pAr-&gt;db, &quot;ROLLBACK TO ar; RELEASE ar;&quot;, 0, 0, 0);</Line>
  <Line number="17554">  }else{</Line>
  <Line number="17555">    rc = arExecSql(pAr, &quot;RELEASE ar;&quot;);</Line>
  <Line number="17556">    if( pAr-&gt;bZip &amp;&amp; pAr-&gt;zFile ){</Line>
  <Line number="17557">      zSql = sqlite3_mprintf(&quot;DROP TABLE %s&quot;, zTemp);</Line>
  <Line number="17558">      arExecSql(pAr, zSql);</Line>
  <Line number="17559">      sqlite3_free(zSql);</Line>
  <Line number="17560">    }</Line>
  <Line number="17561">  }</Line>
  <Line number="17562">  sqlite3_free(zExists);</Line>
  <Line number="17563">  return rc;</Line>
  <Line number="17564">}</Line>
  <Line number="17565"></Line>
  <Line number="17566">/*</Line>
  <Line number="17567">** Implementation of &quot;.ar&quot; dot command.</Line>
  <Line number="17568">*/</Line>
  <Line number="17569">static int arDotCommand(</Line>
  <Line number="17570">  ShellState *pState,          /* Current shell tool state */</Line>
  <Line number="17571">  int fromCmdLine,             /* True if -A command-line option, not .ar cmd */</Line>
  <Line number="17572">  char **azArg,                /* Array of arguments passed to dot command */</Line>
  <Line number="17573">  int nArg                     /* Number of entries in azArg[] */</Line>
  <Line number="17574">){</Line>
  <Line number="17575">  ArCommand cmd;</Line>
  <Line number="17576">  int rc;</Line>
  <Line number="17577">  memset(&amp;cmd, 0, sizeof(cmd));</Line>
  <Line number="17578">  cmd.fromCmdLine = fromCmdLine;</Line>
  <Line number="17579">  rc = arParseCommand(azArg, nArg, &amp;cmd);</Line>
  <Line number="17580">  if( rc==SQLITE_OK ){</Line>
  <Line number="17581">    int eDbType = SHELL_OPEN_UNSPEC;</Line>
  <Line number="17582">    cmd.p = pState;</Line>
  <Line number="17583">    cmd.db = pState-&gt;db;</Line>
  <Line number="17584">    if( cmd.zFile ){</Line>
  <Line number="17585">      eDbType = deduceDatabaseType(cmd.zFile, 1);</Line>
  <Line number="17586">    }else{</Line>
  <Line number="17587">      eDbType = pState-&gt;openMode;</Line>
  <Line number="17588">    }</Line>
  <Line number="17589">    if( eDbType==SHELL_OPEN_ZIPFILE ){</Line>
  <Line number="17590">      if( cmd.eCmd==AR_CMD_EXTRACT || cmd.eCmd==AR_CMD_LIST ){</Line>
  <Line number="17591">        if( cmd.zFile==0 ){</Line>
  <Line number="17592">          cmd.zSrcTable = sqlite3_mprintf(&quot;zip&quot;);</Line>
  <Line number="17593">        }else{</Line>
  <Line number="17594">          cmd.zSrcTable = sqlite3_mprintf(&quot;zipfile(%Q)&quot;, cmd.zFile);</Line>
  <Line number="17595">        }</Line>
  <Line number="17596">      }</Line>
  <Line number="17597">      cmd.bZip = 1;</Line>
  <Line number="17598">    }else if( cmd.zFile ){</Line>
  <Line number="17599">      int flags;</Line>
  <Line number="17600">      if( cmd.bAppend ) eDbType = SHELL_OPEN_APPENDVFS;</Line>
  <Line number="17601">      if( cmd.eCmd==AR_CMD_CREATE || cmd.eCmd==AR_CMD_INSERT </Line>
  <Line number="17602">           || cmd.eCmd==AR_CMD_UPDATE ){</Line>
  <Line number="17603">        flags = SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE;</Line>
  <Line number="17604">      }else{</Line>
  <Line number="17605">        flags = SQLITE_OPEN_READONLY;</Line>
  <Line number="17606">      }</Line>
  <Line number="17607">      cmd.db = 0;</Line>
  <Line number="17608">      if( cmd.bDryRun ){</Line>
  <Line number="17609">        utf8_printf(pState-&gt;out, &quot;-- open database &apos;%s&apos;%s\n&quot;, cmd.zFile,</Line>
  <Line number="17610">             eDbType==SHELL_OPEN_APPENDVFS ? &quot; using &apos;apndvfs&apos;&quot; : &quot;&quot;);</Line>
  <Line number="17611">      }</Line>
  <Line number="17612">      rc = sqlite3_open_v2(cmd.zFile, &amp;cmd.db, flags, </Line>
  <Line number="17613">             eDbType==SHELL_OPEN_APPENDVFS ? &quot;apndvfs&quot; : 0);</Line>
  <Line number="17614">      if( rc!=SQLITE_OK ){</Line>
  <Line number="17615">        utf8_printf(stderr, &quot;cannot open file: %s (%s)\n&quot;, </Line>
  <Line number="17616">            cmd.zFile, sqlite3_errmsg(cmd.db)</Line>
  <Line number="17617">        );</Line>
  <Line number="17618">        goto end_ar_command;</Line>
  <Line number="17619">      }</Line>
  <Line number="17620">      sqlite3_fileio_init(cmd.db, 0, 0);</Line>
  <Line number="17621">      sqlite3_sqlar_init(cmd.db, 0, 0);</Line>
  <Line number="17622">      sqlite3_create_function(cmd.db, &quot;shell_putsnl&quot;, 1, SQLITE_UTF8, cmd.p,</Line>
  <Line number="17623">                              shellPutsFunc, 0, 0);</Line>
  <Line number="17624"></Line>
  <Line number="17625">    }</Line>
  <Line number="17626">    if( cmd.zSrcTable==0 &amp;&amp; cmd.bZip==0 &amp;&amp; cmd.eCmd!=AR_CMD_HELP ){</Line>
  <Line number="17627">      if( cmd.eCmd!=AR_CMD_CREATE</Line>
  <Line number="17628">       &amp;&amp; sqlite3_table_column_metadata(cmd.db,0,&quot;sqlar&quot;,&quot;name&quot;,0,0,0,0,0)</Line>
  <Line number="17629">      ){</Line>
  <Line number="17630">        utf8_printf(stderr, &quot;database does not contain an &apos;sqlar&apos; table\n&quot;);</Line>
  <Line number="17631">        rc = SQLITE_ERROR;</Line>
  <Line number="17632">        goto end_ar_command;</Line>
  <Line number="17633">      }</Line>
  <Line number="17634">      cmd.zSrcTable = sqlite3_mprintf(&quot;sqlar&quot;);</Line>
  <Line number="17635">    }</Line>
  <Line number="17636"></Line>
  <Line number="17637">    switch( cmd.eCmd ){</Line>
  <Line number="17638">      case AR_CMD_CREATE:</Line>
  <Line number="17639">        rc = arCreateOrUpdateCommand(&amp;cmd, 0, 0);</Line>
  <Line number="17640">        break;</Line>
  <Line number="17641"></Line>
  <Line number="17642">      case AR_CMD_EXTRACT:</Line>
  <Line number="17643">        rc = arExtractCommand(&amp;cmd);</Line>
  <Line number="17644">        break;</Line>
  <Line number="17645"></Line>
  <Line number="17646">      case AR_CMD_LIST:</Line>
  <Line number="17647">        rc = arListCommand(&amp;cmd);</Line>
  <Line number="17648">        break;</Line>
  <Line number="17649"></Line>
  <Line number="17650">      case AR_CMD_HELP:</Line>
  <Line number="17651">        arUsage(pState-&gt;out);</Line>
  <Line number="17652">        break;</Line>
  <Line number="17653"></Line>
  <Line number="17654">      case AR_CMD_INSERT:</Line>
  <Line number="17655">        rc = arCreateOrUpdateCommand(&amp;cmd, 1, 0);</Line>
  <Line number="17656">        break;</Line>
  <Line number="17657"></Line>
  <Line number="17658">      default:</Line>
  <Line number="17659">        assert( cmd.eCmd==AR_CMD_UPDATE );</Line>
  <Line number="17660">        rc = arCreateOrUpdateCommand(&amp;cmd, 1, 1);</Line>
  <Line number="17661">        break;</Line>
  <Line number="17662">    }</Line>
  <Line number="17663">  }</Line>
  <Line number="17664">end_ar_command:</Line>
  <Line number="17665">  if( cmd.db!=pState-&gt;db ){</Line>
  <Line number="17666">    close_db(cmd.db);</Line>
  <Line number="17667">  }</Line>
  <Line number="17668">  sqlite3_free(cmd.zSrcTable);</Line>
  <Line number="17669"></Line>
  <Line number="17670">  return rc;</Line>
  <Line number="17671">}</Line>
  <Line number="17672">/* End of the &quot;.archive&quot; or &quot;.ar&quot; command logic</Line>
  <Line number="17673">*******************************************************************************/</Line>
  <Line number="17674">#endif /* !defined(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; defined(SQLITE_HAVE_ZLIB) */</Line>
  <Line number="17675"></Line>
  <Line number="17676">#if !defined(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; defined(SQLITE_ENABLE_DBPAGE_VTAB)</Line>
  <Line number="17677">/*</Line>
  <Line number="17678">** If (*pRc) is not SQLITE_OK when this function is called, it is a no-op.</Line>
  <Line number="17679">** Otherwise, the SQL statement or statements in zSql are executed using</Line>
  <Line number="17680">** database connection db and the error code written to *pRc before</Line>
  <Line number="17681">** this function returns.</Line>
  <Line number="17682">*/</Line>
  <Line number="17683">static void shellExec(sqlite3 *db, int *pRc, const char *zSql){</Line>
  <Line number="17684">  int rc = *pRc;</Line>
  <Line number="17685">  if( rc==SQLITE_OK ){</Line>
  <Line number="17686">    char *zErr = 0;</Line>
  <Line number="17687">    rc = sqlite3_exec(db, zSql, 0, 0, &amp;zErr);</Line>
  <Line number="17688">    if( rc!=SQLITE_OK ){</Line>
  <Line number="17689">      raw_printf(stderr, &quot;SQL error: %s\n&quot;, zErr);</Line>
  <Line number="17690">    }</Line>
  <Line number="17691">    sqlite3_free(zErr);</Line>
  <Line number="17692">    *pRc = rc;</Line>
  <Line number="17693">  }</Line>
  <Line number="17694">}</Line>
  <Line number="17695"></Line>
  <Line number="17696">/*</Line>
  <Line number="17697">** Like shellExec(), except that zFmt is a printf() style format string.</Line>
  <Line number="17698">*/</Line>
  <Line number="17699">static void shellExecPrintf(sqlite3 *db, int *pRc, const char *zFmt, ...){</Line>
  <Line number="17700">  char *z = 0;</Line>
  <Line number="17701">  if( *pRc==SQLITE_OK ){</Line>
  <Line number="17702">    va_list ap;</Line>
  <Line number="17703">    va_start(ap, zFmt);</Line>
  <Line number="17704">    z = sqlite3_vmprintf(zFmt, ap);</Line>
  <Line number="17705">    va_end(ap);</Line>
  <Line number="17706">    if( z==0 ){</Line>
  <Line number="17707">      *pRc = SQLITE_NOMEM;</Line>
  <Line number="17708">    }else{</Line>
  <Line number="17709">      shellExec(db, pRc, z);</Line>
  <Line number="17710">    }</Line>
  <Line number="17711">    sqlite3_free(z);</Line>
  <Line number="17712">  }</Line>
  <Line number="17713">}</Line>
  <Line number="17714"></Line>
  <Line number="17715">/*</Line>
  <Line number="17716">** If *pRc is not SQLITE_OK when this function is called, it is a no-op.</Line>
  <Line number="17717">** Otherwise, an attempt is made to allocate, zero and return a pointer</Line>
  <Line number="17718">** to a buffer nByte bytes in size. If an OOM error occurs, *pRc is set</Line>
  <Line number="17719">** to SQLITE_NOMEM and NULL returned.</Line>
  <Line number="17720">*/</Line>
  <Line number="17721">static void *shellMalloc(int *pRc, sqlite3_int64 nByte){</Line>
  <Line number="17722">  void *pRet = 0;</Line>
  <Line number="17723">  if( *pRc==SQLITE_OK ){</Line>
  <Line number="17724">    pRet = sqlite3_malloc64(nByte);</Line>
  <Line number="17725">    if( pRet==0 ){</Line>
  <Line number="17726">      *pRc = SQLITE_NOMEM;</Line>
  <Line number="17727">    }else{</Line>
  <Line number="17728">      memset(pRet, 0, nByte);</Line>
  <Line number="17729">    }</Line>
  <Line number="17730">  }</Line>
  <Line number="17731">  return pRet;</Line>
  <Line number="17732">}</Line>
  <Line number="17733"></Line>
  <Line number="17734">/*</Line>
  <Line number="17735">** If *pRc is not SQLITE_OK when this function is called, it is a no-op.</Line>
  <Line number="17736">** Otherwise, zFmt is treated as a printf() style string. The result of</Line>
  <Line number="17737">** formatting it along with any trailing arguments is written into a </Line>
  <Line number="17738">** buffer obtained from sqlite3_malloc(), and pointer to which is returned.</Line>
  <Line number="17739">** It is the responsibility of the caller to eventually free this buffer</Line>
  <Line number="17740">** using a call to sqlite3_free().</Line>
  <Line number="17741">** </Line>
  <Line number="17742">** If an OOM error occurs, (*pRc) is set to SQLITE_NOMEM and a NULL </Line>
  <Line number="17743">** pointer returned.</Line>
  <Line number="17744">*/</Line>
  <Line number="17745">static char *shellMPrintf(int *pRc, const char *zFmt, ...){</Line>
  <Line number="17746">  char *z = 0;</Line>
  <Line number="17747">  if( *pRc==SQLITE_OK ){</Line>
  <Line number="17748">    va_list ap;</Line>
  <Line number="17749">    va_start(ap, zFmt);</Line>
  <Line number="17750">    z = sqlite3_vmprintf(zFmt, ap);</Line>
  <Line number="17751">    va_end(ap);</Line>
  <Line number="17752">    if( z==0 ){</Line>
  <Line number="17753">      *pRc = SQLITE_NOMEM;</Line>
  <Line number="17754">    }</Line>
  <Line number="17755">  }</Line>
  <Line number="17756">  return z;</Line>
  <Line number="17757">}</Line>
  <Line number="17758"></Line>
  <Line number="17759">/*</Line>
  <Line number="17760">** When running the &quot;.recover&quot; command, each output table, and the special</Line>
  <Line number="17761">** orphaned row table if it is required, is represented by an instance</Line>
  <Line number="17762">** of the following struct.</Line>
  <Line number="17763">*/</Line>
  <Line number="17764">typedef struct RecoverTable RecoverTable;</Line>
  <Line number="17765">struct RecoverTable {</Line>
  <Line number="17766">  char *zQuoted;                  /* Quoted version of table name */</Line>
  <Line number="17767">  int nCol;                       /* Number of columns in table */</Line>
  <Line number="17768">  char **azlCol;                  /* Array of column lists */</Line>
  <Line number="17769">  int iPk;                        /* Index of IPK column */</Line>
  <Line number="17770">};</Line>
  <Line number="17771"></Line>
  <Line number="17772">/*</Line>
  <Line number="17773">** Free a RecoverTable object allocated by recoverFindTable() or</Line>
  <Line number="17774">** recoverOrphanTable().</Line>
  <Line number="17775">*/</Line>
  <Line number="17776">static void recoverFreeTable(RecoverTable *pTab){</Line>
  <Line number="17777">  if( pTab ){</Line>
  <Line number="17778">    sqlite3_free(pTab-&gt;zQuoted);</Line>
  <Line number="17779">    if( pTab-&gt;azlCol ){</Line>
  <Line number="17780">      int i;</Line>
  <Line number="17781">      for(i=0; i&lt;=pTab-&gt;nCol; i++){</Line>
  <Line number="17782">        sqlite3_free(pTab-&gt;azlCol[i]);</Line>
  <Line number="17783">      }</Line>
  <Line number="17784">      sqlite3_free(pTab-&gt;azlCol);</Line>
  <Line number="17785">    }</Line>
  <Line number="17786">    sqlite3_free(pTab);</Line>
  <Line number="17787">  }</Line>
  <Line number="17788">}</Line>
  <Line number="17789"></Line>
  <Line number="17790">/*</Line>
  <Line number="17791">** This function is a no-op if (*pRc) is not SQLITE_OK when it is called.</Line>
  <Line number="17792">** Otherwise, it allocates and returns a RecoverTable object based on the</Line>
  <Line number="17793">** final four arguments passed to this function. It is the responsibility</Line>
  <Line number="17794">** of the caller to eventually free the returned object using</Line>
  <Line number="17795">** recoverFreeTable().</Line>
  <Line number="17796">*/</Line>
  <Line number="17797">static RecoverTable *recoverNewTable(</Line>
  <Line number="17798">  int *pRc,                       /* IN/OUT: Error code */</Line>
  <Line number="17799">  const char *zName,              /* Name of table */</Line>
  <Line number="17800">  const char *zSql,               /* CREATE TABLE statement */</Line>
  <Line number="17801">  int bIntkey, </Line>
  <Line number="17802">  int nCol</Line>
  <Line number="17803">){</Line>
  <Line number="17804">  sqlite3 *dbtmp = 0;             /* sqlite3 handle for testing CREATE TABLE */</Line>
  <Line number="17805">  int rc = *pRc;</Line>
  <Line number="17806">  RecoverTable *pTab = 0;</Line>
  <Line number="17807"></Line>
  <Line number="17808">  pTab = (RecoverTable*)shellMalloc(&amp;rc, sizeof(RecoverTable));</Line>
  <Line number="17809">  if( rc==SQLITE_OK ){</Line>
  <Line number="17810">    int nSqlCol = 0;</Line>
  <Line number="17811">    int bSqlIntkey = 0;</Line>
  <Line number="17812">    sqlite3_stmt *pStmt = 0;</Line>
  <Line number="17813">    </Line>
  <Line number="17814">    rc = sqlite3_open(&quot;&quot;, &amp;dbtmp);</Line>
  <Line number="17815">    if( rc==SQLITE_OK ){</Line>
  <Line number="17816">      sqlite3_create_function(dbtmp, &quot;shell_idquote&quot;, 1, SQLITE_UTF8, 0,</Line>
  <Line number="17817">                              shellIdQuote, 0, 0);</Line>
  <Line number="17818">    }</Line>
  <Line number="17819">    if( rc==SQLITE_OK ){</Line>
  <Line number="17820">      rc = sqlite3_exec(dbtmp, &quot;PRAGMA writable_schema = on&quot;, 0, 0, 0);</Line>
  <Line number="17821">    }</Line>
  <Line number="17822">    if( rc==SQLITE_OK ){</Line>
  <Line number="17823">      rc = sqlite3_exec(dbtmp, zSql, 0, 0, 0);</Line>
  <Line number="17824">      if( rc==SQLITE_ERROR ){</Line>
  <Line number="17825">        rc = SQLITE_OK;</Line>
  <Line number="17826">        goto finished;</Line>
  <Line number="17827">      }</Line>
  <Line number="17828">    }</Line>
  <Line number="17829">    shellPreparePrintf(dbtmp, &amp;rc, &amp;pStmt, </Line>
  <Line number="17830">        &quot;SELECT count(*) FROM pragma_table_info(%Q)&quot;, zName</Line>
  <Line number="17831">    );</Line>
  <Line number="17832">    if( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pStmt) ){</Line>
  <Line number="17833">      nSqlCol = sqlite3_column_int(pStmt, 0);</Line>
  <Line number="17834">    }</Line>
  <Line number="17835">    shellFinalize(&amp;rc, pStmt);</Line>
  <Line number="17836"></Line>
  <Line number="17837">    if( rc!=SQLITE_OK || nSqlCol&lt;nCol ){</Line>
  <Line number="17838">      goto finished;</Line>
  <Line number="17839">    }</Line>
  <Line number="17840"></Line>
  <Line number="17841">    shellPreparePrintf(dbtmp, &amp;rc, &amp;pStmt, </Line>
  <Line number="17842">      &quot;SELECT (&quot;</Line>
  <Line number="17843">      &quot;  SELECT substr(data,1,1)==X&apos;0D&apos; FROM sqlite_dbpage WHERE pgno=rootpage&quot;</Line>
  <Line number="17844">      &quot;) FROM sqlite_schema WHERE name = %Q&quot;, zName</Line>
  <Line number="17845">    );</Line>
  <Line number="17846">    if( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pStmt) ){</Line>
  <Line number="17847">      bSqlIntkey = sqlite3_column_int(pStmt, 0);</Line>
  <Line number="17848">    }</Line>
  <Line number="17849">    shellFinalize(&amp;rc, pStmt);</Line>
  <Line number="17850"></Line>
  <Line number="17851">    if( bIntkey==bSqlIntkey ){</Line>
  <Line number="17852">      int i;</Line>
  <Line number="17853">      const char *zPk = &quot;_rowid_&quot;;</Line>
  <Line number="17854">      sqlite3_stmt *pPkFinder = 0;</Line>
  <Line number="17855"></Line>
  <Line number="17856">      /* If this is an intkey table and there is an INTEGER PRIMARY KEY,</Line>
  <Line number="17857">      ** set zPk to the name of the PK column, and pTab-&gt;iPk to the index</Line>
  <Line number="17858">      ** of the column, where columns are 0-numbered from left to right.</Line>
  <Line number="17859">      ** Or, if this is a WITHOUT ROWID table or if there is no IPK column,</Line>
  <Line number="17860">      ** leave zPk as &quot;_rowid_&quot; and pTab-&gt;iPk at -2.  */</Line>
  <Line number="17861">      pTab-&gt;iPk = -2;</Line>
  <Line number="17862">      if( bIntkey ){</Line>
  <Line number="17863">        shellPreparePrintf(dbtmp, &amp;rc, &amp;pPkFinder, </Line>
  <Line number="17864">          &quot;SELECT cid, name FROM pragma_table_info(%Q) &quot;</Line>
  <Line number="17865">          &quot;  WHERE pk=1 AND type=&apos;integer&apos; COLLATE nocase&quot;</Line>
  <Line number="17866">          &quot;  AND NOT EXISTS (SELECT cid FROM pragma_table_info(%Q) WHERE pk=2)&quot;</Line>
  <Line number="17867">          , zName, zName</Line>
  <Line number="17868">        );</Line>
  <Line number="17869">        if( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pPkFinder) ){</Line>
  <Line number="17870">          pTab-&gt;iPk = sqlite3_column_int(pPkFinder, 0);</Line>
  <Line number="17871">          zPk = (const char*)sqlite3_column_text(pPkFinder, 1);</Line>
  <Line number="17872">        }</Line>
  <Line number="17873">      }</Line>
  <Line number="17874"></Line>
  <Line number="17875">      pTab-&gt;zQuoted = shellMPrintf(&amp;rc, &quot;\&quot;%w\&quot;&quot;, zName);</Line>
  <Line number="17876">      pTab-&gt;azlCol = (char**)shellMalloc(&amp;rc, sizeof(char*) * (nSqlCol+1));</Line>
  <Line number="17877">      pTab-&gt;nCol = nSqlCol;</Line>
  <Line number="17878"></Line>
  <Line number="17879">      if( bIntkey ){</Line>
  <Line number="17880">        pTab-&gt;azlCol[0] = shellMPrintf(&amp;rc, &quot;\&quot;%w\&quot;&quot;, zPk);</Line>
  <Line number="17881">      }else{</Line>
  <Line number="17882">        pTab-&gt;azlCol[0] = shellMPrintf(&amp;rc, &quot;&quot;);</Line>
  <Line number="17883">      }</Line>
  <Line number="17884">      i = 1;</Line>
  <Line number="17885">      shellPreparePrintf(dbtmp, &amp;rc, &amp;pStmt, </Line>
  <Line number="17886">          &quot;SELECT %Q || group_concat(shell_idquote(name), &apos;, &apos;) &quot;</Line>
  <Line number="17887">          &quot;  FILTER (WHERE cid!=%d) OVER (ORDER BY %s cid) &quot;</Line>
  <Line number="17888">          &quot;FROM pragma_table_info(%Q)&quot;, </Line>
  <Line number="17889">          bIntkey ? &quot;, &quot; : &quot;&quot;, pTab-&gt;iPk, </Line>
  <Line number="17890">          bIntkey ? &quot;&quot; : &quot;(CASE WHEN pk=0 THEN 1000000 ELSE pk END), &quot;,</Line>
  <Line number="17891">          zName</Line>
  <Line number="17892">      );</Line>
  <Line number="17893">      while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pStmt) ){</Line>
  <Line number="17894">        const char *zText = (const char*)sqlite3_column_text(pStmt, 0);</Line>
  <Line number="17895">        pTab-&gt;azlCol[i] = shellMPrintf(&amp;rc, &quot;%s%s&quot;, pTab-&gt;azlCol[0], zText);</Line>
  <Line number="17896">        i++;</Line>
  <Line number="17897">      }</Line>
  <Line number="17898">      shellFinalize(&amp;rc, pStmt);</Line>
  <Line number="17899"></Line>
  <Line number="17900">      shellFinalize(&amp;rc, pPkFinder);</Line>
  <Line number="17901">    }</Line>
  <Line number="17902">  }</Line>
  <Line number="17903"></Line>
  <Line number="17904"> finished:</Line>
  <Line number="17905">  sqlite3_close(dbtmp);</Line>
  <Line number="17906">  *pRc = rc;</Line>
  <Line number="17907">  if( rc!=SQLITE_OK || (pTab &amp;&amp; pTab-&gt;zQuoted==0) ){</Line>
  <Line number="17908">    recoverFreeTable(pTab);</Line>
  <Line number="17909">    pTab = 0;</Line>
  <Line number="17910">  }</Line>
  <Line number="17911">  return pTab;</Line>
  <Line number="17912">}</Line>
  <Line number="17913"></Line>
  <Line number="17914">/*</Line>
  <Line number="17915">** This function is called to search the schema recovered from the</Line>
  <Line number="17916">** sqlite_schema table of the (possibly) corrupt database as part</Line>
  <Line number="17917">** of a &quot;.recover&quot; command. Specifically, for a table with root page</Line>
  <Line number="17918">** iRoot and at least nCol columns. Additionally, if bIntkey is 0, the</Line>
  <Line number="17919">** table must be a WITHOUT ROWID table, or if non-zero, not one of</Line>
  <Line number="17920">** those.</Line>
  <Line number="17921">**</Line>
  <Line number="17922">** If a table is found, a (RecoverTable*) object is returned. Or, if</Line>
  <Line number="17923">** no such table is found, but bIntkey is false and iRoot is the </Line>
  <Line number="17924">** root page of an index in the recovered schema, then (*pbNoop) is</Line>
  <Line number="17925">** set to true and NULL returned. Or, if there is no such table or</Line>
  <Line number="17926">** index, NULL is returned and (*pbNoop) set to 0, indicating that</Line>
  <Line number="17927">** the caller should write data to the orphans table.</Line>
  <Line number="17928">*/</Line>
  <Line number="17929">static RecoverTable *recoverFindTable(</Line>
  <Line number="17930">  ShellState *pState,             /* Shell state object */</Line>
  <Line number="17931">  int *pRc,                       /* IN/OUT: Error code */</Line>
  <Line number="17932">  int iRoot,                      /* Root page of table */</Line>
  <Line number="17933">  int bIntkey,                    /* True for an intkey table */</Line>
  <Line number="17934">  int nCol,                       /* Number of columns in table */</Line>
  <Line number="17935">  int *pbNoop                     /* OUT: True if iRoot is root of index */</Line>
  <Line number="17936">){</Line>
  <Line number="17937">  sqlite3_stmt *pStmt = 0;</Line>
  <Line number="17938">  RecoverTable *pRet = 0;</Line>
  <Line number="17939">  int bNoop = 0;</Line>
  <Line number="17940">  const char *zSql = 0;</Line>
  <Line number="17941">  const char *zName = 0;</Line>
  <Line number="17942"></Line>
  <Line number="17943">  /* Search the recovered schema for an object with root page iRoot. */</Line>
  <Line number="17944">  shellPreparePrintf(pState-&gt;db, pRc, &amp;pStmt,</Line>
  <Line number="17945">      &quot;SELECT type, name, sql FROM recovery.schema WHERE rootpage=%d&quot;, iRoot</Line>
  <Line number="17946">  );</Line>
  <Line number="17947">  while( *pRc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pStmt) ){</Line>
  <Line number="17948">    const char *zType = (const char*)sqlite3_column_text(pStmt, 0);</Line>
  <Line number="17949">    if( bIntkey==0 &amp;&amp; sqlite3_stricmp(zType, &quot;index&quot;)==0 ){</Line>
  <Line number="17950">      bNoop = 1;</Line>
  <Line number="17951">      break;</Line>
  <Line number="17952">    }</Line>
  <Line number="17953">    if( sqlite3_stricmp(zType, &quot;table&quot;)==0 ){</Line>
  <Line number="17954">      zName = (const char*)sqlite3_column_text(pStmt, 1);</Line>
  <Line number="17955">      zSql = (const char*)sqlite3_column_text(pStmt, 2);</Line>
  <Line number="17956">      pRet = recoverNewTable(pRc, zName, zSql, bIntkey, nCol);</Line>
  <Line number="17957">      break;</Line>
  <Line number="17958">    }</Line>
  <Line number="17959">  }</Line>
  <Line number="17960"></Line>
  <Line number="17961">  shellFinalize(pRc, pStmt);</Line>
  <Line number="17962">  *pbNoop = bNoop;</Line>
  <Line number="17963">  return pRet;</Line>
  <Line number="17964">}</Line>
  <Line number="17965"></Line>
  <Line number="17966">/*</Line>
  <Line number="17967">** Return a RecoverTable object representing the orphans table.</Line>
  <Line number="17968">*/</Line>
  <Line number="17969">static RecoverTable *recoverOrphanTable(</Line>
  <Line number="17970">  ShellState *pState,             /* Shell state object */</Line>
  <Line number="17971">  int *pRc,                       /* IN/OUT: Error code */</Line>
  <Line number="17972">  const char *zLostAndFound,      /* Base name for orphans table */</Line>
  <Line number="17973">  int nCol                        /* Number of user data columns */</Line>
  <Line number="17974">){</Line>
  <Line number="17975">  RecoverTable *pTab = 0;</Line>
  <Line number="17976">  if( nCol&gt;=0 &amp;&amp; *pRc==SQLITE_OK ){</Line>
  <Line number="17977">    int i;</Line>
  <Line number="17978"></Line>
  <Line number="17979">    /* This block determines the name of the orphan table. The prefered</Line>
  <Line number="17980">    ** name is zLostAndFound. But if that clashes with another name</Line>
  <Line number="17981">    ** in the recovered schema, try zLostAndFound_0, zLostAndFound_1</Line>
  <Line number="17982">    ** and so on until a non-clashing name is found.  */</Line>
  <Line number="17983">    int iTab = 0;</Line>
  <Line number="17984">    char *zTab = shellMPrintf(pRc, &quot;%s&quot;, zLostAndFound);</Line>
  <Line number="17985">    sqlite3_stmt *pTest = 0;</Line>
  <Line number="17986">    shellPrepare(pState-&gt;db, pRc,</Line>
  <Line number="17987">        &quot;SELECT 1 FROM recovery.schema WHERE name=?&quot;, &amp;pTest</Line>
  <Line number="17988">    );</Line>
  <Line number="17989">    if( pTest ) sqlite3_bind_text(pTest, 1, zTab, -1, SQLITE_TRANSIENT);</Line>
  <Line number="17990">    while( *pRc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pTest) ){</Line>
  <Line number="17991">      shellReset(pRc, pTest);</Line>
  <Line number="17992">      sqlite3_free(zTab);</Line>
  <Line number="17993">      zTab = shellMPrintf(pRc, &quot;%s_%d&quot;, zLostAndFound, iTab++);</Line>
  <Line number="17994">      sqlite3_bind_text(pTest, 1, zTab, -1, SQLITE_TRANSIENT);</Line>
  <Line number="17995">    }</Line>
  <Line number="17996">    shellFinalize(pRc, pTest);</Line>
  <Line number="17997"></Line>
  <Line number="17998">    pTab = (RecoverTable*)shellMalloc(pRc, sizeof(RecoverTable));</Line>
  <Line number="17999">    if( pTab ){</Line>
  <Line number="18000">      pTab-&gt;zQuoted = shellMPrintf(pRc, &quot;\&quot;%w\&quot;&quot;, zTab);</Line>
  <Line number="18001">      pTab-&gt;nCol = nCol;</Line>
  <Line number="18002">      pTab-&gt;iPk = -2;</Line>
  <Line number="18003">      if( nCol&gt;0 ){</Line>
  <Line number="18004">        pTab-&gt;azlCol = (char**)shellMalloc(pRc, sizeof(char*) * (nCol+1));</Line>
  <Line number="18005">        if( pTab-&gt;azlCol ){</Line>
  <Line number="18006">          pTab-&gt;azlCol[nCol] = shellMPrintf(pRc, &quot;&quot;);</Line>
  <Line number="18007">          for(i=nCol-1; i&gt;=0; i--){</Line>
  <Line number="18008">            pTab-&gt;azlCol[i] = shellMPrintf(pRc, &quot;%s, NULL&quot;, pTab-&gt;azlCol[i+1]);</Line>
  <Line number="18009">          }</Line>
  <Line number="18010">        }</Line>
  <Line number="18011">      }</Line>
  <Line number="18012"></Line>
  <Line number="18013">      if( *pRc!=SQLITE_OK ){</Line>
  <Line number="18014">        recoverFreeTable(pTab);</Line>
  <Line number="18015">        pTab = 0;</Line>
  <Line number="18016">      }else{</Line>
  <Line number="18017">        raw_printf(pState-&gt;out, </Line>
  <Line number="18018">            &quot;CREATE TABLE %s(rootpgno INTEGER, &quot;</Line>
  <Line number="18019">            &quot;pgno INTEGER, nfield INTEGER, id INTEGER&quot;, pTab-&gt;zQuoted</Line>
  <Line number="18020">        );</Line>
  <Line number="18021">        for(i=0; i&lt;nCol; i++){</Line>
  <Line number="18022">          raw_printf(pState-&gt;out, &quot;, c%d&quot;, i);</Line>
  <Line number="18023">        }</Line>
  <Line number="18024">        raw_printf(pState-&gt;out, &quot;);\n&quot;);</Line>
  <Line number="18025">      }</Line>
  <Line number="18026">    }</Line>
  <Line number="18027">    sqlite3_free(zTab);</Line>
  <Line number="18028">  }</Line>
  <Line number="18029">  return pTab;</Line>
  <Line number="18030">}</Line>
  <Line number="18031"></Line>
  <Line number="18032">/*</Line>
  <Line number="18033">** This function is called to recover data from the database. A script</Line>
  <Line number="18034">** to construct a new database containing all recovered data is output</Line>
  <Line number="18035">** on stream pState-&gt;out.</Line>
  <Line number="18036">*/</Line>
  <Line number="18037">static int recoverDatabaseCmd(ShellState *pState, int nArg, char **azArg){</Line>
  <Line number="18038">  int rc = SQLITE_OK;</Line>
  <Line number="18039">  sqlite3_stmt *pLoop = 0;        /* Loop through all root pages */</Line>
  <Line number="18040">  sqlite3_stmt *pPages = 0;       /* Loop through all pages in a group */</Line>
  <Line number="18041">  sqlite3_stmt *pCells = 0;       /* Loop through all cells in a page */</Line>
  <Line number="18042">  const char *zRecoveryDb = &quot;&quot;;   /* Name of &quot;recovery&quot; database */</Line>
  <Line number="18043">  const char *zLostAndFound = &quot;lost_and_found&quot;;</Line>
  <Line number="18044">  int i;</Line>
  <Line number="18045">  int nOrphan = -1;</Line>
  <Line number="18046">  RecoverTable *pOrphan = 0;</Line>
  <Line number="18047"></Line>
  <Line number="18048">  int bFreelist = 1;              /* 0 if --freelist-corrupt is specified */</Line>
  <Line number="18049">  int bRowids = 1;                /* 0 if --no-rowids */</Line>
  <Line number="18050">  for(i=1; i&lt;nArg; i++){</Line>
  <Line number="18051">    char *z = azArg[i];</Line>
  <Line number="18052">    int n;</Line>
  <Line number="18053">    if( z[0]==&apos;-&apos; &amp;&amp; z[1]==&apos;-&apos; ) z++;</Line>
  <Line number="18054">    n = strlen30(z);</Line>
  <Line number="18055">    if( n&lt;=17 &amp;&amp; memcmp(&quot;-freelist-corrupt&quot;, z, n)==0 ){</Line>
  <Line number="18056">      bFreelist = 0;</Line>
  <Line number="18057">    }else</Line>
  <Line number="18058">    if( n&lt;=12 &amp;&amp; memcmp(&quot;-recovery-db&quot;, z, n)==0 &amp;&amp; i&lt;(nArg-1) ){</Line>
  <Line number="18059">      i++;</Line>
  <Line number="18060">      zRecoveryDb = azArg[i];</Line>
  <Line number="18061">    }else</Line>
  <Line number="18062">    if( n&lt;=15 &amp;&amp; memcmp(&quot;-lost-and-found&quot;, z, n)==0 &amp;&amp; i&lt;(nArg-1) ){</Line>
  <Line number="18063">      i++;</Line>
  <Line number="18064">      zLostAndFound = azArg[i];</Line>
  <Line number="18065">    }else</Line>
  <Line number="18066">    if( n&lt;=10 &amp;&amp; memcmp(&quot;-no-rowids&quot;, z, n)==0 ){</Line>
  <Line number="18067">      bRowids = 0;</Line>
  <Line number="18068">    }</Line>
  <Line number="18069">    else{</Line>
  <Line number="18070">      utf8_printf(stderr, &quot;unexpected option: %s\n&quot;, azArg[i]); </Line>
  <Line number="18071">      showHelp(pState-&gt;out, azArg[0]);</Line>
  <Line number="18072">      return 1;</Line>
  <Line number="18073">    }</Line>
  <Line number="18074">  }</Line>
  <Line number="18075"></Line>
  <Line number="18076">  shellExecPrintf(pState-&gt;db, &amp;rc,</Line>
  <Line number="18077">    /* Attach an in-memory database named &apos;recovery&apos;. Create an indexed </Line>
  <Line number="18078">    ** cache of the sqlite_dbptr virtual table. */</Line>
  <Line number="18079">    &quot;PRAGMA writable_schema = on;&quot;</Line>
  <Line number="18080">    &quot;ATTACH %Q AS recovery;&quot;</Line>
  <Line number="18081">    &quot;DROP TABLE IF EXISTS recovery.dbptr;&quot;</Line>
  <Line number="18082">    &quot;DROP TABLE IF EXISTS recovery.freelist;&quot;</Line>
  <Line number="18083">    &quot;DROP TABLE IF EXISTS recovery.map;&quot;</Line>
  <Line number="18084">    &quot;DROP TABLE IF EXISTS recovery.schema;&quot;</Line>
  <Line number="18085">    &quot;CREATE TABLE recovery.freelist(pgno INTEGER PRIMARY KEY);&quot;, zRecoveryDb</Line>
  <Line number="18086">  );</Line>
  <Line number="18087"></Line>
  <Line number="18088">  if( bFreelist ){</Line>
  <Line number="18089">    shellExec(pState-&gt;db, &amp;rc,</Line>
  <Line number="18090">      &quot;WITH trunk(pgno) AS (&quot;</Line>
  <Line number="18091">      &quot;  SELECT shell_int32(&quot;</Line>
  <Line number="18092">      &quot;      (SELECT data FROM sqlite_dbpage WHERE pgno=1), 8) AS x &quot;</Line>
  <Line number="18093">      &quot;      WHERE x&gt;0&quot;</Line>
  <Line number="18094">      &quot;    UNION&quot;</Line>
  <Line number="18095">      &quot;  SELECT shell_int32(&quot;</Line>
  <Line number="18096">      &quot;      (SELECT data FROM sqlite_dbpage WHERE pgno=trunk.pgno), 0) AS x &quot;</Line>
  <Line number="18097">      &quot;      FROM trunk WHERE x&gt;0&quot;</Line>
  <Line number="18098">      &quot;),&quot;</Line>
  <Line number="18099">      &quot;freelist(data, n, freepgno) AS (&quot;</Line>
  <Line number="18100">      &quot;  SELECT data, min(16384, shell_int32(data, 1)-1), t.pgno &quot;</Line>
  <Line number="18101">      &quot;      FROM trunk t, sqlite_dbpage s WHERE s.pgno=t.pgno&quot;</Line>
  <Line number="18102">      &quot;    UNION ALL&quot;</Line>
  <Line number="18103">      &quot;  SELECT data, n-1, shell_int32(data, 2+n) &quot;</Line>
  <Line number="18104">      &quot;      FROM freelist WHERE n&gt;=0&quot;</Line>
  <Line number="18105">      &quot;)&quot;</Line>
  <Line number="18106">      &quot;REPLACE INTO recovery.freelist SELECT freepgno FROM freelist;&quot;</Line>
  <Line number="18107">    );</Line>
  <Line number="18108">  }</Line>
  <Line number="18109"></Line>
  <Line number="18110">  /* If this is an auto-vacuum database, add all pointer-map pages to</Line>
  <Line number="18111">  ** the freelist table. Do this regardless of whether or not </Line>
  <Line number="18112">  ** --freelist-corrupt was specified.  */</Line>
  <Line number="18113">  shellExec(pState-&gt;db, &amp;rc, </Line>
  <Line number="18114">    &quot;WITH ptrmap(pgno) AS (&quot;</Line>
  <Line number="18115">    &quot;  SELECT 2 WHERE shell_int32(&quot;</Line>
  <Line number="18116">    &quot;    (SELECT data FROM sqlite_dbpage WHERE pgno=1), 13&quot;</Line>
  <Line number="18117">    &quot;  )&quot;</Line>
  <Line number="18118">    &quot;    UNION ALL &quot;</Line>
  <Line number="18119">    &quot;  SELECT pgno+1+(SELECT page_size FROM pragma_page_size)/5 AS pp &quot;</Line>
  <Line number="18120">    &quot;  FROM ptrmap WHERE pp&lt;=(SELECT page_count FROM pragma_page_count)&quot;</Line>
  <Line number="18121">    &quot;)&quot;</Line>
  <Line number="18122">    &quot;REPLACE INTO recovery.freelist SELECT pgno FROM ptrmap&quot;</Line>
  <Line number="18123">  );</Line>
  <Line number="18124"></Line>
  <Line number="18125">  shellExec(pState-&gt;db, &amp;rc, </Line>
  <Line number="18126">    &quot;CREATE TABLE recovery.dbptr(&quot;</Line>
  <Line number="18127">    &quot;      pgno, child, PRIMARY KEY(child, pgno)&quot;</Line>
  <Line number="18128">    &quot;) WITHOUT ROWID;&quot;</Line>
  <Line number="18129">    &quot;INSERT OR IGNORE INTO recovery.dbptr(pgno, child) &quot;</Line>
  <Line number="18130">    &quot;    SELECT * FROM sqlite_dbptr&quot;</Line>
  <Line number="18131">    &quot;      WHERE pgno NOT IN freelist AND child NOT IN freelist;&quot;</Line>
  <Line number="18132"></Line>
  <Line number="18133">    /* Delete any pointer to page 1. This ensures that page 1 is considered</Line>
  <Line number="18134">    ** a root page, regardless of how corrupt the db is. */</Line>
  <Line number="18135">    &quot;DELETE FROM recovery.dbptr WHERE child = 1;&quot;</Line>
  <Line number="18136"></Line>
  <Line number="18137">    /* Delete all pointers to any pages that have more than one pointer</Line>
  <Line number="18138">    ** to them. Such pages will be treated as root pages when recovering</Line>
  <Line number="18139">    ** data.  */</Line>
  <Line number="18140">    &quot;DELETE FROM recovery.dbptr WHERE child IN (&quot;</Line>
  <Line number="18141">    &quot;  SELECT child FROM recovery.dbptr GROUP BY child HAVING count(*)&gt;1&quot;</Line>
  <Line number="18142">    &quot;);&quot;</Line>
  <Line number="18143"></Line>
  <Line number="18144">    /* Create the &quot;map&quot; table that will (eventually) contain instructions</Line>
  <Line number="18145">    ** for dealing with each page in the db that contains one or more </Line>
  <Line number="18146">    ** records. */</Line>
  <Line number="18147">    &quot;CREATE TABLE recovery.map(&quot;</Line>
  <Line number="18148">      &quot;pgno INTEGER PRIMARY KEY, maxlen INT, intkey, root INT&quot;</Line>
  <Line number="18149">    &quot;);&quot;</Line>
  <Line number="18150"></Line>
  <Line number="18151">    /* Populate table [map]. If there are circular loops of pages in the</Line>
  <Line number="18152">    ** database, the following adds all pages in such a loop to the map</Line>
  <Line number="18153">    ** as individual root pages. This could be handled better.  */</Line>
  <Line number="18154">    &quot;WITH pages(i, maxlen) AS (&quot;</Line>
  <Line number="18155">    &quot;  SELECT page_count, (&quot;</Line>
  <Line number="18156">    &quot;    SELECT max(field+1) FROM sqlite_dbdata WHERE pgno=page_count&quot;</Line>
  <Line number="18157">    &quot;  ) FROM pragma_page_count WHERE page_count&gt;0&quot;</Line>
  <Line number="18158">    &quot;    UNION ALL&quot;</Line>
  <Line number="18159">    &quot;  SELECT i-1, (&quot;</Line>
  <Line number="18160">    &quot;    SELECT max(field+1) FROM sqlite_dbdata WHERE pgno=i-1&quot;</Line>
  <Line number="18161">    &quot;  ) FROM pages WHERE i&gt;=2&quot;</Line>
  <Line number="18162">    &quot;)&quot;</Line>
  <Line number="18163">    &quot;INSERT INTO recovery.map(pgno, maxlen, intkey, root) &quot;</Line>
  <Line number="18164">    &quot;  SELECT i, maxlen, NULL, (&quot;</Line>
  <Line number="18165">    &quot;    WITH p(orig, pgno, parent) AS (&quot;</Line>
  <Line number="18166">    &quot;      SELECT 0, i, (SELECT pgno FROM recovery.dbptr WHERE child=i)&quot;</Line>
  <Line number="18167">    &quot;        UNION &quot;</Line>
  <Line number="18168">    &quot;      SELECT i, p.parent, &quot;</Line>
  <Line number="18169">    &quot;        (SELECT pgno FROM recovery.dbptr WHERE child=p.parent) FROM p&quot;</Line>
  <Line number="18170">    &quot;    )&quot;</Line>
  <Line number="18171">    &quot;    SELECT pgno FROM p WHERE (parent IS NULL OR pgno = orig)&quot;</Line>
  <Line number="18172">    &quot;) &quot;</Line>
  <Line number="18173">    &quot;FROM pages WHERE maxlen IS NOT NULL AND i NOT IN freelist;&quot;</Line>
  <Line number="18174">    &quot;UPDATE recovery.map AS o SET intkey = (&quot;</Line>
  <Line number="18175">    &quot;  SELECT substr(data, 1, 1)==X&apos;0D&apos; FROM sqlite_dbpage WHERE pgno=o.pgno&quot;</Line>
  <Line number="18176">    &quot;);&quot;</Line>
  <Line number="18177"></Line>
  <Line number="18178">    /* Extract data from page 1 and any linked pages into table</Line>
  <Line number="18179">    ** recovery.schema. With the same schema as an sqlite_schema table.  */</Line>
  <Line number="18180">    &quot;CREATE TABLE recovery.schema(type, name, tbl_name, rootpage, sql);&quot;</Line>
  <Line number="18181">    &quot;INSERT INTO recovery.schema SELECT &quot;</Line>
  <Line number="18182">    &quot;  max(CASE WHEN field=0 THEN value ELSE NULL END),&quot;</Line>
  <Line number="18183">    &quot;  max(CASE WHEN field=1 THEN value ELSE NULL END),&quot;</Line>
  <Line number="18184">    &quot;  max(CASE WHEN field=2 THEN value ELSE NULL END),&quot;</Line>
  <Line number="18185">    &quot;  max(CASE WHEN field=3 THEN value ELSE NULL END),&quot;</Line>
  <Line number="18186">    &quot;  max(CASE WHEN field=4 THEN value ELSE NULL END)&quot;</Line>
  <Line number="18187">    &quot;FROM sqlite_dbdata WHERE pgno IN (&quot;</Line>
  <Line number="18188">    &quot;  SELECT pgno FROM recovery.map WHERE root=1&quot;</Line>
  <Line number="18189">    &quot;)&quot;</Line>
  <Line number="18190">    &quot;GROUP BY pgno, cell;&quot;</Line>
  <Line number="18191">    &quot;CREATE INDEX recovery.schema_rootpage ON schema(rootpage);&quot;</Line>
  <Line number="18192">  );</Line>
  <Line number="18193"></Line>
  <Line number="18194">  /* Open a transaction, then print out all non-virtual, non-&quot;sqlite_%&quot; </Line>
  <Line number="18195">  ** CREATE TABLE statements that extracted from the existing schema.  */</Line>
  <Line number="18196">  if( rc==SQLITE_OK ){</Line>
  <Line number="18197">    sqlite3_stmt *pStmt = 0;</Line>
  <Line number="18198">    /* &quot;.recover&quot; might output content in an order which causes immediate</Line>
  <Line number="18199">    ** foreign key constraints to be violated. So disable foreign-key</Line>
  <Line number="18200">    ** constraint enforcement to prevent problems when running the output</Line>
  <Line number="18201">    ** script. */</Line>
  <Line number="18202">    raw_printf(pState-&gt;out, &quot;PRAGMA foreign_keys=OFF;\n&quot;);</Line>
  <Line number="18203">    raw_printf(pState-&gt;out, &quot;BEGIN;\n&quot;);</Line>
  <Line number="18204">    raw_printf(pState-&gt;out, &quot;PRAGMA writable_schema = on;\n&quot;);</Line>
  <Line number="18205">    shellPrepare(pState-&gt;db, &amp;rc,</Line>
  <Line number="18206">        &quot;SELECT sql FROM recovery.schema &quot;</Line>
  <Line number="18207">        &quot;WHERE type=&apos;table&apos; AND sql LIKE &apos;create table%&apos;&quot;, &amp;pStmt</Line>
  <Line number="18208">    );</Line>
  <Line number="18209">    while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pStmt) ){</Line>
  <Line number="18210">      const char *zCreateTable = (const char*)sqlite3_column_text(pStmt, 0);</Line>
  <Line number="18211">      raw_printf(pState-&gt;out, &quot;CREATE TABLE IF NOT EXISTS %s;\n&quot;, </Line>
  <Line number="18212">          &amp;zCreateTable[12]</Line>
  <Line number="18213">      );</Line>
  <Line number="18214">    }</Line>
  <Line number="18215">    shellFinalize(&amp;rc, pStmt);</Line>
  <Line number="18216">  }</Line>
  <Line number="18217"></Line>
  <Line number="18218">  /* Figure out if an orphan table will be required. And if so, how many</Line>
  <Line number="18219">  ** user columns it should contain */</Line>
  <Line number="18220">  shellPrepare(pState-&gt;db, &amp;rc, </Line>
  <Line number="18221">      &quot;SELECT coalesce(max(maxlen), -2) FROM recovery.map WHERE root&gt;1&quot;</Line>
  <Line number="18222">      , &amp;pLoop</Line>
  <Line number="18223">  );</Line>
  <Line number="18224">  if( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pLoop) ){</Line>
  <Line number="18225">    nOrphan = sqlite3_column_int(pLoop, 0);</Line>
  <Line number="18226">  }</Line>
  <Line number="18227">  shellFinalize(&amp;rc, pLoop);</Line>
  <Line number="18228">  pLoop = 0;</Line>
  <Line number="18229"></Line>
  <Line number="18230">  shellPrepare(pState-&gt;db, &amp;rc,</Line>
  <Line number="18231">      &quot;SELECT pgno FROM recovery.map WHERE root=?&quot;, &amp;pPages</Line>
  <Line number="18232">  );</Line>
  <Line number="18233"></Line>
  <Line number="18234">  shellPrepare(pState-&gt;db, &amp;rc,</Line>
  <Line number="18235">      &quot;SELECT max(field), group_concat(shell_escape_crnl(quote&quot;</Line>
  <Line number="18236">      &quot;(case when (? AND field&lt;0) then NULL else value end)&quot;</Line>
  <Line number="18237">      &quot;), &apos;, &apos;)&quot;</Line>
  <Line number="18238">      &quot;, min(field) &quot;</Line>
  <Line number="18239">      &quot;FROM sqlite_dbdata WHERE pgno = ? AND field != ?&quot;</Line>
  <Line number="18240">      &quot;GROUP BY cell&quot;, &amp;pCells</Line>
  <Line number="18241">  );</Line>
  <Line number="18242"></Line>
  <Line number="18243">  /* Loop through each root page. */</Line>
  <Line number="18244">  shellPrepare(pState-&gt;db, &amp;rc, </Line>
  <Line number="18245">      &quot;SELECT root, intkey, max(maxlen) FROM recovery.map&quot; </Line>
  <Line number="18246">      &quot; WHERE root&gt;1 GROUP BY root, intkey ORDER BY root=(&quot;</Line>
  <Line number="18247">      &quot;  SELECT rootpage FROM recovery.schema WHERE name=&apos;sqlite_sequence&apos;&quot;</Line>
  <Line number="18248">      &quot;)&quot;, &amp;pLoop</Line>
  <Line number="18249">  );</Line>
  <Line number="18250">  while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pLoop) ){</Line>
  <Line number="18251">    int iRoot = sqlite3_column_int(pLoop, 0);</Line>
  <Line number="18252">    int bIntkey = sqlite3_column_int(pLoop, 1);</Line>
  <Line number="18253">    int nCol = sqlite3_column_int(pLoop, 2);</Line>
  <Line number="18254">    int bNoop = 0;</Line>
  <Line number="18255">    RecoverTable *pTab;</Line>
  <Line number="18256"></Line>
  <Line number="18257">    assert( bIntkey==0 || bIntkey==1 );</Line>
  <Line number="18258">    pTab = recoverFindTable(pState, &amp;rc, iRoot, bIntkey, nCol, &amp;bNoop);</Line>
  <Line number="18259">    if( bNoop || rc ) continue;</Line>
  <Line number="18260">    if( pTab==0 ){</Line>
  <Line number="18261">      if( pOrphan==0 ){</Line>
  <Line number="18262">        pOrphan = recoverOrphanTable(pState, &amp;rc, zLostAndFound, nOrphan);</Line>
  <Line number="18263">      }</Line>
  <Line number="18264">      pTab = pOrphan;</Line>
  <Line number="18265">      if( pTab==0 ) break;</Line>
  <Line number="18266">    }</Line>
  <Line number="18267"></Line>
  <Line number="18268">    if( 0==sqlite3_stricmp(pTab-&gt;zQuoted, &quot;\&quot;sqlite_sequence\&quot;&quot;) ){</Line>
  <Line number="18269">      raw_printf(pState-&gt;out, &quot;DELETE FROM sqlite_sequence;\n&quot;);</Line>
  <Line number="18270">    }</Line>
  <Line number="18271">    sqlite3_bind_int(pPages, 1, iRoot);</Line>
  <Line number="18272">    if( bRowids==0 &amp;&amp; pTab-&gt;iPk&lt;0 ){</Line>
  <Line number="18273">      sqlite3_bind_int(pCells, 1, 1);</Line>
  <Line number="18274">    }else{</Line>
  <Line number="18275">      sqlite3_bind_int(pCells, 1, 0);</Line>
  <Line number="18276">    }</Line>
  <Line number="18277">    sqlite3_bind_int(pCells, 3, pTab-&gt;iPk);</Line>
  <Line number="18278"></Line>
  <Line number="18279">    while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pPages) ){</Line>
  <Line number="18280">      int iPgno = sqlite3_column_int(pPages, 0);</Line>
  <Line number="18281">      sqlite3_bind_int(pCells, 2, iPgno);</Line>
  <Line number="18282">      while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pCells) ){</Line>
  <Line number="18283">        int nField = sqlite3_column_int(pCells, 0);</Line>
  <Line number="18284">        int iMin = sqlite3_column_int(pCells, 2);</Line>
  <Line number="18285">        const char *zVal = (const char*)sqlite3_column_text(pCells, 1);</Line>
  <Line number="18286"></Line>
  <Line number="18287">        RecoverTable *pTab2 = pTab;</Line>
  <Line number="18288">        if( pTab!=pOrphan &amp;&amp; (iMin&lt;0)!=bIntkey ){</Line>
  <Line number="18289">          if( pOrphan==0 ){</Line>
  <Line number="18290">            pOrphan = recoverOrphanTable(pState, &amp;rc, zLostAndFound, nOrphan);</Line>
  <Line number="18291">          }</Line>
  <Line number="18292">          pTab2 = pOrphan;</Line>
  <Line number="18293">          if( pTab2==0 ) break;</Line>
  <Line number="18294">        }</Line>
  <Line number="18295"></Line>
  <Line number="18296">        nField = nField+1;</Line>
  <Line number="18297">        if( pTab2==pOrphan ){</Line>
  <Line number="18298">          raw_printf(pState-&gt;out, </Line>
  <Line number="18299">              &quot;INSERT INTO %s VALUES(%d, %d, %d, %s%s%s);\n&quot;,</Line>
  <Line number="18300">              pTab2-&gt;zQuoted, iRoot, iPgno, nField,</Line>
  <Line number="18301">              iMin&lt;0 ? &quot;&quot; : &quot;NULL, &quot;, zVal, pTab2-&gt;azlCol[nField]</Line>
  <Line number="18302">          );</Line>
  <Line number="18303">        }else{</Line>
  <Line number="18304">          raw_printf(pState-&gt;out, &quot;INSERT INTO %s(%s) VALUES( %s );\n&quot;, </Line>
  <Line number="18305">              pTab2-&gt;zQuoted, pTab2-&gt;azlCol[nField], zVal</Line>
  <Line number="18306">          );</Line>
  <Line number="18307">        }</Line>
  <Line number="18308">      }</Line>
  <Line number="18309">      shellReset(&amp;rc, pCells);</Line>
  <Line number="18310">    }</Line>
  <Line number="18311">    shellReset(&amp;rc, pPages);</Line>
  <Line number="18312">    if( pTab!=pOrphan ) recoverFreeTable(pTab);</Line>
  <Line number="18313">  }</Line>
  <Line number="18314">  shellFinalize(&amp;rc, pLoop);</Line>
  <Line number="18315">  shellFinalize(&amp;rc, pPages);</Line>
  <Line number="18316">  shellFinalize(&amp;rc, pCells);</Line>
  <Line number="18317">  recoverFreeTable(pOrphan);</Line>
  <Line number="18318"></Line>
  <Line number="18319">  /* The rest of the schema */</Line>
  <Line number="18320">  if( rc==SQLITE_OK ){</Line>
  <Line number="18321">    sqlite3_stmt *pStmt = 0;</Line>
  <Line number="18322">    shellPrepare(pState-&gt;db, &amp;rc, </Line>
  <Line number="18323">        &quot;SELECT sql, name FROM recovery.schema &quot;</Line>
  <Line number="18324">        &quot;WHERE sql NOT LIKE &apos;create table%&apos;&quot;, &amp;pStmt</Line>
  <Line number="18325">    );</Line>
  <Line number="18326">    while( rc==SQLITE_OK &amp;&amp; SQLITE_ROW==sqlite3_step(pStmt) ){</Line>
  <Line number="18327">      const char *zSql = (const char*)sqlite3_column_text(pStmt, 0);</Line>
  <Line number="18328">      if( sqlite3_strnicmp(zSql, &quot;create virt&quot;, 11)==0 ){</Line>
  <Line number="18329">        const char *zName = (const char*)sqlite3_column_text(pStmt, 1);</Line>
  <Line number="18330">        char *zPrint = shellMPrintf(&amp;rc, </Line>
  <Line number="18331">          &quot;INSERT INTO sqlite_schema VALUES(&apos;table&apos;, %Q, %Q, 0, %Q)&quot;,</Line>
  <Line number="18332">          zName, zName, zSql</Line>
  <Line number="18333">        );</Line>
  <Line number="18334">        raw_printf(pState-&gt;out, &quot;%s;\n&quot;, zPrint);</Line>
  <Line number="18335">        sqlite3_free(zPrint);</Line>
  <Line number="18336">      }else{</Line>
  <Line number="18337">        raw_printf(pState-&gt;out, &quot;%s;\n&quot;, zSql);</Line>
  <Line number="18338">      }</Line>
  <Line number="18339">    }</Line>
  <Line number="18340">    shellFinalize(&amp;rc, pStmt);</Line>
  <Line number="18341">  }</Line>
  <Line number="18342"></Line>
  <Line number="18343">  if( rc==SQLITE_OK ){</Line>
  <Line number="18344">    raw_printf(pState-&gt;out, &quot;PRAGMA writable_schema = off;\n&quot;);</Line>
  <Line number="18345">    raw_printf(pState-&gt;out, &quot;COMMIT;\n&quot;);</Line>
  <Line number="18346">  }</Line>
  <Line number="18347">  sqlite3_exec(pState-&gt;db, &quot;DETACH recovery&quot;, 0, 0, 0);</Line>
  <Line number="18348">  return rc;</Line>
  <Line number="18349">}</Line>
  <Line number="18350">#endif /* !(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; defined(SQLITE_ENABLE_DBPAGE_VTAB) */</Line>
  <Line number="18351"></Line>
  <Line number="18352"></Line>
  <Line number="18353">/*</Line>
  <Line number="18354">** If an input line begins with &quot;.&quot; then invoke this routine to</Line>
  <Line number="18355">** process that line.</Line>
  <Line number="18356">**</Line>
  <Line number="18357">** Return 1 on error, 2 to exit, and 0 otherwise.</Line>
  <Line number="18358">*/</Line>
  <Line number="18359">static int do_meta_command(char *zLine, ShellState *p){</Line>
  <Line number="18360">  int h = 1;</Line>
  <Line number="18361">  int nArg = 0;</Line>
  <Line number="18362">  int n, c;</Line>
  <Line number="18363">  int rc = 0;</Line>
  <Line number="18364">  char *azArg[52];</Line>
  <Line number="18365"></Line>
  <Line number="18366">#ifndef SQLITE_OMIT_VIRTUALTABLE</Line>
  <Line number="18367">  if( p-&gt;expert.pExpert ){</Line>
  <Line number="18368">    expertFinish(p, 1, 0);</Line>
  <Line number="18369">  }</Line>
  <Line number="18370">#endif</Line>
  <Line number="18371"></Line>
  <Line number="18372">  /* Parse the input line into tokens.</Line>
  <Line number="18373">  */</Line>
  <Line number="18374">  while( <CheckRefs ids="3509">zLine</CheckRefs>[h] &amp;&amp; nArg&lt;<CheckRefs ids="3513,3511,3512">ArraySize</CheckRefs>(azArg)<CheckRefs ids="3510">-</CheckRefs>1 ){</Line>
  <Line number="18375">    while( <CheckRefs ids="3514,3515,3517,3518,3516">IsSpace</CheckRefs>(zLine[h]) ){ h<CheckRefs ids="3519">++</CheckRefs>; }</Line>
  <Line number="18376">    if( <CheckRefs ids="3520">zLine</CheckRefs>[h]==0 ) break;</Line>
  <Line number="18377">    if( <CheckRefs ids="3521">zLine</CheckRefs>[h]==&apos;\&apos;&apos; || <CheckRefs ids="3522">zLine</CheckRefs>[h]==&apos;&quot;&apos; ){</Line>
  <Line number="18378">      int delim = <CheckRefs ids="3523">zLine</CheckRefs>[h<CheckRefs ids="3524">++</CheckRefs>];</Line>
  <Line number="18379">      azArg[nArg<CheckRefs ids="3526">++</CheckRefs><CheckRefs ids="3525">]</CheckRefs> = &amp;zLine[h];</Line>
  <Line number="18380">      while( <CheckRefs ids="3527">zLine</CheckRefs>[h] &amp;&amp; <CheckRefs ids="3528">zLine</CheckRefs>[h]!=delim ){</Line>
  <Line number="18381">        if( <CheckRefs ids="3529">zLine</CheckRefs>[h]==&apos;\\&apos; &amp;&amp; delim==&apos;&quot;&apos; &amp;&amp; <CheckRefs ids="3530">zLine</CheckRefs>[h<CheckRefs ids="3531">+</CheckRefs>1]!=0 ) h<CheckRefs ids="3532">++</CheckRefs>;</Line>
  <Line number="18382">        h<CheckRefs ids="3533">++</CheckRefs>;</Line>
  <Line number="18383">      }</Line>
  <Line number="18384">      if( <CheckRefs ids="3534">zLine</CheckRefs>[h]==delim ){</Line>
  <Line number="18385">        zLine[h<CheckRefs ids="3535">++</CheckRefs>] = <CheckRefs ids="3536">0</CheckRefs>;</Line>
  <Line number="18386">      }</Line>
  <Line number="18387">      if( delim==&apos;&quot;&apos; ) resolve_backslashes(azArg[nArg<CheckRefs ids="3538">-</CheckRefs>1<CheckRefs ids="3537">]</CheckRefs>);</Line>
  <Line number="18388">    }else{</Line>
  <Line number="18389">      azArg[nArg<CheckRefs ids="3540">++</CheckRefs><CheckRefs ids="3539">]</CheckRefs> = &amp;zLine[h];</Line>
  <Line number="18390">      while( <CheckRefs ids="3541">zLine</CheckRefs>[h] &amp;&amp; !<CheckRefs ids="3545,3546,3542,3543,3544">IsSpace</CheckRefs>(zLine[h]) ){ h<CheckRefs ids="3547">++</CheckRefs>; }</Line>
  <Line number="18391">      if( zLine[h] ) zLine[h<CheckRefs ids="3548">++</CheckRefs>] = <CheckRefs ids="3549">0</CheckRefs>;</Line>
  <Line number="18392">      resolve_backslashes(azArg[nArg<CheckRefs ids="3551">-</CheckRefs>1<CheckRefs ids="3550">]</CheckRefs>);</Line>
  <Line number="18393">    }</Line>
  <Line number="18394">  }</Line>
  <Line number="18395">  azArg[nArg<CheckRefs ids="3552">]</CheckRefs> = 0;</Line>
  <Line number="18396"></Line>
  <Line number="18397">  /* Process the input line.</Line>
  <Line number="18398">  */</Line>
  <Line number="18399">  if( nArg==0 ) return 0; /* no tokens, no error */</Line>
  <Line number="18400">  n = strlen30(azArg[0<CheckRefs ids="3553">]</CheckRefs>);</Line>
  <Line number="18401">  c = <CheckRefs ids="3554">azArg</CheckRefs>[0<CheckRefs ids="3555">]</CheckRefs>[0];</Line>
  <Line number="18402">  clearTempFile(p);</Line>
  <Line number="18403"></Line>
  <Line number="18404">#ifndef SQLITE_OMIT_AUTHORIZATION</Line>
  <Line number="18405">  if( c==&apos;a&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3556">]</CheckRefs>, &quot;auth&quot;, <CheckRefs ids="3557">n</CheckRefs>)==0 ){</Line>
  <Line number="18406">    if( nArg!=2 ){</Line>
  <Line number="18407">      raw_printf(stderr, &quot;Usage: .auth ON|OFF\n&quot;);</Line>
  <Line number="18408">      rc = 1;</Line>
  <Line number="18409">      goto meta_command_exit;</Line>
  <Line number="18410">    }</Line>
  <Line number="18411">    open_db(p, 0);</Line>
  <Line number="18412">    if( booleanValue(azArg[1<CheckRefs ids="3558">]</CheckRefs>) ){</Line>
  <Line number="18413">      sqlite3_set_authorizer(p-&gt;db, shellAuth, p);</Line>
  <Line number="18414">    }else{</Line>
  <Line number="18415">      sqlite3_set_authorizer(p-&gt;db, 0, 0);</Line>
  <Line number="18416">    }</Line>
  <Line number="18417">  }else</Line>
  <Line number="18418">#endif</Line>
  <Line number="18419"></Line>
  <Line number="18420">#if !defined(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; defined(SQLITE_HAVE_ZLIB)</Line>
  <Line number="18421">  if( c==&apos;a&apos; &amp;&amp; strncmp(azArg[0], &quot;archive&quot;, n)==0 ){</Line>
  <Line number="18422">    open_db(p, 0);</Line>
  <Line number="18423">    rc = arDotCommand(p, 0, azArg, nArg);</Line>
  <Line number="18424">  }else</Line>
  <Line number="18425">#endif</Line>
  <Line number="18426"></Line>
  <Line number="18427">  if( (c==&apos;b&apos; &amp;&amp; n&gt;=3 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3559">]</CheckRefs>, &quot;backup&quot;, <CheckRefs ids="3560">n</CheckRefs>)==0)</Line>
  <Line number="18428">   || (c==&apos;s&apos; &amp;&amp; n&gt;=3 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3561">]</CheckRefs>, &quot;save&quot;, <CheckRefs ids="3562">n</CheckRefs>)==0)</Line>
  <Line number="18429">  ){</Line>
  <Line number="18430">    const char *zDestFile = 0;</Line>
  <Line number="18431">    const char *zDb = 0;</Line>
  <Line number="18432">    sqlite3 *pDest;</Line>
  <Line number="18433">    sqlite3_backup *pBackup;</Line>
  <Line number="18434">    int j;</Line>
  <Line number="18435">    int bAsync = 0;</Line>
  <Line number="18436">    const char *zVfs = 0;</Line>
  <Line number="18437">    for(j=1; j&lt;nArg; j<CheckRefs ids="3563">++</CheckRefs>){</Line>
  <Line number="18438">      const char *z = azArg[j<CheckRefs ids="3564">]</CheckRefs>;</Line>
  <Line number="18439">      if( <CheckRefs ids="3565">z</CheckRefs>[0]==&apos;-&apos; ){</Line>
  <Line number="18440">        if( <CheckRefs ids="3566">z</CheckRefs>[1]==&apos;-&apos; ) z++;</Line>
  <Line number="18441">        if( strcmp(z, &quot;-append&quot;)==0 ){</Line>
  <Line number="18442">          zVfs = &quot;apndvfs&quot;;</Line>
  <Line number="18443">        }else</Line>
  <Line number="18444">        if( strcmp(z, &quot;-async&quot;)==0 ){</Line>
  <Line number="18445">          bAsync = 1;</Line>
  <Line number="18446">        }else</Line>
  <Line number="18447">        {</Line>
  <Line number="18448">          utf8_printf(stderr, &quot;unknown option: %s\n&quot;, azArg[j<CheckRefs ids="3567">]</CheckRefs>);</Line>
  <Line number="18449">          return 1;</Line>
  <Line number="18450">        }</Line>
  <Line number="18451">      }else if( zDestFile==0 ){</Line>
  <Line number="18452">        zDestFile = azArg[j<CheckRefs ids="3568">]</CheckRefs>;</Line>
  <Line number="18453">      }else if( zDb==0 ){</Line>
  <Line number="18454">        zDb = zDestFile;</Line>
  <Line number="18455">        zDestFile = azArg[j<CheckRefs ids="3569">]</CheckRefs>;</Line>
  <Line number="18456">      }else{</Line>
  <Line number="18457">        raw_printf(stderr, &quot;Usage: .backup ?DB? ?OPTIONS? FILENAME\n&quot;);</Line>
  <Line number="18458">        return 1;</Line>
  <Line number="18459">      }</Line>
  <Line number="18460">    }</Line>
  <Line number="18461">    if( zDestFile==0 ){</Line>
  <Line number="18462">      raw_printf(stderr, &quot;missing FILENAME argument on .backup\n&quot;);</Line>
  <Line number="18463">      return 1;</Line>
  <Line number="18464">    }</Line>
  <Line number="18465">    if( zDb==0 ) zDb = &quot;main&quot;;</Line>
  <Line number="18466">    rc = sqlite3_open_v2(zDestFile, &amp;pDest, </Line>
  <Line number="18467">                  SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE, zVfs);</Line>
  <Line number="18468">    if( rc!=SQLITE_OK ){</Line>
  <Line number="18469">      utf8_printf(stderr, &quot;Error: cannot open \&quot;%s\&quot;\n&quot;, zDestFile);</Line>
  <Line number="18470">      close_db(pDest);</Line>
  <Line number="18471">      return 1;</Line>
  <Line number="18472">    }</Line>
  <Line number="18473">    if( bAsync ){</Line>
  <Line number="18474">      sqlite3_exec(pDest, &quot;PRAGMA synchronous=OFF; PRAGMA journal_mode=OFF;&quot;,</Line>
  <Line number="18475">                   0, 0, 0);</Line>
  <Line number="18476">    }</Line>
  <Line number="18477">    open_db(p, 0);</Line>
  <Line number="18478">    pBackup = sqlite3_backup_init(pDest, &quot;main&quot;, p-&gt;db, zDb);</Line>
  <Line number="18479">    if( pBackup==0 ){</Line>
  <Line number="18480">      utf8_printf(stderr, &quot;Error: %s\n&quot;, sqlite3_errmsg(pDest));</Line>
  <Line number="18481">      close_db(pDest);</Line>
  <Line number="18482">      return 1;</Line>
  <Line number="18483">    }</Line>
  <Line number="18484">    while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ){}</Line>
  <Line number="18485">    sqlite3_backup_finish(pBackup);</Line>
  <Line number="18486">    if( rc==SQLITE_DONE ){</Line>
  <Line number="18487">      rc = 0;</Line>
  <Line number="18488">    }else{</Line>
  <Line number="18489">      utf8_printf(stderr, &quot;Error: %s\n&quot;, sqlite3_errmsg(pDest));</Line>
  <Line number="18490">      rc = 1;</Line>
  <Line number="18491">    }</Line>
  <Line number="18492">    close_db(pDest);</Line>
  <Line number="18493">  }else</Line>
  <Line number="18494"></Line>
  <Line number="18495">  if( c==&apos;b&apos; &amp;&amp; n&gt;=3 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3570">]</CheckRefs>, &quot;bail&quot;, <CheckRefs ids="3571">n</CheckRefs>)==0 ){</Line>
  <Line number="18496">    if( nArg==2 ){</Line>
  <Line number="18497">      bail_on_error = booleanValue(azArg[1<CheckRefs ids="3572">]</CheckRefs>);</Line>
  <Line number="18498">    }else{</Line>
  <Line number="18499">      raw_printf(stderr, &quot;Usage: .bail on|off\n&quot;);</Line>
  <Line number="18500">      rc = 1;</Line>
  <Line number="18501">    }</Line>
  <Line number="18502">  }else</Line>
  <Line number="18503"></Line>
  <Line number="18504">  if( c==&apos;b&apos; &amp;&amp; n&gt;=3 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3573">]</CheckRefs>, &quot;binary&quot;, <CheckRefs ids="3574">n</CheckRefs>)==0 ){</Line>
  <Line number="18505">    if( nArg==2 ){</Line>
  <Line number="18506">      if( booleanValue(azArg[1<CheckRefs ids="3575">]</CheckRefs>) ){</Line>
  <Line number="18507">        setBinaryMode(p-&gt;out, 1);</Line>
  <Line number="18508">      }else{</Line>
  <Line number="18509">        setTextMode(p-&gt;out, 1);</Line>
  <Line number="18510">      }</Line>
  <Line number="18511">    }else{</Line>
  <Line number="18512">      raw_printf(stderr, &quot;Usage: .binary on|off\n&quot;);</Line>
  <Line number="18513">      rc = 1;</Line>
  <Line number="18514">    }</Line>
  <Line number="18515">  }else</Line>
  <Line number="18516"></Line>
  <Line number="18517">  if( c==&apos;c&apos; &amp;&amp; strcmp(azArg[0<CheckRefs ids="3576">]</CheckRefs>,&quot;cd&quot;)==0 ){</Line>
  <Line number="18518">    if( nArg==2 ){</Line>
  <Line number="18519">#if defined(_WIN32) || defined(WIN32)</Line>
  <Line number="18520">      wchar_t *z = sqlite3_win32_utf8_to_unicode(azArg[1]);</Line>
  <Line number="18521">      rc = !SetCurrentDirectoryW(z);</Line>
  <Line number="18522">      sqlite3_free(z);</Line>
  <Line number="18523">#else</Line>
  <Line number="18524">      rc = chdir(azArg[1<CheckRefs ids="3577">]</CheckRefs>);</Line>
  <Line number="18525">#endif</Line>
  <Line number="18526">      if( rc ){</Line>
  <Line number="18527">        utf8_printf(stderr, &quot;Cannot change to directory \&quot;%s\&quot;\n&quot;, azArg[1<CheckRefs ids="3578">]</CheckRefs>);</Line>
  <Line number="18528">        rc = 1;</Line>
  <Line number="18529">      }</Line>
  <Line number="18530">    }else{</Line>
  <Line number="18531">      raw_printf(stderr, &quot;Usage: .cd DIRECTORY\n&quot;);</Line>
  <Line number="18532">      rc = 1;</Line>
  <Line number="18533">    }</Line>
  <Line number="18534">  }else</Line>
  <Line number="18535"></Line>
  <Line number="18536">  /* The undocumented &quot;.breakpoint&quot; command causes a call to the no-op</Line>
  <Line number="18537">  ** routine named test_breakpoint().</Line>
  <Line number="18538">  */</Line>
  <Line number="18539">  if( c==&apos;b&apos; &amp;&amp; n&gt;=3 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3579">]</CheckRefs>, &quot;breakpoint&quot;, <CheckRefs ids="3580">n</CheckRefs>)==0 ){</Line>
  <Line number="18540">    test_breakpoint();</Line>
  <Line number="18541">  }else</Line>
  <Line number="18542"></Line>
  <Line number="18543">  if( c==&apos;c&apos; &amp;&amp; n&gt;=3 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3581">]</CheckRefs>, &quot;changes&quot;, <CheckRefs ids="3582">n</CheckRefs>)==0 ){</Line>
  <Line number="18544">    if( nArg==2 ){</Line>
  <Line number="18545">      setOrClearFlag(p, <CheckRefs ids="3583">SHFLG_CountChanges</CheckRefs>, azArg[1<CheckRefs ids="3584">]</CheckRefs>);</Line>
  <Line number="18546">    }else{</Line>
  <Line number="18547">      raw_printf(stderr, &quot;Usage: .changes on|off\n&quot;);</Line>
  <Line number="18548">      rc = 1;</Line>
  <Line number="18549">    }</Line>
  <Line number="18550">  }else</Line>
  <Line number="18551"></Line>
  <Line number="18552">  /* Cancel output redirection, if it is currently set (by .testcase)</Line>
  <Line number="18553">  ** Then read the content of the testcase-out.txt file and compare against</Line>
  <Line number="18554">  ** azArg[1].  If there are differences, report an error and exit.</Line>
  <Line number="18555">  */</Line>
  <Line number="18556">  if( c==&apos;c&apos; &amp;&amp; n&gt;=3 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3585">]</CheckRefs>, &quot;check&quot;, <CheckRefs ids="3586">n</CheckRefs>)==0 ){</Line>
  <Line number="18557">    char *zRes = 0;</Line>
  <Line number="18558">    output_reset(p);</Line>
  <Line number="18559">    if( nArg!=2 ){</Line>
  <Line number="18560">      raw_printf(stderr, &quot;Usage: .check GLOB-PATTERN\n&quot;);</Line>
  <Line number="18561">      rc = 2;</Line>
  <Line number="18562">    }else if( (zRes = readFile(&quot;testcase-out.txt&quot;, 0))==0 ){</Line>
  <Line number="18563">      raw_printf(stderr, &quot;Error: cannot read &apos;testcase-out.txt&apos;\n&quot;);</Line>
  <Line number="18564">      rc = 2;</Line>
  <Line number="18565">    }else if( testcase_glob(azArg[1<CheckRefs ids="3587">]</CheckRefs>,zRes)==0 ){</Line>
  <Line number="18566">      utf8_printf(stderr,</Line>
  <Line number="18567">                 &quot;testcase-%s FAILED\n Expected: [%s]\n      Got: [%s]\n&quot;,</Line>
  <Line number="18568">                 p-&gt;zTestcase, azArg[1<CheckRefs ids="3588">]</CheckRefs>, zRes);</Line>
  <Line number="18569">      rc = 1;</Line>
  <Line number="18570">    }else{</Line>
  <Line number="18571">      utf8_printf(stdout, &quot;testcase-%s ok\n&quot;, p-&gt;zTestcase);</Line>
  <Line number="18572">      p-&gt;nCheck<CheckRefs ids="3589">++</CheckRefs>;</Line>
  <Line number="18573">    }</Line>
  <Line number="18574">    sqlite3_free(zRes);</Line>
  <Line number="18575">  }else</Line>
  <Line number="18576"></Line>
  <Line number="18577">  if( c==&apos;c&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3590">]</CheckRefs>, &quot;clone&quot;, <CheckRefs ids="3591">n</CheckRefs>)==0 ){</Line>
  <Line number="18578">    if( nArg==2 ){</Line>
  <Line number="18579">      tryToClone(p, azArg[1<CheckRefs ids="3592">]</CheckRefs>);</Line>
  <Line number="18580">    }else{</Line>
  <Line number="18581">      raw_printf(stderr, &quot;Usage: .clone FILENAME\n&quot;);</Line>
  <Line number="18582">      rc = 1;</Line>
  <Line number="18583">    }</Line>
  <Line number="18584">  }else</Line>
  <Line number="18585"></Line>
  <Line number="18586">  if( c==&apos;d&apos; &amp;&amp; n&gt;1 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3593">]</CheckRefs>, &quot;databases&quot;, <CheckRefs ids="3594">n</CheckRefs>)==0 ){</Line>
  <Line number="18587">    char **azName = 0;</Line>
  <Line number="18588">    int nName = 0;</Line>
  <Line number="18589">    sqlite3_stmt *pStmt;</Line>
  <Line number="18590">    int i;</Line>
  <Line number="18591">    open_db(p, 0);</Line>
  <Line number="18592">    rc = sqlite3_prepare_v2(p-&gt;db, &quot;PRAGMA database_list&quot;, <CheckRefs ids="3595">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="18593">    if( rc ){</Line>
  <Line number="18594">      utf8_printf(stderr, &quot;Error: %s\n&quot;, sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="18595">      rc = 1;</Line>
  <Line number="18596">    }else{</Line>
  <Line number="18597">      while( sqlite3_step(pStmt)==SQLITE_ROW ){</Line>
  <Line number="18598">        const char *zSchema = (const char *)sqlite3_column_text(pStmt,1);</Line>
  <Line number="18599">        const char *zFile = (const char*)sqlite3_column_text(pStmt,2);</Line>
  <Line number="18600">        azName = sqlite3_realloc(azName, (nName<CheckRefs ids="3600">+</CheckRefs>1)<CheckRefs ids="3598,3599">*</CheckRefs>2<CheckRefs ids="3596,3597">*</CheckRefs>sizeof(char*));</Line>
  <Line number="18601">        if( azName==0 ){ shell_out_of_memory();  /* Does not return */ }</Line>
  <Line number="18602">        azName[nName<CheckRefs ids="3601">*</CheckRefs>2] = strdup(zSchema);</Line>
  <Line number="18603">        azName[nName<CheckRefs ids="3603">*</CheckRefs>2<CheckRefs ids="3602">+</CheckRefs>1] = strdup(zFile);</Line>
  <Line number="18604">        nName<CheckRefs ids="3604">++</CheckRefs>;</Line>
  <Line number="18605">      }</Line>
  <Line number="18606">    }</Line>
  <Line number="18607">    sqlite3_finalize(pStmt);</Line>
  <Line number="18608">    for(i=0; i&lt;nName; i<CheckRefs ids="3605">++</CheckRefs>){</Line>
  <Line number="18609">      int eTxn = sqlite3_txn_state(p-&gt;db, azName[i<CheckRefs ids="3606">*</CheckRefs>2]);</Line>
  <Line number="18610">      int bRdonly = sqlite3_db_readonly(p-&gt;db, azName[i<CheckRefs ids="3607">*</CheckRefs>2]);</Line>
  <Line number="18611">      const char *z = azName[i<CheckRefs ids="3609">*</CheckRefs>2<CheckRefs ids="3608">+</CheckRefs>1];</Line>
  <Line number="18612">      utf8_printf(p-&gt;out, &quot;%s: %s %s%s\n&quot;,</Line>
  <Line number="18613">         azName[i<CheckRefs ids="3610">*</CheckRefs>2],</Line>
  <Line number="18614">         z &amp;&amp; <CheckRefs ids="3611">z</CheckRefs>[0] ? z : &quot;\&quot;\&quot;&quot;,</Line>
  <Line number="18615">         bRdonly ? &quot;r/o&quot; : &quot;r/w&quot;,</Line>
  <Line number="18616">         eTxn==SQLITE_TXN_NONE ? &quot;&quot; :</Line>
  <Line number="18617">            eTxn==SQLITE_TXN_READ ? &quot; read-txn&quot; : &quot; write-txn&quot;);</Line>
  <Line number="18618">      free(azName[i<CheckRefs ids="3612">*</CheckRefs>2]);</Line>
  <Line number="18619">      free(azName[i<CheckRefs ids="3614">*</CheckRefs>2<CheckRefs ids="3613">+</CheckRefs>1]);</Line>
  <Line number="18620">    }</Line>
  <Line number="18621">    sqlite3_free(azName);</Line>
  <Line number="18622">  }else</Line>
  <Line number="18623"></Line>
  <Line number="18624">  if( c==&apos;d&apos; &amp;&amp; n&gt;=3 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3615">]</CheckRefs>, &quot;dbconfig&quot;, <CheckRefs ids="3616">n</CheckRefs>)==0 ){</Line>
  <Line number="18625">    static const struct DbConfigChoices {</Line>
  <Line number="18626">      const char *zName;</Line>
  <Line number="18627">      int op;</Line>
  <Line number="18628">    } aDbConfig[] = {</Line>
  <Line number="18629">        { &quot;defensive&quot;,          SQLITE_DBCONFIG_DEFENSIVE             },</Line>
  <Line number="18630">        { &quot;dqs_ddl&quot;,            SQLITE_DBCONFIG_DQS_DDL               },</Line>
  <Line number="18631">        { &quot;dqs_dml&quot;,            SQLITE_DBCONFIG_DQS_DML               },</Line>
  <Line number="18632">        { &quot;enable_fkey&quot;,        SQLITE_DBCONFIG_ENABLE_FKEY           },</Line>
  <Line number="18633">        { &quot;enable_qpsg&quot;,        SQLITE_DBCONFIG_ENABLE_QPSG           },</Line>
  <Line number="18634">        { &quot;enable_trigger&quot;,     SQLITE_DBCONFIG_ENABLE_TRIGGER        },</Line>
  <Line number="18635">        { &quot;enable_view&quot;,        SQLITE_DBCONFIG_ENABLE_VIEW           },</Line>
  <Line number="18636">        { &quot;fts3_tokenizer&quot;,     SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER },</Line>
  <Line number="18637">        { &quot;legacy_alter_table&quot;, SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    },</Line>
  <Line number="18638">        { &quot;legacy_file_format&quot;, SQLITE_DBCONFIG_LEGACY_FILE_FORMAT    },</Line>
  <Line number="18639">        { &quot;load_extension&quot;,     SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION },</Line>
  <Line number="18640">        { &quot;no_ckpt_on_close&quot;,   SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      },</Line>
  <Line number="18641">        { &quot;reset_database&quot;,     SQLITE_DBCONFIG_RESET_DATABASE        },</Line>
  <Line number="18642">        { &quot;trigger_eqp&quot;,        SQLITE_DBCONFIG_TRIGGER_EQP           },</Line>
  <Line number="18643">        { &quot;trusted_schema&quot;,     SQLITE_DBCONFIG_TRUSTED_SCHEMA        },</Line>
  <Line number="18644">        { &quot;writable_schema&quot;,    SQLITE_DBCONFIG_WRITABLE_SCHEMA       },</Line>
  <Line number="18645">    };</Line>
  <Line number="18646">    int ii, v;</Line>
  <Line number="18647">    open_db(p, 0);</Line>
  <Line number="18648">    for(ii=0; ii&lt;<CheckRefs ids="3617,3618,3619">ArraySize</CheckRefs>(aDbConfig); ii<CheckRefs ids="3620">++</CheckRefs>){</Line>
  <Line number="18649">      if( nArg&gt;1 &amp;&amp; strcmp(azArg[1<CheckRefs ids="3621">]</CheckRefs>, aDbConfig[ii<CheckRefs ids="3622">]</CheckRefs>.zName)!=0 ) continue;</Line>
  <Line number="18650">      if( nArg&gt;=3 ){</Line>
  <Line number="18651">        sqlite3_db_config(p-&gt;db, aDbConfig[ii<CheckRefs ids="3623">]</CheckRefs>.op, booleanValue(azArg[2<CheckRefs ids="3624">]</CheckRefs>), 0);</Line>
  <Line number="18652">      }</Line>
  <Line number="18653">      sqlite3_db_config(p-&gt;db, aDbConfig[ii<CheckRefs ids="3625">]</CheckRefs>.op, <CheckRefs ids="3626">-</CheckRefs>1, &amp;v);</Line>
  <Line number="18654">      utf8_printf(p-&gt;out, &quot;%19s %s\n&quot;, aDbConfig[ii<CheckRefs ids="3627">]</CheckRefs>.zName, v ? &quot;on&quot; : &quot;off&quot;);</Line>
  <Line number="18655">      if( nArg&gt;1 ) break;</Line>
  <Line number="18656">    }</Line>
  <Line number="18657">    if( nArg&gt;1 &amp;&amp; ii==<CheckRefs ids="3628,3629,3630">ArraySize</CheckRefs>(aDbConfig) ){</Line>
  <Line number="18658">      utf8_printf(stderr, &quot;Error: unknown dbconfig \&quot;%s\&quot;\n&quot;, azArg[1<CheckRefs ids="3631">]</CheckRefs>);</Line>
  <Line number="18659">      utf8_printf(stderr, &quot;Enter \&quot;.dbconfig\&quot; with no arguments for a list\n&quot;);</Line>
  <Line number="18660">    }   </Line>
  <Line number="18661">  }else</Line>
  <Line number="18662"></Line>
  <Line number="18663">  if( c==&apos;d&apos; &amp;&amp; n&gt;=3 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3632">]</CheckRefs>, &quot;dbinfo&quot;, <CheckRefs ids="3633">n</CheckRefs>)==0 ){</Line>
  <Line number="18664">    rc = shell_dbinfo_command(p, nArg, azArg);</Line>
  <Line number="18665">  }else</Line>
  <Line number="18666"></Line>
  <Line number="18667">#if !defined(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; defined(SQLITE_ENABLE_DBPAGE_VTAB)</Line>
  <Line number="18668">  if( c==&apos;r&apos; &amp;&amp; strncmp(azArg[0], &quot;recover&quot;, n)==0 ){</Line>
  <Line number="18669">    open_db(p, 0);</Line>
  <Line number="18670">    rc = recoverDatabaseCmd(p, nArg, azArg);</Line>
  <Line number="18671">  }else</Line>
  <Line number="18672">#endif /* !(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; defined(SQLITE_ENABLE_DBPAGE_VTAB) */</Line>
  <Line number="18673"></Line>
  <Line number="18674">  if( c==&apos;d&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3634">]</CheckRefs>, &quot;dump&quot;, <CheckRefs ids="3635">n</CheckRefs>)==0 ){</Line>
  <Line number="18675">    char *zLike = 0;</Line>
  <Line number="18676">    char *zSql;</Line>
  <Line number="18677">    int i;</Line>
  <Line number="18678">    int savedShowHeader = p-&gt;showHeader;</Line>
  <Line number="18679">    int savedShellFlags = <CheckRefs ids="3636">p</CheckRefs>-&gt;shellFlgs;</Line>
  <Line number="18680">    <CheckRefs ids="3637">ShellClearFlag</CheckRefs>(p, </Line>
  <Line number="18681">       SHFLG_PreserveRowid|SHFLG_Newlines|SHFLG_Echo</Line>
  <Line number="18682">       |SHFLG_DumpDataOnly|SHFLG_DumpNoSys);</Line>
  <Line number="18683">    for(i=1; i&lt;nArg; i<CheckRefs ids="3638">++</CheckRefs>){</Line>
  <Line number="18684">      if( <CheckRefs ids="3639">azArg</CheckRefs>[i<CheckRefs ids="3640">]</CheckRefs>[0]==&apos;-&apos; ){</Line>
  <Line number="18685">        const char *z = azArg[i<CheckRefs ids="3641">]</CheckRefs>+1;</Line>
  <Line number="18686">        if( <CheckRefs ids="3642">z</CheckRefs>[0]==&apos;-&apos; ) z++;</Line>
  <Line number="18687">        if( strcmp(z,&quot;preserve-rowids&quot;)==0 ){</Line>
  <Line number="18688">#ifdef SQLITE_OMIT_VIRTUALTABLE</Line>
  <Line number="18689">          raw_printf(stderr, &quot;The --preserve-rowids option is not compatible&quot;</Line>
  <Line number="18690">                             &quot; with SQLITE_OMIT_VIRTUALTABLE\n&quot;);</Line>
  <Line number="18691">          rc = 1;</Line>
  <Line number="18692">          sqlite3_free(zLike);</Line>
  <Line number="18693">          goto meta_command_exit;</Line>
  <Line number="18694">#else</Line>
  <Line number="18695">          <CheckRefs ids="3643">ShellSetFlag</CheckRefs>(p, SHFLG_PreserveRowid);</Line>
  <Line number="18696">#endif</Line>
  <Line number="18697">        }else</Line>
  <Line number="18698">        if( strcmp(z,&quot;newlines&quot;)==0 ){</Line>
  <Line number="18699">          <CheckRefs ids="3644">ShellSetFlag</CheckRefs>(p, SHFLG_Newlines);</Line>
  <Line number="18700">        }else</Line>
  <Line number="18701">        if( strcmp(z,&quot;data-only&quot;)==0 ){</Line>
  <Line number="18702">          <CheckRefs ids="3645">ShellSetFlag</CheckRefs>(p, SHFLG_DumpDataOnly);</Line>
  <Line number="18703">        }else</Line>
  <Line number="18704">        if( strcmp(z,&quot;nosys&quot;)==0 ){</Line>
  <Line number="18705">          <CheckRefs ids="3646">ShellSetFlag</CheckRefs>(p, SHFLG_DumpNoSys);</Line>
  <Line number="18706">        }else</Line>
  <Line number="18707">        {</Line>
  <Line number="18708">          raw_printf(stderr, &quot;Unknown option \&quot;%s\&quot; on \&quot;.dump\&quot;\n&quot;, azArg[i<CheckRefs ids="3647">]</CheckRefs>);</Line>
  <Line number="18709">          rc = 1;</Line>
  <Line number="18710">          sqlite3_free(zLike);</Line>
  <Line number="18711">          goto meta_command_exit;</Line>
  <Line number="18712">        }</Line>
  <Line number="18713">      }else{</Line>
  <Line number="18714">        /* azArg[i] contains a LIKE pattern. This &quot;.dump&quot; request should</Line>
  <Line number="18715">        ** only dump data for tables for which either the table name matches</Line>
  <Line number="18716">        ** the LIKE pattern, or the table appears to be a shadow table of</Line>
  <Line number="18717">        ** a virtual table for which the name matches the LIKE pattern.</Line>
  <Line number="18718">        */</Line>
  <Line number="18719">        char *zExpr = sqlite3_mprintf(</Line>
  <Line number="18720">            &quot;name LIKE %Q ESCAPE &apos;\\&apos; OR EXISTS (&quot;</Line>
  <Line number="18721">            &quot;  SELECT 1 FROM sqlite_schema WHERE &quot;</Line>
  <Line number="18722">            &quot;    name LIKE %Q ESCAPE &apos;\\&apos; AND&quot;</Line>
  <Line number="18723">            &quot;    sql LIKE &apos;CREATE VIRTUAL TABLE%%&apos; AND&quot;</Line>
  <Line number="18724">            &quot;    substr(o.name, 1, length(name)+1) == (name||&apos;_&apos;)&quot;</Line>
  <Line number="18725">            &quot;)&quot;, azArg[i<CheckRefs ids="3648">]</CheckRefs>, azArg[i<CheckRefs ids="3649">]</CheckRefs></Line>
  <Line number="18726">        );</Line>
  <Line number="18727">      </Line>
  <Line number="18728">        if( zLike ){</Line>
  <Line number="18729">          zLike = sqlite3_mprintf(&quot;%z OR %z&quot;, zLike, zExpr);</Line>
  <Line number="18730">        }else{</Line>
  <Line number="18731">          zLike = zExpr;</Line>
  <Line number="18732">        }</Line>
  <Line number="18733">      }</Line>
  <Line number="18734">    }</Line>
  <Line number="18735"></Line>
  <Line number="18736">    open_db(p, 0);</Line>
  <Line number="18737"></Line>
  <Line number="18738">    if( (p-&gt;shellFlgs &amp; <CheckRefs ids="3650">SHFLG_DumpDataOnly</CheckRefs>)==<CheckRefs ids="3651">0</CheckRefs> ){</Line>
  <Line number="18739">      /* When playing back a &quot;dump&quot;, the content might appear in an order</Line>
  <Line number="18740">      ** which causes immediate foreign key constraints to be violated.</Line>
  <Line number="18741">      ** So disable foreign-key constraint enforcement to prevent problems. */</Line>
  <Line number="18742">      raw_printf(p-&gt;out, &quot;PRAGMA foreign_keys=OFF;\n&quot;);</Line>
  <Line number="18743">      raw_printf(p-&gt;out, &quot;BEGIN TRANSACTION;\n&quot;);</Line>
  <Line number="18744">    }</Line>
  <Line number="18745">    p-&gt;writableSchema = 0;</Line>
  <Line number="18746">    p-&gt;showHeader = 0;</Line>
  <Line number="18747">    /* Set writable_schema=ON since doing so forces SQLite to initialize</Line>
  <Line number="18748">    ** as much of the schema as it can even if the sqlite_schema table is</Line>
  <Line number="18749">    ** corrupt. */</Line>
  <Line number="18750">    sqlite3_exec(p-&gt;db, &quot;SAVEPOINT dump; PRAGMA writable_schema=ON&quot;, 0, 0, 0);</Line>
  <Line number="18751">    p-&gt;nErr = 0;</Line>
  <Line number="18752">    if( zLike==0 ) zLike = sqlite3_mprintf(&quot;true&quot;);</Line>
  <Line number="18753">    zSql = sqlite3_mprintf(</Line>
  <Line number="18754">      &quot;SELECT name, type, sql FROM sqlite_schema AS o &quot;</Line>
  <Line number="18755">      &quot;WHERE (%s) AND type==&apos;table&apos;&quot;</Line>
  <Line number="18756">      &quot;  AND sql NOT NULL&quot;</Line>
  <Line number="18757">      &quot; ORDER BY tbl_name=&apos;sqlite_sequence&apos;, rowid&quot;,</Line>
  <Line number="18758">      zLike</Line>
  <Line number="18759">    );</Line>
  <Line number="18760">    run_schema_dump_query(p,zSql);</Line>
  <Line number="18761">    sqlite3_free(zSql);</Line>
  <Line number="18762">    if( (p-&gt;shellFlgs &amp; <CheckRefs ids="3652">SHFLG_DumpDataOnly</CheckRefs>)==<CheckRefs ids="3653">0</CheckRefs> ){</Line>
  <Line number="18763">      zSql = sqlite3_mprintf(</Line>
  <Line number="18764">        &quot;SELECT sql FROM sqlite_schema AS o &quot;</Line>
  <Line number="18765">        &quot;WHERE (%s) AND sql NOT NULL&quot;</Line>
  <Line number="18766">        &quot;  AND type IN (&apos;index&apos;,&apos;trigger&apos;,&apos;view&apos;)&quot;,</Line>
  <Line number="18767">        zLike</Line>
  <Line number="18768">      );</Line>
  <Line number="18769">      run_table_dump_query(p, zSql);</Line>
  <Line number="18770">      sqlite3_free(zSql);</Line>
  <Line number="18771">    }</Line>
  <Line number="18772">    sqlite3_free(zLike);</Line>
  <Line number="18773">    if( p-&gt;writableSchema ){</Line>
  <Line number="18774">      raw_printf(p-&gt;out, &quot;PRAGMA writable_schema=OFF;\n&quot;);</Line>
  <Line number="18775">      p-&gt;writableSchema = 0;</Line>
  <Line number="18776">    }</Line>
  <Line number="18777">    sqlite3_exec(p-&gt;db, &quot;PRAGMA writable_schema=OFF;&quot;, 0, 0, 0);</Line>
  <Line number="18778">    sqlite3_exec(p-&gt;db, &quot;RELEASE dump;&quot;, 0, 0, 0);</Line>
  <Line number="18779">    if( (p-&gt;shellFlgs &amp; <CheckRefs ids="3654">SHFLG_DumpDataOnly</CheckRefs>)==<CheckRefs ids="3655">0</CheckRefs> ){</Line>
  <Line number="18780">      raw_printf(p-&gt;out, p-&gt;nErr?&quot;ROLLBACK; -- due to errors\n&quot;:&quot;COMMIT;\n&quot;);</Line>
  <Line number="18781">    }</Line>
  <Line number="18782">    p-&gt;showHeader = savedShowHeader;</Line>
  <Line number="18783">    p-&gt;shellFlgs = <CheckRefs ids="3656">savedShellFlags</CheckRefs>;</Line>
  <Line number="18784">  }else</Line>
  <Line number="18785"></Line>
  <Line number="18786">  if( c==&apos;e&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3657">]</CheckRefs>, &quot;echo&quot;, <CheckRefs ids="3658">n</CheckRefs>)==0 ){</Line>
  <Line number="18787">    if( nArg==2 ){</Line>
  <Line number="18788">      setOrClearFlag(p, <CheckRefs ids="3659">SHFLG_Echo</CheckRefs>, azArg[1<CheckRefs ids="3660">]</CheckRefs>);</Line>
  <Line number="18789">    }else{</Line>
  <Line number="18790">      raw_printf(stderr, &quot;Usage: .echo on|off\n&quot;);</Line>
  <Line number="18791">      rc = 1;</Line>
  <Line number="18792">    }</Line>
  <Line number="18793">  }else</Line>
  <Line number="18794"></Line>
  <Line number="18795">  if( c==&apos;e&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3661">]</CheckRefs>, &quot;eqp&quot;, <CheckRefs ids="3662">n</CheckRefs>)==0 ){</Line>
  <Line number="18796">    if( nArg==2 ){</Line>
  <Line number="18797">      p-&gt;autoEQPtest = <CheckRefs ids="3663">0</CheckRefs>;</Line>
  <Line number="18798">      if( p-&gt;autoEQPtrace ){</Line>
  <Line number="18799">        if( p-&gt;db ) sqlite3_exec(p-&gt;db, &quot;PRAGMA vdbe_trace=OFF;&quot;, 0, 0, 0);</Line>
  <Line number="18800">        p-&gt;autoEQPtrace = <CheckRefs ids="3664">0</CheckRefs>;</Line>
  <Line number="18801">      }</Line>
  <Line number="18802">      if( strcmp(azArg[1<CheckRefs ids="3665">]</CheckRefs>,&quot;full&quot;)==0 ){</Line>
  <Line number="18803">        p-&gt;autoEQP = <CheckRefs ids="3666">AUTOEQP_full</CheckRefs>;</Line>
  <Line number="18804">      }else if( strcmp(azArg[1<CheckRefs ids="3667">]</CheckRefs>,&quot;trigger&quot;)==0 ){</Line>
  <Line number="18805">        p-&gt;autoEQP = <CheckRefs ids="3668">AUTOEQP_trigger</CheckRefs>;</Line>
  <Line number="18806">#ifdef SQLITE_DEBUG</Line>
  <Line number="18807">      }else if( strcmp(azArg[1],&quot;test&quot;)==0 ){</Line>
  <Line number="18808">        p-&gt;autoEQP = AUTOEQP_on;</Line>
  <Line number="18809">        p-&gt;autoEQPtest = 1;</Line>
  <Line number="18810">      }else if( strcmp(azArg[1],&quot;trace&quot;)==0 ){</Line>
  <Line number="18811">        p-&gt;autoEQP = AUTOEQP_full;</Line>
  <Line number="18812">        p-&gt;autoEQPtrace = 1;</Line>
  <Line number="18813">        open_db(p, 0);</Line>
  <Line number="18814">        sqlite3_exec(p-&gt;db, &quot;SELECT name FROM sqlite_schema LIMIT 1&quot;, 0, 0, 0);</Line>
  <Line number="18815">        sqlite3_exec(p-&gt;db, &quot;PRAGMA vdbe_trace=ON;&quot;, 0, 0, 0);</Line>
  <Line number="18816">#endif</Line>
  <Line number="18817">      }else{</Line>
  <Line number="18818">        p-&gt;autoEQP = <CheckRefs ids="3669">(</CheckRefs>u8)booleanValue(azArg[1<CheckRefs ids="3670">]</CheckRefs>);</Line>
  <Line number="18819">      }</Line>
  <Line number="18820">    }else{</Line>
  <Line number="18821">      raw_printf(stderr, &quot;Usage: .eqp off|on|trace|trigger|full\n&quot;);</Line>
  <Line number="18822">      rc = 1;</Line>
  <Line number="18823">    }</Line>
  <Line number="18824">  }else</Line>
  <Line number="18825"></Line>
  <Line number="18826">  if( c==&apos;e&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3671">]</CheckRefs>, &quot;exit&quot;, <CheckRefs ids="3672">n</CheckRefs>)==0 ){</Line>
  <Line number="18827">    if( nArg&gt;1 &amp;&amp; (rc = <CheckRefs ids="3673">(</CheckRefs>int)integerValue(azArg[1<CheckRefs ids="3674">]</CheckRefs>))!=0 ) exit(rc);</Line>
  <Line number="18828">    rc = 2;</Line>
  <Line number="18829">  }else</Line>
  <Line number="18830"></Line>
  <Line number="18831">  /* The &quot;.explain&quot; command is automatic now.  It is largely pointless.  It</Line>
  <Line number="18832">  ** retained purely for backwards compatibility */</Line>
  <Line number="18833">  if( c==&apos;e&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3675">]</CheckRefs>, &quot;explain&quot;, <CheckRefs ids="3676">n</CheckRefs>)==0 ){</Line>
  <Line number="18834">    int val = 1;</Line>
  <Line number="18835">    if( nArg&gt;=2 ){</Line>
  <Line number="18836">      if( strcmp(azArg[1<CheckRefs ids="3677">]</CheckRefs>,&quot;auto&quot;)==0 ){</Line>
  <Line number="18837">        val = 99;</Line>
  <Line number="18838">      }else{</Line>
  <Line number="18839">        val =  booleanValue(azArg[1<CheckRefs ids="3678">]</CheckRefs>);</Line>
  <Line number="18840">      }</Line>
  <Line number="18841">    }</Line>
  <Line number="18842">    if( val==1 &amp;&amp; p-&gt;mode!=MODE_Explain ){</Line>
  <Line number="18843">      p-&gt;normalMode = p-&gt;mode;</Line>
  <Line number="18844">      p-&gt;mode = MODE_Explain;</Line>
  <Line number="18845">      p-&gt;autoExplain = <CheckRefs ids="3679">0</CheckRefs>;</Line>
  <Line number="18846">    }else if( val==0 ){</Line>
  <Line number="18847">      if( p-&gt;mode==MODE_Explain ) p-&gt;mode = p-&gt;normalMode;</Line>
  <Line number="18848">      p-&gt;autoExplain = <CheckRefs ids="3680">0</CheckRefs>;</Line>
  <Line number="18849">    }else if( val==99 ){</Line>
  <Line number="18850">      if( p-&gt;mode==MODE_Explain ) p-&gt;mode = p-&gt;normalMode;</Line>
  <Line number="18851">      p-&gt;autoExplain = <CheckRefs ids="3681">1</CheckRefs>;</Line>
  <Line number="18852">    }</Line>
  <Line number="18853">  }else</Line>
  <Line number="18854"></Line>
  <Line number="18855">#ifndef SQLITE_OMIT_VIRTUALTABLE</Line>
  <Line number="18856">  if( c==&apos;e&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3682">]</CheckRefs>, &quot;expert&quot;, <CheckRefs ids="3683">n</CheckRefs>)==0 ){</Line>
  <Line number="18857">    open_db(p, 0);</Line>
  <Line number="18858">    expertDotCommand(p, azArg, nArg);</Line>
  <Line number="18859">  }else</Line>
  <Line number="18860">#endif</Line>
  <Line number="18861"></Line>
  <Line number="18862">  if( c==&apos;f&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3684">]</CheckRefs>, &quot;filectrl&quot;, <CheckRefs ids="3685">n</CheckRefs>)==0 ){</Line>
  <Line number="18863">    static const struct {</Line>
  <Line number="18864">       const char *zCtrlName;   /* Name of a test-control option */</Line>
  <Line number="18865">       int ctrlCode;            /* Integer code for that option */</Line>
  <Line number="18866">       const char *zUsage;      /* Usage notes */</Line>
  <Line number="18867">    } aCtrl[] = {</Line>
  <Line number="18868">      { &quot;chunk_size&quot;,     SQLITE_FCNTL_CHUNK_SIZE,      &quot;SIZE&quot;           },</Line>
  <Line number="18869">      { &quot;data_version&quot;,   SQLITE_FCNTL_DATA_VERSION,    &quot;&quot;               },</Line>
  <Line number="18870">      { &quot;has_moved&quot;,      SQLITE_FCNTL_HAS_MOVED,       &quot;&quot;               },  </Line>
  <Line number="18871">      { &quot;lock_timeout&quot;,   SQLITE_FCNTL_LOCK_TIMEOUT,    &quot;MILLISEC&quot;       },</Line>
  <Line number="18872">      { &quot;persist_wal&quot;,    SQLITE_FCNTL_PERSIST_WAL,     &quot;[BOOLEAN]&quot;      },</Line>
  <Line number="18873">   /* { &quot;pragma&quot;,         SQLITE_FCNTL_PRAGMA,          &quot;NAME ARG&quot;       },*/</Line>
  <Line number="18874">      { &quot;psow&quot;,       SQLITE_FCNTL_POWERSAFE_OVERWRITE, &quot;[BOOLEAN]&quot;      },</Line>
  <Line number="18875">      { &quot;reserve_bytes&quot;,  SQLITE_FCNTL_RESERVE_BYTES,   &quot;[N]&quot;            },</Line>
  <Line number="18876">      { &quot;size_limit&quot;,     SQLITE_FCNTL_SIZE_LIMIT,      &quot;[LIMIT]&quot;        },</Line>
  <Line number="18877">      { &quot;tempfilename&quot;,   SQLITE_FCNTL_TEMPFILENAME,    &quot;&quot;               },</Line>
  <Line number="18878">   /* { &quot;win32_av_retry&quot;, SQLITE_FCNTL_WIN32_AV_RETRY,  &quot;COUNT DELAY&quot;    },*/</Line>
  <Line number="18879">    };</Line>
  <Line number="18880">    int filectrl = <CheckRefs ids="3686">-</CheckRefs>1;</Line>
  <Line number="18881">    int iCtrl = <CheckRefs ids="3687">-</CheckRefs>1;</Line>
  <Line number="18882">    sqlite3_int64 iRes = <CheckRefs ids="3688">0</CheckRefs>;  /* Integer result to display if rc2==1 */</Line>
  <Line number="18883">    int isOk = 0;            /* 0: usage  1: %lld  2: no-result */</Line>
  <Line number="18884">    int n2, i;</Line>
  <Line number="18885">    const char *zCmd = 0;</Line>
  <Line number="18886">    const char *zSchema = 0;</Line>
  <Line number="18887"></Line>
  <Line number="18888">    open_db(p, 0);</Line>
  <Line number="18889">    zCmd = nArg&gt;=2 ? azArg[1<CheckRefs ids="3689">]</CheckRefs> : &quot;help&quot;;</Line>
  <Line number="18890"></Line>
  <Line number="18891">    if( <CheckRefs ids="3690">zCmd</CheckRefs>[0]==&apos;-&apos; </Line>
  <Line number="18892">     &amp;&amp; (strcmp(zCmd,&quot;--schema&quot;)==0 || strcmp(zCmd,&quot;-schema&quot;)==0)</Line>
  <Line number="18893">     &amp;&amp; nArg&gt;=4</Line>
  <Line number="18894">    ){</Line>
  <Line number="18895">      zSchema = azArg[2<CheckRefs ids="3691">]</CheckRefs>;</Line>
  <Line number="18896">      for(i=3; i&lt;nArg; i<CheckRefs ids="3692">++</CheckRefs>) azArg[i<CheckRefs ids="3694">-</CheckRefs>2<CheckRefs ids="3693">]</CheckRefs> = azArg[i<CheckRefs ids="3695">]</CheckRefs>;</Line>
  <Line number="18897">      nArg <CheckRefs ids="3696">-=</CheckRefs> 2;</Line>
  <Line number="18898">      zCmd = azArg[1<CheckRefs ids="3697">]</CheckRefs>;</Line>
  <Line number="18899">    }</Line>
  <Line number="18900"></Line>
  <Line number="18901">    /* The argument can optionally begin with &quot;-&quot; or &quot;--&quot; */</Line>
  <Line number="18902">    if( <CheckRefs ids="3698">zCmd</CheckRefs>[0]==&apos;-&apos; &amp;&amp; <CheckRefs ids="3699">zCmd</CheckRefs>[1] ){</Line>
  <Line number="18903">      zCmd++;</Line>
  <Line number="18904">      if( <CheckRefs ids="3700">zCmd</CheckRefs>[0]==&apos;-&apos; &amp;&amp; <CheckRefs ids="3701">zCmd</CheckRefs>[1] ) zCmd++;</Line>
  <Line number="18905">    }</Line>
  <Line number="18906"></Line>
  <Line number="18907">    /* --help lists all file-controls */</Line>
  <Line number="18908">    if( strcmp(zCmd,&quot;help&quot;)==0 ){</Line>
  <Line number="18909">      utf8_printf(p-&gt;out, &quot;Available file-controls:\n&quot;);</Line>
  <Line number="18910">      for(i=0; i&lt;<CheckRefs ids="3702,3703,3704">ArraySize</CheckRefs>(aCtrl); i<CheckRefs ids="3705">++</CheckRefs>){</Line>
  <Line number="18911">        utf8_printf(p-&gt;out, &quot;  .filectrl %s %s\n&quot;,</Line>
  <Line number="18912">                    aCtrl[i<CheckRefs ids="3706">]</CheckRefs>.zCtrlName, aCtrl[i<CheckRefs ids="3707">]</CheckRefs>.zUsage);</Line>
  <Line number="18913">      }</Line>
  <Line number="18914">      rc = 1;</Line>
  <Line number="18915">      goto meta_command_exit;</Line>
  <Line number="18916">    }</Line>
  <Line number="18917"></Line>
  <Line number="18918">    /* convert filectrl text option to value. allow any unique prefix</Line>
  <Line number="18919">    ** of the option name, or a numerical value. */</Line>
  <Line number="18920">    n2 = strlen30(zCmd);</Line>
  <Line number="18921">    for(i=0; i&lt;<CheckRefs ids="3709,3710,3708">ArraySize</CheckRefs>(aCtrl); i<CheckRefs ids="3711">++</CheckRefs>){</Line>
  <Line number="18922">      if( strncmp(zCmd, aCtrl[i<CheckRefs ids="3712">]</CheckRefs>.zCtrlName, <CheckRefs ids="3713">n2</CheckRefs>)==0 ){</Line>
  <Line number="18923">        if( filectrl&lt;0 ){</Line>
  <Line number="18924">          filectrl = aCtrl[i<CheckRefs ids="3714">]</CheckRefs>.ctrlCode;</Line>
  <Line number="18925">          iCtrl = i;</Line>
  <Line number="18926">        }else{</Line>
  <Line number="18927">          utf8_printf(stderr, &quot;Error: ambiguous file-control: \&quot;%s\&quot;\n&quot;</Line>
  <Line number="18928">                              &quot;Use \&quot;.filectrl --help\&quot; for help\n&quot;, zCmd);</Line>
  <Line number="18929">          rc = 1;</Line>
  <Line number="18930">          goto meta_command_exit;</Line>
  <Line number="18931">        }</Line>
  <Line number="18932">      }</Line>
  <Line number="18933">    }</Line>
  <Line number="18934">    if( filectrl&lt;0 ){</Line>
  <Line number="18935">      utf8_printf(stderr,&quot;Error: unknown file-control: %s\n&quot;</Line>
  <Line number="18936">                         &quot;Use \&quot;.filectrl --help\&quot; for help\n&quot;, zCmd);</Line>
  <Line number="18937">    }else{</Line>
  <Line number="18938">      switch(filectrl){</Line>
  <Line number="18939">        case SQLITE_FCNTL_SIZE_LIMIT: {</Line>
  <Line number="18940">          if( nArg!=2 &amp;&amp; nArg!=3 ) break;</Line>
  <Line number="18941">          iRes = nArg==3 ? integerValue(azArg[2<CheckRefs ids="3715">]</CheckRefs>) : <CheckRefs ids="3716,3717">-</CheckRefs>1;</Line>
  <Line number="18942">          sqlite3_file_control(p-&gt;db, zSchema, SQLITE_FCNTL_SIZE_LIMIT, &amp;iRes);</Line>
  <Line number="18943">          isOk = 1;</Line>
  <Line number="18944">          break;</Line>
  <Line number="18945">        }</Line>
  <Line number="18946">        case SQLITE_FCNTL_LOCK_TIMEOUT:</Line>
  <Line number="18947">        case SQLITE_FCNTL_CHUNK_SIZE: {</Line>
  <Line number="18948">          int x;</Line>
  <Line number="18949">          if( nArg!=3 ) break;</Line>
  <Line number="18950">          x = <CheckRefs ids="3718">(</CheckRefs>int)integerValue(azArg[2<CheckRefs ids="3719">]</CheckRefs>);</Line>
  <Line number="18951">          sqlite3_file_control(p-&gt;db, zSchema, filectrl, &amp;x);</Line>
  <Line number="18952">          isOk = 2;</Line>
  <Line number="18953">          break;</Line>
  <Line number="18954">        }</Line>
  <Line number="18955">        case SQLITE_FCNTL_PERSIST_WAL:</Line>
  <Line number="18956">        case SQLITE_FCNTL_POWERSAFE_OVERWRITE: {</Line>
  <Line number="18957">          int x;</Line>
  <Line number="18958">          if( nArg!=2 &amp;&amp; nArg!=3 ) break;</Line>
  <Line number="18959">          x = nArg==3 ? booleanValue(azArg[2<CheckRefs ids="3720">]</CheckRefs>) : <CheckRefs ids="3721">-</CheckRefs>1;</Line>
  <Line number="18960">          sqlite3_file_control(p-&gt;db, zSchema, filectrl, &amp;x);</Line>
  <Line number="18961">          iRes = <CheckRefs ids="3722">x</CheckRefs>;</Line>
  <Line number="18962">          isOk = 1;</Line>
  <Line number="18963">          break;</Line>
  <Line number="18964">        }</Line>
  <Line number="18965">        case SQLITE_FCNTL_DATA_VERSION:</Line>
  <Line number="18966">        case SQLITE_FCNTL_HAS_MOVED: {</Line>
  <Line number="18967">          int x;</Line>
  <Line number="18968">          if( nArg!=2 ) break;</Line>
  <Line number="18969">          sqlite3_file_control(p-&gt;db, zSchema, filectrl, &amp;x);</Line>
  <Line number="18970">          iRes = <CheckRefs ids="3723">x</CheckRefs>;</Line>
  <Line number="18971">          isOk = 1;</Line>
  <Line number="18972">          break;</Line>
  <Line number="18973">        }</Line>
  <Line number="18974">        case SQLITE_FCNTL_TEMPFILENAME: {</Line>
  <Line number="18975">          char *z = 0;</Line>
  <Line number="18976">          if( nArg!=2 ) break;</Line>
  <Line number="18977">          sqlite3_file_control(p-&gt;db, zSchema, filectrl, &amp;z);</Line>
  <Line number="18978">          if( z ){</Line>
  <Line number="18979">            utf8_printf(p-&gt;out, &quot;%s\n&quot;, z);</Line>
  <Line number="18980">            sqlite3_free(z);</Line>
  <Line number="18981">          }</Line>
  <Line number="18982">          isOk = 2;</Line>
  <Line number="18983">          break;</Line>
  <Line number="18984">        }</Line>
  <Line number="18985">        case SQLITE_FCNTL_RESERVE_BYTES: {</Line>
  <Line number="18986">          int x;</Line>
  <Line number="18987">          if( nArg&gt;=3 ){</Line>
  <Line number="18988">            x = atoi(azArg[2<CheckRefs ids="3724">]</CheckRefs>);</Line>
  <Line number="18989">            sqlite3_file_control(p-&gt;db, zSchema, filectrl, &amp;x);</Line>
  <Line number="18990">          }</Line>
  <Line number="18991">          x = <CheckRefs ids="3725">-</CheckRefs>1;</Line>
  <Line number="18992">          sqlite3_file_control(p-&gt;db, zSchema, filectrl, &amp;x);</Line>
  <Line number="18993">          utf8_printf(p-&gt;out,&quot;%d\n&quot;, x);</Line>
  <Line number="18994">          isOk = 2;</Line>
  <Line number="18995">          break;</Line>
  <Line number="18996">        }</Line>
  <Line number="18997">      }</Line>
  <Line number="18998">    }</Line>
  <Line number="18999">    if( isOk==0 &amp;&amp; iCtrl&gt;=0 ){</Line>
  <Line number="19000">      utf8_printf(p-&gt;out, &quot;Usage: .filectrl %s %s\n&quot;, zCmd,aCtrl[iCtrl<CheckRefs ids="3726">]</CheckRefs>.zUsage);</Line>
  <Line number="19001">      rc = 1;</Line>
  <Line number="19002">    }else if( isOk==1 ){</Line>
  <Line number="19003">      char zBuf[100];</Line>
  <Line number="19004">      sqlite3_snprintf(<CheckRefs ids="3727">sizeof</CheckRefs>(zBuf), zBuf, &quot;%lld&quot;, iRes);</Line>
  <Line number="19005">      raw_printf(p-&gt;out, &quot;%s\n&quot;, zBuf);</Line>
  <Line number="19006">    }</Line>
  <Line number="19007">  }else</Line>
  <Line number="19008"></Line>
  <Line number="19009">  if( c==&apos;f&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3728">]</CheckRefs>, &quot;fullschema&quot;, <CheckRefs ids="3729">n</CheckRefs>)==0 ){</Line>
  <Line number="19010">    ShellState data;</Line>
  <Line number="19011">    int doStats = 0;</Line>
  <Line number="19012">    memcpy(&amp;data, p, sizeof(data));</Line>
  <Line number="19013">    data.showHeader = 0;</Line>
  <Line number="19014">    data.cMode = data.mode = MODE_Semi;</Line>
  <Line number="19015">    if( nArg==2 &amp;&amp; optionMatch(azArg[1<CheckRefs ids="3730">]</CheckRefs>, &quot;indent&quot;) ){</Line>
  <Line number="19016">      data.cMode = data.mode = MODE_Pretty;</Line>
  <Line number="19017">      nArg = 1;</Line>
  <Line number="19018">    }</Line>
  <Line number="19019">    if( nArg!=1 ){</Line>
  <Line number="19020">      raw_printf(stderr, &quot;Usage: .fullschema ?--indent?\n&quot;);</Line>
  <Line number="19021">      rc = 1;</Line>
  <Line number="19022">      goto meta_command_exit;</Line>
  <Line number="19023">    }</Line>
  <Line number="19024">    open_db(p, 0);</Line>
  <Line number="19025">    rc = sqlite3_exec(p-&gt;db,</Line>
  <Line number="19026">       &quot;SELECT sql FROM&quot;</Line>
  <Line number="19027">       &quot;  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x&quot;</Line>
  <Line number="19028">       &quot;     FROM sqlite_schema UNION ALL&quot;</Line>
  <Line number="19029">       &quot;   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_schema) &quot;</Line>
  <Line number="19030">       &quot;WHERE type!=&apos;meta&apos; AND sql NOTNULL AND name NOT LIKE &apos;sqlite_%&apos; &quot;</Line>
  <Line number="19031">       &quot;ORDER BY rowid&quot;,</Line>
  <Line number="19032">       callback, &amp;data, 0</Line>
  <Line number="19033">    );</Line>
  <Line number="19034">    if( rc==SQLITE_OK ){</Line>
  <Line number="19035">      sqlite3_stmt *pStmt;</Line>
  <Line number="19036">      rc = sqlite3_prepare_v2(p-&gt;db,</Line>
  <Line number="19037">               &quot;SELECT rowid FROM sqlite_schema&quot;</Line>
  <Line number="19038">               &quot; WHERE name GLOB &apos;sqlite_stat[134]&apos;&quot;,</Line>
  <Line number="19039">               <CheckRefs ids="3731">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="19040">      doStats = sqlite3_step(pStmt)==SQLITE_ROW;</Line>
  <Line number="19041">      sqlite3_finalize(pStmt);</Line>
  <Line number="19042">    }</Line>
  <Line number="19043">    if( doStats==0 ){</Line>
  <Line number="19044">      raw_printf(p-&gt;out, &quot;/* No STAT tables available */\n&quot;);</Line>
  <Line number="19045">    }else{</Line>
  <Line number="19046">      raw_printf(p-&gt;out, &quot;ANALYZE sqlite_schema;\n&quot;);</Line>
  <Line number="19047">      sqlite3_exec(p-&gt;db, &quot;SELECT &apos;ANALYZE sqlite_schema&apos;&quot;,</Line>
  <Line number="19048">                   callback, &amp;data, 0);</Line>
  <Line number="19049">      data.cMode = data.mode = MODE_Insert;</Line>
  <Line number="19050">      data.zDestTable = &quot;sqlite_stat1&quot;;</Line>
  <Line number="19051">      shell_exec(&amp;data, &quot;SELECT * FROM sqlite_stat1&quot;, 0);</Line>
  <Line number="19052">      data.zDestTable = &quot;sqlite_stat4&quot;;</Line>
  <Line number="19053">      shell_exec(&amp;data, &quot;SELECT * FROM sqlite_stat4&quot;, 0);</Line>
  <Line number="19054">      raw_printf(p-&gt;out, &quot;ANALYZE sqlite_schema;\n&quot;);</Line>
  <Line number="19055">    }</Line>
  <Line number="19056">  }else</Line>
  <Line number="19057"></Line>
  <Line number="19058">  if( c==&apos;h&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3732">]</CheckRefs>, &quot;headers&quot;, <CheckRefs ids="3733">n</CheckRefs>)==0 ){</Line>
  <Line number="19059">    if( nArg==2 ){</Line>
  <Line number="19060">      p-&gt;showHeader = booleanValue(azArg[1<CheckRefs ids="3734">]</CheckRefs>);</Line>
  <Line number="19061">      p-&gt;shellFlgs |= <CheckRefs ids="3735">SHFLG_HeaderSet</CheckRefs>;</Line>
  <Line number="19062">    }else{</Line>
  <Line number="19063">      raw_printf(stderr, &quot;Usage: .headers on|off\n&quot;);</Line>
  <Line number="19064">      rc = 1;</Line>
  <Line number="19065">    }</Line>
  <Line number="19066">  }else</Line>
  <Line number="19067"></Line>
  <Line number="19068">  if( c==&apos;h&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3736">]</CheckRefs>, &quot;help&quot;, <CheckRefs ids="3737">n</CheckRefs>)==0 ){</Line>
  <Line number="19069">    if( nArg&gt;=2 ){</Line>
  <Line number="19070">      n = showHelp(p-&gt;out, azArg[1<CheckRefs ids="3738">]</CheckRefs>);</Line>
  <Line number="19071">      if( n==0 ){</Line>
  <Line number="19072">        utf8_printf(p-&gt;out, &quot;Nothing matches &apos;%s&apos;\n&quot;, azArg[1<CheckRefs ids="3739">]</CheckRefs>);</Line>
  <Line number="19073">      }</Line>
  <Line number="19074">    }else{</Line>
  <Line number="19075">      showHelp(p-&gt;out, 0);</Line>
  <Line number="19076">    }</Line>
  <Line number="19077">  }else</Line>
  <Line number="19078"></Line>
  <Line number="19079">  if( c==&apos;i&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3740">]</CheckRefs>, &quot;import&quot;, <CheckRefs ids="3741">n</CheckRefs>)==0 ){</Line>
  <Line number="19080">    char *zTable = 0;           /* Insert data into this table */</Line>
  <Line number="19081">    char *zFile = 0;            /* Name of file to extra content from */</Line>
  <Line number="19082">    sqlite3_stmt *pStmt = NULL; /* A statement */</Line>
  <Line number="19083">    int nCol;                   /* Number of columns in the table */</Line>
  <Line number="19084">    int nByte;                  /* Number of bytes in an SQL string */</Line>
  <Line number="19085">    int i, j;                   /* Loop counters */</Line>
  <Line number="19086">    int needCommit;             /* True to COMMIT or ROLLBACK at end */</Line>
  <Line number="19087">    int nSep;                   /* Number of bytes in p-&gt;colSeparator[] */</Line>
  <Line number="19088">    char *zSql;                 /* An SQL statement */</Line>
  <Line number="19089">    ImportCtx sCtx;             /* Reader context */</Line>
  <Line number="19090">    char *(SQLITE_CDECL *xRead)(ImportCtx*); /* Func to read one value */</Line>
  <Line number="19091">    int eVerbose = 0;           /* Larger for more console output */</Line>
  <Line number="19092">    int nSkip = 0;              /* Initial lines to skip */</Line>
  <Line number="19093">    int useOutputMode = 1;      /* Use output mode to determine separators */</Line>
  <Line number="19094"></Line>
  <Line number="19095">    memset(&amp;sCtx, 0, sizeof(sCtx));</Line>
  <Line number="19096">    if( p-&gt;mode==MODE_Ascii ){</Line>
  <Line number="19097">      xRead = ascii_read_one_field;</Line>
  <Line number="19098">    }else{</Line>
  <Line number="19099">      xRead = csv_read_one_field;</Line>
  <Line number="19100">    }</Line>
  <Line number="19101">    for(i=1; i&lt;nArg; i<CheckRefs ids="3742">++</CheckRefs>){</Line>
  <Line number="19102">      char *z = azArg[i<CheckRefs ids="3743">]</CheckRefs>;</Line>
  <Line number="19103">      if( <CheckRefs ids="3744">z</CheckRefs>[0]==&apos;-&apos; &amp;&amp; <CheckRefs ids="3745">z</CheckRefs>[1]==&apos;-&apos; ) z++;</Line>
  <Line number="19104">      if( <CheckRefs ids="3746">z</CheckRefs>[0]!=&apos;-&apos; ){</Line>
  <Line number="19105">        if( zFile==0 ){</Line>
  <Line number="19106">          zFile = z;</Line>
  <Line number="19107">        }else if( zTable==0 ){</Line>
  <Line number="19108">          zTable = z;</Line>
  <Line number="19109">        }else{</Line>
  <Line number="19110">          utf8_printf(p-&gt;out, &quot;ERROR: extra argument: \&quot;%s\&quot;.  Usage:\n&quot;, z);</Line>
  <Line number="19111">          showHelp(p-&gt;out, &quot;import&quot;);</Line>
  <Line number="19112">          rc = 1;</Line>
  <Line number="19113">          goto meta_command_exit;</Line>
  <Line number="19114">        }</Line>
  <Line number="19115">      }else if( strcmp(z,&quot;-v&quot;)==0 ){</Line>
  <Line number="19116">        eVerbose<CheckRefs ids="3747">++</CheckRefs>;</Line>
  <Line number="19117">      }else if( strcmp(z,&quot;-skip&quot;)==0 &amp;&amp; i&lt;nArg<CheckRefs ids="3748">-</CheckRefs>1 ){</Line>
  <Line number="19118">        nSkip = <CheckRefs ids="3749">integerValue</CheckRefs>(azArg[<CheckRefs ids="3751">++</CheckRefs>i<CheckRefs ids="3750">]</CheckRefs>);</Line>
  <Line number="19119">      }else if( strcmp(z,&quot;-ascii&quot;)==0 ){</Line>
  <Line number="19120">        sCtx.cColSep = <CheckRefs ids="3752">SEP_Unit</CheckRefs>[0<CheckRefs ids="3753">]</CheckRefs>;</Line>
  <Line number="19121">        sCtx.cRowSep = <CheckRefs ids="3754">SEP_Record</CheckRefs>[0<CheckRefs ids="3755">]</CheckRefs>;</Line>
  <Line number="19122">        xRead = ascii_read_one_field;</Line>
  <Line number="19123">        useOutputMode = 0;</Line>
  <Line number="19124">      }else if( strcmp(z,&quot;-csv&quot;)==0 ){</Line>
  <Line number="19125">        sCtx.cColSep = &apos;,&apos;;</Line>
  <Line number="19126">        sCtx.cRowSep = &apos;\n&apos;;</Line>
  <Line number="19127">        xRead = csv_read_one_field;</Line>
  <Line number="19128">        useOutputMode = 0;</Line>
  <Line number="19129">      }else{</Line>
  <Line number="19130">        utf8_printf(p-&gt;out, &quot;ERROR: unknown option: \&quot;%s\&quot;.  Usage:\n&quot;, z);</Line>
  <Line number="19131">        showHelp(p-&gt;out, &quot;import&quot;);</Line>
  <Line number="19132">        rc = 1;</Line>
  <Line number="19133">        goto meta_command_exit;</Line>
  <Line number="19134">      }</Line>
  <Line number="19135">    }</Line>
  <Line number="19136">    if( zTable==0 ){</Line>
  <Line number="19137">      utf8_printf(p-&gt;out, &quot;ERROR: missing %s argument. Usage:\n&quot;,</Line>
  <Line number="19138">                  zFile==0 ? &quot;FILE&quot; : &quot;TABLE&quot;);</Line>
  <Line number="19139">      showHelp(p-&gt;out, &quot;import&quot;);</Line>
  <Line number="19140">      rc = 1;</Line>
  <Line number="19141">      goto meta_command_exit;</Line>
  <Line number="19142">    }</Line>
  <Line number="19143">    seenInterrupt = 0;</Line>
  <Line number="19144">    open_db(p, 0);</Line>
  <Line number="19145">    if( useOutputMode ){</Line>
  <Line number="19146">      /* If neither the --csv or --ascii options are specified, then set</Line>
  <Line number="19147">      ** the column and row separator characters from the output mode. */</Line>
  <Line number="19148">      nSep = strlen30(p-&gt;colSeparator);</Line>
  <Line number="19149">      if( nSep==0 ){</Line>
  <Line number="19150">        raw_printf(stderr,</Line>
  <Line number="19151">                   &quot;Error: non-null column separator required for import\n&quot;);</Line>
  <Line number="19152">        rc = 1;</Line>
  <Line number="19153">        goto meta_command_exit;</Line>
  <Line number="19154">      }</Line>
  <Line number="19155">      if( nSep&gt;1 ){</Line>
  <Line number="19156">        raw_printf(stderr, </Line>
  <Line number="19157">              &quot;Error: multi-character column separators not allowed&quot;</Line>
  <Line number="19158">              &quot; for import\n&quot;);</Line>
  <Line number="19159">        rc = 1;</Line>
  <Line number="19160">        goto meta_command_exit;</Line>
  <Line number="19161">      }</Line>
  <Line number="19162">      nSep = strlen30(p-&gt;rowSeparator);</Line>
  <Line number="19163">      if( nSep==0 ){</Line>
  <Line number="19164">        raw_printf(stderr,</Line>
  <Line number="19165">            &quot;Error: non-null row separator required for import\n&quot;);</Line>
  <Line number="19166">        rc = 1;</Line>
  <Line number="19167">        goto meta_command_exit;</Line>
  <Line number="19168">      }</Line>
  <Line number="19169">      if( nSep==2 &amp;&amp; p-&gt;mode==MODE_Csv &amp;&amp; strcmp(p-&gt;rowSeparator,SEP_CrLf)==0 ){</Line>
  <Line number="19170">        /* When importing CSV (only), if the row separator is set to the</Line>
  <Line number="19171">        ** default output row separator, change it to the default input</Line>
  <Line number="19172">        ** row separator.  This avoids having to maintain different input</Line>
  <Line number="19173">        ** and output row separators. */</Line>
  <Line number="19174">        sqlite3_snprintf(<CheckRefs ids="3756">sizeof</CheckRefs>(p-&gt;rowSeparator), p-&gt;rowSeparator, SEP_Row);</Line>
  <Line number="19175">        nSep = strlen30(p-&gt;rowSeparator);</Line>
  <Line number="19176">      }</Line>
  <Line number="19177">      if( nSep&gt;1 ){</Line>
  <Line number="19178">        raw_printf(stderr, &quot;Error: multi-character row separators not allowed&quot;</Line>
  <Line number="19179">                           &quot; for import\n&quot;);</Line>
  <Line number="19180">        rc = 1;</Line>
  <Line number="19181">        goto meta_command_exit;</Line>
  <Line number="19182">      }</Line>
  <Line number="19183">      sCtx.cColSep = <CheckRefs ids="3757">p</CheckRefs>-&gt;colSeparator[0<CheckRefs ids="3758">]</CheckRefs>;</Line>
  <Line number="19184">      sCtx.cRowSep = <CheckRefs ids="3759">p</CheckRefs>-&gt;rowSeparator[0<CheckRefs ids="3760">]</CheckRefs>;</Line>
  <Line number="19185">    }</Line>
  <Line number="19186">    sCtx.zFile = zFile;</Line>
  <Line number="19187">    sCtx.nLine = 1;</Line>
  <Line number="19188">    if( <CheckRefs ids="3761">sCtx</CheckRefs>.zFile[0]==&apos;|&apos; ){</Line>
  <Line number="19189">#ifdef SQLITE_OMIT_POPEN</Line>
  <Line number="19190">      raw_printf(stderr, &quot;Error: pipes are not supported in this OS\n&quot;);</Line>
  <Line number="19191">      rc = 1;</Line>
  <Line number="19192">      goto meta_command_exit;</Line>
  <Line number="19193">#else</Line>
  <Line number="19194">      sCtx.in = popen(sCtx.zFile+1, &quot;r&quot;);</Line>
  <Line number="19195">      sCtx.zFile = &quot;&lt;pipe&gt;&quot;;</Line>
  <Line number="19196">      sCtx.xCloser = pclose;</Line>
  <Line number="19197">#endif</Line>
  <Line number="19198">    }else{</Line>
  <Line number="19199">      sCtx.in = fopen(sCtx.zFile, &quot;rb&quot;);</Line>
  <Line number="19200">      sCtx.xCloser = fclose;</Line>
  <Line number="19201">    }</Line>
  <Line number="19202">    if( sCtx.in==0 ){</Line>
  <Line number="19203">      utf8_printf(stderr, &quot;Error: cannot open \&quot;%s\&quot;\n&quot;, zFile);</Line>
  <Line number="19204">      rc = 1;</Line>
  <Line number="19205">      goto meta_command_exit;</Line>
  <Line number="19206">    }</Line>
  <Line number="19207">    if( eVerbose&gt;=2 || (eVerbose&gt;=1 &amp;&amp; useOutputMode) ){</Line>
  <Line number="19208">      char zSep[2];</Line>
  <Line number="19209">      zSep[1<CheckRefs ids="3762">]</CheckRefs> = <CheckRefs ids="3763">0</CheckRefs>;</Line>
  <Line number="19210">      zSep[0<CheckRefs ids="3764">]</CheckRefs> = <CheckRefs ids="3765">sCtx</CheckRefs>.cColSep;</Line>
  <Line number="19211">      utf8_printf(p-&gt;out, &quot;Column separator &quot;);</Line>
  <Line number="19212">      output_c_string(p-&gt;out, zSep);</Line>
  <Line number="19213">      utf8_printf(p-&gt;out, &quot;, row separator &quot;);</Line>
  <Line number="19214">      zSep[0<CheckRefs ids="3766">]</CheckRefs> = <CheckRefs ids="3767">sCtx</CheckRefs>.cRowSep;</Line>
  <Line number="19215">      output_c_string(p-&gt;out, zSep);</Line>
  <Line number="19216">      utf8_printf(p-&gt;out, &quot;\n&quot;);</Line>
  <Line number="19217">    }</Line>
  <Line number="19218">    while( (nSkip<CheckRefs ids="3768">--</CheckRefs>)&gt;0 ){</Line>
  <Line number="19219">      while( xRead(&amp;sCtx) &amp;&amp; sCtx.cTerm==sCtx.cColSep ){}</Line>
  <Line number="19220">    }</Line>
  <Line number="19221">    zSql = sqlite3_mprintf(&quot;SELECT * FROM \&quot;%w\&quot;&quot;, zTable);</Line>
  <Line number="19222">    if( zSql==0 ){</Line>
  <Line number="19223">      import_cleanup(&amp;sCtx);</Line>
  <Line number="19224">      shell_out_of_memory();</Line>
  <Line number="19225">    }</Line>
  <Line number="19226">    nByte = strlen30(zSql);</Line>
  <Line number="19227">    rc = sqlite3_prepare_v2(p-&gt;db, zSql, <CheckRefs ids="3769">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="19228">    import_append_char(&amp;sCtx, 0);    /* To ensure sCtx.z is allocated */</Line>
  <Line number="19229">    if( rc &amp;&amp; sqlite3_strglob(&quot;no such table: *&quot;, sqlite3_errmsg(p-&gt;db))==0 ){</Line>
  <Line number="19230">      char *zCreate = sqlite3_mprintf(&quot;CREATE TABLE \&quot;%w\&quot;&quot;, zTable);</Line>
  <Line number="19231">      char cSep = <CheckRefs ids="3770">&apos;(&apos;</CheckRefs>;</Line>
  <Line number="19232">      while( xRead(&amp;sCtx) ){</Line>
  <Line number="19233">        zCreate = sqlite3_mprintf(&quot;%z%c\n  \&quot;%w\&quot; TEXT&quot;, zCreate, <CheckRefs ids="3771">cSep</CheckRefs>, sCtx.z);</Line>
  <Line number="19234">        cSep = <CheckRefs ids="3772">&apos;,&apos;</CheckRefs>;</Line>
  <Line number="19235">        if( sCtx.cTerm!=sCtx.cColSep ) break;</Line>
  <Line number="19236">      }</Line>
  <Line number="19237">      if( <CheckRefs ids="3773">cSep</CheckRefs>==&apos;(&apos; ){</Line>
  <Line number="19238">        sqlite3_free(zCreate);</Line>
  <Line number="19239">        import_cleanup(&amp;sCtx);</Line>
  <Line number="19240">        utf8_printf(stderr,&quot;%s: empty file\n&quot;, sCtx.zFile);</Line>
  <Line number="19241">        rc = 1;</Line>
  <Line number="19242">        goto meta_command_exit;</Line>
  <Line number="19243">      }</Line>
  <Line number="19244">      zCreate = sqlite3_mprintf(&quot;%z\n)&quot;, zCreate);</Line>
  <Line number="19245">      if( eVerbose&gt;=1 ){</Line>
  <Line number="19246">        utf8_printf(p-&gt;out, &quot;%s\n&quot;, zCreate);</Line>
  <Line number="19247">      }</Line>
  <Line number="19248">      rc = sqlite3_exec(p-&gt;db, zCreate, 0, 0, 0);</Line>
  <Line number="19249">      sqlite3_free(zCreate);</Line>
  <Line number="19250">      if( rc ){</Line>
  <Line number="19251">        utf8_printf(stderr, &quot;CREATE TABLE \&quot;%s\&quot;(...) failed: %s\n&quot;, zTable,</Line>
  <Line number="19252">                sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="19253">        import_cleanup(&amp;sCtx);</Line>
  <Line number="19254">        rc = 1;</Line>
  <Line number="19255">        goto meta_command_exit;</Line>
  <Line number="19256">      }</Line>
  <Line number="19257">      rc = sqlite3_prepare_v2(p-&gt;db, zSql, <CheckRefs ids="3774">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="19258">    }</Line>
  <Line number="19259">    sqlite3_free(zSql);</Line>
  <Line number="19260">    if( rc ){</Line>
  <Line number="19261">      if (pStmt) sqlite3_finalize(pStmt);</Line>
  <Line number="19262">      utf8_printf(stderr,&quot;Error: %s\n&quot;, sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="19263">      import_cleanup(&amp;sCtx);</Line>
  <Line number="19264">      rc = 1;</Line>
  <Line number="19265">      goto meta_command_exit;</Line>
  <Line number="19266">    }</Line>
  <Line number="19267">    nCol = sqlite3_column_count(pStmt);</Line>
  <Line number="19268">    sqlite3_finalize(pStmt);</Line>
  <Line number="19269">    pStmt = 0;</Line>
  <Line number="19270">    if( nCol==0 ) return 0; /* no columns, no error */</Line>
  <Line number="19271">    zSql = sqlite3_malloc64( nByte<CheckRefs ids="3778">*</CheckRefs>2 <CheckRefs ids="3777">+</CheckRefs> 20 <CheckRefs ids="3775,3776">+</CheckRefs> nCol<CheckRefs ids="3779">*</CheckRefs>2 );</Line>
  <Line number="19272">    if( zSql==0 ){</Line>
  <Line number="19273">      import_cleanup(&amp;sCtx);</Line>
  <Line number="19274">      shell_out_of_memory();</Line>
  <Line number="19275">    }</Line>
  <Line number="19276">    sqlite3_snprintf(nByte<CheckRefs ids="3780">+</CheckRefs>20, zSql, &quot;INSERT INTO \&quot;%w\&quot; VALUES(?&quot;, zTable);</Line>
  <Line number="19277">    j = strlen30(zSql);</Line>
  <Line number="19278">    for(i=1; i&lt;nCol; i<CheckRefs ids="3781">++</CheckRefs>){</Line>
  <Line number="19279">      zSql[j<CheckRefs ids="3782">++</CheckRefs>] = <CheckRefs ids="3783">&apos;,&apos;</CheckRefs>;</Line>
  <Line number="19280">      zSql[j<CheckRefs ids="3784">++</CheckRefs>] = <CheckRefs ids="3785">&apos;?&apos;</CheckRefs>;</Line>
  <Line number="19281">    }</Line>
  <Line number="19282">    zSql[j<CheckRefs ids="3786">++</CheckRefs>] = <CheckRefs ids="3787">&apos;)&apos;</CheckRefs>;</Line>
  <Line number="19283">    zSql[j] = <CheckRefs ids="3788">0</CheckRefs>;</Line>
  <Line number="19284">    if( eVerbose&gt;=2 ){</Line>
  <Line number="19285">      utf8_printf(p-&gt;out, &quot;Insert using: %s\n&quot;, zSql);</Line>
  <Line number="19286">    }</Line>
  <Line number="19287">    rc = sqlite3_prepare_v2(p-&gt;db, zSql, <CheckRefs ids="3789">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="19288">    sqlite3_free(zSql);</Line>
  <Line number="19289">    if( rc ){</Line>
  <Line number="19290">      utf8_printf(stderr, &quot;Error: %s\n&quot;, sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="19291">      if (pStmt) sqlite3_finalize(pStmt);</Line>
  <Line number="19292">      import_cleanup(&amp;sCtx);</Line>
  <Line number="19293">      rc = 1;</Line>
  <Line number="19294">      goto meta_command_exit;</Line>
  <Line number="19295">    }</Line>
  <Line number="19296">    needCommit = sqlite3_get_autocommit(p-&gt;db);</Line>
  <Line number="19297">    if( needCommit ) sqlite3_exec(p-&gt;db, &quot;BEGIN&quot;, 0, 0, 0);</Line>
  <Line number="19298">    do{</Line>
  <Line number="19299">      int startLine = sCtx.nLine;</Line>
  <Line number="19300">      for(i=0; i&lt;nCol; i<CheckRefs ids="3790">++</CheckRefs>){</Line>
  <Line number="19301">        char *z = xRead(&amp;sCtx);</Line>
  <Line number="19302">        /*</Line>
  <Line number="19303">        ** Did we reach end-of-file before finding any columns?</Line>
  <Line number="19304">        ** If so, stop instead of NULL filling the remaining columns.</Line>
  <Line number="19305">        */</Line>
  <Line number="19306">        if( z==0 &amp;&amp; i==0 ) break;</Line>
  <Line number="19307">        /*</Line>
  <Line number="19308">        ** Did we reach end-of-file OR end-of-line before finding any</Line>
  <Line number="19309">        ** columns in ASCII mode?  If so, stop instead of NULL filling</Line>
  <Line number="19310">        ** the remaining columns.</Line>
  <Line number="19311">        */</Line>
  <Line number="19312">        if( p-&gt;mode==MODE_Ascii &amp;&amp; (z==0 || <CheckRefs ids="3791">z</CheckRefs>[0]==0) &amp;&amp; i==0 ) break;</Line>
  <Line number="19313">        sqlite3_bind_text(pStmt, i<CheckRefs ids="3792">+</CheckRefs>1, z, <CheckRefs ids="3793">-</CheckRefs>1, <CheckRefs ids="3794">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="19314">        if( i&lt;nCol<CheckRefs ids="3795">-</CheckRefs>1 &amp;&amp; sCtx.cTerm!=sCtx.cColSep ){</Line>
  <Line number="19315">          utf8_printf(stderr, &quot;%s:%d: expected %d columns but found %d - &quot;</Line>
  <Line number="19316">                          &quot;filling the rest with NULL\n&quot;,</Line>
  <Line number="19317">                          sCtx.zFile, startLine, nCol, i<CheckRefs ids="3796">+</CheckRefs>1);</Line>
  <Line number="19318">          i <CheckRefs ids="3797">+=</CheckRefs> 2;</Line>
  <Line number="19319">          while( i&lt;=nCol ){ sqlite3_bind_null(pStmt, i); i<CheckRefs ids="3798">++</CheckRefs>; }</Line>
  <Line number="19320">        }</Line>
  <Line number="19321">      }</Line>
  <Line number="19322">      if( sCtx.cTerm==sCtx.cColSep ){</Line>
  <Line number="19323">        do{</Line>
  <Line number="19324">          xRead(&amp;sCtx);</Line>
  <Line number="19325">          i<CheckRefs ids="3799">++</CheckRefs>;</Line>
  <Line number="19326">        }while( sCtx.cTerm==sCtx.cColSep );</Line>
  <Line number="19327">        utf8_printf(stderr, &quot;%s:%d: expected %d columns but found %d - &quot;</Line>
  <Line number="19328">                        &quot;extras ignored\n&quot;,</Line>
  <Line number="19329">                        sCtx.zFile, startLine, nCol, i);</Line>
  <Line number="19330">      }</Line>
  <Line number="19331">      if( i&gt;=nCol ){</Line>
  <Line number="19332">        sqlite3_step(pStmt);</Line>
  <Line number="19333">        rc = sqlite3_reset(pStmt);</Line>
  <Line number="19334">        if( rc!=SQLITE_OK ){</Line>
  <Line number="19335">          utf8_printf(stderr, &quot;%s:%d: INSERT failed: %s\n&quot;, sCtx.zFile,</Line>
  <Line number="19336">                      startLine, sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="19337">          sCtx.nErr<CheckRefs ids="3800">++</CheckRefs>;</Line>
  <Line number="19338">        }else{</Line>
  <Line number="19339">          sCtx.nRow<CheckRefs ids="3801">++</CheckRefs>;</Line>
  <Line number="19340">        }</Line>
  <Line number="19341">      }</Line>
  <Line number="19342">    }while( sCtx.cTerm!=<CheckRefs ids="3802">EOF</CheckRefs> );</Line>
  <Line number="19343"></Line>
  <Line number="19344">    import_cleanup(&amp;sCtx);</Line>
  <Line number="19345">    sqlite3_finalize(pStmt);</Line>
  <Line number="19346">    if( needCommit ) sqlite3_exec(p-&gt;db, &quot;COMMIT&quot;, 0, 0, 0);</Line>
  <Line number="19347">    if( eVerbose&gt;0 ){</Line>
  <Line number="19348">      utf8_printf(p-&gt;out,</Line>
  <Line number="19349">          &quot;Added %d rows with %d errors using %d lines of input\n&quot;,</Line>
  <Line number="19350">          sCtx.nRow, sCtx.nErr, sCtx.nLine<CheckRefs ids="3803">-</CheckRefs>1);</Line>
  <Line number="19351">    }</Line>
  <Line number="19352">  }else</Line>
  <Line number="19353"></Line>
  <Line number="19354">#ifndef SQLITE_UNTESTABLE</Line>
  <Line number="19355">  if( c==&apos;i&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3804">]</CheckRefs>, &quot;imposter&quot;, <CheckRefs ids="3805">n</CheckRefs>)==0 ){</Line>
  <Line number="19356">    char *zSql;</Line>
  <Line number="19357">    char *zCollist = 0;</Line>
  <Line number="19358">    sqlite3_stmt *pStmt;</Line>
  <Line number="19359">    int tnum = 0;</Line>
  <Line number="19360">    int isWO = 0;  /* True if making an imposter of a WITHOUT ROWID table */</Line>
  <Line number="19361">    int lenPK = 0; /* Length of the PRIMARY KEY string for isWO tables */</Line>
  <Line number="19362">    int i;</Line>
  <Line number="19363">    if( !(nArg==3 || (nArg==2 &amp;&amp; sqlite3_stricmp(azArg[1<CheckRefs ids="3806">]</CheckRefs>,&quot;off&quot;)==0)) ){</Line>
  <Line number="19364">      utf8_printf(stderr, &quot;Usage: .imposter INDEX IMPOSTER\n&quot;</Line>
  <Line number="19365">                          &quot;       .imposter off\n&quot;);</Line>
  <Line number="19366">      /* Also allowed, but not documented:</Line>
  <Line number="19367">      **</Line>
  <Line number="19368">      **    .imposter TABLE IMPOSTER</Line>
  <Line number="19369">      **</Line>
  <Line number="19370">      ** where TABLE is a WITHOUT ROWID table.  In that case, the</Line>
  <Line number="19371">      ** imposter is another WITHOUT ROWID table with the columns in</Line>
  <Line number="19372">      ** storage order. */</Line>
  <Line number="19373">      rc = 1;</Line>
  <Line number="19374">      goto meta_command_exit;</Line>
  <Line number="19375">    }</Line>
  <Line number="19376">    open_db(p, 0);</Line>
  <Line number="19377">    if( nArg==2 ){</Line>
  <Line number="19378">      sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p-&gt;db, &quot;main&quot;, 0, 1);</Line>
  <Line number="19379">      goto meta_command_exit;</Line>
  <Line number="19380">    }</Line>
  <Line number="19381">    zSql = sqlite3_mprintf(</Line>
  <Line number="19382">      &quot;SELECT rootpage, 0 FROM sqlite_schema&quot;</Line>
  <Line number="19383">      &quot; WHERE name=&apos;%q&apos; AND type=&apos;index&apos;&quot;</Line>
  <Line number="19384">      &quot;UNION ALL &quot;</Line>
  <Line number="19385">      &quot;SELECT rootpage, 1 FROM sqlite_schema&quot;</Line>
  <Line number="19386">      &quot; WHERE name=&apos;%q&apos; AND type=&apos;table&apos;&quot;</Line>
  <Line number="19387">      &quot;   AND sql LIKE &apos;%%without%%rowid%%&apos;&quot;,</Line>
  <Line number="19388">      azArg[1<CheckRefs ids="3807">]</CheckRefs>, azArg[1<CheckRefs ids="3808">]</CheckRefs></Line>
  <Line number="19389">    );</Line>
  <Line number="19390">    sqlite3_prepare_v2(p-&gt;db, zSql, <CheckRefs ids="3809">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="19391">    sqlite3_free(zSql);</Line>
  <Line number="19392">    if( sqlite3_step(pStmt)==SQLITE_ROW ){</Line>
  <Line number="19393">      tnum = sqlite3_column_int(pStmt, 0);</Line>
  <Line number="19394">      isWO = sqlite3_column_int(pStmt, 1);</Line>
  <Line number="19395">    }</Line>
  <Line number="19396">    sqlite3_finalize(pStmt);</Line>
  <Line number="19397">    zSql = sqlite3_mprintf(&quot;PRAGMA index_xinfo=&apos;%q&apos;&quot;, azArg[1<CheckRefs ids="3810">]</CheckRefs>);</Line>
  <Line number="19398">    rc = sqlite3_prepare_v2(p-&gt;db, zSql, <CheckRefs ids="3811">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="19399">    sqlite3_free(zSql);</Line>
  <Line number="19400">    i = 0;</Line>
  <Line number="19401">    while( sqlite3_step(pStmt)==SQLITE_ROW ){</Line>
  <Line number="19402">      char zLabel[20];</Line>
  <Line number="19403">      const char *zCol = (const char*)sqlite3_column_text(pStmt,2);</Line>
  <Line number="19404">      i<CheckRefs ids="3812">++</CheckRefs>;</Line>
  <Line number="19405">      if( zCol==0 ){</Line>
  <Line number="19406">        if( sqlite3_column_int(pStmt,1)==<CheckRefs ids="3813">-</CheckRefs>1 ){</Line>
  <Line number="19407">          zCol = &quot;_ROWID_&quot;;</Line>
  <Line number="19408">        }else{</Line>
  <Line number="19409">          sqlite3_snprintf(<CheckRefs ids="3814">sizeof</CheckRefs>(zLabel),zLabel,&quot;expr%d&quot;,i);</Line>
  <Line number="19410">          zCol = zLabel;</Line>
  <Line number="19411">        }</Line>
  <Line number="19412">      }</Line>
  <Line number="19413">      if( isWO &amp;&amp; lenPK==0 &amp;&amp; sqlite3_column_int(pStmt,5)==0 &amp;&amp; zCollist ){</Line>
  <Line number="19414">        lenPK = <CheckRefs ids="3815">(</CheckRefs>int)strlen(zCollist);</Line>
  <Line number="19415">      }</Line>
  <Line number="19416">      if( zCollist==0 ){</Line>
  <Line number="19417">        zCollist = sqlite3_mprintf(&quot;\&quot;%w\&quot;&quot;, zCol);</Line>
  <Line number="19418">      }else{</Line>
  <Line number="19419">        zCollist = sqlite3_mprintf(&quot;%z,\&quot;%w\&quot;&quot;, zCollist, zCol);</Line>
  <Line number="19420">      }</Line>
  <Line number="19421">    }</Line>
  <Line number="19422">    sqlite3_finalize(pStmt);</Line>
  <Line number="19423">    if( i==0 || tnum==0 ){</Line>
  <Line number="19424">      utf8_printf(stderr, &quot;no such index: \&quot;%s\&quot;\n&quot;, azArg[1<CheckRefs ids="3816">]</CheckRefs>);</Line>
  <Line number="19425">      rc = 1;</Line>
  <Line number="19426">      sqlite3_free(zCollist);</Line>
  <Line number="19427">      goto meta_command_exit;</Line>
  <Line number="19428">    }</Line>
  <Line number="19429">    if( lenPK==0 ) lenPK = 100000;</Line>
  <Line number="19430">    zSql = sqlite3_mprintf(</Line>
  <Line number="19431">          &quot;CREATE TABLE \&quot;%w\&quot;(%s,PRIMARY KEY(%.*s))WITHOUT ROWID&quot;,</Line>
  <Line number="19432">          azArg[2<CheckRefs ids="3817">]</CheckRefs>, zCollist, lenPK, zCollist);</Line>
  <Line number="19433">    sqlite3_free(zCollist);</Line>
  <Line number="19434">    rc = sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p-&gt;db, &quot;main&quot;, 1, tnum);</Line>
  <Line number="19435">    if( rc==SQLITE_OK ){</Line>
  <Line number="19436">      rc = sqlite3_exec(p-&gt;db, zSql, 0, 0, 0);</Line>
  <Line number="19437">      sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p-&gt;db, &quot;main&quot;, 0, 0);</Line>
  <Line number="19438">      if( rc ){</Line>
  <Line number="19439">        utf8_printf(stderr, &quot;Error in [%s]: %s\n&quot;, zSql, sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="19440">      }else{</Line>
  <Line number="19441">        utf8_printf(stdout, &quot;%s;\n&quot;, zSql);</Line>
  <Line number="19442">        raw_printf(stdout,</Line>
  <Line number="19443">          &quot;WARNING: writing to an imposter table will corrupt the \&quot;%s\&quot; %s!\n&quot;,</Line>
  <Line number="19444">          azArg[1<CheckRefs ids="3818">]</CheckRefs>, isWO ? &quot;table&quot; : &quot;index&quot;</Line>
  <Line number="19445">        );</Line>
  <Line number="19446">      }</Line>
  <Line number="19447">    }else{</Line>
  <Line number="19448">      raw_printf(stderr, &quot;SQLITE_TESTCTRL_IMPOSTER returns %d\n&quot;, rc);</Line>
  <Line number="19449">      rc = 1;</Line>
  <Line number="19450">    }</Line>
  <Line number="19451">    sqlite3_free(zSql);</Line>
  <Line number="19452">  }else</Line>
  <Line number="19453">#endif /* !defined(SQLITE_OMIT_TEST_CONTROL) */</Line>
  <Line number="19454"></Line>
  <Line number="19455">#ifdef SQLITE_ENABLE_IOTRACE</Line>
  <Line number="19456">  if( c==&apos;i&apos; &amp;&amp; strncmp(azArg[0], &quot;iotrace&quot;, n)==0 ){</Line>
  <Line number="19457">    SQLITE_API extern void (SQLITE_CDECL *sqlite3IoTrace)(const char*, ...);</Line>
  <Line number="19458">    if( iotrace &amp;&amp; iotrace!=stdout ) fclose(iotrace);</Line>
  <Line number="19459">    iotrace = 0;</Line>
  <Line number="19460">    if( nArg&lt;2 ){</Line>
  <Line number="19461">      sqlite3IoTrace = 0;</Line>
  <Line number="19462">    }else if( strcmp(azArg[1], &quot;-&quot;)==0 ){</Line>
  <Line number="19463">      sqlite3IoTrace = iotracePrintf;</Line>
  <Line number="19464">      iotrace = stdout;</Line>
  <Line number="19465">    }else{</Line>
  <Line number="19466">      iotrace = fopen(azArg[1], &quot;w&quot;);</Line>
  <Line number="19467">      if( iotrace==0 ){</Line>
  <Line number="19468">        utf8_printf(stderr, &quot;Error: cannot open \&quot;%s\&quot;\n&quot;, azArg[1]);</Line>
  <Line number="19469">        sqlite3IoTrace = 0;</Line>
  <Line number="19470">        rc = 1;</Line>
  <Line number="19471">      }else{</Line>
  <Line number="19472">        sqlite3IoTrace = iotracePrintf;</Line>
  <Line number="19473">      }</Line>
  <Line number="19474">    }</Line>
  <Line number="19475">  }else</Line>
  <Line number="19476">#endif</Line>
  <Line number="19477"></Line>
  <Line number="19478">  if( c==&apos;l&apos; &amp;&amp; n&gt;=5 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3819">]</CheckRefs>, &quot;limits&quot;, <CheckRefs ids="3820">n</CheckRefs>)==0 ){</Line>
  <Line number="19479">    static const struct {</Line>
  <Line number="19480">       const char *zLimitName;   /* Name of a limit */</Line>
  <Line number="19481">       int limitCode;            /* Integer code for that limit */</Line>
  <Line number="19482">    } aLimit[] = {</Line>
  <Line number="19483">      { &quot;length&quot;,                SQLITE_LIMIT_LENGTH                    },</Line>
  <Line number="19484">      { &quot;sql_length&quot;,            SQLITE_LIMIT_SQL_LENGTH                },</Line>
  <Line number="19485">      { &quot;column&quot;,                SQLITE_LIMIT_COLUMN                    },</Line>
  <Line number="19486">      { &quot;expr_depth&quot;,            SQLITE_LIMIT_EXPR_DEPTH                },</Line>
  <Line number="19487">      { &quot;compound_select&quot;,       SQLITE_LIMIT_COMPOUND_SELECT           },</Line>
  <Line number="19488">      { &quot;vdbe_op&quot;,               SQLITE_LIMIT_VDBE_OP                   },</Line>
  <Line number="19489">      { &quot;function_arg&quot;,          SQLITE_LIMIT_FUNCTION_ARG              },</Line>
  <Line number="19490">      { &quot;attached&quot;,              SQLITE_LIMIT_ATTACHED                  },</Line>
  <Line number="19491">      { &quot;like_pattern_length&quot;,   SQLITE_LIMIT_LIKE_PATTERN_LENGTH       },</Line>
  <Line number="19492">      { &quot;variable_number&quot;,       SQLITE_LIMIT_VARIABLE_NUMBER           },</Line>
  <Line number="19493">      { &quot;trigger_depth&quot;,         SQLITE_LIMIT_TRIGGER_DEPTH             },</Line>
  <Line number="19494">      { &quot;worker_threads&quot;,        SQLITE_LIMIT_WORKER_THREADS            },</Line>
  <Line number="19495">    };</Line>
  <Line number="19496">    int i, n2;</Line>
  <Line number="19497">    open_db(p, 0);</Line>
  <Line number="19498">    if( nArg==1 ){</Line>
  <Line number="19499">      for(i=0; i&lt;<CheckRefs ids="3822,3823,3821">ArraySize</CheckRefs>(aLimit); i<CheckRefs ids="3824">++</CheckRefs>){</Line>
  <Line number="19500">        printf(&quot;%20s %d\n&quot;, aLimit[i<CheckRefs ids="3825">]</CheckRefs>.zLimitName,</Line>
  <Line number="19501">               sqlite3_limit(p-&gt;db, aLimit[i<CheckRefs ids="3826">]</CheckRefs>.limitCode, <CheckRefs ids="3827">-</CheckRefs>1));</Line>
  <Line number="19502">      }</Line>
  <Line number="19503">    }else if( nArg&gt;3 ){</Line>
  <Line number="19504">      raw_printf(stderr, &quot;Usage: .limit NAME ?NEW-VALUE?\n&quot;);</Line>
  <Line number="19505">      rc = 1;</Line>
  <Line number="19506">      goto meta_command_exit;</Line>
  <Line number="19507">    }else{</Line>
  <Line number="19508">      int iLimit = <CheckRefs ids="3828">-</CheckRefs>1;</Line>
  <Line number="19509">      n2 = strlen30(azArg[1<CheckRefs ids="3829">]</CheckRefs>);</Line>
  <Line number="19510">      for(i=0; i&lt;<CheckRefs ids="3830,3831,3832">ArraySize</CheckRefs>(aLimit); i<CheckRefs ids="3833">++</CheckRefs>){</Line>
  <Line number="19511">        if( sqlite3_strnicmp(aLimit[i<CheckRefs ids="3834">]</CheckRefs>.zLimitName, azArg[1<CheckRefs ids="3835">]</CheckRefs>, n2)==0 ){</Line>
  <Line number="19512">          if( iLimit&lt;0 ){</Line>
  <Line number="19513">            iLimit = i;</Line>
  <Line number="19514">          }else{</Line>
  <Line number="19515">            utf8_printf(stderr, &quot;ambiguous limit: \&quot;%s\&quot;\n&quot;, azArg[1<CheckRefs ids="3836">]</CheckRefs>);</Line>
  <Line number="19516">            rc = 1;</Line>
  <Line number="19517">            goto meta_command_exit;</Line>
  <Line number="19518">          }</Line>
  <Line number="19519">        }</Line>
  <Line number="19520">      }</Line>
  <Line number="19521">      if( iLimit&lt;0 ){</Line>
  <Line number="19522">        utf8_printf(stderr, &quot;unknown limit: \&quot;%s\&quot;\n&quot;</Line>
  <Line number="19523">                        &quot;enter \&quot;.limits\&quot; with no arguments for a list.\n&quot;,</Line>
  <Line number="19524">                         azArg[1<CheckRefs ids="3837">]</CheckRefs>);</Line>
  <Line number="19525">        rc = 1;</Line>
  <Line number="19526">        goto meta_command_exit;</Line>
  <Line number="19527">      }</Line>
  <Line number="19528">      if( nArg==3 ){</Line>
  <Line number="19529">        sqlite3_limit(p-&gt;db, aLimit[iLimit<CheckRefs ids="3838">]</CheckRefs>.limitCode,</Line>
  <Line number="19530">                      <CheckRefs ids="3839">(</CheckRefs>int)integerValue(azArg[2<CheckRefs ids="3840">]</CheckRefs>));</Line>
  <Line number="19531">      }</Line>
  <Line number="19532">      printf(&quot;%20s %d\n&quot;, aLimit[iLimit<CheckRefs ids="3841">]</CheckRefs>.zLimitName,</Line>
  <Line number="19533">             sqlite3_limit(p-&gt;db, aLimit[iLimit<CheckRefs ids="3842">]</CheckRefs>.limitCode, <CheckRefs ids="3843">-</CheckRefs>1));</Line>
  <Line number="19534">    }</Line>
  <Line number="19535">  }else</Line>
  <Line number="19536"></Line>
  <Line number="19537">  if( c==&apos;l&apos; &amp;&amp; n&gt;2 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3844">]</CheckRefs>, &quot;lint&quot;, <CheckRefs ids="3845">n</CheckRefs>)==0 ){</Line>
  <Line number="19538">    open_db(p, 0);</Line>
  <Line number="19539">    lintDotCommand(p, azArg, nArg);</Line>
  <Line number="19540">  }else</Line>
  <Line number="19541"></Line>
  <Line number="19542">#ifndef SQLITE_OMIT_LOAD_EXTENSION</Line>
  <Line number="19543">  if( c==&apos;l&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3846">]</CheckRefs>, &quot;load&quot;, <CheckRefs ids="3847">n</CheckRefs>)==0 ){</Line>
  <Line number="19544">    const char *zFile, *zProc;</Line>
  <Line number="19545">    char *zErrMsg = 0;</Line>
  <Line number="19546">    if( nArg&lt;2 ){</Line>
  <Line number="19547">      raw_printf(stderr, &quot;Usage: .load FILE ?ENTRYPOINT?\n&quot;);</Line>
  <Line number="19548">      rc = 1;</Line>
  <Line number="19549">      goto meta_command_exit;</Line>
  <Line number="19550">    }</Line>
  <Line number="19551">    zFile = azArg[1<CheckRefs ids="3848">]</CheckRefs>;</Line>
  <Line number="19552">    zProc = nArg&gt;=3 ? azArg[2<CheckRefs ids="3849">]</CheckRefs> : 0;</Line>
  <Line number="19553">    open_db(p, 0);</Line>
  <Line number="19554">    rc = sqlite3_load_extension(p-&gt;db, zFile, zProc, &amp;zErrMsg);</Line>
  <Line number="19555">    if( rc!=SQLITE_OK ){</Line>
  <Line number="19556">      utf8_printf(stderr, &quot;Error: %s\n&quot;, zErrMsg);</Line>
  <Line number="19557">      sqlite3_free(zErrMsg);</Line>
  <Line number="19558">      rc = 1;</Line>
  <Line number="19559">    }</Line>
  <Line number="19560">  }else</Line>
  <Line number="19561">#endif</Line>
  <Line number="19562"></Line>
  <Line number="19563">  if( c==&apos;l&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3850">]</CheckRefs>, &quot;log&quot;, <CheckRefs ids="3851">n</CheckRefs>)==0 ){</Line>
  <Line number="19564">    if( nArg!=2 ){</Line>
  <Line number="19565">      raw_printf(stderr, &quot;Usage: .log FILENAME\n&quot;);</Line>
  <Line number="19566">      rc = 1;</Line>
  <Line number="19567">    }else{</Line>
  <Line number="19568">      const char *zFile = azArg[1<CheckRefs ids="3852">]</CheckRefs>;</Line>
  <Line number="19569">      output_file_close(p-&gt;pLog);</Line>
  <Line number="19570">      p-&gt;pLog = output_file_open(zFile, 0);</Line>
  <Line number="19571">    }</Line>
  <Line number="19572">  }else</Line>
  <Line number="19573"></Line>
  <Line number="19574">  if( c==&apos;m&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3853">]</CheckRefs>, &quot;mode&quot;, <CheckRefs ids="3854">n</CheckRefs>)==0 ){</Line>
  <Line number="19575">    const char *zMode = nArg&gt;=2 ? azArg[1<CheckRefs ids="3855">]</CheckRefs> : &quot;&quot;;</Line>
  <Line number="19576">    int n2 = strlen30(zMode);</Line>
  <Line number="19577">    int c2 = <CheckRefs ids="3856">zMode</CheckRefs>[0];</Line>
  <Line number="19578">    if( c2==&apos;l&apos; &amp;&amp; n2&gt;2 &amp;&amp; strncmp(azArg[1<CheckRefs ids="3857">]</CheckRefs>,&quot;lines&quot;,<CheckRefs ids="3858">n2</CheckRefs>)==0 ){</Line>
  <Line number="19579">      p-&gt;mode = MODE_Line;</Line>
  <Line number="19580">      sqlite3_snprintf(<CheckRefs ids="3859">sizeof</CheckRefs>(p-&gt;rowSeparator), p-&gt;rowSeparator, SEP_Row);</Line>
  <Line number="19581">    }else if( c2==&apos;c&apos; &amp;&amp; strncmp(azArg[1<CheckRefs ids="3860">]</CheckRefs>,&quot;columns&quot;,<CheckRefs ids="3861">n2</CheckRefs>)==0 ){</Line>
  <Line number="19582">      p-&gt;mode = MODE_Column;</Line>
  <Line number="19583">      if( (p-&gt;shellFlgs &amp; <CheckRefs ids="3862">SHFLG_HeaderSet</CheckRefs>)==<CheckRefs ids="3863">0</CheckRefs> ){</Line>
  <Line number="19584">        p-&gt;showHeader = 1;</Line>
  <Line number="19585">      }</Line>
  <Line number="19586">      sqlite3_snprintf(<CheckRefs ids="3864">sizeof</CheckRefs>(p-&gt;rowSeparator), p-&gt;rowSeparator, SEP_Row);</Line>
  <Line number="19587">    }else if( c2==&apos;l&apos; &amp;&amp; n2&gt;2 &amp;&amp; strncmp(azArg[1<CheckRefs ids="3865">]</CheckRefs>,&quot;list&quot;,<CheckRefs ids="3866">n2</CheckRefs>)==0 ){</Line>
  <Line number="19588">      p-&gt;mode = MODE_List;</Line>
  <Line number="19589">      sqlite3_snprintf(<CheckRefs ids="3867">sizeof</CheckRefs>(p-&gt;colSeparator), p-&gt;colSeparator, SEP_Column);</Line>
  <Line number="19590">      sqlite3_snprintf(<CheckRefs ids="3868">sizeof</CheckRefs>(p-&gt;rowSeparator), p-&gt;rowSeparator, SEP_Row);</Line>
  <Line number="19591">    }else if( c2==&apos;h&apos; &amp;&amp; strncmp(azArg[1<CheckRefs ids="3869">]</CheckRefs>,&quot;html&quot;,<CheckRefs ids="3870">n2</CheckRefs>)==0 ){</Line>
  <Line number="19592">      p-&gt;mode = MODE_Html;</Line>
  <Line number="19593">    }else if( c2==&apos;t&apos; &amp;&amp; strncmp(azArg[1<CheckRefs ids="3871">]</CheckRefs>,&quot;tcl&quot;,<CheckRefs ids="3872">n2</CheckRefs>)==0 ){</Line>
  <Line number="19594">      p-&gt;mode = MODE_Tcl;</Line>
  <Line number="19595">      sqlite3_snprintf(<CheckRefs ids="3873">sizeof</CheckRefs>(p-&gt;colSeparator), p-&gt;colSeparator, SEP_Space);</Line>
  <Line number="19596">      sqlite3_snprintf(<CheckRefs ids="3874">sizeof</CheckRefs>(p-&gt;rowSeparator), p-&gt;rowSeparator, SEP_Row);</Line>
  <Line number="19597">    }else if( c2==&apos;c&apos; &amp;&amp; strncmp(azArg[1<CheckRefs ids="3875">]</CheckRefs>,&quot;csv&quot;,<CheckRefs ids="3876">n2</CheckRefs>)==0 ){</Line>
  <Line number="19598">      p-&gt;mode = MODE_Csv;</Line>
  <Line number="19599">      sqlite3_snprintf(<CheckRefs ids="3877">sizeof</CheckRefs>(p-&gt;colSeparator), p-&gt;colSeparator, SEP_Comma);</Line>
  <Line number="19600">      sqlite3_snprintf(<CheckRefs ids="3878">sizeof</CheckRefs>(p-&gt;rowSeparator), p-&gt;rowSeparator, SEP_CrLf);</Line>
  <Line number="19601">    }else if( c2==&apos;t&apos; &amp;&amp; strncmp(azArg[1<CheckRefs ids="3879">]</CheckRefs>,&quot;tabs&quot;,<CheckRefs ids="3880">n2</CheckRefs>)==0 ){</Line>
  <Line number="19602">      p-&gt;mode = MODE_List;</Line>
  <Line number="19603">      sqlite3_snprintf(<CheckRefs ids="3881">sizeof</CheckRefs>(p-&gt;colSeparator), p-&gt;colSeparator, SEP_Tab);</Line>
  <Line number="19604">    }else if( c2==&apos;i&apos; &amp;&amp; strncmp(azArg[1<CheckRefs ids="3882">]</CheckRefs>,&quot;insert&quot;,<CheckRefs ids="3883">n2</CheckRefs>)==0 ){</Line>
  <Line number="19605">      p-&gt;mode = MODE_Insert;</Line>
  <Line number="19606">      set_table_name(p, nArg&gt;=3 ? azArg[2<CheckRefs ids="3884">]</CheckRefs> : &quot;table&quot;);</Line>
  <Line number="19607">    }else if( c2==&apos;q&apos; &amp;&amp; strncmp(azArg[1<CheckRefs ids="3885">]</CheckRefs>,&quot;quote&quot;,<CheckRefs ids="3886">n2</CheckRefs>)==0 ){</Line>
  <Line number="19608">      p-&gt;mode = MODE_Quote;</Line>
  <Line number="19609">      sqlite3_snprintf(<CheckRefs ids="3887">sizeof</CheckRefs>(p-&gt;colSeparator), p-&gt;colSeparator, SEP_Comma);</Line>
  <Line number="19610">      sqlite3_snprintf(<CheckRefs ids="3888">sizeof</CheckRefs>(p-&gt;rowSeparator), p-&gt;rowSeparator, SEP_Row);</Line>
  <Line number="19611">    }else if( c2==&apos;a&apos; &amp;&amp; strncmp(azArg[1<CheckRefs ids="3889">]</CheckRefs>,&quot;ascii&quot;,<CheckRefs ids="3890">n2</CheckRefs>)==0 ){</Line>
  <Line number="19612">      p-&gt;mode = MODE_Ascii;</Line>
  <Line number="19613">      sqlite3_snprintf(<CheckRefs ids="3891">sizeof</CheckRefs>(p-&gt;colSeparator), p-&gt;colSeparator, SEP_Unit);</Line>
  <Line number="19614">      sqlite3_snprintf(<CheckRefs ids="3892">sizeof</CheckRefs>(p-&gt;rowSeparator), p-&gt;rowSeparator, SEP_Record);</Line>
  <Line number="19615">    }else if( c2==&apos;m&apos; &amp;&amp; strncmp(azArg[1<CheckRefs ids="3893">]</CheckRefs>,&quot;markdown&quot;,<CheckRefs ids="3894">n2</CheckRefs>)==0 ){</Line>
  <Line number="19616">      p-&gt;mode = MODE_Markdown;</Line>
  <Line number="19617">    }else if( c2==&apos;t&apos; &amp;&amp; strncmp(azArg[1<CheckRefs ids="3895">]</CheckRefs>,&quot;table&quot;,<CheckRefs ids="3896">n2</CheckRefs>)==0 ){</Line>
  <Line number="19618">      p-&gt;mode = MODE_Table;</Line>
  <Line number="19619">    }else if( c2==&apos;b&apos; &amp;&amp; strncmp(azArg[1<CheckRefs ids="3897">]</CheckRefs>,&quot;box&quot;,<CheckRefs ids="3898">n2</CheckRefs>)==0 ){</Line>
  <Line number="19620">      p-&gt;mode = MODE_Box;</Line>
  <Line number="19621">    }else if( c2==&apos;j&apos; &amp;&amp; strncmp(azArg[1<CheckRefs ids="3899">]</CheckRefs>,&quot;json&quot;,<CheckRefs ids="3900">n2</CheckRefs>)==0 ){</Line>
  <Line number="19622">      p-&gt;mode = MODE_Json;</Line>
  <Line number="19623">    }else if( nArg==1 ){</Line>
  <Line number="19624">      raw_printf(p-&gt;out, &quot;current output mode: %s\n&quot;, modeDescr[p-&gt;mode<CheckRefs ids="3901">]</CheckRefs>);</Line>
  <Line number="19625">    }else{</Line>
  <Line number="19626">      raw_printf(stderr, &quot;Error: mode should be one of: &quot;</Line>
  <Line number="19627">         &quot;ascii box column csv html insert json line list markdown &quot;</Line>
  <Line number="19628">         &quot;quote table tabs tcl\n&quot;);</Line>
  <Line number="19629">      rc = 1;</Line>
  <Line number="19630">    }</Line>
  <Line number="19631">    p-&gt;cMode = p-&gt;mode;</Line>
  <Line number="19632">  }else</Line>
  <Line number="19633"></Line>
  <Line number="19634">  if( c==&apos;n&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3902">]</CheckRefs>, &quot;nullvalue&quot;, <CheckRefs ids="3903">n</CheckRefs>)==0 ){</Line>
  <Line number="19635">    if( nArg==2 ){</Line>
  <Line number="19636">      sqlite3_snprintf(<CheckRefs ids="3904">sizeof</CheckRefs>(p-&gt;nullValue), p-&gt;nullValue,</Line>
  <Line number="19637">                       &quot;%.*s&quot;, (int)<CheckRefs ids="3906,3907,3908">ArraySize</CheckRefs>(p-&gt;nullValue)<CheckRefs ids="3905">-</CheckRefs>1, azArg[1<CheckRefs ids="3909">]</CheckRefs>);</Line>
  <Line number="19638">    }else{</Line>
  <Line number="19639">      raw_printf(stderr, &quot;Usage: .nullvalue STRING\n&quot;);</Line>
  <Line number="19640">      rc = 1;</Line>
  <Line number="19641">    }</Line>
  <Line number="19642">  }else</Line>
  <Line number="19643"></Line>
  <Line number="19644">#ifdef SQLITE_DEBUG</Line>
  <Line number="19645">  if( c==&apos;o&apos; &amp;&amp; strcmp(azArg[0],&quot;oom&quot;)==0 ){</Line>
  <Line number="19646">    int i;</Line>
  <Line number="19647">    for(i=1; i&lt;nArg; i++){</Line>
  <Line number="19648">      const char *z = azArg[i];</Line>
  <Line number="19649">      if( z[0]==&apos;-&apos; &amp;&amp; z[1]==&apos;-&apos; ) z++;</Line>
  <Line number="19650">      if( strcmp(z,&quot;-repeat&quot;)==0 ){</Line>
  <Line number="19651">        if( i==nArg-1 ){</Line>
  <Line number="19652">          raw_printf(p-&gt;out, &quot;missing argument on \&quot;%s\&quot;\n&quot;, azArg[i]);</Line>
  <Line number="19653">          rc = 1;</Line>
  <Line number="19654">        }else{</Line>
  <Line number="19655">          oomRepeat = (int)integerValue(azArg[++i]);</Line>
  <Line number="19656">        }</Line>
  <Line number="19657">      }else if( IsDigit(z[0]) ){</Line>
  <Line number="19658">        oomCounter = (int)integerValue(azArg[i]);</Line>
  <Line number="19659">      }else{</Line>
  <Line number="19660">        raw_printf(p-&gt;out, &quot;unknown argument: \&quot;%s\&quot;\n&quot;, azArg[i]);</Line>
  <Line number="19661">        raw_printf(p-&gt;out, &quot;Usage: .oom [--repeat N] [M]\n&quot;);</Line>
  <Line number="19662">        rc = 1;</Line>
  <Line number="19663">      }</Line>
  <Line number="19664">    }</Line>
  <Line number="19665">    if( rc==0 ){</Line>
  <Line number="19666">      raw_printf(p-&gt;out, &quot;oomCounter = %d\n&quot;, oomCounter);</Line>
  <Line number="19667">      raw_printf(p-&gt;out, &quot;oomRepeat  = %d\n&quot;, oomRepeat);</Line>
  <Line number="19668">    }</Line>
  <Line number="19669">  }else</Line>
  <Line number="19670">#endif /* SQLITE_DEBUG */</Line>
  <Line number="19671"></Line>
  <Line number="19672">  if( c==&apos;o&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3910">]</CheckRefs>, &quot;open&quot;, <CheckRefs ids="3911">n</CheckRefs>)==0 &amp;&amp; n&gt;=2 ){</Line>
  <Line number="19673">    char *zNewFilename = 0;  /* Name of the database file to open */</Line>
  <Line number="19674">    int iName = 1;           /* Index in azArg[] of the filename */</Line>
  <Line number="19675">    int newFlag = 0;         /* True to delete file before opening */</Line>
  <Line number="19676">    /* Close the existing database */</Line>
  <Line number="19677">    session_close_all(p);</Line>
  <Line number="19678">    close_db(p-&gt;db);</Line>
  <Line number="19679">    p-&gt;db = 0;</Line>
  <Line number="19680">    p-&gt;zDbFilename = 0;</Line>
  <Line number="19681">    sqlite3_free(p-&gt;zFreeOnClose);</Line>
  <Line number="19682">    p-&gt;zFreeOnClose = 0;</Line>
  <Line number="19683">    p-&gt;openMode = <CheckRefs ids="3912">SHELL_OPEN_UNSPEC</CheckRefs>;</Line>
  <Line number="19684">    p-&gt;openFlags = 0;</Line>
  <Line number="19685">    p-&gt;szMax = <CheckRefs ids="3913">0</CheckRefs>;</Line>
  <Line number="19686">    /* Check for command-line arguments */</Line>
  <Line number="19687">    for(iName=1; iName&lt;nArg; iName<CheckRefs ids="3914">++</CheckRefs>){</Line>
  <Line number="19688">      const char *z = azArg[iName<CheckRefs ids="3915">]</CheckRefs>;</Line>
  <Line number="19689">      if( optionMatch(z,&quot;new&quot;) ){</Line>
  <Line number="19690">        newFlag = 1;</Line>
  <Line number="19691">#ifdef SQLITE_HAVE_ZLIB</Line>
  <Line number="19692">      }else if( optionMatch(z, &quot;zip&quot;) ){</Line>
  <Line number="19693">        p-&gt;openMode = SHELL_OPEN_ZIPFILE;</Line>
  <Line number="19694">#endif</Line>
  <Line number="19695">      }else if( optionMatch(z, &quot;append&quot;) ){</Line>
  <Line number="19696">        p-&gt;openMode = <CheckRefs ids="3916">SHELL_OPEN_APPENDVFS</CheckRefs>;</Line>
  <Line number="19697">      }else if( optionMatch(z, &quot;readonly&quot;) ){</Line>
  <Line number="19698">        p-&gt;openMode = <CheckRefs ids="3917">SHELL_OPEN_READONLY</CheckRefs>;</Line>
  <Line number="19699">      }else if( optionMatch(z, &quot;nofollow&quot;) ){</Line>
  <Line number="19700">        p-&gt;openFlags |= SQLITE_OPEN_NOFOLLOW;</Line>
  <Line number="19701">#ifndef SQLITE_OMIT_DESERIALIZE</Line>
  <Line number="19702">      }else if( optionMatch(z, &quot;deserialize&quot;) ){</Line>
  <Line number="19703">        p-&gt;openMode = <CheckRefs ids="3918">SHELL_OPEN_DESERIALIZE</CheckRefs>;</Line>
  <Line number="19704">      }else if( optionMatch(z, &quot;hexdb&quot;) ){</Line>
  <Line number="19705">        p-&gt;openMode = <CheckRefs ids="3919">SHELL_OPEN_HEXDB</CheckRefs>;</Line>
  <Line number="19706">      }else if( optionMatch(z, &quot;maxsize&quot;) &amp;&amp; iName<CheckRefs ids="3920">+</CheckRefs>1&lt;nArg ){</Line>
  <Line number="19707">        p-&gt;szMax = integerValue(azArg[<CheckRefs ids="3922">++</CheckRefs>iName<CheckRefs ids="3921">]</CheckRefs>);</Line>
  <Line number="19708">#endif /* SQLITE_OMIT_DESERIALIZE */</Line>
  <Line number="19709">      }else if( <CheckRefs ids="3923">z</CheckRefs>[0]==&apos;-&apos; ){</Line>
  <Line number="19710">        utf8_printf(stderr, &quot;unknown option: %s\n&quot;, z);</Line>
  <Line number="19711">        rc = 1;</Line>
  <Line number="19712">        goto meta_command_exit;</Line>
  <Line number="19713">      }else if( zNewFilename ){</Line>
  <Line number="19714">        utf8_printf(stderr, &quot;extra argument: \&quot;%s\&quot;\n&quot;, z);</Line>
  <Line number="19715">        rc = 1;</Line>
  <Line number="19716">        goto meta_command_exit;</Line>
  <Line number="19717">      }else{</Line>
  <Line number="19718">        zNewFilename = sqlite3_mprintf(&quot;%s&quot;, z);</Line>
  <Line number="19719">      }</Line>
  <Line number="19720">    }</Line>
  <Line number="19721">    /* If a filename is specified, try to open it first */</Line>
  <Line number="19722">    if( zNewFilename || <CheckRefs ids="3924">p</CheckRefs>-&gt;openMode==SHELL_OPEN_HEXDB ){</Line>
  <Line number="19723">      if( newFlag ) shellDeleteFile(zNewFilename);</Line>
  <Line number="19724">      p-&gt;zDbFilename = zNewFilename;</Line>
  <Line number="19725">      open_db(p, OPEN_DB_KEEPALIVE);</Line>
  <Line number="19726">      if( p-&gt;db==0 ){</Line>
  <Line number="19727">        utf8_printf(stderr, &quot;Error: cannot open &apos;%s&apos;\n&quot;, zNewFilename);</Line>
  <Line number="19728">        sqlite3_free(zNewFilename);</Line>
  <Line number="19729">      }else{</Line>
  <Line number="19730">        p-&gt;zFreeOnClose = zNewFilename;</Line>
  <Line number="19731">      }</Line>
  <Line number="19732">    }</Line>
  <Line number="19733">    if( p-&gt;db==0 ){</Line>
  <Line number="19734">      /* As a fall-back open a TEMP database */</Line>
  <Line number="19735">      p-&gt;zDbFilename = 0;</Line>
  <Line number="19736">      open_db(p, 0);</Line>
  <Line number="19737">    }</Line>
  <Line number="19738">  }else</Line>
  <Line number="19739"></Line>
  <Line number="19740">  if( (c==&apos;o&apos;</Line>
  <Line number="19741">        &amp;&amp; (strncmp(azArg[0<CheckRefs ids="3925">]</CheckRefs>, &quot;output&quot;, <CheckRefs ids="3926">n</CheckRefs>)==0||strncmp(azArg[0<CheckRefs ids="3927">]</CheckRefs>, &quot;once&quot;, <CheckRefs ids="3928">n</CheckRefs>)==0))</Line>
  <Line number="19742">   || (c==&apos;e&apos; &amp;&amp; n==5 &amp;&amp; strcmp(azArg[0<CheckRefs ids="3929">]</CheckRefs>,&quot;excel&quot;)==0)</Line>
  <Line number="19743">  ){</Line>
  <Line number="19744">    char *zFile = 0;</Line>
  <Line number="19745">    int bTxtMode = 0;</Line>
  <Line number="19746">    int i;</Line>
  <Line number="19747">    int eMode = 0;</Line>
  <Line number="19748">    int bBOM = 0;</Line>
  <Line number="19749">    int bOnce = 0;  /* 0: .output, 1: .once, 2: .excel */</Line>
  <Line number="19750"></Line>
  <Line number="19751">    if( c==&apos;e&apos; ){</Line>
  <Line number="19752">      eMode = &apos;x&apos;;</Line>
  <Line number="19753">      bOnce = 2;</Line>
  <Line number="19754">    }else if( strncmp(azArg[0<CheckRefs ids="3930">]</CheckRefs>,&quot;once&quot;,<CheckRefs ids="3931">n</CheckRefs>)==0 ){</Line>
  <Line number="19755">      bOnce = 1;</Line>
  <Line number="19756">    }</Line>
  <Line number="19757">    for(i=1; i&lt;nArg; i<CheckRefs ids="3932">++</CheckRefs>){</Line>
  <Line number="19758">      char *z = azArg[i<CheckRefs ids="3933">]</CheckRefs>;</Line>
  <Line number="19759">      if( <CheckRefs ids="3934">z</CheckRefs>[0]==&apos;-&apos; ){</Line>
  <Line number="19760">        if( <CheckRefs ids="3935">z</CheckRefs>[1]==&apos;-&apos; ) z++;</Line>
  <Line number="19761">        if( strcmp(z,&quot;-bom&quot;)==0 ){</Line>
  <Line number="19762">          bBOM = 1;</Line>
  <Line number="19763">        }else if( c!=&apos;e&apos; &amp;&amp; strcmp(z,&quot;-x&quot;)==0 ){</Line>
  <Line number="19764">          eMode = &apos;x&apos;;  /* spreadsheet */</Line>
  <Line number="19765">        }else if( c!=&apos;e&apos; &amp;&amp; strcmp(z,&quot;-e&quot;)==0 ){</Line>
  <Line number="19766">          eMode = &apos;e&apos;;  /* text editor */</Line>
  <Line number="19767">        }else{</Line>
  <Line number="19768">          utf8_printf(p-&gt;out, &quot;ERROR: unknown option: \&quot;%s\&quot;.  Usage:\n&quot;,</Line>
  <Line number="19769">                      azArg[i<CheckRefs ids="3936">]</CheckRefs>);</Line>
  <Line number="19770">          showHelp(p-&gt;out, azArg[0<CheckRefs ids="3937">]</CheckRefs>);</Line>
  <Line number="19771">          rc = 1;</Line>
  <Line number="19772">          goto meta_command_exit;</Line>
  <Line number="19773">        }</Line>
  <Line number="19774">      }else if( zFile==0 &amp;&amp; eMode!=&apos;e&apos; &amp;&amp; eMode!=&apos;x&apos; ){</Line>
  <Line number="19775">        zFile = sqlite3_mprintf(&quot;%s&quot;, z);</Line>
  <Line number="19776">        if( <CheckRefs ids="3938">zFile</CheckRefs>[0]==&apos;|&apos; ){</Line>
  <Line number="19777">          while( i<CheckRefs ids="3939">+</CheckRefs>1&lt;nArg ) zFile = sqlite3_mprintf(&quot;%z %s&quot;, zFile, azArg[<CheckRefs ids="3941">++</CheckRefs>i<CheckRefs ids="3940">]</CheckRefs>);</Line>
  <Line number="19778">          break;</Line>
  <Line number="19779">        }</Line>
  <Line number="19780">      }else{</Line>
  <Line number="19781">        utf8_printf(p-&gt;out,&quot;ERROR: extra parameter: \&quot;%s\&quot;.  Usage:\n&quot;,</Line>
  <Line number="19782">                    azArg[i<CheckRefs ids="3942">]</CheckRefs>);</Line>
  <Line number="19783">        showHelp(p-&gt;out, azArg[0<CheckRefs ids="3943">]</CheckRefs>);</Line>
  <Line number="19784">        rc = 1;</Line>
  <Line number="19785">        sqlite3_free(zFile);</Line>
  <Line number="19786">        goto meta_command_exit;</Line>
  <Line number="19787">      }</Line>
  <Line number="19788">    }</Line>
  <Line number="19789">    if( zFile==0 ) zFile = sqlite3_mprintf(&quot;stdout&quot;);</Line>
  <Line number="19790">    if( bOnce ){</Line>
  <Line number="19791">      p-&gt;outCount = 2;</Line>
  <Line number="19792">    }else{</Line>
  <Line number="19793">      p-&gt;outCount = 0;</Line>
  <Line number="19794">    }</Line>
  <Line number="19795">    output_reset(p);</Line>
  <Line number="19796">#ifndef SQLITE_NOHAVE_SYSTEM</Line>
  <Line number="19797">    if( eMode==&apos;e&apos; || eMode==&apos;x&apos; ){</Line>
  <Line number="19798">      p-&gt;doXdgOpen = <CheckRefs ids="3944">1</CheckRefs>;</Line>
  <Line number="19799">      outputModePush(p);</Line>
  <Line number="19800">      if( eMode==&apos;x&apos; ){</Line>
  <Line number="19801">        /* spreadsheet mode.  Output as CSV. */</Line>
  <Line number="19802">        newTempFile(p, &quot;csv&quot;);</Line>
  <Line number="19803">        <CheckRefs ids="3945">ShellClearFlag</CheckRefs>(p, SHFLG_Echo);</Line>
  <Line number="19804">        p-&gt;mode = MODE_Csv;</Line>
  <Line number="19805">        sqlite3_snprintf(<CheckRefs ids="3946">sizeof</CheckRefs>(p-&gt;colSeparator), p-&gt;colSeparator, SEP_Comma);</Line>
  <Line number="19806">        sqlite3_snprintf(<CheckRefs ids="3947">sizeof</CheckRefs>(p-&gt;rowSeparator), p-&gt;rowSeparator, SEP_CrLf);</Line>
  <Line number="19807">      }else{</Line>
  <Line number="19808">        /* text editor mode */</Line>
  <Line number="19809">        newTempFile(p, &quot;txt&quot;);</Line>
  <Line number="19810">        bTxtMode = 1;</Line>
  <Line number="19811">      }</Line>
  <Line number="19812">      sqlite3_free(zFile);</Line>
  <Line number="19813">      zFile = sqlite3_mprintf(&quot;%s&quot;, p-&gt;zTempFile);</Line>
  <Line number="19814">    }</Line>
  <Line number="19815">#endif /* SQLITE_NOHAVE_SYSTEM */</Line>
  <Line number="19816">    if( <CheckRefs ids="3948">zFile</CheckRefs>[0]==&apos;|&apos; ){</Line>
  <Line number="19817">#ifdef SQLITE_OMIT_POPEN</Line>
  <Line number="19818">      raw_printf(stderr, &quot;Error: pipes are not supported in this OS\n&quot;);</Line>
  <Line number="19819">      rc = 1;</Line>
  <Line number="19820">      p-&gt;out = stdout;</Line>
  <Line number="19821">#else</Line>
  <Line number="19822">      p-&gt;out = popen(zFile + 1, &quot;w&quot;);</Line>
  <Line number="19823">      if( p-&gt;out==0 ){</Line>
  <Line number="19824">        utf8_printf(stderr,&quot;Error: cannot open pipe \&quot;%s\&quot;\n&quot;, zFile + 1);</Line>
  <Line number="19825">        p-&gt;out = stdout;</Line>
  <Line number="19826">        rc = 1;</Line>
  <Line number="19827">      }else{</Line>
  <Line number="19828">        if( bBOM ) fprintf(p-&gt;out,&quot;\357\273\277&quot;);</Line>
  <Line number="19829">        sqlite3_snprintf(<CheckRefs ids="3949">sizeof</CheckRefs>(p-&gt;outfile), p-&gt;outfile, &quot;%s&quot;, zFile);</Line>
  <Line number="19830">      }</Line>
  <Line number="19831">#endif</Line>
  <Line number="19832">    }else{</Line>
  <Line number="19833">      p-&gt;out = output_file_open(zFile, bTxtMode);</Line>
  <Line number="19834">      if( p-&gt;out==0 ){</Line>
  <Line number="19835">        if( strcmp(zFile,&quot;off&quot;)!=0 ){</Line>
  <Line number="19836">          utf8_printf(stderr,&quot;Error: cannot write to \&quot;%s\&quot;\n&quot;, zFile);</Line>
  <Line number="19837">        }</Line>
  <Line number="19838">        p-&gt;out = stdout;</Line>
  <Line number="19839">        rc = 1;</Line>
  <Line number="19840">      } else {</Line>
  <Line number="19841">        if( bBOM ) fprintf(p-&gt;out,&quot;\357\273\277&quot;);</Line>
  <Line number="19842">        sqlite3_snprintf(<CheckRefs ids="3950">sizeof</CheckRefs>(p-&gt;outfile), p-&gt;outfile, &quot;%s&quot;, zFile);</Line>
  <Line number="19843">      }</Line>
  <Line number="19844">    }</Line>
  <Line number="19845">    sqlite3_free(zFile);</Line>
  <Line number="19846">  }else</Line>
  <Line number="19847"></Line>
  <Line number="19848">  if( c==&apos;p&apos; &amp;&amp; n&gt;=3 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3951">]</CheckRefs>, &quot;parameter&quot;, <CheckRefs ids="3952">n</CheckRefs>)==0 ){</Line>
  <Line number="19849">    open_db(p,0);</Line>
  <Line number="19850">    if( nArg&lt;=1 ) goto parameter_syntax_error;</Line>
  <Line number="19851"></Line>
  <Line number="19852">    /* .parameter clear</Line>
  <Line number="19853">    ** Clear all bind parameters by dropping the TEMP table that holds them.</Line>
  <Line number="19854">    */</Line>
  <Line number="19855">    if( nArg==2 &amp;&amp; strcmp(azArg[1<CheckRefs ids="3953">]</CheckRefs>,&quot;clear&quot;)==0 ){</Line>
  <Line number="19856">      sqlite3_exec(p-&gt;db, &quot;DROP TABLE IF EXISTS temp.sqlite_parameters;&quot;,</Line>
  <Line number="19857">                   0, 0, 0);</Line>
  <Line number="19858">    }else</Line>
  <Line number="19859"></Line>
  <Line number="19860">    /* .parameter list</Line>
  <Line number="19861">    ** List all bind parameters.</Line>
  <Line number="19862">    */</Line>
  <Line number="19863">    if( nArg==2 &amp;&amp; strcmp(azArg[1<CheckRefs ids="3954">]</CheckRefs>,&quot;list&quot;)==0 ){</Line>
  <Line number="19864">      sqlite3_stmt *pStmt = 0;</Line>
  <Line number="19865">      int rx;</Line>
  <Line number="19866">      int len = 0;</Line>
  <Line number="19867">      rx = sqlite3_prepare_v2(p-&gt;db,</Line>
  <Line number="19868">             &quot;SELECT max(length(key)) &quot;</Line>
  <Line number="19869">             &quot;FROM temp.sqlite_parameters;&quot;, <CheckRefs ids="3955">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="19870">      if( rx==SQLITE_OK &amp;&amp; sqlite3_step(pStmt)==SQLITE_ROW ){</Line>
  <Line number="19871">        len = sqlite3_column_int(pStmt, 0);</Line>
  <Line number="19872">        if( len&gt;40 ) len = 40;</Line>
  <Line number="19873">      }</Line>
  <Line number="19874">      sqlite3_finalize(pStmt);</Line>
  <Line number="19875">      pStmt = 0;</Line>
  <Line number="19876">      if( len ){</Line>
  <Line number="19877">        rx = sqlite3_prepare_v2(p-&gt;db,</Line>
  <Line number="19878">             &quot;SELECT key, quote(value) &quot;</Line>
  <Line number="19879">             &quot;FROM temp.sqlite_parameters;&quot;, <CheckRefs ids="3956">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="19880">        while( sqlite3_step(pStmt)==SQLITE_ROW ){</Line>
  <Line number="19881">          utf8_printf(p-&gt;out, &quot;%-*s %s\n&quot;, len, sqlite3_column_text(pStmt,0),</Line>
  <Line number="19882">                      sqlite3_column_text(pStmt,1));</Line>
  <Line number="19883">        }</Line>
  <Line number="19884">        sqlite3_finalize(pStmt);</Line>
  <Line number="19885">      }</Line>
  <Line number="19886">    }else</Line>
  <Line number="19887"></Line>
  <Line number="19888">    /* .parameter init</Line>
  <Line number="19889">    ** Make sure the TEMP table used to hold bind parameters exists.</Line>
  <Line number="19890">    ** Create it if necessary.</Line>
  <Line number="19891">    */</Line>
  <Line number="19892">    if( nArg==2 &amp;&amp; strcmp(azArg[1<CheckRefs ids="3957">]</CheckRefs>,&quot;init&quot;)==0 ){</Line>
  <Line number="19893">      bind_table_init(p);</Line>
  <Line number="19894">    }else</Line>
  <Line number="19895"></Line>
  <Line number="19896">    /* .parameter set NAME VALUE</Line>
  <Line number="19897">    ** Set or reset a bind parameter.  NAME should be the full parameter</Line>
  <Line number="19898">    ** name exactly as it appears in the query.  (ex: $abc, @def).  The</Line>
  <Line number="19899">    ** VALUE can be in either SQL literal notation, or if not it will be</Line>
  <Line number="19900">    ** understood to be a text string.</Line>
  <Line number="19901">    */</Line>
  <Line number="19902">    if( nArg==4 &amp;&amp; strcmp(azArg[1<CheckRefs ids="3958">]</CheckRefs>,&quot;set&quot;)==0 ){</Line>
  <Line number="19903">      int rx;</Line>
  <Line number="19904">      char *zSql;</Line>
  <Line number="19905">      sqlite3_stmt *pStmt;</Line>
  <Line number="19906">      const char *zKey = azArg[2<CheckRefs ids="3959">]</CheckRefs>;</Line>
  <Line number="19907">      const char *zValue = azArg[3<CheckRefs ids="3960">]</CheckRefs>;</Line>
  <Line number="19908">      bind_table_init(p);</Line>
  <Line number="19909">      zSql = sqlite3_mprintf(</Line>
  <Line number="19910">                  &quot;REPLACE INTO temp.sqlite_parameters(key,value)&quot;</Line>
  <Line number="19911">                  &quot;VALUES(%Q,%s);&quot;, zKey, zValue);</Line>
  <Line number="19912">      if( zSql==0 ) shell_out_of_memory();</Line>
  <Line number="19913">      pStmt = 0;</Line>
  <Line number="19914">      rx = sqlite3_prepare_v2(p-&gt;db, zSql, <CheckRefs ids="3961">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="19915">      sqlite3_free(zSql);</Line>
  <Line number="19916">      if( rx!=SQLITE_OK ){</Line>
  <Line number="19917">        sqlite3_finalize(pStmt);</Line>
  <Line number="19918">        pStmt = 0;</Line>
  <Line number="19919">        zSql = sqlite3_mprintf(</Line>
  <Line number="19920">                   &quot;REPLACE INTO temp.sqlite_parameters(key,value)&quot;</Line>
  <Line number="19921">                   &quot;VALUES(%Q,%Q);&quot;, zKey, zValue);</Line>
  <Line number="19922">        if( zSql==0 ) shell_out_of_memory();</Line>
  <Line number="19923">        rx = sqlite3_prepare_v2(p-&gt;db, zSql, <CheckRefs ids="3962">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="19924">        sqlite3_free(zSql);</Line>
  <Line number="19925">        if( rx!=SQLITE_OK ){</Line>
  <Line number="19926">          utf8_printf(p-&gt;out, &quot;Error: %s\n&quot;, sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="19927">          sqlite3_finalize(pStmt);</Line>
  <Line number="19928">          pStmt = 0;</Line>
  <Line number="19929">          rc = 1;</Line>
  <Line number="19930">        }</Line>
  <Line number="19931">      }</Line>
  <Line number="19932">      sqlite3_step(pStmt);</Line>
  <Line number="19933">      sqlite3_finalize(pStmt);</Line>
  <Line number="19934">    }else</Line>
  <Line number="19935"></Line>
  <Line number="19936">    /* .parameter unset NAME</Line>
  <Line number="19937">    ** Remove the NAME binding from the parameter binding table, if it</Line>
  <Line number="19938">    ** exists.</Line>
  <Line number="19939">    */</Line>
  <Line number="19940">    if( nArg==3 &amp;&amp; strcmp(azArg[1<CheckRefs ids="3963">]</CheckRefs>,&quot;unset&quot;)==0 ){</Line>
  <Line number="19941">      char *zSql = sqlite3_mprintf(</Line>
  <Line number="19942">          &quot;DELETE FROM temp.sqlite_parameters WHERE key=%Q&quot;, azArg[2<CheckRefs ids="3964">]</CheckRefs>);</Line>
  <Line number="19943">      if( zSql==0 ) shell_out_of_memory();</Line>
  <Line number="19944">      sqlite3_exec(p-&gt;db, zSql, 0, 0, 0);</Line>
  <Line number="19945">      sqlite3_free(zSql);</Line>
  <Line number="19946">    }else</Line>
  <Line number="19947">    /* If no command name matches, show a syntax error */</Line>
  <Line number="19948">    parameter_syntax_error:</Line>
  <Line number="19949">    showHelp(p-&gt;out, &quot;parameter&quot;);</Line>
  <Line number="19950">  }else</Line>
  <Line number="19951"></Line>
  <Line number="19952">  if( c==&apos;p&apos; &amp;&amp; n&gt;=3 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3965">]</CheckRefs>, &quot;print&quot;, <CheckRefs ids="3966">n</CheckRefs>)==0 ){</Line>
  <Line number="19953">    int i;</Line>
  <Line number="19954">    for(i=1; i&lt;nArg; i<CheckRefs ids="3967">++</CheckRefs>){</Line>
  <Line number="19955">      if( i&gt;1 ) raw_printf(p-&gt;out, &quot; &quot;);</Line>
  <Line number="19956">      utf8_printf(p-&gt;out, &quot;%s&quot;, azArg[i<CheckRefs ids="3968">]</CheckRefs>);</Line>
  <Line number="19957">    }</Line>
  <Line number="19958">    raw_printf(p-&gt;out, &quot;\n&quot;);</Line>
  <Line number="19959">  }else</Line>
  <Line number="19960"></Line>
  <Line number="19961">#ifndef SQLITE_OMIT_PROGRESS_CALLBACK</Line>
  <Line number="19962">  if( c==&apos;p&apos; &amp;&amp; n&gt;=3 &amp;&amp; strncmp(azArg[0<CheckRefs ids="3969">]</CheckRefs>, &quot;progress&quot;, <CheckRefs ids="3970">n</CheckRefs>)==0 ){</Line>
  <Line number="19963">    int i;</Line>
  <Line number="19964">    int nn = 0;</Line>
  <Line number="19965">    p-&gt;flgProgress = <CheckRefs ids="3971">0</CheckRefs>;</Line>
  <Line number="19966">    p-&gt;mxProgress = <CheckRefs ids="3972">0</CheckRefs>;</Line>
  <Line number="19967">    p-&gt;nProgress = <CheckRefs ids="3973">0</CheckRefs>;</Line>
  <Line number="19968">    for(i=1; i&lt;nArg; i<CheckRefs ids="3974">++</CheckRefs>){</Line>
  <Line number="19969">      const char *z = azArg[i<CheckRefs ids="3975">]</CheckRefs>;</Line>
  <Line number="19970">      if( <CheckRefs ids="3976">z</CheckRefs>[0]==&apos;-&apos; ){</Line>
  <Line number="19971">        z++;</Line>
  <Line number="19972">        if( <CheckRefs ids="3977">z</CheckRefs>[0]==&apos;-&apos; ) z++;</Line>
  <Line number="19973">        if( strcmp(z,&quot;quiet&quot;)==0 || strcmp(z,&quot;q&quot;)==0 ){</Line>
  <Line number="19974">          p-&gt;flgProgress |= <CheckRefs ids="3978">SHELL_PROGRESS_QUIET</CheckRefs>;</Line>
  <Line number="19975">          continue;</Line>
  <Line number="19976">        }</Line>
  <Line number="19977">        if( strcmp(z,&quot;reset&quot;)==0 ){</Line>
  <Line number="19978">          p-&gt;flgProgress |= <CheckRefs ids="3979">SHELL_PROGRESS_RESET</CheckRefs>;</Line>
  <Line number="19979">          continue;</Line>
  <Line number="19980">        }</Line>
  <Line number="19981">        if( strcmp(z,&quot;once&quot;)==0 ){</Line>
  <Line number="19982">          p-&gt;flgProgress |= <CheckRefs ids="3980">SHELL_PROGRESS_ONCE</CheckRefs>;</Line>
  <Line number="19983">          continue;</Line>
  <Line number="19984">        }</Line>
  <Line number="19985">        if( strcmp(z,&quot;limit&quot;)==0 ){</Line>
  <Line number="19986">          if( i<CheckRefs ids="3981">+</CheckRefs>1&gt;=nArg ){</Line>
  <Line number="19987">            utf8_printf(stderr, &quot;Error: missing argument on --limit\n&quot;);</Line>
  <Line number="19988">            rc = 1;</Line>
  <Line number="19989">            goto meta_command_exit;</Line>
  <Line number="19990">          }else{</Line>
  <Line number="19991">            p-&gt;mxProgress = <CheckRefs ids="3982,3983">(</CheckRefs>int)integerValue(azArg[<CheckRefs ids="3985">++</CheckRefs>i<CheckRefs ids="3984">]</CheckRefs>);</Line>
  <Line number="19992">          }</Line>
  <Line number="19993">          continue;</Line>
  <Line number="19994">        }</Line>
  <Line number="19995">        utf8_printf(stderr, &quot;Error: unknown option: \&quot;%s\&quot;\n&quot;, azArg[i<CheckRefs ids="3986">]</CheckRefs>);</Line>
  <Line number="19996">        rc = 1;</Line>
  <Line number="19997">        goto meta_command_exit;</Line>
  <Line number="19998">      }else{</Line>
  <Line number="19999">        nn = <CheckRefs ids="3987">(</CheckRefs>int)integerValue(z);</Line>
  <Line number="20000">      }</Line>
  <Line number="20001">    }</Line>
  <Line number="20002">    open_db(p, 0);</Line>
  <Line number="20003">    sqlite3_progress_handler(p-&gt;db, nn, progress_handler, p);</Line>
  <Line number="20004">  }else</Line>
  <Line number="20005">#endif /* SQLITE_OMIT_PROGRESS_CALLBACK */</Line>
  <Line number="20006"></Line>
  <Line number="20007">  if( c==&apos;p&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="3988">]</CheckRefs>, &quot;prompt&quot;, <CheckRefs ids="3989">n</CheckRefs>)==0 ){</Line>
  <Line number="20008">    if( nArg &gt;= 2) {</Line>
  <Line number="20009">      strncpy(mainPrompt,azArg[1<CheckRefs ids="3990">]</CheckRefs>,(int)<CheckRefs ids="3993,3994,3995">ArraySize</CheckRefs>(mainPrompt)<CheckRefs ids="3991,3992">-</CheckRefs>1);</Line>
  <Line number="20010">    }</Line>
  <Line number="20011">    if( nArg &gt;= 3) {</Line>
  <Line number="20012">      strncpy(continuePrompt,azArg[2<CheckRefs ids="3996">]</CheckRefs>,(int)<CheckRefs ids="3999,4000,4001">ArraySize</CheckRefs>(continuePrompt)<CheckRefs ids="3997,3998">-</CheckRefs>1);</Line>
  <Line number="20013">    }</Line>
  <Line number="20014">  }else</Line>
  <Line number="20015"></Line>
  <Line number="20016">  if( c==&apos;q&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="4002">]</CheckRefs>, &quot;quit&quot;, <CheckRefs ids="4003">n</CheckRefs>)==0 ){</Line>
  <Line number="20017">    rc = 2;</Line>
  <Line number="20018">  }else</Line>
  <Line number="20019"></Line>
  <Line number="20020">  if( c==&apos;r&apos; &amp;&amp; n&gt;=3 &amp;&amp; strncmp(azArg[0<CheckRefs ids="4004">]</CheckRefs>, &quot;read&quot;, <CheckRefs ids="4005">n</CheckRefs>)==0 ){</Line>
  <Line number="20021">    FILE *inSaved = p-&gt;in;</Line>
  <Line number="20022">    int savedLineno = p-&gt;lineno;</Line>
  <Line number="20023">    if( nArg!=2 ){</Line>
  <Line number="20024">      raw_printf(stderr, &quot;Usage: .read FILE\n&quot;);</Line>
  <Line number="20025">      rc = 1;</Line>
  <Line number="20026">      goto meta_command_exit;</Line>
  <Line number="20027">    }</Line>
  <Line number="20028">    if( <CheckRefs ids="4006">azArg</CheckRefs>[1<CheckRefs ids="4007">]</CheckRefs>[0]==&apos;|&apos; ){</Line>
  <Line number="20029">#ifdef SQLITE_OMIT_POPEN</Line>
  <Line number="20030">      raw_printf(stderr, &quot;Error: pipes are not supported in this OS\n&quot;);</Line>
  <Line number="20031">      rc = 1;</Line>
  <Line number="20032">      p-&gt;out = stdout;</Line>
  <Line number="20033">#else</Line>
  <Line number="20034">      p-&gt;in = popen(azArg[1<CheckRefs ids="4008">]</CheckRefs>+1, &quot;r&quot;);</Line>
  <Line number="20035">      if( p-&gt;in==0 ){</Line>
  <Line number="20036">        utf8_printf(stderr, &quot;Error: cannot open \&quot;%s\&quot;\n&quot;, azArg[1<CheckRefs ids="4009">]</CheckRefs>);</Line>
  <Line number="20037">        rc = 1;</Line>
  <Line number="20038">      }else{</Line>
  <Line number="20039">        rc = process_input(p);</Line>
  <Line number="20040">        pclose(p-&gt;in);</Line>
  <Line number="20041">      }</Line>
  <Line number="20042">#endif</Line>
  <Line number="20043">    }else if( notNormalFile(azArg[1<CheckRefs ids="4010">]</CheckRefs>) || (p-&gt;in = fopen(azArg[1<CheckRefs ids="4011">]</CheckRefs>, &quot;rb&quot;))==0 ){</Line>
  <Line number="20044">      utf8_printf(stderr,&quot;Error: cannot open \&quot;%s\&quot;\n&quot;, azArg[1<CheckRefs ids="4012">]</CheckRefs>);</Line>
  <Line number="20045">      rc = 1;</Line>
  <Line number="20046">    }else{</Line>
  <Line number="20047">      rc = process_input(p);</Line>
  <Line number="20048">      fclose(p-&gt;in);</Line>
  <Line number="20049">    }</Line>
  <Line number="20050">    p-&gt;in = inSaved;</Line>
  <Line number="20051">    p-&gt;lineno = savedLineno;</Line>
  <Line number="20052">  }else</Line>
  <Line number="20053"></Line>
  <Line number="20054">  if( c==&apos;r&apos; &amp;&amp; n&gt;=3 &amp;&amp; strncmp(azArg[0<CheckRefs ids="4013">]</CheckRefs>, &quot;restore&quot;, <CheckRefs ids="4014">n</CheckRefs>)==0 ){</Line>
  <Line number="20055">    const char *zSrcFile;</Line>
  <Line number="20056">    const char *zDb;</Line>
  <Line number="20057">    sqlite3 *pSrc;</Line>
  <Line number="20058">    sqlite3_backup *pBackup;</Line>
  <Line number="20059">    int nTimeout = 0;</Line>
  <Line number="20060"></Line>
  <Line number="20061">    if( nArg==2 ){</Line>
  <Line number="20062">      zSrcFile = azArg[1<CheckRefs ids="4015">]</CheckRefs>;</Line>
  <Line number="20063">      zDb = &quot;main&quot;;</Line>
  <Line number="20064">    }else if( nArg==3 ){</Line>
  <Line number="20065">      zSrcFile = azArg[2<CheckRefs ids="4016">]</CheckRefs>;</Line>
  <Line number="20066">      zDb = azArg[1<CheckRefs ids="4017">]</CheckRefs>;</Line>
  <Line number="20067">    }else{</Line>
  <Line number="20068">      raw_printf(stderr, &quot;Usage: .restore ?DB? FILE\n&quot;);</Line>
  <Line number="20069">      rc = 1;</Line>
  <Line number="20070">      goto meta_command_exit;</Line>
  <Line number="20071">    }</Line>
  <Line number="20072">    rc = sqlite3_open(zSrcFile, &amp;pSrc);</Line>
  <Line number="20073">    if( rc!=SQLITE_OK ){</Line>
  <Line number="20074">      utf8_printf(stderr, &quot;Error: cannot open \&quot;%s\&quot;\n&quot;, zSrcFile);</Line>
  <Line number="20075">      close_db(pSrc);</Line>
  <Line number="20076">      return 1;</Line>
  <Line number="20077">    }</Line>
  <Line number="20078">    open_db(p, 0);</Line>
  <Line number="20079">    pBackup = sqlite3_backup_init(p-&gt;db, zDb, pSrc, &quot;main&quot;);</Line>
  <Line number="20080">    if( pBackup==0 ){</Line>
  <Line number="20081">      utf8_printf(stderr, &quot;Error: %s\n&quot;, sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="20082">      close_db(pSrc);</Line>
  <Line number="20083">      return 1;</Line>
  <Line number="20084">    }</Line>
  <Line number="20085">    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK</Line>
  <Line number="20086">          || rc==SQLITE_BUSY  ){</Line>
  <Line number="20087">      if( rc==SQLITE_BUSY ){</Line>
  <Line number="20088">        if( nTimeout<CheckRefs ids="4018">++</CheckRefs> &gt;= 3 ) break;</Line>
  <Line number="20089">        sqlite3_sleep(100);</Line>
  <Line number="20090">      }</Line>
  <Line number="20091">    }</Line>
  <Line number="20092">    sqlite3_backup_finish(pBackup);</Line>
  <Line number="20093">    if( rc==SQLITE_DONE ){</Line>
  <Line number="20094">      rc = 0;</Line>
  <Line number="20095">    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){</Line>
  <Line number="20096">      raw_printf(stderr, &quot;Error: source database is busy\n&quot;);</Line>
  <Line number="20097">      rc = 1;</Line>
  <Line number="20098">    }else{</Line>
  <Line number="20099">      utf8_printf(stderr, &quot;Error: %s\n&quot;, sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="20100">      rc = 1;</Line>
  <Line number="20101">    }</Line>
  <Line number="20102">    close_db(pSrc);</Line>
  <Line number="20103">  }else</Line>
  <Line number="20104"></Line>
  <Line number="20105">  if( c==&apos;s&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="4019">]</CheckRefs>, &quot;scanstats&quot;, <CheckRefs ids="4020">n</CheckRefs>)==0 ){</Line>
  <Line number="20106">    if( nArg==2 ){</Line>
  <Line number="20107">      p-&gt;scanstatsOn = <CheckRefs ids="4021">(</CheckRefs>u8)booleanValue(azArg[1<CheckRefs ids="4022">]</CheckRefs>);</Line>
  <Line number="20108">#ifndef SQLITE_ENABLE_STMT_SCANSTATUS</Line>
  <Line number="20109">      raw_printf(stderr, &quot;Warning: .scanstats not available in this build.\n&quot;);</Line>
  <Line number="20110">#endif</Line>
  <Line number="20111">    }else{</Line>
  <Line number="20112">      raw_printf(stderr, &quot;Usage: .scanstats on|off\n&quot;);</Line>
  <Line number="20113">      rc = 1;</Line>
  <Line number="20114">    }</Line>
  <Line number="20115">  }else</Line>
  <Line number="20116"></Line>
  <Line number="20117">  if( c==&apos;s&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="4023">]</CheckRefs>, &quot;schema&quot;, <CheckRefs ids="4024">n</CheckRefs>)==0 ){</Line>
  <Line number="20118">    ShellText sSelect;</Line>
  <Line number="20119">    ShellState data;</Line>
  <Line number="20120">    char *zErrMsg = 0;</Line>
  <Line number="20121">    const char *zDiv = &quot;(&quot;;</Line>
  <Line number="20122">    const char *zName = 0;</Line>
  <Line number="20123">    int iSchema = 0;</Line>
  <Line number="20124">    int bDebug = 0;</Line>
  <Line number="20125">    int bNoSystemTabs = 0;</Line>
  <Line number="20126">    int ii;</Line>
  <Line number="20127"></Line>
  <Line number="20128">    open_db(p, 0);</Line>
  <Line number="20129">    memcpy(&amp;data, p, sizeof(data));</Line>
  <Line number="20130">    data.showHeader = 0;</Line>
  <Line number="20131">    data.cMode = data.mode = MODE_Semi;</Line>
  <Line number="20132">    initText(&amp;sSelect);</Line>
  <Line number="20133">    for(ii=1; ii&lt;nArg; ii<CheckRefs ids="4025">++</CheckRefs>){</Line>
  <Line number="20134">      if( optionMatch(azArg[ii<CheckRefs ids="4026">]</CheckRefs>,&quot;indent&quot;) ){</Line>
  <Line number="20135">        data.cMode = data.mode = MODE_Pretty;</Line>
  <Line number="20136">      }else if( optionMatch(azArg[ii<CheckRefs ids="4027">]</CheckRefs>,&quot;debug&quot;) ){</Line>
  <Line number="20137">        bDebug = 1;</Line>
  <Line number="20138">      }else if( optionMatch(azArg[ii<CheckRefs ids="4028">]</CheckRefs>,&quot;nosys&quot;) ){</Line>
  <Line number="20139">        bNoSystemTabs = 1;</Line>
  <Line number="20140">      }else if( <CheckRefs ids="4029">azArg</CheckRefs>[ii<CheckRefs ids="4030">]</CheckRefs>[0]==&apos;-&apos; ){</Line>
  <Line number="20141">        utf8_printf(stderr, &quot;Unknown option: \&quot;%s\&quot;\n&quot;, azArg[ii<CheckRefs ids="4031">]</CheckRefs>);</Line>
  <Line number="20142">        rc = 1;</Line>
  <Line number="20143">        goto meta_command_exit;</Line>
  <Line number="20144">      }else if( zName==0 ){</Line>
  <Line number="20145">        zName = azArg[ii<CheckRefs ids="4032">]</CheckRefs>;</Line>
  <Line number="20146">      }else{</Line>
  <Line number="20147">        raw_printf(stderr, &quot;Usage: .schema ?--indent? ?--nosys? ?LIKE-PATTERN?\n&quot;);</Line>
  <Line number="20148">        rc = 1;</Line>
  <Line number="20149">        goto meta_command_exit;</Line>
  <Line number="20150">      }</Line>
  <Line number="20151">    }</Line>
  <Line number="20152">    if( zName!=0 ){</Line>
  <Line number="20153">      int isSchema = sqlite3_strlike(zName, &quot;sqlite_master&quot;, <CheckRefs ids="4033">&apos;\\&apos;</CheckRefs>)==0</Line>
  <Line number="20154">                  || sqlite3_strlike(zName, &quot;sqlite_schema&quot;, <CheckRefs ids="4034">&apos;\\&apos;</CheckRefs>)==0</Line>
  <Line number="20155">                  || sqlite3_strlike(zName,&quot;sqlite_temp_master&quot;, <CheckRefs ids="4035">&apos;\\&apos;</CheckRefs>)==0</Line>
  <Line number="20156">                  || sqlite3_strlike(zName,&quot;sqlite_temp_schema&quot;, <CheckRefs ids="4036">&apos;\\&apos;</CheckRefs>)==0;</Line>
  <Line number="20157">      if( isSchema ){</Line>
  <Line number="20158">        char *new_argv[2], *new_colv[2];</Line>
  <Line number="20159">        new_argv[0<CheckRefs ids="4037">]</CheckRefs> = sqlite3_mprintf(</Line>
  <Line number="20160">                      &quot;CREATE TABLE %s (\n&quot;</Line>
  <Line number="20161">                      &quot;  type text,\n&quot;</Line>
  <Line number="20162">                      &quot;  name text,\n&quot;</Line>
  <Line number="20163">                      &quot;  tbl_name text,\n&quot;</Line>
  <Line number="20164">                      &quot;  rootpage integer,\n&quot;</Line>
  <Line number="20165">                      &quot;  sql text\n&quot;</Line>
  <Line number="20166">                      &quot;)&quot;, zName);</Line>
  <Line number="20167">        new_argv[1<CheckRefs ids="4038">]</CheckRefs> = 0;</Line>
  <Line number="20168">        new_colv[0<CheckRefs ids="4039">]</CheckRefs> = &quot;sql&quot;;</Line>
  <Line number="20169">        new_colv[1<CheckRefs ids="4040">]</CheckRefs> = 0;</Line>
  <Line number="20170">        callback(&amp;data, 1, new_argv, new_colv);</Line>
  <Line number="20171">        sqlite3_free(new_argv[0<CheckRefs ids="4041">]</CheckRefs>);</Line>
  <Line number="20172">      }</Line>
  <Line number="20173">    }</Line>
  <Line number="20174">    if( zDiv ){</Line>
  <Line number="20175">      sqlite3_stmt *pStmt = 0;</Line>
  <Line number="20176">      rc = sqlite3_prepare_v2(p-&gt;db, &quot;SELECT name FROM pragma_database_list&quot;,</Line>
  <Line number="20177">                              <CheckRefs ids="4042">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="20178">      if( rc ){</Line>
  <Line number="20179">        utf8_printf(stderr, &quot;Error: %s\n&quot;, sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="20180">        sqlite3_finalize(pStmt);</Line>
  <Line number="20181">        rc = 1;</Line>
  <Line number="20182">        goto meta_command_exit;</Line>
  <Line number="20183">      }</Line>
  <Line number="20184">      appendText(&amp;sSelect, &quot;SELECT sql FROM&quot;, <CheckRefs ids="4043">0</CheckRefs>);</Line>
  <Line number="20185">      iSchema = 0;</Line>
  <Line number="20186">      while( sqlite3_step(pStmt)==SQLITE_ROW ){</Line>
  <Line number="20187">        const char *zDb = (const char*)sqlite3_column_text(pStmt, 0);</Line>
  <Line number="20188">        char zScNum[30];</Line>
  <Line number="20189">        sqlite3_snprintf(<CheckRefs ids="4044">sizeof</CheckRefs>(zScNum), zScNum, &quot;%d&quot;, <CheckRefs ids="4045">++</CheckRefs>iSchema);</Line>
  <Line number="20190">        appendText(&amp;sSelect, zDiv, <CheckRefs ids="4046">0</CheckRefs>);</Line>
  <Line number="20191">        zDiv = &quot; UNION ALL &quot;;</Line>
  <Line number="20192">        appendText(&amp;sSelect, &quot;SELECT shell_add_schema(sql,&quot;, <CheckRefs ids="4047">0</CheckRefs>);</Line>
  <Line number="20193">        if( sqlite3_stricmp(zDb, &quot;main&quot;)!=0 ){</Line>
  <Line number="20194">          appendText(&amp;sSelect, zDb, <CheckRefs ids="4048">&apos;\&apos;&apos;</CheckRefs>);</Line>
  <Line number="20195">        }else{</Line>
  <Line number="20196">          appendText(&amp;sSelect, &quot;NULL&quot;, <CheckRefs ids="4049">0</CheckRefs>);</Line>
  <Line number="20197">        }</Line>
  <Line number="20198">        appendText(&amp;sSelect, &quot;,name) AS sql, type, tbl_name, name, rowid,&quot;, <CheckRefs ids="4050">0</CheckRefs>);</Line>
  <Line number="20199">        appendText(&amp;sSelect, zScNum, <CheckRefs ids="4051">0</CheckRefs>);</Line>
  <Line number="20200">        appendText(&amp;sSelect, &quot; AS snum, &quot;, <CheckRefs ids="4052">0</CheckRefs>);</Line>
  <Line number="20201">        appendText(&amp;sSelect, zDb, <CheckRefs ids="4053">&apos;\&apos;&apos;</CheckRefs>);</Line>
  <Line number="20202">        appendText(&amp;sSelect, &quot; AS sname FROM &quot;, <CheckRefs ids="4054">0</CheckRefs>);</Line>
  <Line number="20203">        appendText(&amp;sSelect, zDb, quoteChar(zDb));</Line>
  <Line number="20204">        appendText(&amp;sSelect, &quot;.sqlite_schema&quot;, <CheckRefs ids="4055">0</CheckRefs>);</Line>
  <Line number="20205">      }</Line>
  <Line number="20206">      sqlite3_finalize(pStmt);</Line>
  <Line number="20207">#ifndef SQLITE_OMIT_INTROSPECTION_PRAGMAS</Line>
  <Line number="20208">      if( zName ){</Line>
  <Line number="20209">        appendText(&amp;sSelect,</Line>
  <Line number="20210">           &quot; UNION ALL SELECT shell_module_schema(name),&quot;</Line>
  <Line number="20211">           &quot; &apos;table&apos;, name, name, name, 9e+99, &apos;main&apos; FROM pragma_module_list&quot;,</Line>
  <Line number="20212">        <CheckRefs ids="4056">0</CheckRefs>);</Line>
  <Line number="20213">      }</Line>
  <Line number="20214">#endif</Line>
  <Line number="20215">      appendText(&amp;sSelect, &quot;) WHERE &quot;, <CheckRefs ids="4057">0</CheckRefs>);</Line>
  <Line number="20216">      if( zName ){</Line>
  <Line number="20217">        char *zQarg = sqlite3_mprintf(&quot;%Q&quot;, zName);</Line>
  <Line number="20218">        int bGlob = strchr(zName, &apos;*&apos;) != 0 || strchr(zName, &apos;?&apos;) != 0 ||</Line>
  <Line number="20219">                    strchr(zName, &apos;[&apos;) != 0;</Line>
  <Line number="20220">        if( strchr(zName, &apos;.&apos;) ){</Line>
  <Line number="20221">          appendText(&amp;sSelect, &quot;lower(printf(&apos;%s.%s&apos;,sname,tbl_name))&quot;, <CheckRefs ids="4058">0</CheckRefs>);</Line>
  <Line number="20222">        }else{</Line>
  <Line number="20223">          appendText(&amp;sSelect, &quot;lower(tbl_name)&quot;, <CheckRefs ids="4059">0</CheckRefs>);</Line>
  <Line number="20224">        }</Line>
  <Line number="20225">        appendText(&amp;sSelect, bGlob ? &quot; GLOB &quot; : &quot; LIKE &quot;, <CheckRefs ids="4060">0</CheckRefs>);</Line>
  <Line number="20226">        appendText(&amp;sSelect, zQarg, <CheckRefs ids="4061">0</CheckRefs>);</Line>
  <Line number="20227">        if( !bGlob ){</Line>
  <Line number="20228">          appendText(&amp;sSelect, &quot; ESCAPE &apos;\\&apos; &quot;, <CheckRefs ids="4062">0</CheckRefs>);</Line>
  <Line number="20229">        }</Line>
  <Line number="20230">        appendText(&amp;sSelect, &quot; AND &quot;, <CheckRefs ids="4063">0</CheckRefs>);</Line>
  <Line number="20231">        sqlite3_free(zQarg);</Line>
  <Line number="20232">      }</Line>
  <Line number="20233">      if( bNoSystemTabs ){</Line>
  <Line number="20234">        appendText(&amp;sSelect, &quot;name NOT LIKE &apos;sqlite_%%&apos; AND &quot;, <CheckRefs ids="4064">0</CheckRefs>);</Line>
  <Line number="20235">      }</Line>
  <Line number="20236">      appendText(&amp;sSelect, &quot;sql IS NOT NULL&quot;</Line>
  <Line number="20237">                           &quot; ORDER BY snum, rowid&quot;, <CheckRefs ids="4065">0</CheckRefs>);</Line>
  <Line number="20238">      if( bDebug ){</Line>
  <Line number="20239">        utf8_printf(p-&gt;out, &quot;SQL: %s;\n&quot;, sSelect.z);</Line>
  <Line number="20240">      }else{</Line>
  <Line number="20241">        rc = sqlite3_exec(p-&gt;db, sSelect.z, callback, &amp;data, &amp;zErrMsg);</Line>
  <Line number="20242">      }</Line>
  <Line number="20243">      freeText(&amp;sSelect);</Line>
  <Line number="20244">    }</Line>
  <Line number="20245">    if( zErrMsg ){</Line>
  <Line number="20246">      utf8_printf(stderr,&quot;Error: %s\n&quot;, zErrMsg);</Line>
  <Line number="20247">      sqlite3_free(zErrMsg);</Line>
  <Line number="20248">      rc = 1;</Line>
  <Line number="20249">    }else if( rc != SQLITE_OK ){</Line>
  <Line number="20250">      raw_printf(stderr,&quot;Error: querying schema information\n&quot;);</Line>
  <Line number="20251">      rc = 1;</Line>
  <Line number="20252">    }else{</Line>
  <Line number="20253">      rc = 0;</Line>
  <Line number="20254">    }</Line>
  <Line number="20255">  }else</Line>
  <Line number="20256"></Line>
  <Line number="20257">  if( c==&apos;s&apos; &amp;&amp; n==11 &amp;&amp; strncmp(azArg[0<CheckRefs ids="4066">]</CheckRefs>, &quot;selecttrace&quot;, <CheckRefs ids="4067">n</CheckRefs>)==0 ){</Line>
  <Line number="20258">    unsigned int x = nArg&gt;=2 ? <CheckRefs ids="4068">(</CheckRefs>unsigned int)integerValue(azArg[1<CheckRefs ids="4069">]</CheckRefs>) : 0xffffffff;</Line>
  <Line number="20259">    sqlite3_test_control(SQLITE_TESTCTRL_TRACEFLAGS, 1, &amp;x);</Line>
  <Line number="20260">  }else</Line>
  <Line number="20261"></Line>
  <Line number="20262">#if defined(SQLITE_ENABLE_SESSION)</Line>
  <Line number="20263">  if( c==&apos;s&apos; &amp;&amp; strncmp(azArg[0],&quot;session&quot;,n)==0 &amp;&amp; n&gt;=3 ){</Line>
  <Line number="20264">    OpenSession *pSession = &amp;p-&gt;aSession[0];</Line>
  <Line number="20265">    char **azCmd = &amp;azArg[1];</Line>
  <Line number="20266">    int iSes = 0;</Line>
  <Line number="20267">    int nCmd = nArg - 1;</Line>
  <Line number="20268">    int i;</Line>
  <Line number="20269">    if( nArg&lt;=1 ) goto session_syntax_error;</Line>
  <Line number="20270">    open_db(p, 0);</Line>
  <Line number="20271">    if( nArg&gt;=3 ){</Line>
  <Line number="20272">      for(iSes=0; iSes&lt;p-&gt;nSession; iSes++){</Line>
  <Line number="20273">        if( strcmp(p-&gt;aSession[iSes].zName, azArg[1])==0 ) break;</Line>
  <Line number="20274">      }</Line>
  <Line number="20275">      if( iSes&lt;p-&gt;nSession ){</Line>
  <Line number="20276">        pSession = &amp;p-&gt;aSession[iSes];</Line>
  <Line number="20277">        azCmd++;</Line>
  <Line number="20278">        nCmd--;</Line>
  <Line number="20279">      }else{</Line>
  <Line number="20280">        pSession = &amp;p-&gt;aSession[0];</Line>
  <Line number="20281">        iSes = 0;</Line>
  <Line number="20282">      }</Line>
  <Line number="20283">    }</Line>
  <Line number="20284"></Line>
  <Line number="20285">    /* .session attach TABLE</Line>
  <Line number="20286">    ** Invoke the sqlite3session_attach() interface to attach a particular</Line>
  <Line number="20287">    ** table so that it is never filtered.</Line>
  <Line number="20288">    */</Line>
  <Line number="20289">    if( strcmp(azCmd[0],&quot;attach&quot;)==0 ){</Line>
  <Line number="20290">      if( nCmd!=2 ) goto session_syntax_error;</Line>
  <Line number="20291">      if( pSession-&gt;p==0 ){</Line>
  <Line number="20292">        session_not_open:</Line>
  <Line number="20293">        raw_printf(stderr, &quot;ERROR: No sessions are open\n&quot;);</Line>
  <Line number="20294">      }else{</Line>
  <Line number="20295">        rc = sqlite3session_attach(pSession-&gt;p, azCmd[1]);</Line>
  <Line number="20296">        if( rc ){</Line>
  <Line number="20297">          raw_printf(stderr, &quot;ERROR: sqlite3session_attach() returns %d\n&quot;, rc);</Line>
  <Line number="20298">          rc = 0;</Line>
  <Line number="20299">        }</Line>
  <Line number="20300">      }</Line>
  <Line number="20301">    }else</Line>
  <Line number="20302"></Line>
  <Line number="20303">    /* .session changeset FILE</Line>
  <Line number="20304">    ** .session patchset FILE</Line>
  <Line number="20305">    ** Write a changeset or patchset into a file.  The file is overwritten.</Line>
  <Line number="20306">    */</Line>
  <Line number="20307">    if( strcmp(azCmd[0],&quot;changeset&quot;)==0 || strcmp(azCmd[0],&quot;patchset&quot;)==0 ){</Line>
  <Line number="20308">      FILE *out = 0;</Line>
  <Line number="20309">      if( nCmd!=2 ) goto session_syntax_error;</Line>
  <Line number="20310">      if( pSession-&gt;p==0 ) goto session_not_open;</Line>
  <Line number="20311">      out = fopen(azCmd[1], &quot;wb&quot;);</Line>
  <Line number="20312">      if( out==0 ){</Line>
  <Line number="20313">        utf8_printf(stderr, &quot;ERROR: cannot open \&quot;%s\&quot; for writing\n&quot;,</Line>
  <Line number="20314">                    azCmd[1]);</Line>
  <Line number="20315">      }else{</Line>
  <Line number="20316">        int szChng;</Line>
  <Line number="20317">        void *pChng;</Line>
  <Line number="20318">        if( azCmd[0][0]==&apos;c&apos; ){</Line>
  <Line number="20319">          rc = sqlite3session_changeset(pSession-&gt;p, &amp;szChng, &amp;pChng);</Line>
  <Line number="20320">        }else{</Line>
  <Line number="20321">          rc = sqlite3session_patchset(pSession-&gt;p, &amp;szChng, &amp;pChng);</Line>
  <Line number="20322">        }</Line>
  <Line number="20323">        if( rc ){</Line>
  <Line number="20324">          printf(&quot;Error: error code %d\n&quot;, rc);</Line>
  <Line number="20325">          rc = 0;</Line>
  <Line number="20326">        }</Line>
  <Line number="20327">        if( pChng</Line>
  <Line number="20328">          &amp;&amp; fwrite(pChng, szChng, 1, out)!=1 ){</Line>
  <Line number="20329">          raw_printf(stderr, &quot;ERROR: Failed to write entire %d-byte output\n&quot;,</Line>
  <Line number="20330">                  szChng);</Line>
  <Line number="20331">        }</Line>
  <Line number="20332">        sqlite3_free(pChng);</Line>
  <Line number="20333">        fclose(out);</Line>
  <Line number="20334">      }</Line>
  <Line number="20335">    }else</Line>
  <Line number="20336"></Line>
  <Line number="20337">    /* .session close</Line>
  <Line number="20338">    ** Close the identified session</Line>
  <Line number="20339">    */</Line>
  <Line number="20340">    if( strcmp(azCmd[0], &quot;close&quot;)==0 ){</Line>
  <Line number="20341">      if( nCmd!=1 ) goto session_syntax_error;</Line>
  <Line number="20342">      if( p-&gt;nSession ){</Line>
  <Line number="20343">        session_close(pSession);</Line>
  <Line number="20344">        p-&gt;aSession[iSes] = p-&gt;aSession[--p-&gt;nSession];</Line>
  <Line number="20345">      }</Line>
  <Line number="20346">    }else</Line>
  <Line number="20347"></Line>
  <Line number="20348">    /* .session enable ?BOOLEAN?</Line>
  <Line number="20349">    ** Query or set the enable flag</Line>
  <Line number="20350">    */</Line>
  <Line number="20351">    if( strcmp(azCmd[0], &quot;enable&quot;)==0 ){</Line>
  <Line number="20352">      int ii;</Line>
  <Line number="20353">      if( nCmd&gt;2 ) goto session_syntax_error;</Line>
  <Line number="20354">      ii = nCmd==1 ? -1 : booleanValue(azCmd[1]);</Line>
  <Line number="20355">      if( p-&gt;nSession ){</Line>
  <Line number="20356">        ii = sqlite3session_enable(pSession-&gt;p, ii);</Line>
  <Line number="20357">        utf8_printf(p-&gt;out, &quot;session %s enable flag = %d\n&quot;,</Line>
  <Line number="20358">                    pSession-&gt;zName, ii);</Line>
  <Line number="20359">      }</Line>
  <Line number="20360">    }else</Line>
  <Line number="20361"></Line>
  <Line number="20362">    /* .session filter GLOB ....</Line>
  <Line number="20363">    ** Set a list of GLOB patterns of table names to be excluded.</Line>
  <Line number="20364">    */</Line>
  <Line number="20365">    if( strcmp(azCmd[0], &quot;filter&quot;)==0 ){</Line>
  <Line number="20366">      int ii, nByte;</Line>
  <Line number="20367">      if( nCmd&lt;2 ) goto session_syntax_error;</Line>
  <Line number="20368">      if( p-&gt;nSession ){</Line>
  <Line number="20369">        for(ii=0; ii&lt;pSession-&gt;nFilter; ii++){</Line>
  <Line number="20370">          sqlite3_free(pSession-&gt;azFilter[ii]);</Line>
  <Line number="20371">        }</Line>
  <Line number="20372">        sqlite3_free(pSession-&gt;azFilter);</Line>
  <Line number="20373">        nByte = sizeof(pSession-&gt;azFilter[0])*(nCmd-1);</Line>
  <Line number="20374">        pSession-&gt;azFilter = sqlite3_malloc( nByte );</Line>
  <Line number="20375">        if( pSession-&gt;azFilter==0 ){</Line>
  <Line number="20376">          raw_printf(stderr, &quot;Error: out or memory\n&quot;);</Line>
  <Line number="20377">          exit(1);</Line>
  <Line number="20378">        }</Line>
  <Line number="20379">        for(ii=1; ii&lt;nCmd; ii++){</Line>
  <Line number="20380">          pSession-&gt;azFilter[ii-1] = sqlite3_mprintf(&quot;%s&quot;, azCmd[ii]);</Line>
  <Line number="20381">        }</Line>
  <Line number="20382">        pSession-&gt;nFilter = ii-1;</Line>
  <Line number="20383">      }</Line>
  <Line number="20384">    }else</Line>
  <Line number="20385"></Line>
  <Line number="20386">    /* .session indirect ?BOOLEAN?</Line>
  <Line number="20387">    ** Query or set the indirect flag</Line>
  <Line number="20388">    */</Line>
  <Line number="20389">    if( strcmp(azCmd[0], &quot;indirect&quot;)==0 ){</Line>
  <Line number="20390">      int ii;</Line>
  <Line number="20391">      if( nCmd&gt;2 ) goto session_syntax_error;</Line>
  <Line number="20392">      ii = nCmd==1 ? -1 : booleanValue(azCmd[1]);</Line>
  <Line number="20393">      if( p-&gt;nSession ){</Line>
  <Line number="20394">        ii = sqlite3session_indirect(pSession-&gt;p, ii);</Line>
  <Line number="20395">        utf8_printf(p-&gt;out, &quot;session %s indirect flag = %d\n&quot;,</Line>
  <Line number="20396">                    pSession-&gt;zName, ii);</Line>
  <Line number="20397">      }</Line>
  <Line number="20398">    }else</Line>
  <Line number="20399"></Line>
  <Line number="20400">    /* .session isempty</Line>
  <Line number="20401">    ** Determine if the session is empty</Line>
  <Line number="20402">    */</Line>
  <Line number="20403">    if( strcmp(azCmd[0], &quot;isempty&quot;)==0 ){</Line>
  <Line number="20404">      int ii;</Line>
  <Line number="20405">      if( nCmd!=1 ) goto session_syntax_error;</Line>
  <Line number="20406">      if( p-&gt;nSession ){</Line>
  <Line number="20407">        ii = sqlite3session_isempty(pSession-&gt;p);</Line>
  <Line number="20408">        utf8_printf(p-&gt;out, &quot;session %s isempty flag = %d\n&quot;,</Line>
  <Line number="20409">                    pSession-&gt;zName, ii);</Line>
  <Line number="20410">      }</Line>
  <Line number="20411">    }else</Line>
  <Line number="20412"></Line>
  <Line number="20413">    /* .session list</Line>
  <Line number="20414">    ** List all currently open sessions</Line>
  <Line number="20415">    */</Line>
  <Line number="20416">    if( strcmp(azCmd[0],&quot;list&quot;)==0 ){</Line>
  <Line number="20417">      for(i=0; i&lt;p-&gt;nSession; i++){</Line>
  <Line number="20418">        utf8_printf(p-&gt;out, &quot;%d %s\n&quot;, i, p-&gt;aSession[i].zName);</Line>
  <Line number="20419">      }</Line>
  <Line number="20420">    }else</Line>
  <Line number="20421"></Line>
  <Line number="20422">    /* .session open DB NAME</Line>
  <Line number="20423">    ** Open a new session called NAME on the attached database DB.</Line>
  <Line number="20424">    ** DB is normally &quot;main&quot;.</Line>
  <Line number="20425">    */</Line>
  <Line number="20426">    if( strcmp(azCmd[0],&quot;open&quot;)==0 ){</Line>
  <Line number="20427">      char *zName;</Line>
  <Line number="20428">      if( nCmd!=3 ) goto session_syntax_error;</Line>
  <Line number="20429">      zName = azCmd[2];</Line>
  <Line number="20430">      if( zName[0]==0 ) goto session_syntax_error;</Line>
  <Line number="20431">      for(i=0; i&lt;p-&gt;nSession; i++){</Line>
  <Line number="20432">        if( strcmp(p-&gt;aSession[i].zName,zName)==0 ){</Line>
  <Line number="20433">          utf8_printf(stderr, &quot;Session \&quot;%s\&quot; already exists\n&quot;, zName);</Line>
  <Line number="20434">          goto meta_command_exit;</Line>
  <Line number="20435">        }</Line>
  <Line number="20436">      }</Line>
  <Line number="20437">      if( p-&gt;nSession&gt;=ArraySize(p-&gt;aSession) ){</Line>
  <Line number="20438">        raw_printf(stderr, &quot;Maximum of %d sessions\n&quot;, ArraySize(p-&gt;aSession));</Line>
  <Line number="20439">        goto meta_command_exit;</Line>
  <Line number="20440">      }</Line>
  <Line number="20441">      pSession = &amp;p-&gt;aSession[p-&gt;nSession];</Line>
  <Line number="20442">      rc = sqlite3session_create(p-&gt;db, azCmd[1], &amp;pSession-&gt;p);</Line>
  <Line number="20443">      if( rc ){</Line>
  <Line number="20444">        raw_printf(stderr, &quot;Cannot open session: error code=%d\n&quot;, rc);</Line>
  <Line number="20445">        rc = 0;</Line>
  <Line number="20446">        goto meta_command_exit;</Line>
  <Line number="20447">      }</Line>
  <Line number="20448">      pSession-&gt;nFilter = 0;</Line>
  <Line number="20449">      sqlite3session_table_filter(pSession-&gt;p, session_filter, pSession);</Line>
  <Line number="20450">      p-&gt;nSession++;</Line>
  <Line number="20451">      pSession-&gt;zName = sqlite3_mprintf(&quot;%s&quot;, zName);</Line>
  <Line number="20452">    }else</Line>
  <Line number="20453">    /* If no command name matches, show a syntax error */</Line>
  <Line number="20454">    session_syntax_error:</Line>
  <Line number="20455">    showHelp(p-&gt;out, &quot;session&quot;);</Line>
  <Line number="20456">  }else</Line>
  <Line number="20457">#endif</Line>
  <Line number="20458"></Line>
  <Line number="20459">#ifdef SQLITE_DEBUG</Line>
  <Line number="20460">  /* Undocumented commands for internal testing.  Subject to change</Line>
  <Line number="20461">  ** without notice. */</Line>
  <Line number="20462">  if( c==&apos;s&apos; &amp;&amp; n&gt;=10 &amp;&amp; strncmp(azArg[0], &quot;selftest-&quot;, 9)==0 ){</Line>
  <Line number="20463">    if( strncmp(azArg[0]+9, &quot;boolean&quot;, n-9)==0 ){</Line>
  <Line number="20464">      int i, v;</Line>
  <Line number="20465">      for(i=1; i&lt;nArg; i++){</Line>
  <Line number="20466">        v = booleanValue(azArg[i]);</Line>
  <Line number="20467">        utf8_printf(p-&gt;out, &quot;%s: %d 0x%x\n&quot;, azArg[i], v, v);</Line>
  <Line number="20468">      }</Line>
  <Line number="20469">    }</Line>
  <Line number="20470">    if( strncmp(azArg[0]+9, &quot;integer&quot;, n-9)==0 ){</Line>
  <Line number="20471">      int i; sqlite3_int64 v;</Line>
  <Line number="20472">      for(i=1; i&lt;nArg; i++){</Line>
  <Line number="20473">        char zBuf[200];</Line>
  <Line number="20474">        v = integerValue(azArg[i]);</Line>
  <Line number="20475">        sqlite3_snprintf(sizeof(zBuf),zBuf,&quot;%s: %lld 0x%llx\n&quot;, azArg[i],v,v);</Line>
  <Line number="20476">        utf8_printf(p-&gt;out, &quot;%s&quot;, zBuf);</Line>
  <Line number="20477">      }</Line>
  <Line number="20478">    }</Line>
  <Line number="20479">  }else</Line>
  <Line number="20480">#endif</Line>
  <Line number="20481"></Line>
  <Line number="20482">  if( c==&apos;s&apos; &amp;&amp; n&gt;=4 &amp;&amp; strncmp(azArg[0<CheckRefs ids="4070">]</CheckRefs>,&quot;selftest&quot;,<CheckRefs ids="4071">n</CheckRefs>)==0 ){</Line>
  <Line number="20483">    int bIsInit = 0;         /* True to initialize the SELFTEST table */</Line>
  <Line number="20484">    int bVerbose = 0;        /* Verbose output */</Line>
  <Line number="20485">    int bSelftestExists;     /* True if SELFTEST already exists */</Line>
  <Line number="20486">    int i, k;                /* Loop counters */</Line>
  <Line number="20487">    int nTest = 0;           /* Number of tests runs */</Line>
  <Line number="20488">    int nErr = 0;            /* Number of errors seen */</Line>
  <Line number="20489">    ShellText str;           /* Answer for a query */</Line>
  <Line number="20490">    sqlite3_stmt *pStmt = 0; /* Query against the SELFTEST table */</Line>
  <Line number="20491"></Line>
  <Line number="20492">    open_db(p,0);</Line>
  <Line number="20493">    for(i=1; i&lt;nArg; i<CheckRefs ids="4072">++</CheckRefs>){</Line>
  <Line number="20494">      const char *z = azArg[i<CheckRefs ids="4073">]</CheckRefs>;</Line>
  <Line number="20495">      if( <CheckRefs ids="4074">z</CheckRefs>[0]==&apos;-&apos; &amp;&amp; <CheckRefs ids="4075">z</CheckRefs>[1]==&apos;-&apos; ) z++;</Line>
  <Line number="20496">      if( strcmp(z,&quot;-init&quot;)==0 ){</Line>
  <Line number="20497">        bIsInit = 1;</Line>
  <Line number="20498">      }else</Line>
  <Line number="20499">      if( strcmp(z,&quot;-v&quot;)==0 ){</Line>
  <Line number="20500">        bVerbose<CheckRefs ids="4076">++</CheckRefs>;</Line>
  <Line number="20501">      }else</Line>
  <Line number="20502">      {</Line>
  <Line number="20503">        utf8_printf(stderr, &quot;Unknown option \&quot;%s\&quot; on \&quot;%s\&quot;\n&quot;,</Line>
  <Line number="20504">                    azArg[i<CheckRefs ids="4077">]</CheckRefs>, azArg[0<CheckRefs ids="4078">]</CheckRefs>);</Line>
  <Line number="20505">        raw_printf(stderr, &quot;Should be one of: --init -v\n&quot;);</Line>
  <Line number="20506">        rc = 1;</Line>
  <Line number="20507">        goto meta_command_exit;</Line>
  <Line number="20508">      }</Line>
  <Line number="20509">    }</Line>
  <Line number="20510">    if( sqlite3_table_column_metadata(p-&gt;db,&quot;main&quot;,&quot;selftest&quot;,0,0,0,0,0,0)</Line>
  <Line number="20511">           != SQLITE_OK ){</Line>
  <Line number="20512">      bSelftestExists = 0;</Line>
  <Line number="20513">    }else{</Line>
  <Line number="20514">      bSelftestExists = 1;</Line>
  <Line number="20515">    }</Line>
  <Line number="20516">    if( bIsInit ){</Line>
  <Line number="20517">      createSelftestTable(p);</Line>
  <Line number="20518">      bSelftestExists = 1;</Line>
  <Line number="20519">    }</Line>
  <Line number="20520">    initText(&amp;str);</Line>
  <Line number="20521">    appendText(&amp;str, &quot;x&quot;, <CheckRefs ids="4079">0</CheckRefs>);</Line>
  <Line number="20522">    for(k=bSelftestExists; k&gt;=0; k<CheckRefs ids="4080">--</CheckRefs>){</Line>
  <Line number="20523">      if( k==1 ){</Line>
  <Line number="20524">        rc = sqlite3_prepare_v2(p-&gt;db,</Line>
  <Line number="20525">            &quot;SELECT tno,op,cmd,ans FROM selftest ORDER BY tno&quot;,</Line>
  <Line number="20526">            <CheckRefs ids="4081">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="20527">      }else{</Line>
  <Line number="20528">        rc = sqlite3_prepare_v2(p-&gt;db,</Line>
  <Line number="20529">          &quot;VALUES(0,&apos;memo&apos;,&apos;Missing SELFTEST table - default checks only&apos;,&apos;&apos;),&quot;</Line>
  <Line number="20530">          &quot;      (1,&apos;run&apos;,&apos;PRAGMA integrity_check&apos;,&apos;ok&apos;)&quot;,</Line>
  <Line number="20531">          <CheckRefs ids="4082">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="20532">      }</Line>
  <Line number="20533">      if( rc ){</Line>
  <Line number="20534">        raw_printf(stderr, &quot;Error querying the selftest table\n&quot;);</Line>
  <Line number="20535">        rc = 1;</Line>
  <Line number="20536">        sqlite3_finalize(pStmt);</Line>
  <Line number="20537">        goto meta_command_exit;</Line>
  <Line number="20538">      }</Line>
  <Line number="20539">      for(i=1; sqlite3_step(pStmt)==SQLITE_ROW; i<CheckRefs ids="4083">++</CheckRefs>){</Line>
  <Line number="20540">        int tno = sqlite3_column_int(pStmt, 0);</Line>
  <Line number="20541">        const char *zOp = (const char*)sqlite3_column_text(pStmt, 1);</Line>
  <Line number="20542">        const char *zSql = (const char*)sqlite3_column_text(pStmt, 2);</Line>
  <Line number="20543">        const char *zAns = (const char*)sqlite3_column_text(pStmt, 3);</Line>
  <Line number="20544"></Line>
  <Line number="20545">        k = 0;</Line>
  <Line number="20546">        if( bVerbose&gt;0 ){</Line>
  <Line number="20547">          char *zQuote = sqlite3_mprintf(&quot;%q&quot;, zSql);</Line>
  <Line number="20548">          printf(&quot;%d: %s %s\n&quot;, tno, zOp, zSql);</Line>
  <Line number="20549">          sqlite3_free(zQuote);</Line>
  <Line number="20550">        }</Line>
  <Line number="20551">        if( strcmp(zOp,&quot;memo&quot;)==0 ){</Line>
  <Line number="20552">          utf8_printf(p-&gt;out, &quot;%s\n&quot;, zSql);</Line>
  <Line number="20553">        }else</Line>
  <Line number="20554">        if( strcmp(zOp,&quot;run&quot;)==0 ){</Line>
  <Line number="20555">          char *zErrMsg = 0;</Line>
  <Line number="20556">          str.n = 0;</Line>
  <Line number="20557">          str.z[0] = <CheckRefs ids="4084">0</CheckRefs>;</Line>
  <Line number="20558">          rc = sqlite3_exec(p-&gt;db, zSql, captureOutputCallback, &amp;str, &amp;zErrMsg);</Line>
  <Line number="20559">          nTest<CheckRefs ids="4085">++</CheckRefs>;</Line>
  <Line number="20560">          if( bVerbose ){</Line>
  <Line number="20561">            utf8_printf(p-&gt;out, &quot;Result: %s\n&quot;, str.z);</Line>
  <Line number="20562">          }</Line>
  <Line number="20563">          if( rc || zErrMsg ){</Line>
  <Line number="20564">            nErr<CheckRefs ids="4086">++</CheckRefs>;</Line>
  <Line number="20565">            rc = 1;</Line>
  <Line number="20566">            utf8_printf(p-&gt;out, &quot;%d: error-code-%d: %s\n&quot;, tno, rc, zErrMsg);</Line>
  <Line number="20567">            sqlite3_free(zErrMsg);</Line>
  <Line number="20568">          }else if( strcmp(zAns,str.z)!=0 ){</Line>
  <Line number="20569">            nErr<CheckRefs ids="4087">++</CheckRefs>;</Line>
  <Line number="20570">            rc = 1;</Line>
  <Line number="20571">            utf8_printf(p-&gt;out, &quot;%d: Expected: [%s]\n&quot;, tno, zAns);</Line>
  <Line number="20572">            utf8_printf(p-&gt;out, &quot;%d:      Got: [%s]\n&quot;, tno, str.z);</Line>
  <Line number="20573">          }</Line>
  <Line number="20574">        }else</Line>
  <Line number="20575">        {</Line>
  <Line number="20576">          utf8_printf(stderr,</Line>
  <Line number="20577">            &quot;Unknown operation \&quot;%s\&quot; on selftest line %d\n&quot;, zOp, tno);</Line>
  <Line number="20578">          rc = 1;</Line>
  <Line number="20579">          break;</Line>
  <Line number="20580">        }</Line>
  <Line number="20581">      } /* End loop over rows of content from SELFTEST */</Line>
  <Line number="20582">      sqlite3_finalize(pStmt);</Line>
  <Line number="20583">    } /* End loop over k */</Line>
  <Line number="20584">    freeText(&amp;str);</Line>
  <Line number="20585">    utf8_printf(p-&gt;out, &quot;%d errors out of %d tests\n&quot;, nErr, nTest);</Line>
  <Line number="20586">  }else</Line>
  <Line number="20587"></Line>
  <Line number="20588">  if( c==&apos;s&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="4088">]</CheckRefs>, &quot;separator&quot;, <CheckRefs ids="4089">n</CheckRefs>)==0 ){</Line>
  <Line number="20589">    if( nArg&lt;2 || nArg&gt;3 ){</Line>
  <Line number="20590">      raw_printf(stderr, &quot;Usage: .separator COL ?ROW?\n&quot;);</Line>
  <Line number="20591">      rc = 1;</Line>
  <Line number="20592">    }</Line>
  <Line number="20593">    if( nArg&gt;=2 ){</Line>
  <Line number="20594">      sqlite3_snprintf(<CheckRefs ids="4090">sizeof</CheckRefs>(p-&gt;colSeparator), p-&gt;colSeparator,</Line>
  <Line number="20595">                       &quot;%.*s&quot;, (int)<CheckRefs ids="4092,4093,4094">ArraySize</CheckRefs>(p-&gt;colSeparator)<CheckRefs ids="4091">-</CheckRefs>1, azArg[1<CheckRefs ids="4095">]</CheckRefs>);</Line>
  <Line number="20596">    }</Line>
  <Line number="20597">    if( nArg&gt;=3 ){</Line>
  <Line number="20598">      sqlite3_snprintf(<CheckRefs ids="4096">sizeof</CheckRefs>(p-&gt;rowSeparator), p-&gt;rowSeparator,</Line>
  <Line number="20599">                       &quot;%.*s&quot;, (int)<CheckRefs ids="4098,4099,4100">ArraySize</CheckRefs>(p-&gt;rowSeparator)<CheckRefs ids="4097">-</CheckRefs>1, azArg[2<CheckRefs ids="4101">]</CheckRefs>);</Line>
  <Line number="20600">    }</Line>
  <Line number="20601">  }else</Line>
  <Line number="20602"></Line>
  <Line number="20603">  if( c==&apos;s&apos; &amp;&amp; n&gt;=4 &amp;&amp; strncmp(azArg[0<CheckRefs ids="4102">]</CheckRefs>,&quot;sha3sum&quot;,<CheckRefs ids="4103">n</CheckRefs>)==0 ){</Line>
  <Line number="20604">    const char *zLike = 0;   /* Which table to checksum. 0 means everything */</Line>
  <Line number="20605">    int i;                   /* Loop counter */</Line>
  <Line number="20606">    int bSchema = 0;         /* Also hash the schema */</Line>
  <Line number="20607">    int bSeparate = 0;       /* Hash each table separately */</Line>
  <Line number="20608">    int iSize = 224;         /* Hash algorithm to use */</Line>
  <Line number="20609">    int bDebug = 0;          /* Only show the query that would have run */</Line>
  <Line number="20610">    sqlite3_stmt *pStmt;     /* For querying tables names */</Line>
  <Line number="20611">    char *zSql;              /* SQL to be run */</Line>
  <Line number="20612">    char *zSep;              /* Separator */</Line>
  <Line number="20613">    ShellText sSql;          /* Complete SQL for the query to run the hash */</Line>
  <Line number="20614">    ShellText sQuery;        /* Set of queries used to read all content */</Line>
  <Line number="20615">    open_db(p, 0);</Line>
  <Line number="20616">    for(i=1; i&lt;nArg; i<CheckRefs ids="4104">++</CheckRefs>){</Line>
  <Line number="20617">      const char *z = azArg[i<CheckRefs ids="4105">]</CheckRefs>;</Line>
  <Line number="20618">      if( <CheckRefs ids="4106">z</CheckRefs>[0]==&apos;-&apos; ){</Line>
  <Line number="20619">        z++;</Line>
  <Line number="20620">        if( <CheckRefs ids="4107">z</CheckRefs>[0]==&apos;-&apos; ) z++;</Line>
  <Line number="20621">        if( strcmp(z,&quot;schema&quot;)==0 ){</Line>
  <Line number="20622">          bSchema = 1;</Line>
  <Line number="20623">        }else</Line>
  <Line number="20624">        if( strcmp(z,&quot;sha3-224&quot;)==0 || strcmp(z,&quot;sha3-256&quot;)==0</Line>
  <Line number="20625">         || strcmp(z,&quot;sha3-384&quot;)==0 || strcmp(z,&quot;sha3-512&quot;)==0</Line>
  <Line number="20626">        ){</Line>
  <Line number="20627">          iSize = atoi(&amp;z[5]);</Line>
  <Line number="20628">        }else</Line>
  <Line number="20629">        if( strcmp(z,&quot;debug&quot;)==0 ){</Line>
  <Line number="20630">          bDebug = 1;</Line>
  <Line number="20631">        }else</Line>
  <Line number="20632">        {</Line>
  <Line number="20633">          utf8_printf(stderr, &quot;Unknown option \&quot;%s\&quot; on \&quot;%s\&quot;\n&quot;,</Line>
  <Line number="20634">                      azArg[i<CheckRefs ids="4108">]</CheckRefs>, azArg[0<CheckRefs ids="4109">]</CheckRefs>);</Line>
  <Line number="20635">          showHelp(p-&gt;out, azArg[0<CheckRefs ids="4110">]</CheckRefs>);</Line>
  <Line number="20636">          rc = 1;</Line>
  <Line number="20637">          goto meta_command_exit;</Line>
  <Line number="20638">        }</Line>
  <Line number="20639">      }else if( zLike ){</Line>
  <Line number="20640">        raw_printf(stderr, &quot;Usage: .sha3sum ?OPTIONS? ?LIKE-PATTERN?\n&quot;);</Line>
  <Line number="20641">        rc = 1;</Line>
  <Line number="20642">        goto meta_command_exit;</Line>
  <Line number="20643">      }else{</Line>
  <Line number="20644">        zLike = z;</Line>
  <Line number="20645">        bSeparate = 1;</Line>
  <Line number="20646">        if( sqlite3_strlike(&quot;sqlite\\_%&quot;, zLike, <CheckRefs ids="4111">&apos;\\&apos;</CheckRefs>)==0 ) bSchema = 1;</Line>
  <Line number="20647">      }</Line>
  <Line number="20648">    }</Line>
  <Line number="20649">    if( bSchema ){</Line>
  <Line number="20650">      zSql = &quot;SELECT lower(name) FROM sqlite_schema&quot;</Line>
  <Line number="20651">             &quot; WHERE type=&apos;table&apos; AND coalesce(rootpage,0)&gt;1&quot;</Line>
  <Line number="20652">             &quot; UNION ALL SELECT &apos;sqlite_schema&apos;&quot;</Line>
  <Line number="20653">             &quot; ORDER BY 1 collate nocase&quot;;</Line>
  <Line number="20654">    }else{</Line>
  <Line number="20655">      zSql = &quot;SELECT lower(name) FROM sqlite_schema&quot;</Line>
  <Line number="20656">             &quot; WHERE type=&apos;table&apos; AND coalesce(rootpage,0)&gt;1&quot;</Line>
  <Line number="20657">             &quot; AND name NOT LIKE &apos;sqlite_%&apos;&quot;</Line>
  <Line number="20658">             &quot; ORDER BY 1 collate nocase&quot;;</Line>
  <Line number="20659">    }</Line>
  <Line number="20660">    sqlite3_prepare_v2(p-&gt;db, zSql, <CheckRefs ids="4112">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="20661">    initText(&amp;sQuery);</Line>
  <Line number="20662">    initText(&amp;sSql);</Line>
  <Line number="20663">    appendText(&amp;sSql, &quot;WITH [sha3sum$query](a,b) AS(&quot;,<CheckRefs ids="4113">0</CheckRefs>);</Line>
  <Line number="20664">    zSep = &quot;VALUES(&quot;;</Line>
  <Line number="20665">    while( SQLITE_ROW==sqlite3_step(pStmt) ){</Line>
  <Line number="20666">      const char *zTab = (const char*)sqlite3_column_text(pStmt,0);</Line>
  <Line number="20667">      if( zLike &amp;&amp; sqlite3_strlike(zLike, zTab, <CheckRefs ids="4114">0</CheckRefs>)!=0 ) continue;</Line>
  <Line number="20668">      if( strncmp(zTab, &quot;sqlite_&quot;,<CheckRefs ids="4115">7</CheckRefs>)!=0 ){</Line>
  <Line number="20669">        appendText(&amp;sQuery,&quot;SELECT * FROM &quot;, <CheckRefs ids="4116">0</CheckRefs>);</Line>
  <Line number="20670">        appendText(&amp;sQuery,zTab,<CheckRefs ids="4117">&apos;&quot;&apos;</CheckRefs>);</Line>
  <Line number="20671">        appendText(&amp;sQuery,&quot; NOT INDEXED;&quot;, <CheckRefs ids="4118">0</CheckRefs>);</Line>
  <Line number="20672">      }else if( strcmp(zTab, &quot;sqlite_schema&quot;)==0 ){</Line>
  <Line number="20673">        appendText(&amp;sQuery,&quot;SELECT type,name,tbl_name,sql FROM sqlite_schema&quot;</Line>
  <Line number="20674">                           &quot; ORDER BY name;&quot;, <CheckRefs ids="4119">0</CheckRefs>);</Line>
  <Line number="20675">      }else if( strcmp(zTab, &quot;sqlite_sequence&quot;)==0 ){</Line>
  <Line number="20676">        appendText(&amp;sQuery,&quot;SELECT name,seq FROM sqlite_sequence&quot;</Line>
  <Line number="20677">                           &quot; ORDER BY name;&quot;, <CheckRefs ids="4120">0</CheckRefs>);</Line>
  <Line number="20678">      }else if( strcmp(zTab, &quot;sqlite_stat1&quot;)==0 ){</Line>
  <Line number="20679">        appendText(&amp;sQuery,&quot;SELECT tbl,idx,stat FROM sqlite_stat1&quot;</Line>
  <Line number="20680">                           &quot; ORDER BY tbl,idx;&quot;, <CheckRefs ids="4121">0</CheckRefs>);</Line>
  <Line number="20681">      }else if( strcmp(zTab, &quot;sqlite_stat4&quot;)==0 ){</Line>
  <Line number="20682">        appendText(&amp;sQuery, &quot;SELECT * FROM &quot;, <CheckRefs ids="4122">0</CheckRefs>);</Line>
  <Line number="20683">        appendText(&amp;sQuery, zTab, <CheckRefs ids="4123">0</CheckRefs>);</Line>
  <Line number="20684">        appendText(&amp;sQuery, &quot; ORDER BY tbl, idx, rowid;\n&quot;, <CheckRefs ids="4124">0</CheckRefs>);</Line>
  <Line number="20685">      }</Line>
  <Line number="20686">      appendText(&amp;sSql, zSep, <CheckRefs ids="4125">0</CheckRefs>);</Line>
  <Line number="20687">      appendText(&amp;sSql, sQuery.z, <CheckRefs ids="4126">&apos;\&apos;&apos;</CheckRefs>);</Line>
  <Line number="20688">      sQuery.n = 0;</Line>
  <Line number="20689">      appendText(&amp;sSql, &quot;,&quot;, <CheckRefs ids="4127">0</CheckRefs>);</Line>
  <Line number="20690">      appendText(&amp;sSql, zTab, <CheckRefs ids="4128">&apos;\&apos;&apos;</CheckRefs>);</Line>
  <Line number="20691">      zSep = &quot;),(&quot;;</Line>
  <Line number="20692">    }</Line>
  <Line number="20693">    sqlite3_finalize(pStmt);</Line>
  <Line number="20694">    if( bSeparate ){</Line>
  <Line number="20695">      zSql = sqlite3_mprintf(</Line>
  <Line number="20696">          &quot;%s))&quot;</Line>
  <Line number="20697">          &quot; SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label&quot;</Line>
  <Line number="20698">          &quot;   FROM [sha3sum$query]&quot;,</Line>
  <Line number="20699">          sSql.z, iSize);</Line>
  <Line number="20700">    }else{</Line>
  <Line number="20701">      zSql = sqlite3_mprintf(</Line>
  <Line number="20702">          &quot;%s))&quot;</Line>
  <Line number="20703">          &quot; SELECT lower(hex(sha3_query(group_concat(a,&apos;&apos;),%d))) AS hash&quot;</Line>
  <Line number="20704">          &quot;   FROM [sha3sum$query]&quot;,</Line>
  <Line number="20705">          sSql.z, iSize);</Line>
  <Line number="20706">    }</Line>
  <Line number="20707">    freeText(&amp;sQuery);</Line>
  <Line number="20708">    freeText(&amp;sSql);</Line>
  <Line number="20709">    if( bDebug ){</Line>
  <Line number="20710">      utf8_printf(p-&gt;out, &quot;%s\n&quot;, zSql);</Line>
  <Line number="20711">    }else{</Line>
  <Line number="20712">      shell_exec(p, zSql, 0);</Line>
  <Line number="20713">    }</Line>
  <Line number="20714">    sqlite3_free(zSql);</Line>
  <Line number="20715">  }else</Line>
  <Line number="20716"></Line>
  <Line number="20717">#ifndef SQLITE_NOHAVE_SYSTEM</Line>
  <Line number="20718">  if( c==&apos;s&apos;</Line>
  <Line number="20719">   &amp;&amp; (strncmp(azArg[0<CheckRefs ids="4129">]</CheckRefs>, &quot;shell&quot;, <CheckRefs ids="4130">n</CheckRefs>)==0 || strncmp(azArg[0<CheckRefs ids="4131">]</CheckRefs>,&quot;system&quot;,<CheckRefs ids="4132">n</CheckRefs>)==0)</Line>
  <Line number="20720">  ){</Line>
  <Line number="20721">    char *zCmd;</Line>
  <Line number="20722">    int i, x;</Line>
  <Line number="20723">    if( nArg&lt;2 ){</Line>
  <Line number="20724">      raw_printf(stderr, &quot;Usage: .system COMMAND\n&quot;);</Line>
  <Line number="20725">      rc = 1;</Line>
  <Line number="20726">      goto meta_command_exit;</Line>
  <Line number="20727">    }</Line>
  <Line number="20728">    zCmd = sqlite3_mprintf(strchr(azArg[1<CheckRefs ids="4133">]</CheckRefs>,&apos; &apos;)==0?&quot;%s&quot;:&quot;\&quot;%s\&quot;&quot;, azArg[1<CheckRefs ids="4134">]</CheckRefs>);</Line>
  <Line number="20729">    for(i=2; i&lt;nArg; i<CheckRefs ids="4135">++</CheckRefs>){</Line>
  <Line number="20730">      zCmd = sqlite3_mprintf(strchr(azArg[i<CheckRefs ids="4136">]</CheckRefs>,&apos; &apos;)==0?&quot;%z %s&quot;:&quot;%z \&quot;%s\&quot;&quot;,</Line>
  <Line number="20731">                             zCmd, azArg[i<CheckRefs ids="4137">]</CheckRefs>);</Line>
  <Line number="20732">    }</Line>
  <Line number="20733">    x = system(zCmd);</Line>
  <Line number="20734">    sqlite3_free(zCmd);</Line>
  <Line number="20735">    if( x ) raw_printf(stderr, &quot;System command returns %d\n&quot;, x);</Line>
  <Line number="20736">  }else</Line>
  <Line number="20737">#endif /* !defined(SQLITE_NOHAVE_SYSTEM) */</Line>
  <Line number="20738"></Line>
  <Line number="20739">  if( c==&apos;s&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="4138">]</CheckRefs>, &quot;show&quot;, <CheckRefs ids="4139">n</CheckRefs>)==0 ){</Line>
  <Line number="20740">    static const char *azBool[] = { &quot;off&quot;, &quot;on&quot;, &quot;trigger&quot;, &quot;full&quot;};</Line>
  <Line number="20741">    const char *zOut;</Line>
  <Line number="20742">    int i;</Line>
  <Line number="20743">    if( nArg!=1 ){</Line>
  <Line number="20744">      raw_printf(stderr, &quot;Usage: .show\n&quot;);</Line>
  <Line number="20745">      rc = 1;</Line>
  <Line number="20746">      goto meta_command_exit;</Line>
  <Line number="20747">    }</Line>
  <Line number="20748">    utf8_printf(p-&gt;out, &quot;%12.12s: %s\n&quot;,&quot;echo&quot;,</Line>
  <Line number="20749">                                  azBool[<CheckRefs ids="4141,4142">ShellHasFlag</CheckRefs>(p, SHFLG_Echo)<CheckRefs ids="4140">]</CheckRefs>);</Line>
  <Line number="20750">    utf8_printf(p-&gt;out, &quot;%12.12s: %s\n&quot;,&quot;eqp&quot;, azBool[<CheckRefs ids="4144">p</CheckRefs>-&gt;autoEQP&amp;3<CheckRefs ids="4143">]</CheckRefs>);</Line>
  <Line number="20751">    utf8_printf(p-&gt;out, &quot;%12.12s: %s\n&quot;,&quot;explain&quot;,</Line>
  <Line number="20752">         p-&gt;mode==MODE_Explain ? &quot;on&quot; : <CheckRefs ids="4145">p</CheckRefs>-&gt;autoExplain ? &quot;auto&quot; : &quot;off&quot;);</Line>
  <Line number="20753">    utf8_printf(p-&gt;out,&quot;%12.12s: %s\n&quot;,&quot;headers&quot;, azBool[p-&gt;showHeader!=0<CheckRefs ids="4146">]</CheckRefs>);</Line>
  <Line number="20754">    utf8_printf(p-&gt;out, &quot;%12.12s: %s\n&quot;,&quot;mode&quot;, modeDescr[p-&gt;mode<CheckRefs ids="4147">]</CheckRefs>);</Line>
  <Line number="20755">    utf8_printf(p-&gt;out, &quot;%12.12s: &quot;, &quot;nullvalue&quot;);</Line>
  <Line number="20756">      output_c_string(p-&gt;out, p-&gt;nullValue);</Line>
  <Line number="20757">      raw_printf(p-&gt;out, &quot;\n&quot;);</Line>
  <Line number="20758">    utf8_printf(p-&gt;out,&quot;%12.12s: %s\n&quot;,&quot;output&quot;,</Line>
  <Line number="20759">            strlen30(p-&gt;outfile) ? p-&gt;outfile : &quot;stdout&quot;);</Line>
  <Line number="20760">    utf8_printf(p-&gt;out,&quot;%12.12s: &quot;, &quot;colseparator&quot;);</Line>
  <Line number="20761">      output_c_string(p-&gt;out, p-&gt;colSeparator);</Line>
  <Line number="20762">      raw_printf(p-&gt;out, &quot;\n&quot;);</Line>
  <Line number="20763">    utf8_printf(p-&gt;out,&quot;%12.12s: &quot;, &quot;rowseparator&quot;);</Line>
  <Line number="20764">      output_c_string(p-&gt;out, p-&gt;rowSeparator);</Line>
  <Line number="20765">      raw_printf(p-&gt;out, &quot;\n&quot;);</Line>
  <Line number="20766">    switch( p-&gt;statsOn ){</Line>
  <Line number="20767">      case <CheckRefs ids="4148">0</CheckRefs>:  zOut = &quot;off&quot;;     break;</Line>
  <Line number="20768">      default: zOut = &quot;on&quot;;      break;</Line>
  <Line number="20769">      case <CheckRefs ids="4149">2</CheckRefs>:  zOut = &quot;stmt&quot;;    break;</Line>
  <Line number="20770">      case <CheckRefs ids="4150">3</CheckRefs>:  zOut = &quot;vmstep&quot;;  break;</Line>
  <Line number="20771">    }</Line>
  <Line number="20772">    utf8_printf(p-&gt;out, &quot;%12.12s: %s\n&quot;,&quot;stats&quot;, zOut);</Line>
  <Line number="20773">    utf8_printf(p-&gt;out, &quot;%12.12s: &quot;, &quot;width&quot;);</Line>
  <Line number="20774">    for (i=0;i&lt;p-&gt;nWidth;i<CheckRefs ids="4151">++</CheckRefs>) {</Line>
  <Line number="20775">      raw_printf(p-&gt;out, &quot;%d &quot;, p-&gt;colWidth[i]);</Line>
  <Line number="20776">    }</Line>
  <Line number="20777">    raw_printf(p-&gt;out, &quot;\n&quot;);</Line>
  <Line number="20778">    utf8_printf(p-&gt;out, &quot;%12.12s: %s\n&quot;, &quot;filename&quot;,</Line>
  <Line number="20779">                p-&gt;zDbFilename ? p-&gt;zDbFilename : &quot;&quot;);</Line>
  <Line number="20780">  }else</Line>
  <Line number="20781"></Line>
  <Line number="20782">  if( c==&apos;s&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="4152">]</CheckRefs>, &quot;stats&quot;, <CheckRefs ids="4153">n</CheckRefs>)==0 ){</Line>
  <Line number="20783">    if( nArg==2 ){</Line>
  <Line number="20784">      if( strcmp(azArg[1<CheckRefs ids="4154">]</CheckRefs>,&quot;stmt&quot;)==0 ){</Line>
  <Line number="20785">        p-&gt;statsOn = <CheckRefs ids="4155">2</CheckRefs>;</Line>
  <Line number="20786">      }else if( strcmp(azArg[1<CheckRefs ids="4156">]</CheckRefs>,&quot;vmstep&quot;)==0 ){</Line>
  <Line number="20787">        p-&gt;statsOn = <CheckRefs ids="4157">3</CheckRefs>;</Line>
  <Line number="20788">      }else{</Line>
  <Line number="20789">        p-&gt;statsOn = <CheckRefs ids="4158,4159">(</CheckRefs>u8)booleanValue(azArg[1<CheckRefs ids="4160">]</CheckRefs>);</Line>
  <Line number="20790">      }</Line>
  <Line number="20791">    }else if( nArg==1 ){</Line>
  <Line number="20792">      display_stats(p-&gt;db, p, 0);</Line>
  <Line number="20793">    }else{</Line>
  <Line number="20794">      raw_printf(stderr, &quot;Usage: .stats ?on|off|stmt|vmstep?\n&quot;);</Line>
  <Line number="20795">      rc = 1;</Line>
  <Line number="20796">    }</Line>
  <Line number="20797">  }else</Line>
  <Line number="20798"></Line>
  <Line number="20799">  if( (c==&apos;t&apos; &amp;&amp; n&gt;1 &amp;&amp; strncmp(azArg[0<CheckRefs ids="4161">]</CheckRefs>, &quot;tables&quot;, <CheckRefs ids="4162">n</CheckRefs>)==0)</Line>
  <Line number="20800">   || (c==&apos;i&apos; &amp;&amp; (strncmp(azArg[0<CheckRefs ids="4163">]</CheckRefs>, &quot;indices&quot;, <CheckRefs ids="4164">n</CheckRefs>)==0</Line>
  <Line number="20801">                 || strncmp(azArg[0<CheckRefs ids="4165">]</CheckRefs>, &quot;indexes&quot;, <CheckRefs ids="4166">n</CheckRefs>)==0) )</Line>
  <Line number="20802">  ){</Line>
  <Line number="20803">    sqlite3_stmt *pStmt;</Line>
  <Line number="20804">    char **azResult;</Line>
  <Line number="20805">    int nRow, nAlloc;</Line>
  <Line number="20806">    int ii;</Line>
  <Line number="20807">    ShellText s;</Line>
  <Line number="20808">    initText(&amp;s);</Line>
  <Line number="20809">    open_db(p, 0);</Line>
  <Line number="20810">    rc = sqlite3_prepare_v2(p-&gt;db, &quot;PRAGMA database_list&quot;, <CheckRefs ids="4167">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="20811">    if( rc ){</Line>
  <Line number="20812">      sqlite3_finalize(pStmt);</Line>
  <Line number="20813">      return shellDatabaseError(p-&gt;db);</Line>
  <Line number="20814">    }</Line>
  <Line number="20815"></Line>
  <Line number="20816">    if( nArg&gt;2 &amp;&amp; c==&apos;i&apos; ){</Line>
  <Line number="20817">      /* It is an historical accident that the .indexes command shows an error</Line>
  <Line number="20818">      ** when called with the wrong number of arguments whereas the .tables</Line>
  <Line number="20819">      ** command does not. */</Line>
  <Line number="20820">      raw_printf(stderr, &quot;Usage: .indexes ?LIKE-PATTERN?\n&quot;);</Line>
  <Line number="20821">      rc = 1;</Line>
  <Line number="20822">      sqlite3_finalize(pStmt);</Line>
  <Line number="20823">      goto meta_command_exit;</Line>
  <Line number="20824">    }</Line>
  <Line number="20825">    for(ii=0; sqlite3_step(pStmt)==SQLITE_ROW; ii<CheckRefs ids="4168">++</CheckRefs>){</Line>
  <Line number="20826">      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);</Line>
  <Line number="20827">      if( zDbName==0 ) continue;</Line>
  <Line number="20828">      if( s.z &amp;&amp; <CheckRefs ids="4169">s</CheckRefs>.z[0] ) appendText(&amp;s, &quot; UNION ALL &quot;, <CheckRefs ids="4170">0</CheckRefs>);</Line>
  <Line number="20829">      if( sqlite3_stricmp(zDbName, &quot;main&quot;)==0 ){</Line>
  <Line number="20830">        appendText(&amp;s, &quot;SELECT name FROM &quot;, <CheckRefs ids="4171">0</CheckRefs>);</Line>
  <Line number="20831">      }else{</Line>
  <Line number="20832">        appendText(&amp;s, &quot;SELECT &quot;, <CheckRefs ids="4172">0</CheckRefs>);</Line>
  <Line number="20833">        appendText(&amp;s, zDbName, <CheckRefs ids="4173">&apos;\&apos;&apos;</CheckRefs>);</Line>
  <Line number="20834">        appendText(&amp;s, &quot;||&apos;.&apos;||name FROM &quot;, <CheckRefs ids="4174">0</CheckRefs>);</Line>
  <Line number="20835">      }</Line>
  <Line number="20836">      appendText(&amp;s, zDbName, <CheckRefs ids="4175">&apos;&quot;&apos;</CheckRefs>);</Line>
  <Line number="20837">      appendText(&amp;s, &quot;.sqlite_schema &quot;, <CheckRefs ids="4176">0</CheckRefs>);</Line>
  <Line number="20838">      if( c==&apos;t&apos; ){</Line>
  <Line number="20839">        appendText(&amp;s,&quot; WHERE type IN (&apos;table&apos;,&apos;view&apos;)&quot;</Line>
  <Line number="20840">                      &quot;   AND name NOT LIKE &apos;sqlite_%&apos;&quot;</Line>
  <Line number="20841">                      &quot;   AND name LIKE ?1&quot;, <CheckRefs ids="4177">0</CheckRefs>);</Line>
  <Line number="20842">      }else{</Line>
  <Line number="20843">        appendText(&amp;s,&quot; WHERE type=&apos;index&apos;&quot;</Line>
  <Line number="20844">                      &quot;   AND tbl_name LIKE ?1&quot;, <CheckRefs ids="4178">0</CheckRefs>);</Line>
  <Line number="20845">      }</Line>
  <Line number="20846">    }</Line>
  <Line number="20847">    rc = sqlite3_finalize(pStmt);</Line>
  <Line number="20848">    appendText(&amp;s, &quot; ORDER BY 1&quot;, <CheckRefs ids="4179">0</CheckRefs>);</Line>
  <Line number="20849">    rc = sqlite3_prepare_v2(p-&gt;db, s.z, <CheckRefs ids="4180">-</CheckRefs>1, &amp;pStmt, 0);</Line>
  <Line number="20850">    freeText(&amp;s);</Line>
  <Line number="20851">    if( rc ) return shellDatabaseError(p-&gt;db);</Line>
  <Line number="20852"></Line>
  <Line number="20853">    /* Run the SQL statement prepared by the above block. Store the results</Line>
  <Line number="20854">    ** as an array of nul-terminated strings in azResult[].  */</Line>
  <Line number="20855">    nRow = nAlloc = 0;</Line>
  <Line number="20856">    azResult = 0;</Line>
  <Line number="20857">    if( nArg&gt;1 ){</Line>
  <Line number="20858">      sqlite3_bind_text(pStmt, 1, azArg[1<CheckRefs ids="4181">]</CheckRefs>, <CheckRefs ids="4182">-</CheckRefs>1, <CheckRefs ids="4183">SQLITE_TRANSIENT</CheckRefs>);</Line>
  <Line number="20859">    }else{</Line>
  <Line number="20860">      sqlite3_bind_text(pStmt, 1, &quot;%&quot;, <CheckRefs ids="4184">-</CheckRefs>1, SQLITE_STATIC);</Line>
  <Line number="20861">    }</Line>
  <Line number="20862">    while( sqlite3_step(pStmt)==SQLITE_ROW ){</Line>
  <Line number="20863">      if( nRow&gt;=nAlloc ){</Line>
  <Line number="20864">        char **azNew;</Line>
  <Line number="20865">        int n2 = nAlloc<CheckRefs ids="4186">*</CheckRefs>2 <CheckRefs ids="4185">+</CheckRefs> 10;</Line>
  <Line number="20866">        azNew = sqlite3_realloc64(azResult, sizeof(azResult[0])<CheckRefs ids="4187,4188">*</CheckRefs><CheckRefs ids="4189">n2</CheckRefs>);</Line>
  <Line number="20867">        if( azNew==0 ) shell_out_of_memory();</Line>
  <Line number="20868">        nAlloc = n2;</Line>
  <Line number="20869">        azResult = azNew;</Line>
  <Line number="20870">      }</Line>
  <Line number="20871">      azResult[nRow] = sqlite3_mprintf(&quot;%s&quot;, sqlite3_column_text(pStmt, 0));</Line>
  <Line number="20872">      if( 0==azResult[nRow] ) shell_out_of_memory();</Line>
  <Line number="20873">      nRow<CheckRefs ids="4190">++</CheckRefs>;</Line>
  <Line number="20874">    }</Line>
  <Line number="20875">    if( sqlite3_finalize(pStmt)!=SQLITE_OK ){</Line>
  <Line number="20876">      rc = shellDatabaseError(p-&gt;db);</Line>
  <Line number="20877">    }</Line>
  <Line number="20878"></Line>
  <Line number="20879">    /* Pretty-print the contents of array azResult[] to the output */</Line>
  <Line number="20880">    if( rc==0 &amp;&amp; nRow&gt;0 ){</Line>
  <Line number="20881">      int len, maxlen = 0;</Line>
  <Line number="20882">      int i, j;</Line>
  <Line number="20883">      int nPrintCol, nPrintRow;</Line>
  <Line number="20884">      for(i=0; i&lt;nRow; i<CheckRefs ids="4191">++</CheckRefs>){</Line>
  <Line number="20885">        len = strlen30(azResult[i]);</Line>
  <Line number="20886">        if( len&gt;maxlen ) maxlen = len;</Line>
  <Line number="20887">      }</Line>
  <Line number="20888">      nPrintCol = 80<CheckRefs ids="4192,4193">/</CheckRefs>(maxlen<CheckRefs ids="4194">+</CheckRefs>2);</Line>
  <Line number="20889">      if( nPrintCol&lt;1 ) nPrintCol = 1;</Line>
  <Line number="20890">      nPrintRow = (nRow <CheckRefs ids="4198">+</CheckRefs> nPrintCol <CheckRefs ids="4197">-</CheckRefs> 1)<CheckRefs ids="4195,4196">/</CheckRefs>nPrintCol;</Line>
  <Line number="20891">      for(i=0; i&lt;nPrintRow; i<CheckRefs ids="4199">++</CheckRefs>){</Line>
  <Line number="20892">        for(j=i; j&lt;nRow; j<CheckRefs ids="4200">+=</CheckRefs>nPrintRow){</Line>
  <Line number="20893">          char *zSp = j&lt;nPrintRow ? &quot;&quot; : &quot;  &quot;;</Line>
  <Line number="20894">          utf8_printf(p-&gt;out, &quot;%s%-*s&quot;, zSp, maxlen,</Line>
  <Line number="20895">                      azResult[j] ? azResult[j]:&quot;&quot;);</Line>
  <Line number="20896">        }</Line>
  <Line number="20897">        raw_printf(p-&gt;out, &quot;\n&quot;);</Line>
  <Line number="20898">      }</Line>
  <Line number="20899">    }</Line>
  <Line number="20900"></Line>
  <Line number="20901">    for(ii=0; ii&lt;nRow; ii<CheckRefs ids="4201">++</CheckRefs>) sqlite3_free(azResult[ii]);</Line>
  <Line number="20902">    sqlite3_free(azResult);</Line>
  <Line number="20903">  }else</Line>
  <Line number="20904"></Line>
  <Line number="20905">  /* Begin redirecting output to the file &quot;testcase-out.txt&quot; */</Line>
  <Line number="20906">  if( c==&apos;t&apos; &amp;&amp; strcmp(azArg[0<CheckRefs ids="4202">]</CheckRefs>,&quot;testcase&quot;)==0 ){</Line>
  <Line number="20907">    output_reset(p);</Line>
  <Line number="20908">    p-&gt;out = output_file_open(&quot;testcase-out.txt&quot;, 0);</Line>
  <Line number="20909">    if( p-&gt;out==0 ){</Line>
  <Line number="20910">      raw_printf(stderr, &quot;Error: cannot open &apos;testcase-out.txt&apos;\n&quot;);</Line>
  <Line number="20911">    }</Line>
  <Line number="20912">    if( nArg&gt;=2 ){</Line>
  <Line number="20913">      sqlite3_snprintf(<CheckRefs ids="4203">sizeof</CheckRefs>(p-&gt;zTestcase), p-&gt;zTestcase, &quot;%s&quot;, azArg[1<CheckRefs ids="4204">]</CheckRefs>);</Line>
  <Line number="20914">    }else{</Line>
  <Line number="20915">      sqlite3_snprintf(<CheckRefs ids="4205">sizeof</CheckRefs>(p-&gt;zTestcase), p-&gt;zTestcase, &quot;?&quot;);</Line>
  <Line number="20916">    }</Line>
  <Line number="20917">  }else</Line>
  <Line number="20918"></Line>
  <Line number="20919">#ifndef SQLITE_UNTESTABLE</Line>
  <Line number="20920">  if( c==&apos;t&apos; &amp;&amp; n&gt;=8 &amp;&amp; strncmp(azArg[0<CheckRefs ids="4206">]</CheckRefs>, &quot;testctrl&quot;, <CheckRefs ids="4207">n</CheckRefs>)==0 ){</Line>
  <Line number="20921">    static const struct {</Line>
  <Line number="20922">       const char *zCtrlName;   /* Name of a test-control option */</Line>
  <Line number="20923">       int ctrlCode;            /* Integer code for that option */</Line>
  <Line number="20924">       const char *zUsage;      /* Usage notes */</Line>
  <Line number="20925">    } aCtrl[] = {</Line>
  <Line number="20926">      { &quot;always&quot;,             SQLITE_TESTCTRL_ALWAYS,        &quot;BOOLEAN&quot;        },</Line>
  <Line number="20927">      { &quot;assert&quot;,             SQLITE_TESTCTRL_ASSERT,        &quot;BOOLEAN&quot;        },</Line>
  <Line number="20928">    /*{ &quot;benign_malloc_hooks&quot;,SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS, &quot;&quot;       },*/</Line>
  <Line number="20929">    /*{ &quot;bitvec_test&quot;,        SQLITE_TESTCTRL_BITVEC_TEST,   &quot;&quot;             },*/</Line>
  <Line number="20930">      { &quot;byteorder&quot;,          SQLITE_TESTCTRL_BYTEORDER,     &quot;&quot;               },</Line>
  <Line number="20931">      { &quot;extra_schema_checks&quot;,SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS,&quot;BOOLEAN&quot;   },</Line>
  <Line number="20932">    /*{ &quot;fault_install&quot;,      SQLITE_TESTCTRL_FAULT_INSTALL, &quot;&quot;             },*/</Line>
  <Line number="20933">      { &quot;imposter&quot;,         SQLITE_TESTCTRL_IMPOSTER, &quot;SCHEMA ON/OFF ROOTPAGE&quot;},</Line>
  <Line number="20934">      { &quot;internal_functions&quot;, SQLITE_TESTCTRL_INTERNAL_FUNCTIONS, &quot;&quot; },</Line>
  <Line number="20935">      { &quot;localtime_fault&quot;,    SQLITE_TESTCTRL_LOCALTIME_FAULT,&quot;BOOLEAN&quot;       },</Line>
  <Line number="20936">      { &quot;never_corrupt&quot;,      SQLITE_TESTCTRL_NEVER_CORRUPT, &quot;BOOLEAN&quot;        },</Line>
  <Line number="20937">      { &quot;optimizations&quot;,      SQLITE_TESTCTRL_OPTIMIZATIONS, &quot;DISABLE-MASK&quot;   },</Line>
  <Line number="20938">#ifdef YYCOVERAGE</Line>
  <Line number="20939">      { &quot;parser_coverage&quot;,    SQLITE_TESTCTRL_PARSER_COVERAGE, &quot;&quot;             },</Line>
  <Line number="20940">#endif</Line>
  <Line number="20941">      { &quot;pending_byte&quot;,       SQLITE_TESTCTRL_PENDING_BYTE,  &quot;OFFSET  &quot;       },</Line>
  <Line number="20942">      { &quot;prng_restore&quot;,       SQLITE_TESTCTRL_PRNG_RESTORE,  &quot;&quot;               },</Line>
  <Line number="20943">      { &quot;prng_save&quot;,          SQLITE_TESTCTRL_PRNG_SAVE,     &quot;&quot;               },</Line>
  <Line number="20944">      { &quot;prng_seed&quot;,          SQLITE_TESTCTRL_PRNG_SEED,     &quot;SEED ?db?&quot;      },</Line>
  <Line number="20945">      { &quot;seek_count&quot;,         SQLITE_TESTCTRL_SEEK_COUNT,    &quot;&quot;               },</Line>
  <Line number="20946">      { &quot;tune&quot;,               SQLITE_TESTCTRL_TUNE,          &quot;ID VALUE&quot;       },</Line>
  <Line number="20947">    };</Line>
  <Line number="20948">    int testctrl = <CheckRefs ids="4208">-</CheckRefs>1;</Line>
  <Line number="20949">    int iCtrl = <CheckRefs ids="4209">-</CheckRefs>1;</Line>
  <Line number="20950">    int rc2 = 0;    /* 0: usage.  1: %d  2: %x  3: no-output */</Line>
  <Line number="20951">    int isOk = 0;</Line>
  <Line number="20952">    int i, n2;</Line>
  <Line number="20953">    const char *zCmd = 0;</Line>
  <Line number="20954"></Line>
  <Line number="20955">    open_db(p, 0);</Line>
  <Line number="20956">    zCmd = nArg&gt;=2 ? azArg[1<CheckRefs ids="4210">]</CheckRefs> : &quot;help&quot;;</Line>
  <Line number="20957"></Line>
  <Line number="20958">    /* The argument can optionally begin with &quot;-&quot; or &quot;--&quot; */</Line>
  <Line number="20959">    if( <CheckRefs ids="4211">zCmd</CheckRefs>[0]==&apos;-&apos; &amp;&amp; <CheckRefs ids="4212">zCmd</CheckRefs>[1] ){</Line>
  <Line number="20960">      zCmd++;</Line>
  <Line number="20961">      if( <CheckRefs ids="4213">zCmd</CheckRefs>[0]==&apos;-&apos; &amp;&amp; <CheckRefs ids="4214">zCmd</CheckRefs>[1] ) zCmd++;</Line>
  <Line number="20962">    }</Line>
  <Line number="20963"></Line>
  <Line number="20964">    /* --help lists all test-controls */</Line>
  <Line number="20965">    if( strcmp(zCmd,&quot;help&quot;)==0 ){</Line>
  <Line number="20966">      utf8_printf(p-&gt;out, &quot;Available test-controls:\n&quot;);</Line>
  <Line number="20967">      for(i=0; i&lt;<CheckRefs ids="4215,4216,4217">ArraySize</CheckRefs>(aCtrl); i<CheckRefs ids="4218">++</CheckRefs>){</Line>
  <Line number="20968">        utf8_printf(p-&gt;out, &quot;  .testctrl %s %s\n&quot;,</Line>
  <Line number="20969">                    aCtrl[i<CheckRefs ids="4219">]</CheckRefs>.zCtrlName, aCtrl[i<CheckRefs ids="4220">]</CheckRefs>.zUsage);</Line>
  <Line number="20970">      }</Line>
  <Line number="20971">      rc = 1;</Line>
  <Line number="20972">      goto meta_command_exit;</Line>
  <Line number="20973">    }</Line>
  <Line number="20974"></Line>
  <Line number="20975">    /* convert testctrl text option to value. allow any unique prefix</Line>
  <Line number="20976">    ** of the option name, or a numerical value. */</Line>
  <Line number="20977">    n2 = strlen30(zCmd);</Line>
  <Line number="20978">    for(i=0; i&lt;<CheckRefs ids="4222,4223,4221">ArraySize</CheckRefs>(aCtrl); i<CheckRefs ids="4224">++</CheckRefs>){</Line>
  <Line number="20979">      if( strncmp(zCmd, aCtrl[i<CheckRefs ids="4225">]</CheckRefs>.zCtrlName, <CheckRefs ids="4226">n2</CheckRefs>)==0 ){</Line>
  <Line number="20980">        if( testctrl&lt;0 ){</Line>
  <Line number="20981">          testctrl = aCtrl[i<CheckRefs ids="4227">]</CheckRefs>.ctrlCode;</Line>
  <Line number="20982">          iCtrl = i;</Line>
  <Line number="20983">        }else{</Line>
  <Line number="20984">          utf8_printf(stderr, &quot;Error: ambiguous test-control: \&quot;%s\&quot;\n&quot;</Line>
  <Line number="20985">                              &quot;Use \&quot;.testctrl --help\&quot; for help\n&quot;, zCmd);</Line>
  <Line number="20986">          rc = 1;</Line>
  <Line number="20987">          goto meta_command_exit;</Line>
  <Line number="20988">        }</Line>
  <Line number="20989">      }</Line>
  <Line number="20990">    }</Line>
  <Line number="20991">    if( testctrl&lt;0 ){</Line>
  <Line number="20992">      utf8_printf(stderr,&quot;Error: unknown test-control: %s\n&quot;</Line>
  <Line number="20993">                         &quot;Use \&quot;.testctrl --help\&quot; for help\n&quot;, zCmd);</Line>
  <Line number="20994">    }else{</Line>
  <Line number="20995">      switch(testctrl){</Line>
  <Line number="20996"></Line>
  <Line number="20997">        /* sqlite3_test_control(int, db, int) */</Line>
  <Line number="20998">        case SQLITE_TESTCTRL_OPTIMIZATIONS:</Line>
  <Line number="20999">          if( nArg==3 ){</Line>
  <Line number="21000">            unsigned int opt = <CheckRefs ids="4228">(</CheckRefs>unsigned int)strtol(azArg[2<CheckRefs ids="4229">]</CheckRefs>, 0, 0);</Line>
  <Line number="21001">            rc2 = sqlite3_test_control(testctrl, p-&gt;db, opt);</Line>
  <Line number="21002">            isOk = 3;</Line>
  <Line number="21003">          }</Line>
  <Line number="21004">          break;</Line>
  <Line number="21005"></Line>
  <Line number="21006">        /* sqlite3_test_control(int) */</Line>
  <Line number="21007">        case SQLITE_TESTCTRL_PRNG_SAVE:</Line>
  <Line number="21008">        case SQLITE_TESTCTRL_PRNG_RESTORE:</Line>
  <Line number="21009">        case SQLITE_TESTCTRL_BYTEORDER:</Line>
  <Line number="21010">          if( nArg==2 ){</Line>
  <Line number="21011">            rc2 = sqlite3_test_control(testctrl);</Line>
  <Line number="21012">            isOk = testctrl==SQLITE_TESTCTRL_BYTEORDER ? 1 : 3;</Line>
  <Line number="21013">          }</Line>
  <Line number="21014">          break;</Line>
  <Line number="21015"></Line>
  <Line number="21016">        /* sqlite3_test_control(int, uint) */</Line>
  <Line number="21017">        case SQLITE_TESTCTRL_PENDING_BYTE:</Line>
  <Line number="21018">          if( nArg==3 ){</Line>
  <Line number="21019">            unsigned int opt = <CheckRefs ids="4230">(</CheckRefs>unsigned int)integerValue(azArg[2<CheckRefs ids="4231">]</CheckRefs>);</Line>
  <Line number="21020">            rc2 = sqlite3_test_control(testctrl, opt);</Line>
  <Line number="21021">            isOk = 3;</Line>
  <Line number="21022">          }</Line>
  <Line number="21023">          break;</Line>
  <Line number="21024"></Line>
  <Line number="21025">        /* sqlite3_test_control(int, int, sqlite3*) */</Line>
  <Line number="21026">        case SQLITE_TESTCTRL_PRNG_SEED:</Line>
  <Line number="21027">          if( nArg==3 || nArg==4 ){</Line>
  <Line number="21028">            int ii = <CheckRefs ids="4232">(</CheckRefs>int)integerValue(azArg[2<CheckRefs ids="4233">]</CheckRefs>);</Line>
  <Line number="21029">            sqlite3 *db;</Line>
  <Line number="21030">            if( ii==0 &amp;&amp; strcmp(azArg[2<CheckRefs ids="4234">]</CheckRefs>,&quot;random&quot;)==0 ){</Line>
  <Line number="21031">              sqlite3_randomness(<CheckRefs ids="4235">sizeof</CheckRefs>(ii),&amp;ii);</Line>
  <Line number="21032">              printf(&quot;-- random seed: %d\n&quot;, ii);</Line>
  <Line number="21033">            }</Line>
  <Line number="21034">            if( nArg==3 ){</Line>
  <Line number="21035">              db = 0;</Line>
  <Line number="21036">            }else{</Line>
  <Line number="21037">              db = p-&gt;db;</Line>
  <Line number="21038">              /* Make sure the schema has been loaded */</Line>
  <Line number="21039">              sqlite3_table_column_metadata(db, 0, &quot;x&quot;, 0, 0, 0, 0, 0, 0);</Line>
  <Line number="21040">            }</Line>
  <Line number="21041">            rc2 = sqlite3_test_control(testctrl, ii, db);</Line>
  <Line number="21042">            isOk = 3;</Line>
  <Line number="21043">          }</Line>
  <Line number="21044">          break;</Line>
  <Line number="21045"></Line>
  <Line number="21046">        /* sqlite3_test_control(int, int) */</Line>
  <Line number="21047">        case SQLITE_TESTCTRL_ASSERT:</Line>
  <Line number="21048">        case SQLITE_TESTCTRL_ALWAYS:</Line>
  <Line number="21049">          if( nArg==3 ){</Line>
  <Line number="21050">            int opt = booleanValue(azArg[2<CheckRefs ids="4236">]</CheckRefs>);</Line>
  <Line number="21051">            rc2 = sqlite3_test_control(testctrl, opt);</Line>
  <Line number="21052">            isOk = 1;</Line>
  <Line number="21053">          }</Line>
  <Line number="21054">          break;</Line>
  <Line number="21055"></Line>
  <Line number="21056">        /* sqlite3_test_control(int, int) */</Line>
  <Line number="21057">        case SQLITE_TESTCTRL_LOCALTIME_FAULT:</Line>
  <Line number="21058">        case SQLITE_TESTCTRL_NEVER_CORRUPT:</Line>
  <Line number="21059">          if( nArg==3 ){</Line>
  <Line number="21060">            int opt = booleanValue(azArg[2<CheckRefs ids="4237">]</CheckRefs>);</Line>
  <Line number="21061">            rc2 = sqlite3_test_control(testctrl, opt);</Line>
  <Line number="21062">            isOk = 3;</Line>
  <Line number="21063">          }</Line>
  <Line number="21064">          break;</Line>
  <Line number="21065"></Line>
  <Line number="21066">        /* sqlite3_test_control(sqlite3*) */</Line>
  <Line number="21067">        case SQLITE_TESTCTRL_INTERNAL_FUNCTIONS:</Line>
  <Line number="21068">          rc2 = sqlite3_test_control(testctrl, p-&gt;db);</Line>
  <Line number="21069">          isOk = 3;</Line>
  <Line number="21070">          break;</Line>
  <Line number="21071"></Line>
  <Line number="21072">        case SQLITE_TESTCTRL_IMPOSTER:</Line>
  <Line number="21073">          if( nArg==5 ){</Line>
  <Line number="21074">            rc2 = sqlite3_test_control(testctrl, p-&gt;db,</Line>
  <Line number="21075">                          azArg[2<CheckRefs ids="4238">]</CheckRefs>,</Line>
  <Line number="21076">                          integerValue(azArg[3<CheckRefs ids="4239">]</CheckRefs>),</Line>
  <Line number="21077">                          integerValue(azArg[4<CheckRefs ids="4240">]</CheckRefs>));</Line>
  <Line number="21078">            isOk = 3;</Line>
  <Line number="21079">          }</Line>
  <Line number="21080">          break;</Line>
  <Line number="21081"></Line>
  <Line number="21082">        case SQLITE_TESTCTRL_SEEK_COUNT: {</Line>
  <Line number="21083">          u64 x = <CheckRefs ids="4241">0</CheckRefs>;</Line>
  <Line number="21084">          rc2 = sqlite3_test_control(testctrl, p-&gt;db, &amp;x);</Line>
  <Line number="21085">          utf8_printf(p-&gt;out, &quot;%llu\n&quot;, x);</Line>
  <Line number="21086">          isOk = 3;</Line>
  <Line number="21087">          break;</Line>
  <Line number="21088">        }</Line>
  <Line number="21089"></Line>
  <Line number="21090">#ifdef YYCOVERAGE</Line>
  <Line number="21091">        case SQLITE_TESTCTRL_PARSER_COVERAGE: {</Line>
  <Line number="21092">          if( nArg==2 ){</Line>
  <Line number="21093">            sqlite3_test_control(testctrl, p-&gt;out);</Line>
  <Line number="21094">            isOk = 3;</Line>
  <Line number="21095">          }</Line>
  <Line number="21096">          break;</Line>
  <Line number="21097">        }</Line>
  <Line number="21098">#endif</Line>
  <Line number="21099">#ifdef SQLITE_DEBUG</Line>
  <Line number="21100">        case SQLITE_TESTCTRL_TUNE: {</Line>
  <Line number="21101">          if( nArg==4 ){</Line>
  <Line number="21102">            int id = (int)integerValue(azArg[2]);</Line>
  <Line number="21103">            int val = (int)integerValue(azArg[3]);</Line>
  <Line number="21104">            sqlite3_test_control(testctrl, id, &amp;val);</Line>
  <Line number="21105">            isOk = 3;</Line>
  <Line number="21106">          }else if( nArg==3 ){</Line>
  <Line number="21107">            int id = (int)integerValue(azArg[2]);</Line>
  <Line number="21108">            sqlite3_test_control(testctrl, -id, &amp;rc2);</Line>
  <Line number="21109">            isOk = 1;</Line>
  <Line number="21110">          }else if( nArg==2 ){</Line>
  <Line number="21111">            int id = 1;</Line>
  <Line number="21112">            while(1){</Line>
  <Line number="21113">              int val = 0;</Line>
  <Line number="21114">              rc2 = sqlite3_test_control(testctrl, -id, &amp;val);</Line>
  <Line number="21115">              if( rc2!=SQLITE_OK ) break;</Line>
  <Line number="21116">              if( id&gt;1 ) utf8_printf(p-&gt;out, &quot;  &quot;);</Line>
  <Line number="21117">              utf8_printf(p-&gt;out, &quot;%d: %d&quot;, id, val);</Line>
  <Line number="21118">              id++;</Line>
  <Line number="21119">            }</Line>
  <Line number="21120">            if( id&gt;1 ) utf8_printf(p-&gt;out, &quot;\n&quot;);</Line>
  <Line number="21121">            isOk = 3;</Line>
  <Line number="21122">          }</Line>
  <Line number="21123">          break;</Line>
  <Line number="21124">        }</Line>
  <Line number="21125">#endif</Line>
  <Line number="21126">      }</Line>
  <Line number="21127">    }</Line>
  <Line number="21128">    if( isOk==0 &amp;&amp; iCtrl&gt;=0 ){</Line>
  <Line number="21129">      utf8_printf(p-&gt;out, &quot;Usage: .testctrl %s %s\n&quot;, zCmd,aCtrl[iCtrl<CheckRefs ids="4242">]</CheckRefs>.zUsage);</Line>
  <Line number="21130">      rc = 1;</Line>
  <Line number="21131">    }else if( isOk==1 ){</Line>
  <Line number="21132">      raw_printf(p-&gt;out, &quot;%d\n&quot;, rc2);</Line>
  <Line number="21133">    }else if( isOk==2 ){</Line>
  <Line number="21134">      raw_printf(p-&gt;out, &quot;0x%08x\n&quot;, rc2);</Line>
  <Line number="21135">    }</Line>
  <Line number="21136">  }else</Line>
  <Line number="21137">#endif /* !defined(SQLITE_UNTESTABLE) */</Line>
  <Line number="21138"></Line>
  <Line number="21139">  if( c==&apos;t&apos; &amp;&amp; n&gt;4 &amp;&amp; strncmp(azArg[0<CheckRefs ids="4243">]</CheckRefs>, &quot;timeout&quot;, <CheckRefs ids="4244">n</CheckRefs>)==0 ){</Line>
  <Line number="21140">    open_db(p, 0);</Line>
  <Line number="21141">    sqlite3_busy_timeout(p-&gt;db, nArg&gt;=2 ? <CheckRefs ids="4245">(</CheckRefs>int)integerValue(azArg[1<CheckRefs ids="4246">]</CheckRefs>) : 0);</Line>
  <Line number="21142">  }else</Line>
  <Line number="21143"></Line>
  <Line number="21144">  if( c==&apos;t&apos; &amp;&amp; n&gt;=5 &amp;&amp; strncmp(azArg[0<CheckRefs ids="4247">]</CheckRefs>, &quot;timer&quot;, <CheckRefs ids="4248">n</CheckRefs>)==0 ){</Line>
  <Line number="21145">    if( nArg==2 ){</Line>
  <Line number="21146">      enableTimer = booleanValue(azArg[1<CheckRefs ids="4249">]</CheckRefs>);</Line>
  <Line number="21147">      if( enableTimer &amp;&amp; !HAS_TIMER ){</Line>
  <Line number="21148">        raw_printf(stderr, &quot;Error: timer not available on this system.\n&quot;);</Line>
  <Line number="21149">        enableTimer = 0;</Line>
  <Line number="21150">      }</Line>
  <Line number="21151">    }else{</Line>
  <Line number="21152">      raw_printf(stderr, &quot;Usage: .timer on|off\n&quot;);</Line>
  <Line number="21153">      rc = 1;</Line>
  <Line number="21154">    }</Line>
  <Line number="21155">  }else</Line>
  <Line number="21156"></Line>
  <Line number="21157">#ifndef SQLITE_OMIT_TRACE</Line>
  <Line number="21158">  if( c==&apos;t&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="4250">]</CheckRefs>, &quot;trace&quot;, <CheckRefs ids="4251">n</CheckRefs>)==0 ){</Line>
  <Line number="21159">    int mType = 0;</Line>
  <Line number="21160">    int jj;</Line>
  <Line number="21161">    open_db(p, 0);</Line>
  <Line number="21162">    for(jj=1; jj&lt;nArg; jj<CheckRefs ids="4252">++</CheckRefs>){</Line>
  <Line number="21163">      const char *z = azArg[jj<CheckRefs ids="4253">]</CheckRefs>;</Line>
  <Line number="21164">      if( <CheckRefs ids="4254">z</CheckRefs>[0]==&apos;-&apos; ){</Line>
  <Line number="21165">        if( optionMatch(z, &quot;expanded&quot;) ){</Line>
  <Line number="21166">          p-&gt;eTraceType = <CheckRefs ids="4255">SHELL_TRACE_EXPANDED</CheckRefs>;</Line>
  <Line number="21167">        }</Line>
  <Line number="21168">#ifdef SQLITE_ENABLE_NORMALIZE</Line>
  <Line number="21169">        else if( optionMatch(z, &quot;normalized&quot;) ){</Line>
  <Line number="21170">          p-&gt;eTraceType = SHELL_TRACE_NORMALIZED;</Line>
  <Line number="21171">        }</Line>
  <Line number="21172">#endif</Line>
  <Line number="21173">        else if( optionMatch(z, &quot;plain&quot;) ){</Line>
  <Line number="21174">          p-&gt;eTraceType = <CheckRefs ids="4256">SHELL_TRACE_PLAIN</CheckRefs>;</Line>
  <Line number="21175">        }</Line>
  <Line number="21176">        else if( optionMatch(z, &quot;profile&quot;) ){</Line>
  <Line number="21177">          mType |= SQLITE_TRACE_PROFILE;</Line>
  <Line number="21178">        }</Line>
  <Line number="21179">        else if( optionMatch(z, &quot;row&quot;) ){</Line>
  <Line number="21180">          mType |= SQLITE_TRACE_ROW;</Line>
  <Line number="21181">        }</Line>
  <Line number="21182">        else if( optionMatch(z, &quot;stmt&quot;) ){</Line>
  <Line number="21183">          mType |= SQLITE_TRACE_STMT;</Line>
  <Line number="21184">        }</Line>
  <Line number="21185">        else if( optionMatch(z, &quot;close&quot;) ){</Line>
  <Line number="21186">          mType |= SQLITE_TRACE_CLOSE;</Line>
  <Line number="21187">        }</Line>
  <Line number="21188">        else {</Line>
  <Line number="21189">          raw_printf(stderr, &quot;Unknown option \&quot;%s\&quot; on \&quot;.trace\&quot;\n&quot;, z);</Line>
  <Line number="21190">          rc = 1;</Line>
  <Line number="21191">          goto meta_command_exit;</Line>
  <Line number="21192">        }</Line>
  <Line number="21193">      }else{</Line>
  <Line number="21194">        output_file_close(p-&gt;traceOut);</Line>
  <Line number="21195">        p-&gt;traceOut = output_file_open(azArg[1<CheckRefs ids="4257">]</CheckRefs>, 0);</Line>
  <Line number="21196">      }</Line>
  <Line number="21197">    }</Line>
  <Line number="21198">    if( p-&gt;traceOut==0 ){</Line>
  <Line number="21199">      sqlite3_trace_v2(p-&gt;db, <CheckRefs ids="4258">0</CheckRefs>, 0, 0);</Line>
  <Line number="21200">    }else{</Line>
  <Line number="21201">      if( mType==0 ) mType = SQLITE_TRACE_STMT;</Line>
  <Line number="21202">      sqlite3_trace_v2(p-&gt;db, <CheckRefs ids="4259">mType</CheckRefs>, sql_trace_callback, p);</Line>
  <Line number="21203">    }</Line>
  <Line number="21204">  }else</Line>
  <Line number="21205">#endif /* !defined(SQLITE_OMIT_TRACE) */</Line>
  <Line number="21206"></Line>
  <Line number="21207">#if defined(SQLITE_DEBUG) &amp;&amp; !defined(SQLITE_OMIT_VIRTUALTABLE)</Line>
  <Line number="21208">  if( c==&apos;u&apos; &amp;&amp; strncmp(azArg[0], &quot;unmodule&quot;, n)==0 ){</Line>
  <Line number="21209">    int ii;</Line>
  <Line number="21210">    int lenOpt;</Line>
  <Line number="21211">    char *zOpt;</Line>
  <Line number="21212">    if( nArg&lt;2 ){</Line>
  <Line number="21213">      raw_printf(stderr, &quot;Usage: .unmodule [--allexcept] NAME ...\n&quot;);</Line>
  <Line number="21214">      rc = 1;</Line>
  <Line number="21215">      goto meta_command_exit;</Line>
  <Line number="21216">    }</Line>
  <Line number="21217">    open_db(p, 0);</Line>
  <Line number="21218">    zOpt = azArg[1];</Line>
  <Line number="21219">    if( zOpt[0]==&apos;-&apos; &amp;&amp; zOpt[1]==&apos;-&apos; &amp;&amp; zOpt[2]!=0 ) zOpt++;</Line>
  <Line number="21220">    lenOpt = (int)strlen(zOpt);</Line>
  <Line number="21221">    if( lenOpt&gt;=3 &amp;&amp; strncmp(zOpt, &quot;-allexcept&quot;,lenOpt)==0 ){</Line>
  <Line number="21222">      assert( azArg[nArg]==0 );</Line>
  <Line number="21223">      sqlite3_drop_modules(p-&gt;db, nArg&gt;2 ? (const char**)(azArg+2) : 0);</Line>
  <Line number="21224">    }else{</Line>
  <Line number="21225">      for(ii=1; ii&lt;nArg; ii++){</Line>
  <Line number="21226">        sqlite3_create_module(p-&gt;db, azArg[ii], 0, 0);</Line>
  <Line number="21227">      }</Line>
  <Line number="21228">    }</Line>
  <Line number="21229">  }else</Line>
  <Line number="21230">#endif</Line>
  <Line number="21231"></Line>
  <Line number="21232">#if SQLITE_USER_AUTHENTICATION</Line>
  <Line number="21233">  if( c==&apos;u&apos; &amp;&amp; strncmp(azArg[0], &quot;user&quot;, n)==0 ){</Line>
  <Line number="21234">    if( nArg&lt;2 ){</Line>
  <Line number="21235">      raw_printf(stderr, &quot;Usage: .user SUBCOMMAND ...\n&quot;);</Line>
  <Line number="21236">      rc = 1;</Line>
  <Line number="21237">      goto meta_command_exit;</Line>
  <Line number="21238">    }</Line>
  <Line number="21239">    open_db(p, 0);</Line>
  <Line number="21240">    if( strcmp(azArg[1],&quot;login&quot;)==0 ){</Line>
  <Line number="21241">      if( nArg!=4 ){</Line>
  <Line number="21242">        raw_printf(stderr, &quot;Usage: .user login USER PASSWORD\n&quot;);</Line>
  <Line number="21243">        rc = 1;</Line>
  <Line number="21244">        goto meta_command_exit;</Line>
  <Line number="21245">      }</Line>
  <Line number="21246">      rc = sqlite3_user_authenticate(p-&gt;db, azArg[2], azArg[3],</Line>
  <Line number="21247">                                     strlen30(azArg[3]));</Line>
  <Line number="21248">      if( rc ){</Line>
  <Line number="21249">        utf8_printf(stderr, &quot;Authentication failed for user %s\n&quot;, azArg[2]);</Line>
  <Line number="21250">        rc = 1;</Line>
  <Line number="21251">      }</Line>
  <Line number="21252">    }else if( strcmp(azArg[1],&quot;add&quot;)==0 ){</Line>
  <Line number="21253">      if( nArg!=5 ){</Line>
  <Line number="21254">        raw_printf(stderr, &quot;Usage: .user add USER PASSWORD ISADMIN\n&quot;);</Line>
  <Line number="21255">        rc = 1;</Line>
  <Line number="21256">        goto meta_command_exit;</Line>
  <Line number="21257">      }</Line>
  <Line number="21258">      rc = sqlite3_user_add(p-&gt;db, azArg[2], azArg[3], strlen30(azArg[3]),</Line>
  <Line number="21259">                            booleanValue(azArg[4]));</Line>
  <Line number="21260">      if( rc ){</Line>
  <Line number="21261">        raw_printf(stderr, &quot;User-Add failed: %d\n&quot;, rc);</Line>
  <Line number="21262">        rc = 1;</Line>
  <Line number="21263">      }</Line>
  <Line number="21264">    }else if( strcmp(azArg[1],&quot;edit&quot;)==0 ){</Line>
  <Line number="21265">      if( nArg!=5 ){</Line>
  <Line number="21266">        raw_printf(stderr, &quot;Usage: .user edit USER PASSWORD ISADMIN\n&quot;);</Line>
  <Line number="21267">        rc = 1;</Line>
  <Line number="21268">        goto meta_command_exit;</Line>
  <Line number="21269">      }</Line>
  <Line number="21270">      rc = sqlite3_user_change(p-&gt;db, azArg[2], azArg[3], strlen30(azArg[3]),</Line>
  <Line number="21271">                              booleanValue(azArg[4]));</Line>
  <Line number="21272">      if( rc ){</Line>
  <Line number="21273">        raw_printf(stderr, &quot;User-Edit failed: %d\n&quot;, rc);</Line>
  <Line number="21274">        rc = 1;</Line>
  <Line number="21275">      }</Line>
  <Line number="21276">    }else if( strcmp(azArg[1],&quot;delete&quot;)==0 ){</Line>
  <Line number="21277">      if( nArg!=3 ){</Line>
  <Line number="21278">        raw_printf(stderr, &quot;Usage: .user delete USER\n&quot;);</Line>
  <Line number="21279">        rc = 1;</Line>
  <Line number="21280">        goto meta_command_exit;</Line>
  <Line number="21281">      }</Line>
  <Line number="21282">      rc = sqlite3_user_delete(p-&gt;db, azArg[2]);</Line>
  <Line number="21283">      if( rc ){</Line>
  <Line number="21284">        raw_printf(stderr, &quot;User-Delete failed: %d\n&quot;, rc);</Line>
  <Line number="21285">        rc = 1;</Line>
  <Line number="21286">      }</Line>
  <Line number="21287">    }else{</Line>
  <Line number="21288">      raw_printf(stderr, &quot;Usage: .user login|add|edit|delete ...\n&quot;);</Line>
  <Line number="21289">      rc = 1;</Line>
  <Line number="21290">      goto meta_command_exit;</Line>
  <Line number="21291">    }</Line>
  <Line number="21292">  }else</Line>
  <Line number="21293">#endif /* SQLITE_USER_AUTHENTICATION */</Line>
  <Line number="21294"></Line>
  <Line number="21295">  if( c==&apos;v&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="4260">]</CheckRefs>, &quot;version&quot;, <CheckRefs ids="4261">n</CheckRefs>)==0 ){</Line>
  <Line number="21296">    utf8_printf(p-&gt;out, &quot;SQLite %s %s\n&quot; /*extra-version-info*/,</Line>
  <Line number="21297">        sqlite3_libversion(), sqlite3_sourceid());</Line>
  <Line number="21298">#if SQLITE_HAVE_ZLIB</Line>
  <Line number="21299">    utf8_printf(p-&gt;out, &quot;zlib version %s\n&quot;, zlibVersion());</Line>
  <Line number="21300">#endif</Line>
  <Line number="21301">#define CTIMEOPT_VAL_(opt) #opt</Line>
  <Line number="21302">#define CTIMEOPT_VAL(opt) CTIMEOPT_VAL_(opt)</Line>
  <Line number="21303">#if defined(__clang__) &amp;&amp; defined(__clang_major__)</Line>
  <Line number="21304">    utf8_printf(p-&gt;out, &quot;clang-&quot; CTIMEOPT_VAL(__clang_major__) &quot;.&quot;</Line>
  <Line number="21305">                    CTIMEOPT_VAL(__clang_minor__) &quot;.&quot;</Line>
  <Line number="21306">                    CTIMEOPT_VAL(__clang_patchlevel__) &quot;\n&quot;);</Line>
  <Line number="21307">#elif defined(_MSC_VER)</Line>
  <Line number="21308">    utf8_printf(p-&gt;out, &quot;msvc-&quot; CTIMEOPT_VAL(_MSC_VER) &quot;\n&quot;);</Line>
  <Line number="21309">#elif defined(__GNUC__) &amp;&amp; defined(__VERSION__)</Line>
  <Line number="21310">    utf8_printf(p-&gt;out, &quot;gcc-&quot; __VERSION__ &quot;\n&quot;);</Line>
  <Line number="21311">#endif</Line>
  <Line number="21312">  }else</Line>
  <Line number="21313"></Line>
  <Line number="21314">  if( c==&apos;v&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="4262">]</CheckRefs>, &quot;vfsinfo&quot;, <CheckRefs ids="4263">n</CheckRefs>)==0 ){</Line>
  <Line number="21315">    const char *zDbName = nArg==2 ? azArg[1<CheckRefs ids="4264">]</CheckRefs> : &quot;main&quot;;</Line>
  <Line number="21316">    sqlite3_vfs *pVfs = 0;</Line>
  <Line number="21317">    if( p-&gt;db ){</Line>
  <Line number="21318">      sqlite3_file_control(p-&gt;db, zDbName, SQLITE_FCNTL_VFS_POINTER, &amp;pVfs);</Line>
  <Line number="21319">      if( pVfs ){</Line>
  <Line number="21320">        utf8_printf(p-&gt;out, &quot;vfs.zName      = \&quot;%s\&quot;\n&quot;, pVfs-&gt;zName);</Line>
  <Line number="21321">        raw_printf(p-&gt;out, &quot;vfs.iVersion   = %d\n&quot;, pVfs-&gt;iVersion);</Line>
  <Line number="21322">        raw_printf(p-&gt;out, &quot;vfs.szOsFile   = %d\n&quot;, pVfs-&gt;szOsFile);</Line>
  <Line number="21323">        raw_printf(p-&gt;out, &quot;vfs.mxPathname = %d\n&quot;, pVfs-&gt;mxPathname);</Line>
  <Line number="21324">      }</Line>
  <Line number="21325">    }</Line>
  <Line number="21326">  }else</Line>
  <Line number="21327"></Line>
  <Line number="21328">  if( c==&apos;v&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="4265">]</CheckRefs>, &quot;vfslist&quot;, <CheckRefs ids="4266">n</CheckRefs>)==0 ){</Line>
  <Line number="21329">    sqlite3_vfs *pVfs;</Line>
  <Line number="21330">    sqlite3_vfs *pCurrent = 0;</Line>
  <Line number="21331">    if( p-&gt;db ){</Line>
  <Line number="21332">      sqlite3_file_control(p-&gt;db, &quot;main&quot;, SQLITE_FCNTL_VFS_POINTER, &amp;pCurrent);</Line>
  <Line number="21333">    }</Line>
  <Line number="21334">    for(pVfs=sqlite3_vfs_find(0); pVfs; pVfs=pVfs-&gt;pNext){</Line>
  <Line number="21335">      utf8_printf(p-&gt;out, &quot;vfs.zName      = \&quot;%s\&quot;%s\n&quot;, pVfs-&gt;zName,</Line>
  <Line number="21336">           pVfs==pCurrent ? &quot;  &lt;--- CURRENT&quot; : &quot;&quot;);</Line>
  <Line number="21337">      raw_printf(p-&gt;out, &quot;vfs.iVersion   = %d\n&quot;, pVfs-&gt;iVersion);</Line>
  <Line number="21338">      raw_printf(p-&gt;out, &quot;vfs.szOsFile   = %d\n&quot;, pVfs-&gt;szOsFile);</Line>
  <Line number="21339">      raw_printf(p-&gt;out, &quot;vfs.mxPathname = %d\n&quot;, pVfs-&gt;mxPathname);</Line>
  <Line number="21340">      if( pVfs-&gt;pNext ){</Line>
  <Line number="21341">        raw_printf(p-&gt;out, &quot;-----------------------------------\n&quot;);</Line>
  <Line number="21342">      }</Line>
  <Line number="21343">    }</Line>
  <Line number="21344">  }else</Line>
  <Line number="21345"></Line>
  <Line number="21346">  if( c==&apos;v&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="4267">]</CheckRefs>, &quot;vfsname&quot;, <CheckRefs ids="4268">n</CheckRefs>)==0 ){</Line>
  <Line number="21347">    const char *zDbName = nArg==2 ? azArg[1<CheckRefs ids="4269">]</CheckRefs> : &quot;main&quot;;</Line>
  <Line number="21348">    char *zVfsName = 0;</Line>
  <Line number="21349">    if( p-&gt;db ){</Line>
  <Line number="21350">      sqlite3_file_control(p-&gt;db, zDbName, SQLITE_FCNTL_VFSNAME, &amp;zVfsName);</Line>
  <Line number="21351">      if( zVfsName ){</Line>
  <Line number="21352">        utf8_printf(p-&gt;out, &quot;%s\n&quot;, zVfsName);</Line>
  <Line number="21353">        sqlite3_free(zVfsName);</Line>
  <Line number="21354">      }</Line>
  <Line number="21355">    }</Line>
  <Line number="21356">  }else</Line>
  <Line number="21357"></Line>
  <Line number="21358">  if( c==&apos;w&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="4270">]</CheckRefs>, &quot;wheretrace&quot;, <CheckRefs ids="4271">n</CheckRefs>)==0 ){</Line>
  <Line number="21359">    unsigned int x = nArg&gt;=2 ? <CheckRefs ids="4272">(</CheckRefs>unsigned int)integerValue(azArg[1<CheckRefs ids="4273">]</CheckRefs>) : 0xffffffff;</Line>
  <Line number="21360">    sqlite3_test_control(SQLITE_TESTCTRL_TRACEFLAGS, 3, &amp;x);</Line>
  <Line number="21361">  }else</Line>
  <Line number="21362"></Line>
  <Line number="21363">  if( c==&apos;w&apos; &amp;&amp; strncmp(azArg[0<CheckRefs ids="4274">]</CheckRefs>, &quot;width&quot;, <CheckRefs ids="4275">n</CheckRefs>)==0 ){</Line>
  <Line number="21364">    int j;</Line>
  <Line number="21365">    <CheckRefs ids="4276,4277,4278,4279">assert</CheckRefs>( nArg&lt;=ArraySize(azArg) );</Line>
  <Line number="21366">    p-&gt;nWidth = nArg<CheckRefs ids="4280">-</CheckRefs>1;</Line>
  <Line number="21367">    p-&gt;colWidth = realloc(p-&gt;colWidth, <CheckRefs ids="4283">p</CheckRefs>-&gt;nWidth<CheckRefs ids="4282">*</CheckRefs>sizeof(int)<CheckRefs ids="4281">*</CheckRefs><CheckRefs ids="4284">2</CheckRefs>);</Line>
  <Line number="21368">    if( p-&gt;colWidth==0 &amp;&amp; p-&gt;nWidth&gt;0 ) shell_out_of_memory();</Line>
  <Line number="21369">    if( p-&gt;nWidth ) p-&gt;actualWidth = &amp;p-&gt;colWidth[p-&gt;nWidth];</Line>
  <Line number="21370">    for(j=1; j&lt;nArg; j<CheckRefs ids="4285">++</CheckRefs>){</Line>
  <Line number="21371">      p-&gt;colWidth[j<CheckRefs ids="4286">-</CheckRefs>1] = <CheckRefs ids="4287">(</CheckRefs>int)integerValue(azArg[j<CheckRefs ids="4288">]</CheckRefs>);</Line>
  <Line number="21372">    }</Line>
  <Line number="21373">  }else</Line>
  <Line number="21374"></Line>
  <Line number="21375">  {</Line>
  <Line number="21376">    utf8_printf(stderr, &quot;Error: unknown command or invalid arguments: &quot;</Line>
  <Line number="21377">      &quot; \&quot;%s\&quot;. Enter \&quot;.help\&quot; for help\n&quot;, azArg[0<CheckRefs ids="4289">]</CheckRefs>);</Line>
  <Line number="21378">    rc = 1;</Line>
  <Line number="21379">  }</Line>
  <Line number="21380"></Line>
  <Line number="21381">meta_command_exit:</Line>
  <Line number="21382">  if( p-&gt;outCount ){</Line>
  <Line number="21383">    p-&gt;outCount<CheckRefs ids="4290">--</CheckRefs>;</Line>
  <Line number="21384">    if( p-&gt;outCount==0 ) output_reset(p);</Line>
  <Line number="21385">  }</Line>
  <Line number="21386">  return rc;</Line>
  <Line number="21387">}</Line>
  <Line number="21388"></Line>
  <Line number="21389">/*</Line>
  <Line number="21390">** Return TRUE if a semicolon occurs anywhere in the first N characters</Line>
  <Line number="21391">** of string z[].</Line>
  <Line number="21392">*/</Line>
  <Line number="21393">static int line_contains_semicolon(const char *z, int N){</Line>
  <Line number="21394">  int i;</Line>
  <Line number="21395">  for(i=0; i&lt;N; i<CheckRefs ids="4291">++</CheckRefs>){  if( <CheckRefs ids="4292">z</CheckRefs>[i]==&apos;;&apos; ) return 1; }</Line>
  <Line number="21396">  return 0;</Line>
  <Line number="21397">}</Line>
  <Line number="21398"></Line>
  <Line number="21399">/*</Line>
  <Line number="21400">** Test to see if a line consists entirely of whitespace.</Line>
  <Line number="21401">*/</Line>
  <Line number="21402">static int _all_whitespace(const char *z){</Line>
  <Line number="21403">  for(; *z; z++){</Line>
  <Line number="21404">    if( <CheckRefs ids="4293,4294,4296,4297,4295">IsSpace</CheckRefs>(z[0]) ) continue;</Line>
  <Line number="21405">    if( <CheckRefs ids="4298">*</CheckRefs>z==&apos;/&apos; &amp;&amp; <CheckRefs ids="4299">z</CheckRefs>[1]==&apos;*&apos; ){</Line>
  <Line number="21406">      z += 2;</Line>
  <Line number="21407">      while( <CheckRefs ids="4300">*</CheckRefs>z &amp;&amp; (<CheckRefs ids="4301">*</CheckRefs>z!=&apos;*&apos; || <CheckRefs ids="4302">z</CheckRefs>[1]!=&apos;/&apos;) ){ z++; }</Line>
  <Line number="21408">      if( <CheckRefs ids="4303">*</CheckRefs>z==0 ) return 0;</Line>
  <Line number="21409">      z++;</Line>
  <Line number="21410">      continue;</Line>
  <Line number="21411">    }</Line>
  <Line number="21412">    if( <CheckRefs ids="4304">*</CheckRefs>z==&apos;-&apos; &amp;&amp; <CheckRefs ids="4305">z</CheckRefs>[1]==&apos;-&apos; ){</Line>
  <Line number="21413">      z += 2;</Line>
  <Line number="21414">      while( <CheckRefs ids="4306">*</CheckRefs>z &amp;&amp; <CheckRefs ids="4307">*</CheckRefs>z!=&apos;\n&apos; ){ z++; }</Line>
  <Line number="21415">      if( <CheckRefs ids="4308">*</CheckRefs>z==0 ) return 1;</Line>
  <Line number="21416">      continue;</Line>
  <Line number="21417">    }</Line>
  <Line number="21418">    return 0;</Line>
  <Line number="21419">  }</Line>
  <Line number="21420">  return 1;</Line>
  <Line number="21421">}</Line>
  <Line number="21422"></Line>
  <Line number="21423">/*</Line>
  <Line number="21424">** Return TRUE if the line typed in is an SQL command terminator other</Line>
  <Line number="21425">** than a semi-colon.  The SQL Server style &quot;go&quot; command is understood</Line>
  <Line number="21426">** as is the Oracle &quot;/&quot;.</Line>
  <Line number="21427">*/</Line>
  <Line number="21428">static int line_is_command_terminator(const char *zLine){</Line>
  <Line number="21429">  while( <CheckRefs ids="4309,4310,4312,4313,4311">IsSpace</CheckRefs>(zLine[0]) ){ zLine++; };</Line>
  <Line number="21430">  if( <CheckRefs ids="4314">zLine</CheckRefs>[0]==&apos;/&apos; &amp;&amp; _all_whitespace(&amp;zLine[1]) ){</Line>
  <Line number="21431">    return 1;  /* Oracle */</Line>
  <Line number="21432">  }</Line>
  <Line number="21433">  if( <CheckRefs ids="4315,4317,4318,4316">ToLower</CheckRefs>(zLine[0])==&apos;g&apos; &amp;&amp; <CheckRefs ids="4319,4321,4320,4322">ToLower</CheckRefs>(zLine[1])==&apos;o&apos;</Line>
  <Line number="21434">         &amp;&amp; _all_whitespace(&amp;zLine[2]) ){</Line>
  <Line number="21435">    return 1;  /* SQL Server */</Line>
  <Line number="21436">  }</Line>
  <Line number="21437">  return 0;</Line>
  <Line number="21438">}</Line>
  <Line number="21439"></Line>
  <Line number="21440">/*</Line>
  <Line number="21441">** We need a default sqlite3_complete() implementation to use in case</Line>
  <Line number="21442">** the shell is compiled with SQLITE_OMIT_COMPLETE.  The default assumes</Line>
  <Line number="21443">** any arbitrary text is a complete SQL statement.  This is not very</Line>
  <Line number="21444">** user-friendly, but it does seem to work.</Line>
  <Line number="21445">*/</Line>
  <Line number="21446">#ifdef SQLITE_OMIT_COMPLETE</Line>
  <Line number="21447">#define sqlite3_complete(x) 1</Line>
  <Line number="21448">#endif</Line>
  <Line number="21449"></Line>
  <Line number="21450">/*</Line>
  <Line number="21451">** Return true if zSql is a complete SQL statement.  Return false if it</Line>
  <Line number="21452">** ends in the middle of a string literal or C-style comment.</Line>
  <Line number="21453">*/</Line>
  <Line number="21454">static int line_is_complete(char *zSql, int nSql){</Line>
  <Line number="21455">  int rc;</Line>
  <Line number="21456">  if( zSql==0 ) return 1;</Line>
  <Line number="21457">  zSql[nSql] = <CheckRefs ids="4323">&apos;;&apos;</CheckRefs>;</Line>
  <Line number="21458">  zSql[nSql<CheckRefs ids="4324">+</CheckRefs>1] = <CheckRefs ids="4325">0</CheckRefs>;</Line>
  <Line number="21459">  rc = sqlite3_complete(zSql);</Line>
  <Line number="21460">  zSql[nSql] = <CheckRefs ids="4326">0</CheckRefs>;</Line>
  <Line number="21461">  return rc;</Line>
  <Line number="21462">}</Line>
  <Line number="21463"></Line>
  <Line number="21464">/*</Line>
  <Line number="21465">** Run a single line of SQL.  Return the number of errors.</Line>
  <Line number="21466">*/</Line>
  <Line number="21467">static int runOneSqlLine(ShellState *p, char *zSql, FILE *in, int startline){</Line>
  <Line number="21468">  int rc;</Line>
  <Line number="21469">  char *zErrMsg = 0;</Line>
  <Line number="21470"></Line>
  <Line number="21471">  open_db(p, 0);</Line>
  <Line number="21472">  if( <CheckRefs ids="4327,4328">ShellHasFlag</CheckRefs>(p,SHFLG_Backslash) ) resolve_backslashes(zSql);</Line>
  <Line number="21473">  if( p-&gt;flgProgress &amp; <CheckRefs ids="4329">SHELL_PROGRESS_RESET</CheckRefs> ) p-&gt;nProgress = <CheckRefs ids="4330">0</CheckRefs>;</Line>
  <Line number="21474">  BEGIN_TIMER;</Line>
  <Line number="21475">  rc = shell_exec(p, zSql, &amp;zErrMsg);</Line>
  <Line number="21476">  END_TIMER;</Line>
  <Line number="21477">  if( rc || zErrMsg ){</Line>
  <Line number="21478">    char zPrefix[100];</Line>
  <Line number="21479">    if( in!=0 || !stdin_is_interactive ){</Line>
  <Line number="21480">      sqlite3_snprintf(<CheckRefs ids="4331">sizeof</CheckRefs>(zPrefix), zPrefix,</Line>
  <Line number="21481">                       &quot;Error: near line %d:&quot;, startline);</Line>
  <Line number="21482">    }else{</Line>
  <Line number="21483">      sqlite3_snprintf(<CheckRefs ids="4332">sizeof</CheckRefs>(zPrefix), zPrefix, &quot;Error:&quot;);</Line>
  <Line number="21484">    }</Line>
  <Line number="21485">    if( zErrMsg!=0 ){</Line>
  <Line number="21486">      utf8_printf(stderr, &quot;%s %s\n&quot;, zPrefix, zErrMsg);</Line>
  <Line number="21487">      sqlite3_free(zErrMsg);</Line>
  <Line number="21488">      zErrMsg = 0;</Line>
  <Line number="21489">    }else{</Line>
  <Line number="21490">      utf8_printf(stderr, &quot;%s %s\n&quot;, zPrefix, sqlite3_errmsg(p-&gt;db));</Line>
  <Line number="21491">    }</Line>
  <Line number="21492">    return 1;</Line>
  <Line number="21493">  }else if( <CheckRefs ids="4334,4333">ShellHasFlag</CheckRefs>(p, SHFLG_CountChanges) ){</Line>
  <Line number="21494">    raw_printf(p-&gt;out, &quot;changes: %3d   total_changes: %d\n&quot;,</Line>
  <Line number="21495">            sqlite3_changes(p-&gt;db), sqlite3_total_changes(p-&gt;db));</Line>
  <Line number="21496">  }</Line>
  <Line number="21497">  return 0;</Line>
  <Line number="21498">}</Line>
  <Line number="21499"></Line>
  <Line number="21500"></Line>
  <Line number="21501">/*</Line>
  <Line number="21502">** Read input from *in and process it.  If *in==0 then input</Line>
  <Line number="21503">** is interactive - the user is typing it it.  Otherwise, input</Line>
  <Line number="21504">** is coming from a file or device.  A prompt is issued and history</Line>
  <Line number="21505">** is saved only if input is interactive.  An interrupt signal will</Line>
  <Line number="21506">** cause this routine to exit immediately, unless input is interactive.</Line>
  <Line number="21507">**</Line>
  <Line number="21508">** Return the number of errors.</Line>
  <Line number="21509">*/</Line>
  <Line number="21510">static int process_input(ShellState *p){</Line>
  <Line number="21511">  char *zLine = 0;          /* A single input line */</Line>
  <Line number="21512">  char *zSql = 0;           /* Accumulated SQL text */</Line>
  <Line number="21513">  int nLine;                /* Length of current line */</Line>
  <Line number="21514">  int nSql = 0;             /* Bytes of zSql[] used */</Line>
  <Line number="21515">  int nAlloc = 0;           /* Allocated zSql[] space */</Line>
  <Line number="21516">  int nSqlPrior = 0;        /* Bytes of zSql[] used by prior line */</Line>
  <Line number="21517">  int rc;                   /* Error code */</Line>
  <Line number="21518">  int errCnt = 0;           /* Number of errors seen */</Line>
  <Line number="21519">  int startline = 0;        /* Line number for start of current input */</Line>
  <Line number="21520"></Line>
  <Line number="21521">  p-&gt;lineno = 0;</Line>
  <Line number="21522">  while( errCnt==0 || !bail_on_error || (p-&gt;in==0 &amp;&amp; stdin_is_interactive) ){</Line>
  <Line number="21523">    fflush(p-&gt;out);</Line>
  <Line number="21524">    zLine = one_input_line(p-&gt;in, zLine, nSql&gt;0);</Line>
  <Line number="21525">    if( zLine==0 ){</Line>
  <Line number="21526">      /* End of input */</Line>
  <Line number="21527">      if( p-&gt;in==0 &amp;&amp; stdin_is_interactive ) printf(&quot;\n&quot;);</Line>
  <Line number="21528">      break;</Line>
  <Line number="21529">    }</Line>
  <Line number="21530">    if( seenInterrupt ){</Line>
  <Line number="21531">      if( p-&gt;in!=0 ) break;</Line>
  <Line number="21532">      seenInterrupt = 0;</Line>
  <Line number="21533">    }</Line>
  <Line number="21534">    p-&gt;lineno<CheckRefs ids="4335">++</CheckRefs>;</Line>
  <Line number="21535">    if( nSql==0 &amp;&amp; _all_whitespace(zLine) ){</Line>
  <Line number="21536">      if( <CheckRefs ids="4337,4336">ShellHasFlag</CheckRefs>(p, SHFLG_Echo) ) printf(&quot;%s\n&quot;, zLine);</Line>
  <Line number="21537">      continue;</Line>
  <Line number="21538">    }</Line>
  <Line number="21539">    if( zLine &amp;&amp; (<CheckRefs ids="4338">zLine</CheckRefs>[0]==&apos;.&apos; || <CheckRefs ids="4339">zLine</CheckRefs>[0]==&apos;#&apos;) &amp;&amp; nSql==0 ){</Line>
  <Line number="21540">      if( <CheckRefs ids="4340,4341">ShellHasFlag</CheckRefs>(p, SHFLG_Echo) ) printf(&quot;%s\n&quot;, zLine);</Line>
  <Line number="21541">      if( <CheckRefs ids="4342">zLine</CheckRefs>[0]==&apos;.&apos; ){</Line>
  <Line number="21542">        rc = do_meta_command(zLine, p);</Line>
  <Line number="21543">        if( rc==2 ){ /* exit requested */</Line>
  <Line number="21544">          break;</Line>
  <Line number="21545">        }else if( rc ){</Line>
  <Line number="21546">          errCnt<CheckRefs ids="4343">++</CheckRefs>;</Line>
  <Line number="21547">        }</Line>
  <Line number="21548">      }</Line>
  <Line number="21549">      continue;</Line>
  <Line number="21550">    }</Line>
  <Line number="21551">    if( line_is_command_terminator(zLine) &amp;&amp; line_is_complete(zSql, nSql) ){</Line>
  <Line number="21552">      memcpy(zLine,&quot;;&quot;,<CheckRefs ids="4344">2</CheckRefs>);</Line>
  <Line number="21553">    }</Line>
  <Line number="21554">    nLine = strlen30(zLine);</Line>
  <Line number="21555">    if( nSql<CheckRefs ids="4346">+</CheckRefs>nLine<CheckRefs ids="4345">+</CheckRefs>2&gt;=nAlloc ){</Line>
  <Line number="21556">      nAlloc = nSql<CheckRefs ids="4348">+</CheckRefs>nLine<CheckRefs ids="4347">+</CheckRefs>100;</Line>
  <Line number="21557">      zSql = realloc(zSql, <CheckRefs ids="4349">nAlloc</CheckRefs>);</Line>
  <Line number="21558">      if( zSql==0 ) shell_out_of_memory();</Line>
  <Line number="21559">    }</Line>
  <Line number="21560">    nSqlPrior = nSql;</Line>
  <Line number="21561">    if( nSql==0 ){</Line>
  <Line number="21562">      int i;</Line>
  <Line number="21563">      for(i=0; <CheckRefs ids="4350">zLine</CheckRefs>[i] &amp;&amp; <CheckRefs ids="4354,4355,4352,4351,4353">IsSpace</CheckRefs>(zLine[i]); i<CheckRefs ids="4356">++</CheckRefs>){}</Line>
  <Line number="21564">      <CheckRefs ids="4357">assert</CheckRefs>( nAlloc&gt;0 &amp;&amp; zSql!=0 );</Line>
  <Line number="21565">      memcpy(zSql, zLine+i, nLine<CheckRefs ids="4360">+</CheckRefs>1<CheckRefs ids="4358,4359">-</CheckRefs>i);</Line>
  <Line number="21566">      startline = p-&gt;lineno;</Line>
  <Line number="21567">      nSql = nLine<CheckRefs ids="4361">-</CheckRefs>i;</Line>
  <Line number="21568">    }else{</Line>
  <Line number="21569">      zSql[nSql<CheckRefs ids="4362">++</CheckRefs>] = <CheckRefs ids="4363">&apos;\n&apos;</CheckRefs>;</Line>
  <Line number="21570">      memcpy(zSql+nSql, zLine, nLine<CheckRefs ids="4364,4365">+</CheckRefs>1);</Line>
  <Line number="21571">      nSql <CheckRefs ids="4366">+=</CheckRefs> nLine;</Line>
  <Line number="21572">    }</Line>
  <Line number="21573">    if( nSql &amp;&amp; line_contains_semicolon(&amp;zSql[nSqlPrior], nSql<CheckRefs ids="4367">-</CheckRefs>nSqlPrior)</Line>
  <Line number="21574">                &amp;&amp; sqlite3_complete(zSql) ){</Line>
  <Line number="21575">      errCnt <CheckRefs ids="4368">+=</CheckRefs> runOneSqlLine(p, zSql, p-&gt;in, startline);</Line>
  <Line number="21576">      nSql = 0;</Line>
  <Line number="21577">      if( p-&gt;outCount ){</Line>
  <Line number="21578">        output_reset(p);</Line>
  <Line number="21579">        p-&gt;outCount = 0;</Line>
  <Line number="21580">      }else{</Line>
  <Line number="21581">        clearTempFile(p);</Line>
  <Line number="21582">      }</Line>
  <Line number="21583">    }else if( nSql &amp;&amp; _all_whitespace(zSql) ){</Line>
  <Line number="21584">      if( <CheckRefs ids="4369,4370">ShellHasFlag</CheckRefs>(p, SHFLG_Echo) ) printf(&quot;%s\n&quot;, zSql);</Line>
  <Line number="21585">      nSql = 0;</Line>
  <Line number="21586">    }</Line>
  <Line number="21587">  }</Line>
  <Line number="21588">  if( nSql &amp;&amp; !_all_whitespace(zSql) ){</Line>
  <Line number="21589">    errCnt <CheckRefs ids="4371">+=</CheckRefs> runOneSqlLine(p, zSql, p-&gt;in, startline);</Line>
  <Line number="21590">  }</Line>
  <Line number="21591">  free(zSql);</Line>
  <Line number="21592">  free(zLine);</Line>
  <Line number="21593">  return errCnt&gt;0;</Line>
  <Line number="21594">}</Line>
  <Line number="21595"></Line>
  <Line number="21596">/*</Line>
  <Line number="21597">** Return a pathname which is the user&apos;s home directory.  A</Line>
  <Line number="21598">** 0 return indicates an error of some kind.</Line>
  <Line number="21599">*/</Line>
  <Line number="21600">static char *find_home_dir(int clearFlag){</Line>
  <Line number="21601">  static char *home_dir = NULL;</Line>
  <Line number="21602">  if( clearFlag ){</Line>
  <Line number="21603">    free(home_dir);</Line>
  <Line number="21604">    home_dir = 0;</Line>
  <Line number="21605">    return 0;</Line>
  <Line number="21606">  }</Line>
  <Line number="21607">  if( home_dir ) return home_dir;</Line>
  <Line number="21608"></Line>
  <Line number="21609">#if !defined(_WIN32) &amp;&amp; !defined(WIN32) &amp;&amp; !defined(_WIN32_WCE) \</Line>
  <Line number="21610">     &amp;&amp; !defined(__RTP__) &amp;&amp; !defined(_WRS_KERNEL)</Line>
  <Line number="21611">  {</Line>
  <Line number="21612">    struct passwd *pwent;</Line>
  <Line number="21613">    uid_t uid = getuid();</Line>
  <Line number="21614">    if( (pwent=getpwuid(uid)) != NULL) {</Line>
  <Line number="21615">      home_dir = pwent-&gt;pw_dir;</Line>
  <Line number="21616">    }</Line>
  <Line number="21617">  }</Line>
  <Line number="21618">#endif</Line>
  <Line number="21619"></Line>
  <Line number="21620">#if defined(_WIN32_WCE)</Line>
  <Line number="21621">  /* Windows CE (arm-wince-mingw32ce-gcc) does not provide getenv()</Line>
  <Line number="21622">   */</Line>
  <Line number="21623">  home_dir = &quot;/&quot;;</Line>
  <Line number="21624">#else</Line>
  <Line number="21625"></Line>
  <Line number="21626">#if defined(_WIN32) || defined(WIN32)</Line>
  <Line number="21627">  if (!home_dir) {</Line>
  <Line number="21628">    home_dir = getenv(&quot;USERPROFILE&quot;);</Line>
  <Line number="21629">  }</Line>
  <Line number="21630">#endif</Line>
  <Line number="21631"></Line>
  <Line number="21632">  if (!home_dir) {</Line>
  <Line number="21633">    home_dir = getenv(&quot;HOME&quot;);</Line>
  <Line number="21634">  }</Line>
  <Line number="21635"></Line>
  <Line number="21636">#if defined(_WIN32) || defined(WIN32)</Line>
  <Line number="21637">  if (!home_dir) {</Line>
  <Line number="21638">    char *zDrive, *zPath;</Line>
  <Line number="21639">    int n;</Line>
  <Line number="21640">    zDrive = getenv(&quot;HOMEDRIVE&quot;);</Line>
  <Line number="21641">    zPath = getenv(&quot;HOMEPATH&quot;);</Line>
  <Line number="21642">    if( zDrive &amp;&amp; zPath ){</Line>
  <Line number="21643">      n = strlen30(zDrive) + strlen30(zPath) + 1;</Line>
  <Line number="21644">      home_dir = malloc( n );</Line>
  <Line number="21645">      if( home_dir==0 ) return 0;</Line>
  <Line number="21646">      sqlite3_snprintf(n, home_dir, &quot;%s%s&quot;, zDrive, zPath);</Line>
  <Line number="21647">      return home_dir;</Line>
  <Line number="21648">    }</Line>
  <Line number="21649">    home_dir = &quot;c:\\&quot;;</Line>
  <Line number="21650">  }</Line>
  <Line number="21651">#endif</Line>
  <Line number="21652"></Line>
  <Line number="21653">#endif /* !_WIN32_WCE */</Line>
  <Line number="21654"></Line>
  <Line number="21655">  if( home_dir ){</Line>
  <Line number="21656">    int n = strlen30(home_dir) <CheckRefs ids="4372">+</CheckRefs> 1;</Line>
  <Line number="21657">    char *z = malloc( <CheckRefs ids="4373">n</CheckRefs> );</Line>
  <Line number="21658">    if( z ) memcpy(z, home_dir, <CheckRefs ids="4374">n</CheckRefs>);</Line>
  <Line number="21659">    home_dir = z;</Line>
  <Line number="21660">  }</Line>
  <Line number="21661"></Line>
  <Line number="21662">  return home_dir;</Line>
  <Line number="21663">}</Line>
  <Line number="21664"></Line>
  <Line number="21665">/*</Line>
  <Line number="21666">** Read input from the file given by sqliterc_override.  Or if that</Line>
  <Line number="21667">** parameter is NULL, take input from ~/.sqliterc</Line>
  <Line number="21668">**</Line>
  <Line number="21669">** Returns the number of errors.</Line>
  <Line number="21670">*/</Line>
  <Line number="21671">static void process_sqliterc(</Line>
  <Line number="21672">  ShellState *p,                  /* Configuration data */</Line>
  <Line number="21673">  const char *sqliterc_override   /* Name of config file. NULL to use default */</Line>
  <Line number="21674">){</Line>
  <Line number="21675">  char *home_dir = NULL;</Line>
  <Line number="21676">  const char *sqliterc = sqliterc_override;</Line>
  <Line number="21677">  char *zBuf = 0;</Line>
  <Line number="21678">  FILE *inSaved = p-&gt;in;</Line>
  <Line number="21679">  int savedLineno = p-&gt;lineno;</Line>
  <Line number="21680"></Line>
  <Line number="21681">  if (sqliterc == NULL) {</Line>
  <Line number="21682">    home_dir = find_home_dir(0);</Line>
  <Line number="21683">    if( home_dir==0 ){</Line>
  <Line number="21684">      raw_printf(stderr, &quot;-- warning: cannot find home directory;&quot;</Line>
  <Line number="21685">                      &quot; cannot read ~/.sqliterc\n&quot;);</Line>
  <Line number="21686">      return;</Line>
  <Line number="21687">    }</Line>
  <Line number="21688">    zBuf = sqlite3_mprintf(&quot;%s/.sqliterc&quot;,home_dir);</Line>
  <Line number="21689">    sqliterc = zBuf;</Line>
  <Line number="21690">  }</Line>
  <Line number="21691">  p-&gt;in = fopen(sqliterc,&quot;rb&quot;);</Line>
  <Line number="21692">  if( p-&gt;in ){</Line>
  <Line number="21693">    if( stdin_is_interactive ){</Line>
  <Line number="21694">      utf8_printf(stderr,&quot;-- Loading resources from %s\n&quot;,sqliterc);</Line>
  <Line number="21695">    }</Line>
  <Line number="21696">    if( process_input(p) &amp;&amp; bail_on_error ) exit(1);</Line>
  <Line number="21697">    fclose(p-&gt;in);</Line>
  <Line number="21698">  }else if( sqliterc_override!=0 ){</Line>
  <Line number="21699">    utf8_printf(stderr,&quot;cannot open: \&quot;%s\&quot;\n&quot;, sqliterc);</Line>
  <Line number="21700">    if( bail_on_error ) exit(1);</Line>
  <Line number="21701">  }</Line>
  <Line number="21702">  p-&gt;in = inSaved;</Line>
  <Line number="21703">  p-&gt;lineno = savedLineno;</Line>
  <Line number="21704">  sqlite3_free(zBuf);</Line>
  <Line number="21705">}</Line>
  <Line number="21706"></Line>
  <Line number="21707">/*</Line>
  <Line number="21708">** Show available command line options</Line>
  <Line number="21709">*/</Line>
  <Line number="21710">static const char zOptions[] =</Line>
  <Line number="21711">#if defined(SQLITE_HAVE_ZLIB) &amp;&amp; !defined(SQLITE_OMIT_VIRTUALTABLE)</Line>
  <Line number="21712">  &quot;   -A ARGS...           run \&quot;.archive ARGS\&quot; and exit\n&quot;</Line>
  <Line number="21713">#endif</Line>
  <Line number="21714">  &quot;   -append              append the database to the end of the file\n&quot;</Line>
  <Line number="21715">  &quot;   -ascii               set output mode to &apos;ascii&apos;\n&quot;</Line>
  <Line number="21716">  &quot;   -bail                stop after hitting an error\n&quot;</Line>
  <Line number="21717">  &quot;   -batch               force batch I/O\n&quot;</Line>
  <Line number="21718">  &quot;   -box                 set output mode to &apos;box&apos;\n&quot;</Line>
  <Line number="21719">  &quot;   -column              set output mode to &apos;column&apos;\n&quot;</Line>
  <Line number="21720">  &quot;   -cmd COMMAND         run \&quot;COMMAND\&quot; before reading stdin\n&quot;</Line>
  <Line number="21721">  &quot;   -csv                 set output mode to &apos;csv&apos;\n&quot;</Line>
  <Line number="21722">#if !defined(SQLITE_OMIT_DESERIALIZE)</Line>
  <Line number="21723">  &quot;   -deserialize         open the database using sqlite3_deserialize()\n&quot;</Line>
  <Line number="21724">#endif</Line>
  <Line number="21725">  &quot;   -echo                print commands before execution\n&quot;</Line>
  <Line number="21726">  &quot;   -init FILENAME       read/process named file\n&quot;</Line>
  <Line number="21727">  &quot;   -[no]header          turn headers on or off\n&quot;</Line>
  <Line number="21728">#if defined(SQLITE_ENABLE_MEMSYS3) || defined(SQLITE_ENABLE_MEMSYS5)</Line>
  <Line number="21729">  &quot;   -heap SIZE           Size of heap for memsys3 or memsys5\n&quot;</Line>
  <Line number="21730">#endif</Line>
  <Line number="21731">  &quot;   -help                show this message\n&quot;</Line>
  <Line number="21732">  &quot;   -html                set output mode to HTML\n&quot;</Line>
  <Line number="21733">  &quot;   -interactive         force interactive I/O\n&quot;</Line>
  <Line number="21734">  &quot;   -json                set output mode to &apos;json&apos;\n&quot;</Line>
  <Line number="21735">  &quot;   -line                set output mode to &apos;line&apos;\n&quot;</Line>
  <Line number="21736">  &quot;   -list                set output mode to &apos;list&apos;\n&quot;</Line>
  <Line number="21737">  &quot;   -lookaside SIZE N    use N entries of SZ bytes for lookaside memory\n&quot;</Line>
  <Line number="21738">  &quot;   -markdown            set output mode to &apos;markdown&apos;\n&quot;</Line>
  <Line number="21739">#if !defined(SQLITE_OMIT_DESERIALIZE)</Line>
  <Line number="21740">  &quot;   -maxsize N           maximum size for a --deserialize database\n&quot;</Line>
  <Line number="21741">#endif</Line>
  <Line number="21742">  &quot;   -memtrace            trace all memory allocations and deallocations\n&quot;</Line>
  <Line number="21743">  &quot;   -mmap N              default mmap size set to N\n&quot;</Line>
  <Line number="21744">#ifdef SQLITE_ENABLE_MULTIPLEX</Line>
  <Line number="21745">  &quot;   -multiplex           enable the multiplexor VFS\n&quot;</Line>
  <Line number="21746">#endif</Line>
  <Line number="21747">  &quot;   -newline SEP         set output row separator. Default: &apos;\\n&apos;\n&quot;</Line>
  <Line number="21748">  &quot;   -nofollow            refuse to open symbolic links to database files\n&quot;</Line>
  <Line number="21749">  &quot;   -nullvalue TEXT      set text string for NULL values. Default &apos;&apos;\n&quot;</Line>
  <Line number="21750">  &quot;   -pagecache SIZE N    use N slots of SZ bytes each for page cache memory\n&quot;</Line>
  <Line number="21751">  &quot;   -quote               set output mode to &apos;quote&apos;\n&quot;</Line>
  <Line number="21752">  &quot;   -readonly            open the database read-only\n&quot;</Line>
  <Line number="21753">  &quot;   -separator SEP       set output column separator. Default: &apos;|&apos;\n&quot;</Line>
  <Line number="21754">#ifdef SQLITE_ENABLE_SORTER_REFERENCES</Line>
  <Line number="21755">  &quot;   -sorterref SIZE      sorter references threshold size\n&quot;</Line>
  <Line number="21756">#endif</Line>
  <Line number="21757">  &quot;   -stats               print memory stats before each finalize\n&quot;</Line>
  <Line number="21758">  &quot;   -table               set output mode to &apos;table&apos;\n&quot;</Line>
  <Line number="21759">  &quot;   -tabs                set output mode to &apos;tabs&apos;\n&quot;</Line>
  <Line number="21760">  &quot;   -version             show SQLite version\n&quot;</Line>
  <Line number="21761">  &quot;   -vfs NAME            use NAME as the default VFS\n&quot;</Line>
  <Line number="21762">#ifdef SQLITE_ENABLE_VFSTRACE</Line>
  <Line number="21763">  &quot;   -vfstrace            enable tracing of all VFS calls\n&quot;</Line>
  <Line number="21764">#endif</Line>
  <Line number="21765">#ifdef SQLITE_HAVE_ZLIB</Line>
  <Line number="21766">  &quot;   -zip                 open the file as a ZIP Archive\n&quot;</Line>
  <Line number="21767">#endif</Line>
  <Line number="21768">;</Line>
  <Line number="21769">static void usage(int showDetail){</Line>
  <Line number="21770">  utf8_printf(stderr,</Line>
  <Line number="21771">      &quot;Usage: %s [OPTIONS] FILENAME [SQL]\n&quot;</Line>
  <Line number="21772">      &quot;FILENAME is the name of an SQLite database. A new database is created\n&quot;</Line>
  <Line number="21773">      &quot;if the file does not previously exist.\n&quot;, Argv0);</Line>
  <Line number="21774">  if( showDetail ){</Line>
  <Line number="21775">    utf8_printf(stderr, &quot;OPTIONS include:\n%s&quot;, zOptions);</Line>
  <Line number="21776">  }else{</Line>
  <Line number="21777">    raw_printf(stderr, &quot;Use the -help option for additional information\n&quot;);</Line>
  <Line number="21778">  }</Line>
  <Line number="21779">  exit(1);</Line>
  <Line number="21780">}</Line>
  <Line number="21781"></Line>
  <Line number="21782">/*</Line>
  <Line number="21783">** Internal check:  Verify that the SQLite is uninitialized.  Print a</Line>
  <Line number="21784">** error message if it is initialized.</Line>
  <Line number="21785">*/</Line>
  <Line number="21786">static void verify_uninitialized(void){</Line>
  <Line number="21787">  if( sqlite3_config(<CheckRefs ids="4375">-</CheckRefs>1)==SQLITE_MISUSE ){</Line>
  <Line number="21788">    utf8_printf(stdout, &quot;WARNING: attempt to configure SQLite after&quot;</Line>
  <Line number="21789">                        &quot; initialization.\n&quot;);</Line>
  <Line number="21790">  }</Line>
  <Line number="21791">}</Line>
  <Line number="21792"></Line>
  <Line number="21793">/*</Line>
  <Line number="21794">** Initialize the state information in data</Line>
  <Line number="21795">*/</Line>
  <Line number="21796">static void main_init(ShellState *data) {</Line>
  <Line number="21797">  memset(data, 0, sizeof(*data));</Line>
  <Line number="21798">  data-&gt;normalMode = data-&gt;cMode = data-&gt;mode = MODE_List;</Line>
  <Line number="21799">  data-&gt;autoExplain = <CheckRefs ids="4376">1</CheckRefs>;</Line>
  <Line number="21800">  memcpy(data-&gt;colSeparator,SEP_Column, <CheckRefs ids="4377">2</CheckRefs>);</Line>
  <Line number="21801">  memcpy(data-&gt;rowSeparator,SEP_Row, <CheckRefs ids="4378">2</CheckRefs>);</Line>
  <Line number="21802">  data-&gt;showHeader = 0;</Line>
  <Line number="21803">  data-&gt;shellFlgs = <CheckRefs ids="4379">SHFLG_Lookaside</CheckRefs>;</Line>
  <Line number="21804">  verify_uninitialized();</Line>
  <Line number="21805">  sqlite3_config(SQLITE_CONFIG_URI, 1);</Line>
  <Line number="21806">  sqlite3_config(SQLITE_CONFIG_LOG, shellLog, data);</Line>
  <Line number="21807">  sqlite3_config(SQLITE_CONFIG_MULTITHREAD);</Line>
  <Line number="21808">  sqlite3_snprintf(<CheckRefs ids="4380">sizeof</CheckRefs>(mainPrompt), mainPrompt,&quot;sqlite&gt; &quot;);</Line>
  <Line number="21809">  sqlite3_snprintf(<CheckRefs ids="4381">sizeof</CheckRefs>(continuePrompt), continuePrompt,&quot;   ...&gt; &quot;);</Line>
  <Line number="21810">}</Line>
  <Line number="21811"></Line>
  <Line number="21812">/*</Line>
  <Line number="21813">** Output text to the console in a font that attracts extra attention.</Line>
  <Line number="21814">*/</Line>
  <Line number="21815">#ifdef _WIN32</Line>
  <Line number="21816">static void printBold(const char *zText){</Line>
  <Line number="21817">#if !SQLITE_OS_WINRT</Line>
  <Line number="21818">  HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);</Line>
  <Line number="21819">  CONSOLE_SCREEN_BUFFER_INFO defaultScreenInfo;</Line>
  <Line number="21820">  GetConsoleScreenBufferInfo(out, &amp;defaultScreenInfo);</Line>
  <Line number="21821">  SetConsoleTextAttribute(out,</Line>
  <Line number="21822">         FOREGROUND_RED|FOREGROUND_INTENSITY</Line>
  <Line number="21823">  );</Line>
  <Line number="21824">#endif</Line>
  <Line number="21825">  printf(&quot;%s&quot;, zText);</Line>
  <Line number="21826">#if !SQLITE_OS_WINRT</Line>
  <Line number="21827">  SetConsoleTextAttribute(out, defaultScreenInfo.wAttributes);</Line>
  <Line number="21828">#endif</Line>
  <Line number="21829">}</Line>
  <Line number="21830">#else</Line>
  <Line number="21831">static void printBold(const char *zText){</Line>
  <Line number="21832">  printf(&quot;\033[1m%s\033[0m&quot;, zText);</Line>
  <Line number="21833">}</Line>
  <Line number="21834">#endif</Line>
  <Line number="21835"></Line>
  <Line number="21836">/*</Line>
  <Line number="21837">** Get the argument to an --option.  Throw an error and die if no argument</Line>
  <Line number="21838">** is available.</Line>
  <Line number="21839">*/</Line>
  <Line number="21840">static char *cmdline_option_value(int argc, char **argv, int i){</Line>
  <Line number="21841">  if( i==argc ){</Line>
  <Line number="21842">    utf8_printf(stderr, &quot;%s: Error: missing argument to %s\n&quot;,</Line>
  <Line number="21843">            argv[0], argv[argc<CheckRefs ids="4382">-</CheckRefs>1]);</Line>
  <Line number="21844">    exit(1);</Line>
  <Line number="21845">  }</Line>
  <Line number="21846">  return argv[i];</Line>
  <Line number="21847">}</Line>
  <Line number="21848"></Line>
  <Line number="21849">#ifndef SQLITE_SHELL_IS_UTF8</Line>
  <Line number="21850">#  if (defined(_WIN32) || defined(WIN32)) \</Line>
  <Line number="21851">   &amp;&amp; (defined(_MSC_VER) || (defined(UNICODE) &amp;&amp; defined(__GNUC__)))</Line>
  <Line number="21852">#    define SQLITE_SHELL_IS_UTF8          (0)</Line>
  <Line number="21853">#  else</Line>
  <Line number="21854">#    define SQLITE_SHELL_IS_UTF8          (1)</Line>
  <Line number="21855">#  endif</Line>
  <Line number="21856">#endif</Line>
  <Line number="21857"></Line>
  <Line number="21858">#if SQLITE_SHELL_IS_UTF8</Line>
  <Line number="21859">int SQLITE_CDECL main(int argc, char **argv){</Line>
  <Line number="21860">#else</Line>
  <Line number="21861">int SQLITE_CDECL wmain(int argc, wchar_t **wargv){</Line>
  <Line number="21862">  char **argv;</Line>
  <Line number="21863">#endif</Line>
  <Line number="21864">  char *zErrMsg = 0;</Line>
  <Line number="21865">  ShellState data;</Line>
  <Line number="21866">  const char *zInitFile = 0;</Line>
  <Line number="21867">  int i;</Line>
  <Line number="21868">  int rc = 0;</Line>
  <Line number="21869">  int warnInmemoryDb = 0;</Line>
  <Line number="21870">  int readStdin = 1;</Line>
  <Line number="21871">  int nCmd = 0;</Line>
  <Line number="21872">  char **azCmd = 0;</Line>
  <Line number="21873">  const char *zVfs = 0;           /* Value of -vfs command-line option */</Line>
  <Line number="21874">#if !SQLITE_SHELL_IS_UTF8</Line>
  <Line number="21875">  char **argvToFree = 0;</Line>
  <Line number="21876">  int argcToFree = 0;</Line>
  <Line number="21877">#endif</Line>
  <Line number="21878"></Line>
  <Line number="21879">  setBinaryMode(stdin, 0);</Line>
  <Line number="21880">  setvbuf(stderr, 0, _IONBF, <CheckRefs ids="4383">0</CheckRefs>); /* Make sure stderr is unbuffered */</Line>
  <Line number="21881">  stdin_is_interactive = isatty(0);</Line>
  <Line number="21882">  stdout_is_console = isatty(1);</Line>
  <Line number="21883"></Line>
  <Line number="21884">#ifdef SQLITE_DEBUG</Line>
  <Line number="21885">  registerOomSimulator();</Line>
  <Line number="21886">#endif</Line>
  <Line number="21887"></Line>
  <Line number="21888">#if !defined(_WIN32_WCE)</Line>
  <Line number="21889">  if( getenv(&quot;SQLITE_DEBUG_BREAK&quot;) ){</Line>
  <Line number="21890">    if( isatty(0) &amp;&amp; isatty(2) ){</Line>
  <Line number="21891">      fprintf(stderr,</Line>
  <Line number="21892">          &quot;attach debugger to process %d and press any key to continue.\n&quot;,</Line>
  <Line number="21893">          GETPID());</Line>
  <Line number="21894">      fgetc(stdin);</Line>
  <Line number="21895">    }else{</Line>
  <Line number="21896">#if defined(_WIN32) || defined(WIN32)</Line>
  <Line number="21897">#if SQLITE_OS_WINRT</Line>
  <Line number="21898">      __debugbreak();</Line>
  <Line number="21899">#else</Line>
  <Line number="21900">      DebugBreak();</Line>
  <Line number="21901">#endif</Line>
  <Line number="21902">#elif defined(SIGTRAP)</Line>
  <Line number="21903">      raise(SIGTRAP);</Line>
  <Line number="21904">#endif</Line>
  <Line number="21905">    }</Line>
  <Line number="21906">  }</Line>
  <Line number="21907">#endif</Line>
  <Line number="21908"></Line>
  <Line number="21909">#if USE_SYSTEM_SQLITE+0!=1</Line>
  <Line number="21910">  if( strncmp(sqlite3_sourceid(),SQLITE_SOURCE_ID,<CheckRefs ids="4384">60</CheckRefs>)!=0 ){</Line>
  <Line number="21911">    utf8_printf(stderr, &quot;SQLite header and source version mismatch\n%s\n%s\n&quot;,</Line>
  <Line number="21912">            sqlite3_sourceid(), SQLITE_SOURCE_ID);</Line>
  <Line number="21913">    exit(1);</Line>
  <Line number="21914">  }</Line>
  <Line number="21915">#endif</Line>
  <Line number="21916">  main_init(&amp;data);</Line>
  <Line number="21917"></Line>
  <Line number="21918">  /* On Windows, we must translate command-line arguments into UTF-8.</Line>
  <Line number="21919">  ** The SQLite memory allocator subsystem has to be enabled in order to</Line>
  <Line number="21920">  ** do this.  But we want to run an sqlite3_shutdown() afterwards so that</Line>
  <Line number="21921">  ** subsequent sqlite3_config() calls will work.  So copy all results into</Line>
  <Line number="21922">  ** memory that does not come from the SQLite memory allocator.</Line>
  <Line number="21923">  */</Line>
  <Line number="21924">#if !SQLITE_SHELL_IS_UTF8</Line>
  <Line number="21925">  sqlite3_initialize();</Line>
  <Line number="21926">  argvToFree = malloc(sizeof(argv[0])*argc*2);</Line>
  <Line number="21927">  argcToFree = argc;</Line>
  <Line number="21928">  argv = argvToFree + argc;</Line>
  <Line number="21929">  if( argv==0 ) shell_out_of_memory();</Line>
  <Line number="21930">  for(i=0; i&lt;argc; i++){</Line>
  <Line number="21931">    char *z = sqlite3_win32_unicode_to_utf8(wargv[i]);</Line>
  <Line number="21932">    int n;</Line>
  <Line number="21933">    if( z==0 ) shell_out_of_memory();</Line>
  <Line number="21934">    n = (int)strlen(z);</Line>
  <Line number="21935">    argv[i] = malloc( n+1 );</Line>
  <Line number="21936">    if( argv[i]==0 ) shell_out_of_memory();</Line>
  <Line number="21937">    memcpy(argv[i], z, n+1);</Line>
  <Line number="21938">    argvToFree[i] = argv[i];</Line>
  <Line number="21939">    sqlite3_free(z);</Line>
  <Line number="21940">  }</Line>
  <Line number="21941">  sqlite3_shutdown();</Line>
  <Line number="21942">#endif</Line>
  <Line number="21943"></Line>
  <Line number="21944">  <CheckRefs ids="4385">assert</CheckRefs>( argc&gt;=1 &amp;&amp; argv &amp;&amp; argv[0] );</Line>
  <Line number="21945">  Argv0 = argv[0];</Line>
  <Line number="21946"></Line>
  <Line number="21947">  /* Make sure we have a valid signal handler early, before anything</Line>
  <Line number="21948">  ** else is done.</Line>
  <Line number="21949">  */</Line>
  <Line number="21950">#ifdef SIGINT</Line>
  <Line number="21951">  signal(SIGINT, interrupt_handler);</Line>
  <Line number="21952">#elif (defined(_WIN32) || defined(WIN32)) &amp;&amp; !defined(_WIN32_WCE)</Line>
  <Line number="21953">  SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);</Line>
  <Line number="21954">#endif</Line>
  <Line number="21955"></Line>
  <Line number="21956">#ifdef SQLITE_SHELL_DBNAME_PROC</Line>
  <Line number="21957">  {</Line>
  <Line number="21958">    /* If the SQLITE_SHELL_DBNAME_PROC macro is defined, then it is the name</Line>
  <Line number="21959">    ** of a C-function that will provide the name of the database file.  Use</Line>
  <Line number="21960">    ** this compile-time option to embed this shell program in larger</Line>
  <Line number="21961">    ** applications. */</Line>
  <Line number="21962">    extern void SQLITE_SHELL_DBNAME_PROC(const char**);</Line>
  <Line number="21963">    SQLITE_SHELL_DBNAME_PROC(&amp;data.zDbFilename);</Line>
  <Line number="21964">    warnInmemoryDb = 0;</Line>
  <Line number="21965">  }</Line>
  <Line number="21966">#endif</Line>
  <Line number="21967"></Line>
  <Line number="21968">  /* Do an initial pass through the command-line argument to locate</Line>
  <Line number="21969">  ** the name of the database file, the name of the initialization file,</Line>
  <Line number="21970">  ** the size of the alternative malloc heap,</Line>
  <Line number="21971">  ** and the first command to execute.</Line>
  <Line number="21972">  */</Line>
  <Line number="21973">  verify_uninitialized();</Line>
  <Line number="21974">  for(i=1; i&lt;argc; i<CheckRefs ids="4386">++</CheckRefs>){</Line>
  <Line number="21975">    char *z;</Line>
  <Line number="21976">    z = argv[i];</Line>
  <Line number="21977">    if( <CheckRefs ids="4387">z</CheckRefs>[0]!=&apos;-&apos; ){</Line>
  <Line number="21978">      if( data.zDbFilename==0 ){</Line>
  <Line number="21979">        data.zDbFilename = z;</Line>
  <Line number="21980">      }else{</Line>
  <Line number="21981">        /* Excesss arguments are interpreted as SQL (or dot-commands) and</Line>
  <Line number="21982">        ** mean that nothing is read from stdin */</Line>
  <Line number="21983">        readStdin = 0;</Line>
  <Line number="21984">        nCmd<CheckRefs ids="4388">++</CheckRefs>;</Line>
  <Line number="21985">        azCmd = realloc(azCmd, sizeof(azCmd[0])<CheckRefs ids="4389">*</CheckRefs><CheckRefs ids="4390">nCmd</CheckRefs>);</Line>
  <Line number="21986">        if( azCmd==0 ) shell_out_of_memory();</Line>
  <Line number="21987">        azCmd[nCmd<CheckRefs ids="4391">-</CheckRefs>1] = z;</Line>
  <Line number="21988">      }</Line>
  <Line number="21989">    }</Line>
  <Line number="21990">    if( <CheckRefs ids="4392">z</CheckRefs>[1]==&apos;-&apos; ) z++;</Line>
  <Line number="21991">    if( strcmp(z,&quot;-separator&quot;)==0</Line>
  <Line number="21992">     || strcmp(z,&quot;-nullvalue&quot;)==0</Line>
  <Line number="21993">     || strcmp(z,&quot;-newline&quot;)==0</Line>
  <Line number="21994">     || strcmp(z,&quot;-cmd&quot;)==0</Line>
  <Line number="21995">    ){</Line>
  <Line number="21996">      (void)cmdline_option_value(argc, argv, <CheckRefs ids="4393">++</CheckRefs>i);</Line>
  <Line number="21997">    }else if( strcmp(z,&quot;-init&quot;)==0 ){</Line>
  <Line number="21998">      zInitFile = cmdline_option_value(argc, argv, <CheckRefs ids="4394">++</CheckRefs>i);</Line>
  <Line number="21999">    }else if( strcmp(z,&quot;-batch&quot;)==0 ){</Line>
  <Line number="22000">      /* Need to check for batch mode here to so we can avoid printing</Line>
  <Line number="22001">      ** informational messages (like from process_sqliterc) before</Line>
  <Line number="22002">      ** we do the actual processing of arguments later in a second pass.</Line>
  <Line number="22003">      */</Line>
  <Line number="22004">      stdin_is_interactive = 0;</Line>
  <Line number="22005">    }else if( strcmp(z,&quot;-heap&quot;)==0 ){</Line>
  <Line number="22006">#if defined(SQLITE_ENABLE_MEMSYS3) || defined(SQLITE_ENABLE_MEMSYS5)</Line>
  <Line number="22007">      const char *zSize;</Line>
  <Line number="22008">      sqlite3_int64 szHeap;</Line>
  <Line number="22009"></Line>
  <Line number="22010">      zSize = cmdline_option_value(argc, argv, ++i);</Line>
  <Line number="22011">      szHeap = integerValue(zSize);</Line>
  <Line number="22012">      if( szHeap&gt;0x7fff0000 ) szHeap = 0x7fff0000;</Line>
  <Line number="22013">      sqlite3_config(SQLITE_CONFIG_HEAP, malloc((int)szHeap), (int)szHeap, 64);</Line>
  <Line number="22014">#else</Line>
  <Line number="22015">      (void)cmdline_option_value(argc, argv, <CheckRefs ids="4395">++</CheckRefs>i);</Line>
  <Line number="22016">#endif</Line>
  <Line number="22017">    }else if( strcmp(z,&quot;-pagecache&quot;)==0 ){</Line>
  <Line number="22018">      sqlite3_int64 n, sz;</Line>
  <Line number="22019">      sz = integerValue(cmdline_option_value(argc,argv,<CheckRefs ids="4396">++</CheckRefs>i));</Line>
  <Line number="22020">      if( sz&gt;<CheckRefs ids="4397">70000</CheckRefs> ) sz = <CheckRefs ids="4398">70000</CheckRefs>;</Line>
  <Line number="22021">      if( sz&lt;<CheckRefs ids="4399">0</CheckRefs> ) sz = <CheckRefs ids="4400">0</CheckRefs>;</Line>
  <Line number="22022">      n = integerValue(cmdline_option_value(argc,argv,<CheckRefs ids="4401">++</CheckRefs>i));</Line>
  <Line number="22023">      if( sz&gt;<CheckRefs ids="4402">0</CheckRefs> &amp;&amp; n&gt;<CheckRefs ids="4403">0</CheckRefs> &amp;&amp; 0xffffffffffffLL<CheckRefs ids="4404,4405">/</CheckRefs>sz&lt;n ){</Line>
  <Line number="22024">        n = 0xffffffffffffLL<CheckRefs ids="4406,4407">/</CheckRefs>sz;</Line>
  <Line number="22025">      }</Line>
  <Line number="22026">      sqlite3_config(SQLITE_CONFIG_PAGECACHE,</Line>
  <Line number="22027">                    (n&gt;<CheckRefs ids="4408">0</CheckRefs> &amp;&amp; sz&gt;<CheckRefs ids="4409">0</CheckRefs>) ? malloc(n<CheckRefs ids="4410,4411">*</CheckRefs>sz) : 0, sz, n);</Line>
  <Line number="22028">      data.shellFlgs |= <CheckRefs ids="4412">SHFLG_Pagecache</CheckRefs>;</Line>
  <Line number="22029">    }else if( strcmp(z,&quot;-lookaside&quot;)==0 ){</Line>
  <Line number="22030">      int n, sz;</Line>
  <Line number="22031">      sz = <CheckRefs ids="4413">(</CheckRefs>int)integerValue(cmdline_option_value(argc,argv,<CheckRefs ids="4414">++</CheckRefs>i));</Line>
  <Line number="22032">      if( sz&lt;0 ) sz = 0;</Line>
  <Line number="22033">      n = <CheckRefs ids="4415">(</CheckRefs>int)integerValue(cmdline_option_value(argc,argv,<CheckRefs ids="4416">++</CheckRefs>i));</Line>
  <Line number="22034">      if( n&lt;0 ) n = 0;</Line>
  <Line number="22035">      sqlite3_config(SQLITE_CONFIG_LOOKASIDE, sz, n);</Line>
  <Line number="22036">      if( sz<CheckRefs ids="4417">*</CheckRefs>n==0 ) data.shellFlgs &amp;= <CheckRefs ids="4418">~</CheckRefs>SHFLG_Lookaside;</Line>
  <Line number="22037">#ifdef SQLITE_ENABLE_VFSTRACE</Line>
  <Line number="22038">    }else if( strcmp(z,&quot;-vfstrace&quot;)==0 ){</Line>
  <Line number="22039">      extern int vfstrace_register(</Line>
  <Line number="22040">         const char *zTraceName,</Line>
  <Line number="22041">         const char *zOldVfsName,</Line>
  <Line number="22042">         int (*xOut)(const char*,void*),</Line>
  <Line number="22043">         void *pOutArg,</Line>
  <Line number="22044">         int makeDefault</Line>
  <Line number="22045">      );</Line>
  <Line number="22046">      vfstrace_register(&quot;trace&quot;,0,(int(*)(const char*,void*))fputs,stderr,1);</Line>
  <Line number="22047">#endif</Line>
  <Line number="22048">#ifdef SQLITE_ENABLE_MULTIPLEX</Line>
  <Line number="22049">    }else if( strcmp(z,&quot;-multiplex&quot;)==0 ){</Line>
  <Line number="22050">      extern int sqlite3_multiple_initialize(const char*,int);</Line>
  <Line number="22051">      sqlite3_multiplex_initialize(0, 1);</Line>
  <Line number="22052">#endif</Line>
  <Line number="22053">    }else if( strcmp(z,&quot;-mmap&quot;)==0 ){</Line>
  <Line number="22054">      sqlite3_int64 sz = integerValue(cmdline_option_value(argc,argv,<CheckRefs ids="4419">++</CheckRefs>i));</Line>
  <Line number="22055">      sqlite3_config(SQLITE_CONFIG_MMAP_SIZE, sz, sz);</Line>
  <Line number="22056">#ifdef SQLITE_ENABLE_SORTER_REFERENCES</Line>
  <Line number="22057">    }else if( strcmp(z,&quot;-sorterref&quot;)==0 ){</Line>
  <Line number="22058">      sqlite3_int64 sz = integerValue(cmdline_option_value(argc,argv,++i));</Line>
  <Line number="22059">      sqlite3_config(SQLITE_CONFIG_SORTERREF_SIZE, (int)sz);</Line>
  <Line number="22060">#endif</Line>
  <Line number="22061">    }else if( strcmp(z,&quot;-vfs&quot;)==0 ){</Line>
  <Line number="22062">      zVfs = cmdline_option_value(argc, argv, <CheckRefs ids="4420">++</CheckRefs>i);</Line>
  <Line number="22063">#ifdef SQLITE_HAVE_ZLIB</Line>
  <Line number="22064">    }else if( strcmp(z,&quot;-zip&quot;)==0 ){</Line>
  <Line number="22065">      data.openMode = SHELL_OPEN_ZIPFILE;</Line>
  <Line number="22066">#endif</Line>
  <Line number="22067">    }else if( strcmp(z,&quot;-append&quot;)==0 ){</Line>
  <Line number="22068">      data.openMode = <CheckRefs ids="4421">SHELL_OPEN_APPENDVFS</CheckRefs>;</Line>
  <Line number="22069">#ifndef SQLITE_OMIT_DESERIALIZE</Line>
  <Line number="22070">    }else if( strcmp(z,&quot;-deserialize&quot;)==0 ){</Line>
  <Line number="22071">      data.openMode = <CheckRefs ids="4422">SHELL_OPEN_DESERIALIZE</CheckRefs>;</Line>
  <Line number="22072">    }else if( strcmp(z,&quot;-maxsize&quot;)==0 &amp;&amp; i<CheckRefs ids="4423">+</CheckRefs>1&lt;argc ){</Line>
  <Line number="22073">      data.szMax = integerValue(argv[<CheckRefs ids="4424">++</CheckRefs>i]);</Line>
  <Line number="22074">#endif</Line>
  <Line number="22075">    }else if( strcmp(z,&quot;-readonly&quot;)==0 ){</Line>
  <Line number="22076">      data.openMode = <CheckRefs ids="4425">SHELL_OPEN_READONLY</CheckRefs>;</Line>
  <Line number="22077">    }else if( strcmp(z,&quot;-nofollow&quot;)==0 ){</Line>
  <Line number="22078">      data.openFlags = SQLITE_OPEN_NOFOLLOW;</Line>
  <Line number="22079">#if !defined(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; defined(SQLITE_HAVE_ZLIB)</Line>
  <Line number="22080">    }else if( strncmp(z, &quot;-A&quot;,2)==0 ){</Line>
  <Line number="22081">      /* All remaining command-line arguments are passed to the &quot;.archive&quot;</Line>
  <Line number="22082">      ** command, so ignore them */</Line>
  <Line number="22083">      break;</Line>
  <Line number="22084">#endif</Line>
  <Line number="22085">    }else if( strcmp(z, &quot;-memtrace&quot;)==0 ){</Line>
  <Line number="22086">      sqlite3MemTraceActivate(stderr);</Line>
  <Line number="22087">    }else if( strcmp(z,&quot;-bail&quot;)==0 ){</Line>
  <Line number="22088">      bail_on_error = 1;</Line>
  <Line number="22089">    }</Line>
  <Line number="22090">  }</Line>
  <Line number="22091">  verify_uninitialized();</Line>
  <Line number="22092"></Line>
  <Line number="22093"></Line>
  <Line number="22094">#ifdef SQLITE_SHELL_INIT_PROC</Line>
  <Line number="22095">  {</Line>
  <Line number="22096">    /* If the SQLITE_SHELL_INIT_PROC macro is defined, then it is the name</Line>
  <Line number="22097">    ** of a C-function that will perform initialization actions on SQLite that</Line>
  <Line number="22098">    ** occur just before or after sqlite3_initialize(). Use this compile-time</Line>
  <Line number="22099">    ** option to embed this shell program in larger applications. */</Line>
  <Line number="22100">    extern void SQLITE_SHELL_INIT_PROC(void);</Line>
  <Line number="22101">    SQLITE_SHELL_INIT_PROC();</Line>
  <Line number="22102">  }</Line>
  <Line number="22103">#else</Line>
  <Line number="22104">  /* All the sqlite3_config() calls have now been made. So it is safe</Line>
  <Line number="22105">  ** to call sqlite3_initialize() and process any command line -vfs option. */</Line>
  <Line number="22106">  sqlite3_initialize();</Line>
  <Line number="22107">#endif</Line>
  <Line number="22108"></Line>
  <Line number="22109">  if( zVfs ){</Line>
  <Line number="22110">    sqlite3_vfs *pVfs = sqlite3_vfs_find(zVfs);</Line>
  <Line number="22111">    if( pVfs ){</Line>
  <Line number="22112">      sqlite3_vfs_register(pVfs, 1);</Line>
  <Line number="22113">    }else{</Line>
  <Line number="22114">      utf8_printf(stderr, &quot;no such VFS: \&quot;%s\&quot;\n&quot;, argv[i]);</Line>
  <Line number="22115">      exit(1);</Line>
  <Line number="22116">    }</Line>
  <Line number="22117">  }</Line>
  <Line number="22118"></Line>
  <Line number="22119">  if( data.zDbFilename==0 ){</Line>
  <Line number="22120">#ifndef SQLITE_OMIT_MEMORYDB</Line>
  <Line number="22121">    data.zDbFilename = &quot;:memory:&quot;;</Line>
  <Line number="22122">    warnInmemoryDb = argc==1;</Line>
  <Line number="22123">#else</Line>
  <Line number="22124">    utf8_printf(stderr,&quot;%s: Error: no database filename specified\n&quot;, Argv0);</Line>
  <Line number="22125">    return 1;</Line>
  <Line number="22126">#endif</Line>
  <Line number="22127">  }</Line>
  <Line number="22128">  data.out = stdout;</Line>
  <Line number="22129">  sqlite3_appendvfs_init(0,0,0);</Line>
  <Line number="22130"></Line>
  <Line number="22131">  /* Go ahead and open the database file if it already exists.  If the</Line>
  <Line number="22132">  ** file does not exist, delay opening it.  This prevents empty database</Line>
  <Line number="22133">  ** files from being created if a user mistypes the database name argument</Line>
  <Line number="22134">  ** to the sqlite command-line tool.</Line>
  <Line number="22135">  */</Line>
  <Line number="22136">  if( access(data.zDbFilename, 0)==0 ){</Line>
  <Line number="22137">    open_db(&amp;data, 0);</Line>
  <Line number="22138">  }</Line>
  <Line number="22139"></Line>
  <Line number="22140">  /* Process the initialization file if there is one.  If no -init option</Line>
  <Line number="22141">  ** is given on the command line, look for a file named ~/.sqliterc and</Line>
  <Line number="22142">  ** try to process it.</Line>
  <Line number="22143">  */</Line>
  <Line number="22144">  process_sqliterc(&amp;data,zInitFile);</Line>
  <Line number="22145"></Line>
  <Line number="22146">  /* Make a second pass through the command-line argument and set</Line>
  <Line number="22147">  ** options.  This second pass is delayed until after the initialization</Line>
  <Line number="22148">  ** file is processed so that the command-line arguments will override</Line>
  <Line number="22149">  ** settings in the initialization file.</Line>
  <Line number="22150">  */</Line>
  <Line number="22151">  for(i=1; i&lt;argc; i<CheckRefs ids="4426">++</CheckRefs>){</Line>
  <Line number="22152">    char *z = argv[i];</Line>
  <Line number="22153">    if( <CheckRefs ids="4427">z</CheckRefs>[0]!=&apos;-&apos; ) continue;</Line>
  <Line number="22154">    if( <CheckRefs ids="4428">z</CheckRefs>[1]==&apos;-&apos; ){ z++; }</Line>
  <Line number="22155">    if( strcmp(z,&quot;-init&quot;)==0 ){</Line>
  <Line number="22156">      i<CheckRefs ids="4429">++</CheckRefs>;</Line>
  <Line number="22157">    }else if( strcmp(z,&quot;-html&quot;)==0 ){</Line>
  <Line number="22158">      data.mode = MODE_Html;</Line>
  <Line number="22159">    }else if( strcmp(z,&quot;-list&quot;)==0 ){</Line>
  <Line number="22160">      data.mode = MODE_List;</Line>
  <Line number="22161">    }else if( strcmp(z,&quot;-quote&quot;)==0 ){</Line>
  <Line number="22162">      data.mode = MODE_Quote;</Line>
  <Line number="22163">      sqlite3_snprintf(<CheckRefs ids="4430">sizeof</CheckRefs>(data.colSeparator), data.colSeparator, SEP_Comma);</Line>
  <Line number="22164">      sqlite3_snprintf(<CheckRefs ids="4431">sizeof</CheckRefs>(data.rowSeparator), data.rowSeparator, SEP_Row);</Line>
  <Line number="22165">    }else if( strcmp(z,&quot;-line&quot;)==0 ){</Line>
  <Line number="22166">      data.mode = MODE_Line;</Line>
  <Line number="22167">    }else if( strcmp(z,&quot;-column&quot;)==0 ){</Line>
  <Line number="22168">      data.mode = MODE_Column;</Line>
  <Line number="22169">    }else if( strcmp(z,&quot;-json&quot;)==0 ){</Line>
  <Line number="22170">      data.mode = MODE_Json;</Line>
  <Line number="22171">    }else if( strcmp(z,&quot;-markdown&quot;)==0 ){</Line>
  <Line number="22172">      data.mode = MODE_Markdown;</Line>
  <Line number="22173">    }else if( strcmp(z,&quot;-table&quot;)==0 ){</Line>
  <Line number="22174">      data.mode = MODE_Table;</Line>
  <Line number="22175">    }else if( strcmp(z,&quot;-box&quot;)==0 ){</Line>
  <Line number="22176">      data.mode = MODE_Box;</Line>
  <Line number="22177">    }else if( strcmp(z,&quot;-csv&quot;)==0 ){</Line>
  <Line number="22178">      data.mode = MODE_Csv;</Line>
  <Line number="22179">      memcpy(data.colSeparator,&quot;,&quot;,<CheckRefs ids="4432">2</CheckRefs>);</Line>
  <Line number="22180">#ifdef SQLITE_HAVE_ZLIB</Line>
  <Line number="22181">    }else if( strcmp(z,&quot;-zip&quot;)==0 ){</Line>
  <Line number="22182">      data.openMode = SHELL_OPEN_ZIPFILE;</Line>
  <Line number="22183">#endif</Line>
  <Line number="22184">    }else if( strcmp(z,&quot;-append&quot;)==0 ){</Line>
  <Line number="22185">      data.openMode = <CheckRefs ids="4433">SHELL_OPEN_APPENDVFS</CheckRefs>;</Line>
  <Line number="22186">#ifndef SQLITE_OMIT_DESERIALIZE</Line>
  <Line number="22187">    }else if( strcmp(z,&quot;-deserialize&quot;)==0 ){</Line>
  <Line number="22188">      data.openMode = <CheckRefs ids="4434">SHELL_OPEN_DESERIALIZE</CheckRefs>;</Line>
  <Line number="22189">    }else if( strcmp(z,&quot;-maxsize&quot;)==0 &amp;&amp; i<CheckRefs ids="4435">+</CheckRefs>1&lt;argc ){</Line>
  <Line number="22190">      data.szMax = integerValue(argv[<CheckRefs ids="4436">++</CheckRefs>i]);</Line>
  <Line number="22191">#endif</Line>
  <Line number="22192">    }else if( strcmp(z,&quot;-readonly&quot;)==0 ){</Line>
  <Line number="22193">      data.openMode = <CheckRefs ids="4437">SHELL_OPEN_READONLY</CheckRefs>;</Line>
  <Line number="22194">    }else if( strcmp(z,&quot;-nofollow&quot;)==0 ){</Line>
  <Line number="22195">      data.openFlags |= SQLITE_OPEN_NOFOLLOW;</Line>
  <Line number="22196">    }else if( strcmp(z,&quot;-ascii&quot;)==0 ){</Line>
  <Line number="22197">      data.mode = MODE_Ascii;</Line>
  <Line number="22198">      sqlite3_snprintf(<CheckRefs ids="4438">sizeof</CheckRefs>(data.colSeparator), data.colSeparator, SEP_Unit);</Line>
  <Line number="22199">      sqlite3_snprintf(<CheckRefs ids="4439">sizeof</CheckRefs>(data.rowSeparator), data.rowSeparator, SEP_Record);</Line>
  <Line number="22200">    }else if( strcmp(z,&quot;-tabs&quot;)==0 ){</Line>
  <Line number="22201">      data.mode = MODE_List;</Line>
  <Line number="22202">      sqlite3_snprintf(<CheckRefs ids="4440">sizeof</CheckRefs>(data.colSeparator), data.colSeparator, SEP_Tab);</Line>
  <Line number="22203">      sqlite3_snprintf(<CheckRefs ids="4441">sizeof</CheckRefs>(data.rowSeparator), data.rowSeparator, SEP_Row);</Line>
  <Line number="22204">    }else if( strcmp(z,&quot;-separator&quot;)==0 ){</Line>
  <Line number="22205">      sqlite3_snprintf(<CheckRefs ids="4442">sizeof</CheckRefs>(data.colSeparator), data.colSeparator,</Line>
  <Line number="22206">                       &quot;%s&quot;,cmdline_option_value(argc,argv,<CheckRefs ids="4443">++</CheckRefs>i));</Line>
  <Line number="22207">    }else if( strcmp(z,&quot;-newline&quot;)==0 ){</Line>
  <Line number="22208">      sqlite3_snprintf(<CheckRefs ids="4444">sizeof</CheckRefs>(data.rowSeparator), data.rowSeparator,</Line>
  <Line number="22209">                       &quot;%s&quot;,cmdline_option_value(argc,argv,<CheckRefs ids="4445">++</CheckRefs>i));</Line>
  <Line number="22210">    }else if( strcmp(z,&quot;-nullvalue&quot;)==0 ){</Line>
  <Line number="22211">      sqlite3_snprintf(<CheckRefs ids="4446">sizeof</CheckRefs>(data.nullValue), data.nullValue,</Line>
  <Line number="22212">                       &quot;%s&quot;,cmdline_option_value(argc,argv,<CheckRefs ids="4447">++</CheckRefs>i));</Line>
  <Line number="22213">    }else if( strcmp(z,&quot;-header&quot;)==0 ){</Line>
  <Line number="22214">      data.showHeader = 1;</Line>
  <Line number="22215">    }else if( strcmp(z,&quot;-noheader&quot;)==0 ){</Line>
  <Line number="22216">      data.showHeader = 0;</Line>
  <Line number="22217">    }else if( strcmp(z,&quot;-echo&quot;)==0 ){</Line>
  <Line number="22218">      <CheckRefs ids="4448">ShellSetFlag</CheckRefs>(&amp;data, SHFLG_Echo);</Line>
  <Line number="22219">    }else if( strcmp(z,&quot;-eqp&quot;)==0 ){</Line>
  <Line number="22220">      data.autoEQP = <CheckRefs ids="4449">AUTOEQP_on</CheckRefs>;</Line>
  <Line number="22221">    }else if( strcmp(z,&quot;-eqpfull&quot;)==0 ){</Line>
  <Line number="22222">      data.autoEQP = <CheckRefs ids="4450">AUTOEQP_full</CheckRefs>;</Line>
  <Line number="22223">    }else if( strcmp(z,&quot;-stats&quot;)==0 ){</Line>
  <Line number="22224">      data.statsOn = <CheckRefs ids="4451">1</CheckRefs>;</Line>
  <Line number="22225">    }else if( strcmp(z,&quot;-scanstats&quot;)==0 ){</Line>
  <Line number="22226">      data.scanstatsOn = <CheckRefs ids="4452">1</CheckRefs>;</Line>
  <Line number="22227">    }else if( strcmp(z,&quot;-backslash&quot;)==0 ){</Line>
  <Line number="22228">      /* Undocumented command-line option: -backslash</Line>
  <Line number="22229">      ** Causes C-style backslash escapes to be evaluated in SQL statements</Line>
  <Line number="22230">      ** prior to sending the SQL into SQLite.  Useful for injecting</Line>
  <Line number="22231">      ** crazy bytes in the middle of SQL statements for testing and debugging.</Line>
  <Line number="22232">      */</Line>
  <Line number="22233">      <CheckRefs ids="4453">ShellSetFlag</CheckRefs>(&amp;data, SHFLG_Backslash);</Line>
  <Line number="22234">    }else if( strcmp(z,&quot;-bail&quot;)==0 ){</Line>
  <Line number="22235">      /* No-op.  The bail_on_error flag should already be set. */</Line>
  <Line number="22236">    }else if( strcmp(z,&quot;-version&quot;)==0 ){</Line>
  <Line number="22237">      printf(&quot;%s %s\n&quot;, sqlite3_libversion(), sqlite3_sourceid());</Line>
  <Line number="22238">      return 0;</Line>
  <Line number="22239">    }else if( strcmp(z,&quot;-interactive&quot;)==0 ){</Line>
  <Line number="22240">      stdin_is_interactive = 1;</Line>
  <Line number="22241">    }else if( strcmp(z,&quot;-batch&quot;)==0 ){</Line>
  <Line number="22242">      stdin_is_interactive = 0;</Line>
  <Line number="22243">    }else if( strcmp(z,&quot;-heap&quot;)==0 ){</Line>
  <Line number="22244">      i<CheckRefs ids="4454">++</CheckRefs>;</Line>
  <Line number="22245">    }else if( strcmp(z,&quot;-pagecache&quot;)==0 ){</Line>
  <Line number="22246">      i<CheckRefs ids="4455">+=</CheckRefs>2;</Line>
  <Line number="22247">    }else if( strcmp(z,&quot;-lookaside&quot;)==0 ){</Line>
  <Line number="22248">      i<CheckRefs ids="4456">+=</CheckRefs>2;</Line>
  <Line number="22249">    }else if( strcmp(z,&quot;-mmap&quot;)==0 ){</Line>
  <Line number="22250">      i<CheckRefs ids="4457">++</CheckRefs>;</Line>
  <Line number="22251">    }else if( strcmp(z,&quot;-memtrace&quot;)==0 ){</Line>
  <Line number="22252">      i<CheckRefs ids="4458">++</CheckRefs>;</Line>
  <Line number="22253">#ifdef SQLITE_ENABLE_SORTER_REFERENCES</Line>
  <Line number="22254">    }else if( strcmp(z,&quot;-sorterref&quot;)==0 ){</Line>
  <Line number="22255">      i++;</Line>
  <Line number="22256">#endif</Line>
  <Line number="22257">    }else if( strcmp(z,&quot;-vfs&quot;)==0 ){</Line>
  <Line number="22258">      i<CheckRefs ids="4459">++</CheckRefs>;</Line>
  <Line number="22259">#ifdef SQLITE_ENABLE_VFSTRACE</Line>
  <Line number="22260">    }else if( strcmp(z,&quot;-vfstrace&quot;)==0 ){</Line>
  <Line number="22261">      i++;</Line>
  <Line number="22262">#endif</Line>
  <Line number="22263">#ifdef SQLITE_ENABLE_MULTIPLEX</Line>
  <Line number="22264">    }else if( strcmp(z,&quot;-multiplex&quot;)==0 ){</Line>
  <Line number="22265">      i++;</Line>
  <Line number="22266">#endif</Line>
  <Line number="22267">    }else if( strcmp(z,&quot;-help&quot;)==0 ){</Line>
  <Line number="22268">      usage(1);</Line>
  <Line number="22269">    }else if( strcmp(z,&quot;-cmd&quot;)==0 ){</Line>
  <Line number="22270">      /* Run commands that follow -cmd first and separately from commands</Line>
  <Line number="22271">      ** that simply appear on the command-line.  This seems goofy.  It would</Line>
  <Line number="22272">      ** be better if all commands ran in the order that they appear.  But</Line>
  <Line number="22273">      ** we retain the goofy behavior for historical compatibility. */</Line>
  <Line number="22274">      if( i==argc<CheckRefs ids="4460">-</CheckRefs>1 ) break;</Line>
  <Line number="22275">      z = cmdline_option_value(argc,argv,<CheckRefs ids="4461">++</CheckRefs>i);</Line>
  <Line number="22276">      if( <CheckRefs ids="4462">z</CheckRefs>[0]==&apos;.&apos; ){</Line>
  <Line number="22277">        rc = do_meta_command(z, &amp;data);</Line>
  <Line number="22278">        if( rc &amp;&amp; bail_on_error ) return rc==2 ? 0 : rc;</Line>
  <Line number="22279">      }else{</Line>
  <Line number="22280">        open_db(&amp;data, 0);</Line>
  <Line number="22281">        rc = shell_exec(&amp;data, z, &amp;zErrMsg);</Line>
  <Line number="22282">        if( zErrMsg!=0 ){</Line>
  <Line number="22283">          utf8_printf(stderr,&quot;Error: %s\n&quot;, zErrMsg);</Line>
  <Line number="22284">          if( bail_on_error ) return rc!=0 ? rc : 1;</Line>
  <Line number="22285">        }else if( rc!=0 ){</Line>
  <Line number="22286">          utf8_printf(stderr,&quot;Error: unable to process SQL \&quot;%s\&quot;\n&quot;, z);</Line>
  <Line number="22287">          if( bail_on_error ) return rc;</Line>
  <Line number="22288">        }</Line>
  <Line number="22289">      }</Line>
  <Line number="22290">#if !defined(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; defined(SQLITE_HAVE_ZLIB)</Line>
  <Line number="22291">    }else if( strncmp(z, &quot;-A&quot;, 2)==0 ){</Line>
  <Line number="22292">      if( nCmd&gt;0 ){</Line>
  <Line number="22293">        utf8_printf(stderr, &quot;Error: cannot mix regular SQL or dot-commands&quot;</Line>
  <Line number="22294">                            &quot; with \&quot;%s\&quot;\n&quot;, z);</Line>
  <Line number="22295">        return 1;</Line>
  <Line number="22296">      }</Line>
  <Line number="22297">      open_db(&amp;data, OPEN_DB_ZIPFILE);</Line>
  <Line number="22298">      if( z[2] ){</Line>
  <Line number="22299">        argv[i] = &amp;z[2];</Line>
  <Line number="22300">        arDotCommand(&amp;data, 1, argv+(i-1), argc-(i-1));</Line>
  <Line number="22301">      }else{</Line>
  <Line number="22302">        arDotCommand(&amp;data, 1, argv+i, argc-i);</Line>
  <Line number="22303">      }</Line>
  <Line number="22304">      readStdin = 0;</Line>
  <Line number="22305">      break;</Line>
  <Line number="22306">#endif</Line>
  <Line number="22307">    }else{</Line>
  <Line number="22308">      utf8_printf(stderr,&quot;%s: Error: unknown option: %s\n&quot;, Argv0, z);</Line>
  <Line number="22309">      raw_printf(stderr,&quot;Use -help for a list of options.\n&quot;);</Line>
  <Line number="22310">      return 1;</Line>
  <Line number="22311">    }</Line>
  <Line number="22312">    data.cMode = data.mode;</Line>
  <Line number="22313">  }</Line>
  <Line number="22314"></Line>
  <Line number="22315">  if( !readStdin ){</Line>
  <Line number="22316">    /* Run all arguments that do not begin with &apos;-&apos; as if they were separate</Line>
  <Line number="22317">    ** command-line inputs, except for the argToSkip argument which contains</Line>
  <Line number="22318">    ** the database filename.</Line>
  <Line number="22319">    */</Line>
  <Line number="22320">    for(i=0; i&lt;nCmd; i<CheckRefs ids="4463">++</CheckRefs>){</Line>
  <Line number="22321">      if( <CheckRefs ids="4464">azCmd</CheckRefs>[i][0]==&apos;.&apos; ){</Line>
  <Line number="22322">        rc = do_meta_command(azCmd[i], &amp;data);</Line>
  <Line number="22323">        if( rc ){</Line>
  <Line number="22324">          free(azCmd);</Line>
  <Line number="22325">          return rc==2 ? 0 : rc;</Line>
  <Line number="22326">        }</Line>
  <Line number="22327">      }else{</Line>
  <Line number="22328">        open_db(&amp;data, 0);</Line>
  <Line number="22329">        rc = shell_exec(&amp;data, azCmd[i], &amp;zErrMsg);</Line>
  <Line number="22330">        if( zErrMsg || rc ){</Line>
  <Line number="22331">          if( zErrMsg!=0 ){</Line>
  <Line number="22332">            utf8_printf(stderr,&quot;Error: %s\n&quot;, zErrMsg);</Line>
  <Line number="22333">          }else{</Line>
  <Line number="22334">            utf8_printf(stderr,&quot;Error: unable to process SQL: %s\n&quot;, azCmd[i]);</Line>
  <Line number="22335">          }</Line>
  <Line number="22336">          sqlite3_free(zErrMsg);</Line>
  <Line number="22337">          free(azCmd);</Line>
  <Line number="22338">          return rc!=0 ? rc : 1;</Line>
  <Line number="22339">        }</Line>
  <Line number="22340">      }</Line>
  <Line number="22341">    }</Line>
  <Line number="22342">  }else{</Line>
  <Line number="22343">    /* Run commands received from standard input</Line>
  <Line number="22344">    */</Line>
  <Line number="22345">    if( stdin_is_interactive ){</Line>
  <Line number="22346">      char *zHome;</Line>
  <Line number="22347">      char *zHistory;</Line>
  <Line number="22348">      int nHistory;</Line>
  <Line number="22349">      printf(</Line>
  <Line number="22350">        &quot;SQLite version %s %.19s\n&quot; /*extra-version-info*/</Line>
  <Line number="22351">        &quot;Enter \&quot;.help\&quot; for usage hints.\n&quot;,</Line>
  <Line number="22352">        sqlite3_libversion(), sqlite3_sourceid()</Line>
  <Line number="22353">      );</Line>
  <Line number="22354">      if( warnInmemoryDb ){</Line>
  <Line number="22355">        printf(&quot;Connected to a &quot;);</Line>
  <Line number="22356">        printBold(&quot;transient in-memory database&quot;);</Line>
  <Line number="22357">        printf(&quot;.\nUse \&quot;.open FILENAME\&quot; to reopen on a &quot;</Line>
  <Line number="22358">               &quot;persistent database.\n&quot;);</Line>
  <Line number="22359">      }</Line>
  <Line number="22360">      zHistory = getenv(&quot;SQLITE_HISTORY&quot;);</Line>
  <Line number="22361">      if( zHistory ){</Line>
  <Line number="22362">        zHistory = strdup(zHistory);</Line>
  <Line number="22363">      }else if( (zHome = find_home_dir(0))!=0 ){</Line>
  <Line number="22364">        nHistory = strlen30(zHome) <CheckRefs ids="4465">+</CheckRefs> 20;</Line>
  <Line number="22365">        if( (zHistory = malloc(<CheckRefs ids="4466">nHistory</CheckRefs>))!=0 ){</Line>
  <Line number="22366">          sqlite3_snprintf(nHistory, zHistory,&quot;%s/.sqlite_history&quot;, zHome);</Line>
  <Line number="22367">        }</Line>
  <Line number="22368">      }</Line>
  <Line number="22369">      if( zHistory ){ shell_read_history(zHistory); }</Line>
  <Line number="22370">#if HAVE_READLINE || HAVE_EDITLINE</Line>
  <Line number="22371">      rl_attempted_completion_function = readline_completion;</Line>
  <Line number="22372">#elif HAVE_LINENOISE</Line>
  <Line number="22373">      linenoiseSetCompletionCallback(linenoise_completion);</Line>
  <Line number="22374">#endif</Line>
  <Line number="22375">      data.in = 0;</Line>
  <Line number="22376">      rc = process_input(&amp;data);</Line>
  <Line number="22377">      if( zHistory ){</Line>
  <Line number="22378">        shell_stifle_history(2000);</Line>
  <Line number="22379">        shell_write_history(zHistory);</Line>
  <Line number="22380">        free(zHistory);</Line>
  <Line number="22381">      }</Line>
  <Line number="22382">    }else{</Line>
  <Line number="22383">      data.in = stdin;</Line>
  <Line number="22384">      rc = process_input(&amp;data);</Line>
  <Line number="22385">    }</Line>
  <Line number="22386">  }</Line>
  <Line number="22387">  free(azCmd);</Line>
  <Line number="22388">  set_table_name(&amp;data, 0);</Line>
  <Line number="22389">  if( data.db ){</Line>
  <Line number="22390">    session_close_all(&amp;data);</Line>
  <Line number="22391">    close_db(data.db);</Line>
  <Line number="22392">  }</Line>
  <Line number="22393">  sqlite3_free(data.zFreeOnClose);</Line>
  <Line number="22394">  find_home_dir(1);</Line>
  <Line number="22395">  output_reset(&amp;data);</Line>
  <Line number="22396">  data.doXdgOpen = <CheckRefs ids="4467">0</CheckRefs>;</Line>
  <Line number="22397">  clearTempFile(&amp;data);</Line>
  <Line number="22398">#if !SQLITE_SHELL_IS_UTF8</Line>
  <Line number="22399">  for(i=0; i&lt;argcToFree; i++) free(argvToFree[i]);</Line>
  <Line number="22400">  free(argvToFree);</Line>
  <Line number="22401">#endif</Line>
  <Line number="22402">  free(data.colWidth);</Line>
  <Line number="22403">  /* Clear the global data structure so that valgrind will detect memory</Line>
  <Line number="22404">  ** leaks */</Line>
  <Line number="22405">  memset(&amp;data, 0, sizeof(data));</Line>
  <Line number="22406">  return rc;</Line>
  <Line number="22407">}</Line>
</SourceFile>
