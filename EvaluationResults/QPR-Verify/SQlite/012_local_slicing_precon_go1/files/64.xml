<SourceFile>
  <Line number="1">/* Copyright (C) 1991-2020 Free Software Foundation, Inc.</Line>
  <Line number="2">   This file is part of the GNU C Library.</Line>
  <Line number="3"></Line>
  <Line number="4">   The GNU C Library is free software; you can redistribute it and/or</Line>
  <Line number="5">   modify it under the terms of the GNU Lesser General Public</Line>
  <Line number="6">   License as published by the Free Software Foundation; either</Line>
  <Line number="7">   version 2.1 of the License, or (at your option) any later version.</Line>
  <Line number="8"></Line>
  <Line number="9">   The GNU C Library is distributed in the hope that it will be useful,</Line>
  <Line number="10">   but WITHOUT ANY WARRANTY; without even the implied warranty of</Line>
  <Line number="11">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</Line>
  <Line number="12">   Lesser General Public License for more details.</Line>
  <Line number="13"></Line>
  <Line number="14">   You should have received a copy of the GNU Lesser General Public</Line>
  <Line number="15">   License along with the GNU C Library; if not, see</Line>
  <Line number="16">   &lt;https://www.gnu.org/licenses/&gt;.  */</Line>
  <Line number="17"></Line>
  <Line number="18">/*</Line>
  <Line number="19"> *	ISO C99 Standard: 7.21 String handling	&lt;string.h&gt;</Line>
  <Line number="20"> */</Line>
  <Line number="21"></Line>
  <Line number="22">#ifndef	_STRING_H</Line>
  <Line number="23">#define	_STRING_H	1</Line>
  <Line number="24"></Line>
  <Line number="25">#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION</Line>
  <Line number="26">#include &lt;bits/libc-header-start.h&gt;</Line>
  <Line number="27"></Line>
  <Line number="28">__BEGIN_DECLS</Line>
  <Line number="29"></Line>
  <Line number="30">/* Get size_t and NULL from &lt;stddef.h&gt;.  */</Line>
  <Line number="31">#define	__need_size_t</Line>
  <Line number="32">#define	__need_NULL</Line>
  <Line number="33">#include &lt;stddef.h&gt;</Line>
  <Line number="34"></Line>
  <Line number="35">/* Tell the caller that we provide correct C++ prototypes.  */</Line>
  <Line number="36">#if defined __cplusplus &amp;&amp; (__GNUC_PREREQ (4, 4) \</Line>
  <Line number="37">			    || __glibc_clang_prereq (3, 5))</Line>
  <Line number="38"># define __CORRECT_ISO_CPP_STRING_H_PROTO</Line>
  <Line number="39">#endif</Line>
  <Line number="40"></Line>
  <Line number="41"></Line>
  <Line number="42">/* Copy N bytes of SRC to DEST.  */</Line>
  <Line number="43">extern void *memcpy (void *__restrict __dest, const void *__restrict __src,</Line>
  <Line number="44">		     size_t __n) __THROW __nonnull ((1, 2));</Line>
  <Line number="45">/* Copy N bytes of SRC to DEST, guaranteeing</Line>
  <Line number="46">   correct behavior for overlapping strings.  */</Line>
  <Line number="47">extern void *memmove (void *__dest, const void *__src, size_t __n)</Line>
  <Line number="48">     __THROW __nonnull ((1, 2));</Line>
  <Line number="49"></Line>
  <Line number="50">/* Copy no more than N bytes of SRC to DEST, stopping when C is found.</Line>
  <Line number="51">   Return the position in DEST one byte past where C was copied,</Line>
  <Line number="52">   or NULL if C was not found in the first N bytes of SRC.  */</Line>
  <Line number="53">#if defined __USE_MISC || defined __USE_XOPEN || __GLIBC_USE (ISOC2X)</Line>
  <Line number="54">extern void *memccpy (void *__restrict __dest, const void *__restrict __src,</Line>
  <Line number="55">		      int __c, size_t __n)</Line>
  <Line number="56">     __THROW __nonnull ((1, 2));</Line>
  <Line number="57">#endif /* Misc || X/Open.  */</Line>
  <Line number="58"></Line>
  <Line number="59"></Line>
  <Line number="60">/* Set N bytes of S to C.  */</Line>
  <Line number="61">extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1));</Line>
  <Line number="62"></Line>
  <Line number="63">/* Compare N bytes of S1 and S2.  */</Line>
  <Line number="64">extern int memcmp (const void *__s1, const void *__s2, size_t __n)</Line>
  <Line number="65">     __THROW __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="66"></Line>
  <Line number="67">/* Search N bytes of S for C.  */</Line>
  <Line number="68">#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO</Line>
  <Line number="69">extern &quot;C++&quot;</Line>
  <Line number="70">{</Line>
  <Line number="71">extern void *memchr (void *__s, int __c, size_t __n)</Line>
  <Line number="72">      __THROW __asm (&quot;memchr&quot;) __attribute_pure__ __nonnull ((1));</Line>
  <Line number="73">extern const void *memchr (const void *__s, int __c, size_t __n)</Line>
  <Line number="74">      __THROW __asm (&quot;memchr&quot;) __attribute_pure__ __nonnull ((1));</Line>
  <Line number="75"></Line>
  <Line number="76"># ifdef __OPTIMIZE__</Line>
  <Line number="77">__extern_always_inline void *</Line>
  <Line number="78">memchr (void *__s, int __c, size_t __n) __THROW</Line>
  <Line number="79">{</Line>
  <Line number="80">  return __builtin_memchr (__s, __c, __n);</Line>
  <Line number="81">}</Line>
  <Line number="82"></Line>
  <Line number="83">__extern_always_inline const void *</Line>
  <Line number="84">memchr (const void *__s, int __c, size_t __n) __THROW</Line>
  <Line number="85">{</Line>
  <Line number="86">  return __builtin_memchr (__s, __c, __n);</Line>
  <Line number="87">}</Line>
  <Line number="88"># endif</Line>
  <Line number="89">}</Line>
  <Line number="90">#else</Line>
  <Line number="91">extern void *memchr (const void *__s, int __c, size_t __n)</Line>
  <Line number="92">      __THROW __attribute_pure__ __nonnull ((1));</Line>
  <Line number="93">#endif</Line>
  <Line number="94"></Line>
  <Line number="95">#ifdef __USE_GNU</Line>
  <Line number="96">/* Search in S for C.  This is similar to `memchr&apos; but there is no</Line>
  <Line number="97">   length limit.  */</Line>
  <Line number="98"># ifdef __CORRECT_ISO_CPP_STRING_H_PROTO</Line>
  <Line number="99">extern &quot;C++&quot; void *rawmemchr (void *__s, int __c)</Line>
  <Line number="100">     __THROW __asm (&quot;rawmemchr&quot;) __attribute_pure__ __nonnull ((1));</Line>
  <Line number="101">extern &quot;C++&quot; const void *rawmemchr (const void *__s, int __c)</Line>
  <Line number="102">     __THROW __asm (&quot;rawmemchr&quot;) __attribute_pure__ __nonnull ((1));</Line>
  <Line number="103"># else</Line>
  <Line number="104">extern void *rawmemchr (const void *__s, int __c)</Line>
  <Line number="105">     __THROW __attribute_pure__ __nonnull ((1));</Line>
  <Line number="106"># endif</Line>
  <Line number="107"></Line>
  <Line number="108">/* Search N bytes of S for the final occurrence of C.  */</Line>
  <Line number="109"># ifdef __CORRECT_ISO_CPP_STRING_H_PROTO</Line>
  <Line number="110">extern &quot;C++&quot; void *memrchr (void *__s, int __c, size_t __n)</Line>
  <Line number="111">      __THROW __asm (&quot;memrchr&quot;) __attribute_pure__ __nonnull ((1));</Line>
  <Line number="112">extern &quot;C++&quot; const void *memrchr (const void *__s, int __c, size_t __n)</Line>
  <Line number="113">      __THROW __asm (&quot;memrchr&quot;) __attribute_pure__ __nonnull ((1));</Line>
  <Line number="114"># else</Line>
  <Line number="115">extern void *memrchr (const void *__s, int __c, size_t __n)</Line>
  <Line number="116">      __THROW __attribute_pure__ __nonnull ((1));</Line>
  <Line number="117"># endif</Line>
  <Line number="118">#endif</Line>
  <Line number="119"></Line>
  <Line number="120"></Line>
  <Line number="121">/* Copy SRC to DEST.  */</Line>
  <Line number="122">extern char *strcpy (char *__restrict __dest, const char *__restrict __src)</Line>
  <Line number="123">     __THROW __nonnull ((1, 2));</Line>
  <Line number="124">/* Copy no more than N characters of SRC to DEST.  */</Line>
  <Line number="125">extern char *strncpy (char *__restrict __dest,</Line>
  <Line number="126">		      const char *__restrict __src, size_t __n)</Line>
  <Line number="127">     __THROW __nonnull ((1, 2));</Line>
  <Line number="128"></Line>
  <Line number="129">/* Append SRC onto DEST.  */</Line>
  <Line number="130">extern char *strcat (char *__restrict __dest, const char *__restrict __src)</Line>
  <Line number="131">     __THROW __nonnull ((1, 2));</Line>
  <Line number="132">/* Append no more than N characters from SRC onto DEST.  */</Line>
  <Line number="133">extern char *strncat (char *__restrict __dest, const char *__restrict __src,</Line>
  <Line number="134">		      size_t __n) __THROW __nonnull ((1, 2));</Line>
  <Line number="135"></Line>
  <Line number="136">/* Compare S1 and S2.  */</Line>
  <Line number="137">extern int strcmp (const char *__s1, const char *__s2)</Line>
  <Line number="138">     __THROW __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="139">/* Compare N characters of S1 and S2.  */</Line>
  <Line number="140">extern int strncmp (const char *__s1, const char *__s2, size_t __n)</Line>
  <Line number="141">     __THROW __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="142"></Line>
  <Line number="143">/* Compare the collated forms of S1 and S2.  */</Line>
  <Line number="144">extern int strcoll (const char *__s1, const char *__s2)</Line>
  <Line number="145">     __THROW __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="146">/* Put a transformation of SRC into no more than N bytes of DEST.  */</Line>
  <Line number="147">extern size_t strxfrm (char *__restrict __dest,</Line>
  <Line number="148">		       const char *__restrict __src, size_t __n)</Line>
  <Line number="149">     __THROW __nonnull ((2));</Line>
  <Line number="150"></Line>
  <Line number="151">#ifdef __USE_XOPEN2K8</Line>
  <Line number="152">/* POSIX.1-2008 extended locale interface (see locale.h).  */</Line>
  <Line number="153"># include &lt;bits/types/locale_t.h&gt;</Line>
  <Line number="154"></Line>
  <Line number="155">/* Compare the collated forms of S1 and S2, using sorting rules from L.  */</Line>
  <Line number="156">extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)</Line>
  <Line number="157">     __THROW __attribute_pure__ __nonnull ((1, 2, 3));</Line>
  <Line number="158">/* Put a transformation of SRC into no more than N bytes of DEST,</Line>
  <Line number="159">   using sorting rules from L.  */</Line>
  <Line number="160">extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,</Line>
  <Line number="161">			 locale_t __l) __THROW __nonnull ((2, 4));</Line>
  <Line number="162">#endif</Line>
  <Line number="163"></Line>
  <Line number="164">#if (defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8	\</Line>
  <Line number="165">     || __GLIBC_USE (LIB_EXT2) || __GLIBC_USE (ISOC2X))</Line>
  <Line number="166">/* Duplicate S, returning an identical malloc&apos;d string.  */</Line>
  <Line number="167">extern char *strdup (const char *__s)</Line>
  <Line number="168">     __THROW __attribute_malloc__ __nonnull ((1));</Line>
  <Line number="169">#endif</Line>
  <Line number="170"></Line>
  <Line number="171">/* Return a malloc&apos;d copy of at most N bytes of STRING.  The</Line>
  <Line number="172">   resultant string is terminated even if no null terminator</Line>
  <Line number="173">   appears before STRING[N].  */</Line>
  <Line number="174">#if defined __USE_XOPEN2K8 || __GLIBC_USE (LIB_EXT2) || __GLIBC_USE (ISOC2X)</Line>
  <Line number="175">extern char *strndup (const char *__string, size_t __n)</Line>
  <Line number="176">     __THROW __attribute_malloc__ __nonnull ((1));</Line>
  <Line number="177">#endif</Line>
  <Line number="178"></Line>
  <Line number="179">#if defined __USE_GNU &amp;&amp; defined __GNUC__</Line>
  <Line number="180">/* Duplicate S, returning an identical alloca&apos;d string.  */</Line>
  <Line number="181"># define strdupa(s)							      \</Line>
  <Line number="182">  (__extension__							      \</Line>
  <Line number="183">    ({									      \</Line>
  <Line number="184">      const char *__old = (s);						      \</Line>
  <Line number="185">      size_t __len = strlen (__old) + 1;				      \</Line>
  <Line number="186">      char *__new = (char *) __builtin_alloca (__len);			      \</Line>
  <Line number="187">      (char *) memcpy (__new, __old, __len);				      \</Line>
  <Line number="188">    }))</Line>
  <Line number="189"></Line>
  <Line number="190">/* Return an alloca&apos;d copy of at most N bytes of string.  */</Line>
  <Line number="191"># define strndupa(s, n)							      \</Line>
  <Line number="192">  (__extension__							      \</Line>
  <Line number="193">    ({									      \</Line>
  <Line number="194">      const char *__old = (s);						      \</Line>
  <Line number="195">      size_t __len = strnlen (__old, (n));				      \</Line>
  <Line number="196">      char *__new = (char *) __builtin_alloca (__len + 1);		      \</Line>
  <Line number="197">      __new[__len] = &apos;\0&apos;;						      \</Line>
  <Line number="198">      (char *) memcpy (__new, __old, __len);				      \</Line>
  <Line number="199">    }))</Line>
  <Line number="200">#endif</Line>
  <Line number="201"></Line>
  <Line number="202">/* Find the first occurrence of C in S.  */</Line>
  <Line number="203">#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO</Line>
  <Line number="204">extern &quot;C++&quot;</Line>
  <Line number="205">{</Line>
  <Line number="206">extern char *strchr (char *__s, int __c)</Line>
  <Line number="207">     __THROW __asm (&quot;strchr&quot;) __attribute_pure__ __nonnull ((1));</Line>
  <Line number="208">extern const char *strchr (const char *__s, int __c)</Line>
  <Line number="209">     __THROW __asm (&quot;strchr&quot;) __attribute_pure__ __nonnull ((1));</Line>
  <Line number="210"></Line>
  <Line number="211"># ifdef __OPTIMIZE__</Line>
  <Line number="212">__extern_always_inline char *</Line>
  <Line number="213">strchr (char *__s, int __c) __THROW</Line>
  <Line number="214">{</Line>
  <Line number="215">  return __builtin_strchr (__s, __c);</Line>
  <Line number="216">}</Line>
  <Line number="217"></Line>
  <Line number="218">__extern_always_inline const char *</Line>
  <Line number="219">strchr (const char *__s, int __c) __THROW</Line>
  <Line number="220">{</Line>
  <Line number="221">  return __builtin_strchr (__s, __c);</Line>
  <Line number="222">}</Line>
  <Line number="223"># endif</Line>
  <Line number="224">}</Line>
  <Line number="225">#else</Line>
  <Line number="226">extern char *strchr (const char *__s, int __c)</Line>
  <Line number="227">     __THROW __attribute_pure__ __nonnull ((1));</Line>
  <Line number="228">#endif</Line>
  <Line number="229">/* Find the last occurrence of C in S.  */</Line>
  <Line number="230">#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO</Line>
  <Line number="231">extern &quot;C++&quot;</Line>
  <Line number="232">{</Line>
  <Line number="233">extern char *strrchr (char *__s, int __c)</Line>
  <Line number="234">     __THROW __asm (&quot;strrchr&quot;) __attribute_pure__ __nonnull ((1));</Line>
  <Line number="235">extern const char *strrchr (const char *__s, int __c)</Line>
  <Line number="236">     __THROW __asm (&quot;strrchr&quot;) __attribute_pure__ __nonnull ((1));</Line>
  <Line number="237"></Line>
  <Line number="238"># ifdef __OPTIMIZE__</Line>
  <Line number="239">__extern_always_inline char *</Line>
  <Line number="240">strrchr (char *__s, int __c) __THROW</Line>
  <Line number="241">{</Line>
  <Line number="242">  return __builtin_strrchr (__s, __c);</Line>
  <Line number="243">}</Line>
  <Line number="244"></Line>
  <Line number="245">__extern_always_inline const char *</Line>
  <Line number="246">strrchr (const char *__s, int __c) __THROW</Line>
  <Line number="247">{</Line>
  <Line number="248">  return __builtin_strrchr (__s, __c);</Line>
  <Line number="249">}</Line>
  <Line number="250"># endif</Line>
  <Line number="251">}</Line>
  <Line number="252">#else</Line>
  <Line number="253">extern char *strrchr (const char *__s, int __c)</Line>
  <Line number="254">     __THROW __attribute_pure__ __nonnull ((1));</Line>
  <Line number="255">#endif</Line>
  <Line number="256"></Line>
  <Line number="257">#ifdef __USE_GNU</Line>
  <Line number="258">/* This function is similar to `strchr&apos;.  But it returns a pointer to</Line>
  <Line number="259">   the closing NUL byte in case C is not found in S.  */</Line>
  <Line number="260"># ifdef __CORRECT_ISO_CPP_STRING_H_PROTO</Line>
  <Line number="261">extern &quot;C++&quot; char *strchrnul (char *__s, int __c)</Line>
  <Line number="262">     __THROW __asm (&quot;strchrnul&quot;) __attribute_pure__ __nonnull ((1));</Line>
  <Line number="263">extern &quot;C++&quot; const char *strchrnul (const char *__s, int __c)</Line>
  <Line number="264">     __THROW __asm (&quot;strchrnul&quot;) __attribute_pure__ __nonnull ((1));</Line>
  <Line number="265"># else</Line>
  <Line number="266">extern char *strchrnul (const char *__s, int __c)</Line>
  <Line number="267">     __THROW __attribute_pure__ __nonnull ((1));</Line>
  <Line number="268"># endif</Line>
  <Line number="269">#endif</Line>
  <Line number="270"></Line>
  <Line number="271">/* Return the length of the initial segment of S which</Line>
  <Line number="272">   consists entirely of characters not in REJECT.  */</Line>
  <Line number="273">extern size_t strcspn (const char *__s, const char *__reject)</Line>
  <Line number="274">     __THROW __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="275">/* Return the length of the initial segment of S which</Line>
  <Line number="276">   consists entirely of characters in ACCEPT.  */</Line>
  <Line number="277">extern size_t strspn (const char *__s, const char *__accept)</Line>
  <Line number="278">     __THROW __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="279">/* Find the first occurrence in S of any character in ACCEPT.  */</Line>
  <Line number="280">#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO</Line>
  <Line number="281">extern &quot;C++&quot;</Line>
  <Line number="282">{</Line>
  <Line number="283">extern char *strpbrk (char *__s, const char *__accept)</Line>
  <Line number="284">     __THROW __asm (&quot;strpbrk&quot;) __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="285">extern const char *strpbrk (const char *__s, const char *__accept)</Line>
  <Line number="286">     __THROW __asm (&quot;strpbrk&quot;) __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="287"></Line>
  <Line number="288"># ifdef __OPTIMIZE__</Line>
  <Line number="289">__extern_always_inline char *</Line>
  <Line number="290">strpbrk (char *__s, const char *__accept) __THROW</Line>
  <Line number="291">{</Line>
  <Line number="292">  return __builtin_strpbrk (__s, __accept);</Line>
  <Line number="293">}</Line>
  <Line number="294"></Line>
  <Line number="295">__extern_always_inline const char *</Line>
  <Line number="296">strpbrk (const char *__s, const char *__accept) __THROW</Line>
  <Line number="297">{</Line>
  <Line number="298">  return __builtin_strpbrk (__s, __accept);</Line>
  <Line number="299">}</Line>
  <Line number="300"># endif</Line>
  <Line number="301">}</Line>
  <Line number="302">#else</Line>
  <Line number="303">extern char *strpbrk (const char *__s, const char *__accept)</Line>
  <Line number="304">     __THROW __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="305">#endif</Line>
  <Line number="306">/* Find the first occurrence of NEEDLE in HAYSTACK.  */</Line>
  <Line number="307">#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO</Line>
  <Line number="308">extern &quot;C++&quot;</Line>
  <Line number="309">{</Line>
  <Line number="310">extern char *strstr (char *__haystack, const char *__needle)</Line>
  <Line number="311">     __THROW __asm (&quot;strstr&quot;) __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="312">extern const char *strstr (const char *__haystack, const char *__needle)</Line>
  <Line number="313">     __THROW __asm (&quot;strstr&quot;) __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="314"></Line>
  <Line number="315"># ifdef __OPTIMIZE__</Line>
  <Line number="316">__extern_always_inline char *</Line>
  <Line number="317">strstr (char *__haystack, const char *__needle) __THROW</Line>
  <Line number="318">{</Line>
  <Line number="319">  return __builtin_strstr (__haystack, __needle);</Line>
  <Line number="320">}</Line>
  <Line number="321"></Line>
  <Line number="322">__extern_always_inline const char *</Line>
  <Line number="323">strstr (const char *__haystack, const char *__needle) __THROW</Line>
  <Line number="324">{</Line>
  <Line number="325">  return __builtin_strstr (__haystack, __needle);</Line>
  <Line number="326">}</Line>
  <Line number="327"># endif</Line>
  <Line number="328">}</Line>
  <Line number="329">#else</Line>
  <Line number="330">extern char *strstr (const char *__haystack, const char *__needle)</Line>
  <Line number="331">     __THROW __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="332">#endif</Line>
  <Line number="333"></Line>
  <Line number="334"></Line>
  <Line number="335">/* Divide S into tokens separated by characters in DELIM.  */</Line>
  <Line number="336">extern char *strtok (char *__restrict __s, const char *__restrict __delim)</Line>
  <Line number="337">     __THROW __nonnull ((2));</Line>
  <Line number="338"></Line>
  <Line number="339">/* Divide S into tokens separated by characters in DELIM.  Information</Line>
  <Line number="340">   passed between calls are stored in SAVE_PTR.  */</Line>
  <Line number="341">extern char *__strtok_r (char *__restrict __s,</Line>
  <Line number="342">			 const char *__restrict __delim,</Line>
  <Line number="343">			 char **__restrict __save_ptr)</Line>
  <Line number="344">     __THROW __nonnull ((2, 3));</Line>
  <Line number="345">#ifdef __USE_POSIX</Line>
  <Line number="346">extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,</Line>
  <Line number="347">		       char **__restrict __save_ptr)</Line>
  <Line number="348">     __THROW __nonnull ((2, 3));</Line>
  <Line number="349">#endif</Line>
  <Line number="350"></Line>
  <Line number="351">#ifdef __USE_GNU</Line>
  <Line number="352">/* Similar to `strstr&apos; but this function ignores the case of both strings.  */</Line>
  <Line number="353"># ifdef __CORRECT_ISO_CPP_STRING_H_PROTO</Line>
  <Line number="354">extern &quot;C++&quot; char *strcasestr (char *__haystack, const char *__needle)</Line>
  <Line number="355">     __THROW __asm (&quot;strcasestr&quot;) __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="356">extern &quot;C++&quot; const char *strcasestr (const char *__haystack,</Line>
  <Line number="357">				     const char *__needle)</Line>
  <Line number="358">     __THROW __asm (&quot;strcasestr&quot;) __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="359"># else</Line>
  <Line number="360">extern char *strcasestr (const char *__haystack, const char *__needle)</Line>
  <Line number="361">     __THROW __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="362"># endif</Line>
  <Line number="363">#endif</Line>
  <Line number="364"></Line>
  <Line number="365">#ifdef __USE_GNU</Line>
  <Line number="366">/* Find the first occurrence of NEEDLE in HAYSTACK.</Line>
  <Line number="367">   NEEDLE is NEEDLELEN bytes long;</Line>
  <Line number="368">   HAYSTACK is HAYSTACKLEN bytes long.  */</Line>
  <Line number="369">extern void *memmem (const void *__haystack, size_t __haystacklen,</Line>
  <Line number="370">		     const void *__needle, size_t __needlelen)</Line>
  <Line number="371">     __THROW __attribute_pure__ __nonnull ((1, 3));</Line>
  <Line number="372"></Line>
  <Line number="373">/* Copy N bytes of SRC to DEST, return pointer to bytes after the</Line>
  <Line number="374">   last written byte.  */</Line>
  <Line number="375">extern void *__mempcpy (void *__restrict __dest,</Line>
  <Line number="376">			const void *__restrict __src, size_t __n)</Line>
  <Line number="377">     __THROW __nonnull ((1, 2));</Line>
  <Line number="378">extern void *mempcpy (void *__restrict __dest,</Line>
  <Line number="379">		      const void *__restrict __src, size_t __n)</Line>
  <Line number="380">     __THROW __nonnull ((1, 2));</Line>
  <Line number="381">#endif</Line>
  <Line number="382"></Line>
  <Line number="383"></Line>
  <Line number="384">/* Return the length of S.  */</Line>
  <Line number="385">extern size_t strlen (const char *__s)</Line>
  <Line number="386">     __THROW __attribute_pure__ __nonnull ((1));</Line>
  <Line number="387"></Line>
  <Line number="388">#ifdef	__USE_XOPEN2K8</Line>
  <Line number="389">/* Find the length of STRING, but scan at most MAXLEN characters.</Line>
  <Line number="390">   If no &apos;\0&apos; terminator is found in that many characters, return MAXLEN.  */</Line>
  <Line number="391">extern size_t strnlen (const char *__string, size_t __maxlen)</Line>
  <Line number="392">     __THROW __attribute_pure__ __nonnull ((1));</Line>
  <Line number="393">#endif</Line>
  <Line number="394"></Line>
  <Line number="395"></Line>
  <Line number="396">/* Return a string describing the meaning of the `errno&apos; code in ERRNUM.  */</Line>
  <Line number="397">extern char *strerror (int __errnum) __THROW;</Line>
  <Line number="398">#ifdef __USE_XOPEN2K</Line>
  <Line number="399">/* Reentrant version of `strerror&apos;.</Line>
  <Line number="400">   There are 2 flavors of `strerror_r&apos;, GNU which returns the string</Line>
  <Line number="401">   and may or may not use the supplied temporary buffer and POSIX one</Line>
  <Line number="402">   which fills the string into the buffer.</Line>
  <Line number="403">   To use the POSIX version, -D_XOPEN_SOURCE=600 or -D_POSIX_C_SOURCE=200112L</Line>
  <Line number="404">   without -D_GNU_SOURCE is needed, otherwise the GNU version is</Line>
  <Line number="405">   preferred.  */</Line>
  <Line number="406"># if defined __USE_XOPEN2K &amp;&amp; !defined __USE_GNU</Line>
  <Line number="407">/* Fill BUF with a string describing the meaning of the `errno&apos; code in</Line>
  <Line number="408">   ERRNUM.  */</Line>
  <Line number="409">#  ifdef __REDIRECT_NTH</Line>
  <Line number="410">extern int __REDIRECT_NTH (strerror_r,</Line>
  <Line number="411">			   (int __errnum, char *__buf, size_t __buflen),</Line>
  <Line number="412">			   __xpg_strerror_r) __nonnull ((2));</Line>
  <Line number="413">#  else</Line>
  <Line number="414">extern int __xpg_strerror_r (int __errnum, char *__buf, size_t __buflen)</Line>
  <Line number="415">     __THROW __nonnull ((2));</Line>
  <Line number="416">#   define strerror_r __xpg_strerror_r</Line>
  <Line number="417">#  endif</Line>
  <Line number="418"># else</Line>
  <Line number="419">/* If a temporary buffer is required, at most BUFLEN bytes of BUF will be</Line>
  <Line number="420">   used.  */</Line>
  <Line number="421">extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)</Line>
  <Line number="422">     __THROW __nonnull ((2)) __wur;</Line>
  <Line number="423"># endif</Line>
  <Line number="424">#endif</Line>
  <Line number="425"></Line>
  <Line number="426">#ifdef __USE_XOPEN2K8</Line>
  <Line number="427">/* Translate error number to string according to the locale L.  */</Line>
  <Line number="428">extern char *strerror_l (int __errnum, locale_t __l) __THROW;</Line>
  <Line number="429">#endif</Line>
  <Line number="430"></Line>
  <Line number="431">#ifdef __USE_MISC</Line>
  <Line number="432"># include &lt;strings.h&gt;</Line>
  <Line number="433"></Line>
  <Line number="434">/* Set N bytes of S to 0.  The compiler will not delete a call to this</Line>
  <Line number="435">   function, even if S is dead after the call.  */</Line>
  <Line number="436">extern void explicit_bzero (void *__s, size_t __n) __THROW __nonnull ((1));</Line>
  <Line number="437"></Line>
  <Line number="438">/* Return the next DELIM-delimited token from *STRINGP,</Line>
  <Line number="439">   terminating it with a &apos;\0&apos;, and update *STRINGP to point past it.  */</Line>
  <Line number="440">extern char *strsep (char **__restrict __stringp,</Line>
  <Line number="441">		     const char *__restrict __delim)</Line>
  <Line number="442">     __THROW __nonnull ((1, 2));</Line>
  <Line number="443">#endif</Line>
  <Line number="444"></Line>
  <Line number="445">#ifdef	__USE_XOPEN2K8</Line>
  <Line number="446">/* Return a string describing the meaning of the signal number in SIG.  */</Line>
  <Line number="447">extern char *strsignal (int __sig) __THROW;</Line>
  <Line number="448"></Line>
  <Line number="449">/* Copy SRC to DEST, returning the address of the terminating &apos;\0&apos; in DEST.  */</Line>
  <Line number="450">extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)</Line>
  <Line number="451">     __THROW __nonnull ((1, 2));</Line>
  <Line number="452">extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)</Line>
  <Line number="453">     __THROW __nonnull ((1, 2));</Line>
  <Line number="454"></Line>
  <Line number="455">/* Copy no more than N characters of SRC to DEST, returning the address of</Line>
  <Line number="456">   the last character written into DEST.  */</Line>
  <Line number="457">extern char *__stpncpy (char *__restrict __dest,</Line>
  <Line number="458">			const char *__restrict __src, size_t __n)</Line>
  <Line number="459">     __THROW __nonnull ((1, 2));</Line>
  <Line number="460">extern char *stpncpy (char *__restrict __dest,</Line>
  <Line number="461">		      const char *__restrict __src, size_t __n)</Line>
  <Line number="462">     __THROW __nonnull ((1, 2));</Line>
  <Line number="463">#endif</Line>
  <Line number="464"></Line>
  <Line number="465">#ifdef	__USE_GNU</Line>
  <Line number="466">/* Compare S1 and S2 as strings holding name &amp; indices/version numbers.  */</Line>
  <Line number="467">extern int strverscmp (const char *__s1, const char *__s2)</Line>
  <Line number="468">     __THROW __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="469"></Line>
  <Line number="470">/* Sautee STRING briskly.  */</Line>
  <Line number="471">extern char *strfry (char *__string) __THROW __nonnull ((1));</Line>
  <Line number="472"></Line>
  <Line number="473">/* Frobnicate N bytes of S.  */</Line>
  <Line number="474">extern void *memfrob (void *__s, size_t __n) __THROW __nonnull ((1));</Line>
  <Line number="475"></Line>
  <Line number="476"># ifndef basename</Line>
  <Line number="477">/* Return the file name within directory of FILENAME.  We don&apos;t</Line>
  <Line number="478">   declare the function if the `basename&apos; macro is available (defined</Line>
  <Line number="479">   in &lt;libgen.h&gt;) which makes the XPG version of this function</Line>
  <Line number="480">   available.  */</Line>
  <Line number="481">#  ifdef __CORRECT_ISO_CPP_STRING_H_PROTO</Line>
  <Line number="482">extern &quot;C++&quot; char *basename (char *__filename)</Line>
  <Line number="483">     __THROW __asm (&quot;basename&quot;) __nonnull ((1));</Line>
  <Line number="484">extern &quot;C++&quot; const char *basename (const char *__filename)</Line>
  <Line number="485">     __THROW __asm (&quot;basename&quot;) __nonnull ((1));</Line>
  <Line number="486">#  else</Line>
  <Line number="487">extern char *basename (const char *__filename) __THROW __nonnull ((1));</Line>
  <Line number="488">#  endif</Line>
  <Line number="489"># endif</Line>
  <Line number="490">#endif</Line>
  <Line number="491"></Line>
  <Line number="492">#if __GNUC_PREREQ (3,4)</Line>
  <Line number="493"># if __USE_FORTIFY_LEVEL &gt; 0 &amp;&amp; defined __fortify_function</Line>
  <Line number="494">/* Functions with security checks.  */</Line>
  <Line number="495">#  include &lt;bits/string_fortified.h&gt;</Line>
  <Line number="496"># endif</Line>
  <Line number="497">#endif</Line>
  <Line number="498"></Line>
  <Line number="499">__END_DECLS</Line>
  <Line number="500"></Line>
  <Line number="501">#endif /* string.h  */</Line>
</SourceFile>
