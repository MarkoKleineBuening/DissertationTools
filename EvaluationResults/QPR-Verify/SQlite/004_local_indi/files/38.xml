<SourceFile>
  <Line number="1">/* Copyright (C) 1991-2020 Free Software Foundation, Inc.</Line>
  <Line number="2">   This file is part of the GNU C Library.</Line>
  <Line number="3"></Line>
  <Line number="4">   The GNU C Library is free software; you can redistribute it and/or</Line>
  <Line number="5">   modify it under the terms of the GNU Lesser General Public</Line>
  <Line number="6">   License as published by the Free Software Foundation; either</Line>
  <Line number="7">   version 2.1 of the License, or (at your option) any later version.</Line>
  <Line number="8"></Line>
  <Line number="9">   The GNU C Library is distributed in the hope that it will be useful,</Line>
  <Line number="10">   but WITHOUT ANY WARRANTY; without even the implied warranty of</Line>
  <Line number="11">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</Line>
  <Line number="12">   Lesser General Public License for more details.</Line>
  <Line number="13"></Line>
  <Line number="14">   You should have received a copy of the GNU Lesser General Public</Line>
  <Line number="15">   License along with the GNU C Library; if not, see</Line>
  <Line number="16">   &lt;https://www.gnu.org/licenses/&gt;.  */</Line>
  <Line number="17"></Line>
  <Line number="18">/*</Line>
  <Line number="19"> *	POSIX Standard: 5.1.2 Directory Operations	&lt;dirent.h&gt;</Line>
  <Line number="20"> */</Line>
  <Line number="21"></Line>
  <Line number="22">#ifndef	_DIRENT_H</Line>
  <Line number="23">#define	_DIRENT_H	1</Line>
  <Line number="24"></Line>
  <Line number="25">#include &lt;features.h&gt;</Line>
  <Line number="26"></Line>
  <Line number="27">__BEGIN_DECLS</Line>
  <Line number="28"></Line>
  <Line number="29">#include &lt;bits/types.h&gt;</Line>
  <Line number="30"></Line>
  <Line number="31">#ifdef __USE_XOPEN</Line>
  <Line number="32"># ifndef __ino_t_defined</Line>
  <Line number="33">#  ifndef __USE_FILE_OFFSET64</Line>
  <Line number="34">typedef __ino_t ino_t;</Line>
  <Line number="35">#  else</Line>
  <Line number="36">typedef __ino64_t ino_t;</Line>
  <Line number="37">#  endif</Line>
  <Line number="38">#  define __ino_t_defined</Line>
  <Line number="39"># endif</Line>
  <Line number="40"># if defined __USE_LARGEFILE64 &amp;&amp; !defined __ino64_t_defined</Line>
  <Line number="41">typedef __ino64_t ino64_t;</Line>
  <Line number="42">#  define __ino64_t_defined</Line>
  <Line number="43"># endif</Line>
  <Line number="44">#endif</Line>
  <Line number="45"></Line>
  <Line number="46">/* This file defines `struct dirent&apos;.</Line>
  <Line number="47"></Line>
  <Line number="48">   It defines the macro `_DIRENT_HAVE_D_NAMLEN&apos; iff there is a `d_namlen&apos;</Line>
  <Line number="49">   member that gives the length of `d_name&apos;.</Line>
  <Line number="50"></Line>
  <Line number="51">   It defines the macro `_DIRENT_HAVE_D_RECLEN&apos; iff there is a `d_reclen&apos;</Line>
  <Line number="52">   member that gives the size of the entire directory entry.</Line>
  <Line number="53"></Line>
  <Line number="54">   It defines the macro `_DIRENT_HAVE_D_OFF&apos; iff there is a `d_off&apos;</Line>
  <Line number="55">   member that gives the file offset of the next directory entry.</Line>
  <Line number="56"></Line>
  <Line number="57">   It defines the macro `_DIRENT_HAVE_D_TYPE&apos; iff there is a `d_type&apos;</Line>
  <Line number="58">   member that gives the type of the file.</Line>
  <Line number="59"> */</Line>
  <Line number="60"></Line>
  <Line number="61">#include &lt;bits/dirent.h&gt;</Line>
  <Line number="62"></Line>
  <Line number="63">#if defined __USE_MISC &amp;&amp; !defined d_fileno</Line>
  <Line number="64"># define d_ino	d_fileno		 /* Backward compatibility.  */</Line>
  <Line number="65">#endif</Line>
  <Line number="66"></Line>
  <Line number="67">/* These macros extract size information from a `struct dirent *&apos;.</Line>
  <Line number="68">   They may evaluate their argument multiple times, so it must not</Line>
  <Line number="69">   have side effects.  Each of these may involve a relatively costly</Line>
  <Line number="70">   call to `strlen&apos; on some systems, so these values should be cached.</Line>
  <Line number="71"></Line>
  <Line number="72">   _D_EXACT_NAMLEN (DP)	returns the length of DP-&gt;d_name, not including</Line>
  <Line number="73">   its terminating null character.</Line>
  <Line number="74"></Line>
  <Line number="75">   _D_ALLOC_NAMLEN (DP)	returns a size at least (_D_EXACT_NAMLEN (DP) + 1);</Line>
  <Line number="76">   that is, the allocation size needed to hold the DP-&gt;d_name string.</Line>
  <Line number="77">   Use this macro when you don&apos;t need the exact length, just an upper bound.</Line>
  <Line number="78">   This macro is less likely to require calling `strlen&apos; than _D_EXACT_NAMLEN.</Line>
  <Line number="79">   */</Line>
  <Line number="80"></Line>
  <Line number="81">#ifdef _DIRENT_HAVE_D_NAMLEN</Line>
  <Line number="82"># define _D_EXACT_NAMLEN(d) ((d)-&gt;d_namlen)</Line>
  <Line number="83"># define _D_ALLOC_NAMLEN(d) (_D_EXACT_NAMLEN (d) + 1)</Line>
  <Line number="84">#else</Line>
  <Line number="85"># define _D_EXACT_NAMLEN(d) (strlen ((d)-&gt;d_name))</Line>
  <Line number="86"># ifdef _DIRENT_HAVE_D_RECLEN</Line>
  <Line number="87">#  define _D_ALLOC_NAMLEN(d) (((char *) (d) + (d)-&gt;d_reclen) - &amp;(d)-&gt;d_name[0])</Line>
  <Line number="88"># else</Line>
  <Line number="89">#  define _D_ALLOC_NAMLEN(d) (sizeof (d)-&gt;d_name &gt; 1 ? sizeof (d)-&gt;d_name \</Line>
  <Line number="90">			      : _D_EXACT_NAMLEN (d) + 1)</Line>
  <Line number="91"># endif</Line>
  <Line number="92">#endif</Line>
  <Line number="93"></Line>
  <Line number="94"></Line>
  <Line number="95">#ifdef __USE_MISC</Line>
  <Line number="96">/* File types for `d_type&apos;.  */</Line>
  <Line number="97">enum</Line>
  <Line number="98">  {</Line>
  <Line number="99">    DT_UNKNOWN = 0,</Line>
  <Line number="100"># define DT_UNKNOWN	DT_UNKNOWN</Line>
  <Line number="101">    DT_FIFO = 1,</Line>
  <Line number="102"># define DT_FIFO	DT_FIFO</Line>
  <Line number="103">    DT_CHR = 2,</Line>
  <Line number="104"># define DT_CHR		DT_CHR</Line>
  <Line number="105">    DT_DIR = 4,</Line>
  <Line number="106"># define DT_DIR		DT_DIR</Line>
  <Line number="107">    DT_BLK = 6,</Line>
  <Line number="108"># define DT_BLK		DT_BLK</Line>
  <Line number="109">    DT_REG = 8,</Line>
  <Line number="110"># define DT_REG		DT_REG</Line>
  <Line number="111">    DT_LNK = 10,</Line>
  <Line number="112"># define DT_LNK		DT_LNK</Line>
  <Line number="113">    DT_SOCK = 12,</Line>
  <Line number="114"># define DT_SOCK	DT_SOCK</Line>
  <Line number="115">    DT_WHT = 14</Line>
  <Line number="116"># define DT_WHT		DT_WHT</Line>
  <Line number="117">  };</Line>
  <Line number="118"></Line>
  <Line number="119">/* Convert between stat structure types and directory types.  */</Line>
  <Line number="120"># define IFTODT(mode)	(((mode) &amp; 0170000) &gt;&gt; 12)</Line>
  <Line number="121"># define DTTOIF(dirtype)	((dirtype) &lt;&lt; 12)</Line>
  <Line number="122">#endif</Line>
  <Line number="123"></Line>
  <Line number="124"></Line>
  <Line number="125">/* This is the data type of directory stream objects.</Line>
  <Line number="126">   The actual structure is opaque to users.  */</Line>
  <Line number="127">typedef struct __dirstream DIR;</Line>
  <Line number="128"></Line>
  <Line number="129">/* Open a directory stream on NAME.</Line>
  <Line number="130">   Return a DIR stream on the directory, or NULL if it could not be opened.</Line>
  <Line number="131"></Line>
  <Line number="132">   This function is a possible cancellation point and therefore not</Line>
  <Line number="133">   marked with __THROW.  */</Line>
  <Line number="134">extern DIR *opendir (const char *__name) __nonnull ((1));</Line>
  <Line number="135"></Line>
  <Line number="136">#ifdef __USE_XOPEN2K8</Line>
  <Line number="137">/* Same as opendir, but open the stream on the file descriptor FD.</Line>
  <Line number="138"></Line>
  <Line number="139">   This function is a possible cancellation point and therefore not</Line>
  <Line number="140">   marked with __THROW.  */</Line>
  <Line number="141">extern DIR *fdopendir (int __fd);</Line>
  <Line number="142">#endif</Line>
  <Line number="143"></Line>
  <Line number="144">/* Close the directory stream DIRP.</Line>
  <Line number="145">   Return 0 if successful, -1 if not.</Line>
  <Line number="146"></Line>
  <Line number="147">   This function is a possible cancellation point and therefore not</Line>
  <Line number="148">   marked with __THROW.  */</Line>
  <Line number="149">extern int closedir (DIR *__dirp) __nonnull ((1));</Line>
  <Line number="150"></Line>
  <Line number="151">/* Read a directory entry from DIRP.  Return a pointer to a `struct</Line>
  <Line number="152">   dirent&apos; describing the entry, or NULL for EOF or error.  The</Line>
  <Line number="153">   storage returned may be overwritten by a later readdir call on the</Line>
  <Line number="154">   same DIR stream.</Line>
  <Line number="155"></Line>
  <Line number="156">   If the Large File Support API is selected we have to use the</Line>
  <Line number="157">   appropriate interface.</Line>
  <Line number="158"></Line>
  <Line number="159">   This function is a possible cancellation point and therefore not</Line>
  <Line number="160">   marked with __THROW.  */</Line>
  <Line number="161">#ifndef __USE_FILE_OFFSET64</Line>
  <Line number="162">extern struct dirent *readdir (DIR *__dirp) __nonnull ((1));</Line>
  <Line number="163">#else</Line>
  <Line number="164"># ifdef __REDIRECT</Line>
  <Line number="165">extern struct dirent *__REDIRECT (readdir, (DIR *__dirp), readdir64)</Line>
  <Line number="166">     __nonnull ((1));</Line>
  <Line number="167"># else</Line>
  <Line number="168">#  define readdir readdir64</Line>
  <Line number="169"># endif</Line>
  <Line number="170">#endif</Line>
  <Line number="171"></Line>
  <Line number="172">#ifdef __USE_LARGEFILE64</Line>
  <Line number="173">extern struct dirent64 *readdir64 (DIR *__dirp) __nonnull ((1));</Line>
  <Line number="174">#endif</Line>
  <Line number="175"></Line>
  <Line number="176">#ifdef __USE_POSIX</Line>
  <Line number="177">/* Reentrant version of `readdir&apos;.  Return in RESULT a pointer to the</Line>
  <Line number="178">   next entry.</Line>
  <Line number="179"></Line>
  <Line number="180">   This function is a possible cancellation point and therefore not</Line>
  <Line number="181">   marked with __THROW.  */</Line>
  <Line number="182"># ifndef __USE_FILE_OFFSET64</Line>
  <Line number="183">extern int readdir_r (DIR *__restrict __dirp,</Line>
  <Line number="184">		      struct dirent *__restrict __entry,</Line>
  <Line number="185">		      struct dirent **__restrict __result)</Line>
  <Line number="186">     __nonnull ((1, 2, 3)) __attribute_deprecated__;</Line>
  <Line number="187"># else</Line>
  <Line number="188">#  ifdef __REDIRECT</Line>
  <Line number="189">extern int __REDIRECT (readdir_r,</Line>
  <Line number="190">		       (DIR *__restrict __dirp,</Line>
  <Line number="191">			struct dirent *__restrict __entry,</Line>
  <Line number="192">			struct dirent **__restrict __result),</Line>
  <Line number="193">		       readdir64_r)</Line>
  <Line number="194">  __nonnull ((1, 2, 3)) __attribute_deprecated__;</Line>
  <Line number="195">#  else</Line>
  <Line number="196">#   define readdir_r readdir64_r</Line>
  <Line number="197">#  endif</Line>
  <Line number="198"># endif</Line>
  <Line number="199"></Line>
  <Line number="200"># ifdef __USE_LARGEFILE64</Line>
  <Line number="201">extern int readdir64_r (DIR *__restrict __dirp,</Line>
  <Line number="202">			struct dirent64 *__restrict __entry,</Line>
  <Line number="203">			struct dirent64 **__restrict __result)</Line>
  <Line number="204">  __nonnull ((1, 2, 3)) __attribute_deprecated__;</Line>
  <Line number="205"># endif</Line>
  <Line number="206">#endif	/* POSIX or misc */</Line>
  <Line number="207"></Line>
  <Line number="208">/* Rewind DIRP to the beginning of the directory.  */</Line>
  <Line number="209">extern void rewinddir (DIR *__dirp) __THROW __nonnull ((1));</Line>
  <Line number="210"></Line>
  <Line number="211">#if defined __USE_MISC || defined __USE_XOPEN</Line>
  <Line number="212"># include &lt;bits/types.h&gt;</Line>
  <Line number="213"></Line>
  <Line number="214">/* Seek to position POS on DIRP.  */</Line>
  <Line number="215">extern void seekdir (DIR *__dirp, long int __pos) __THROW __nonnull ((1));</Line>
  <Line number="216"></Line>
  <Line number="217">/* Return the current position of DIRP.  */</Line>
  <Line number="218">extern long int telldir (DIR *__dirp) __THROW __nonnull ((1));</Line>
  <Line number="219">#endif</Line>
  <Line number="220"></Line>
  <Line number="221">#ifdef __USE_XOPEN2K8</Line>
  <Line number="222"></Line>
  <Line number="223">/* Return the file descriptor used by DIRP.  */</Line>
  <Line number="224">extern int dirfd (DIR *__dirp) __THROW __nonnull ((1));</Line>
  <Line number="225"></Line>
  <Line number="226"># if defined __OPTIMIZE__ &amp;&amp; defined _DIR_dirfd</Line>
  <Line number="227">#  define dirfd(dirp)	_DIR_dirfd (dirp)</Line>
  <Line number="228"># endif</Line>
  <Line number="229"></Line>
  <Line number="230"># ifdef __USE_MISC</Line>
  <Line number="231">#  ifndef MAXNAMLEN</Line>
  <Line number="232">/* Get the definitions of the POSIX.1 limits.  */</Line>
  <Line number="233">#  include &lt;bits/posix1_lim.h&gt;</Line>
  <Line number="234"></Line>
  <Line number="235">/* `MAXNAMLEN&apos; is the BSD name for what POSIX calls `NAME_MAX&apos;.  */</Line>
  <Line number="236">#   ifdef NAME_MAX</Line>
  <Line number="237">#    define MAXNAMLEN	NAME_MAX</Line>
  <Line number="238">#   else</Line>
  <Line number="239">#    define MAXNAMLEN	255</Line>
  <Line number="240">#   endif</Line>
  <Line number="241">#  endif</Line>
  <Line number="242"># endif</Line>
  <Line number="243"></Line>
  <Line number="244"># define __need_size_t</Line>
  <Line number="245"># include &lt;stddef.h&gt;</Line>
  <Line number="246"></Line>
  <Line number="247">/* Scan the directory DIR, calling SELECTOR on each directory entry.</Line>
  <Line number="248">   Entries for which SELECT returns nonzero are individually malloc&apos;d,</Line>
  <Line number="249">   sorted using qsort with CMP, and collected in a malloc&apos;d array in</Line>
  <Line number="250">   *NAMELIST.  Returns the number of entries selected, or -1 on error.</Line>
  <Line number="251"></Line>
  <Line number="252">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="253">   __THROW.  */</Line>
  <Line number="254"># ifndef __USE_FILE_OFFSET64</Line>
  <Line number="255">extern int scandir (const char *__restrict __dir,</Line>
  <Line number="256">		    struct dirent ***__restrict __namelist,</Line>
  <Line number="257">		    int (*__selector) (const struct dirent *),</Line>
  <Line number="258">		    int (*__cmp) (const struct dirent **,</Line>
  <Line number="259">				  const struct dirent **))</Line>
  <Line number="260">     __nonnull ((1, 2));</Line>
  <Line number="261"># else</Line>
  <Line number="262">#  ifdef __REDIRECT</Line>
  <Line number="263">extern int __REDIRECT (scandir,</Line>
  <Line number="264">		       (const char *__restrict __dir,</Line>
  <Line number="265">			struct dirent ***__restrict __namelist,</Line>
  <Line number="266">			int (*__selector) (const struct dirent *),</Line>
  <Line number="267">			int (*__cmp) (const struct dirent **,</Line>
  <Line number="268">				      const struct dirent **)),</Line>
  <Line number="269">		       scandir64) __nonnull ((1, 2));</Line>
  <Line number="270">#  else</Line>
  <Line number="271">#   define scandir scandir64</Line>
  <Line number="272">#  endif</Line>
  <Line number="273"># endif</Line>
  <Line number="274"></Line>
  <Line number="275"># if defined __USE_GNU &amp;&amp; defined __USE_LARGEFILE64</Line>
  <Line number="276">/* This function is like `scandir&apos; but it uses the 64bit dirent structure.</Line>
  <Line number="277">   Please note that the CMP function must now work with struct dirent64 **.  */</Line>
  <Line number="278">extern int scandir64 (const char *__restrict __dir,</Line>
  <Line number="279">		      struct dirent64 ***__restrict __namelist,</Line>
  <Line number="280">		      int (*__selector) (const struct dirent64 *),</Line>
  <Line number="281">		      int (*__cmp) (const struct dirent64 **,</Line>
  <Line number="282">				    const struct dirent64 **))</Line>
  <Line number="283">     __nonnull ((1, 2));</Line>
  <Line number="284"># endif</Line>
  <Line number="285"></Line>
  <Line number="286"># ifdef __USE_GNU</Line>
  <Line number="287">/* Similar to `scandir&apos; but a relative DIR name is interpreted relative</Line>
  <Line number="288">   to the directory for which DFD is a descriptor.</Line>
  <Line number="289"></Line>
  <Line number="290">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="291">   __THROW.  */</Line>
  <Line number="292">#  ifndef __USE_FILE_OFFSET64</Line>
  <Line number="293">extern int scandirat (int __dfd, const char *__restrict __dir,</Line>
  <Line number="294">		      struct dirent ***__restrict __namelist,</Line>
  <Line number="295">		      int (*__selector) (const struct dirent *),</Line>
  <Line number="296">		      int (*__cmp) (const struct dirent **,</Line>
  <Line number="297">				    const struct dirent **))</Line>
  <Line number="298">     __nonnull ((2, 3));</Line>
  <Line number="299">#  else</Line>
  <Line number="300">#   ifdef __REDIRECT</Line>
  <Line number="301">extern int __REDIRECT (scandirat,</Line>
  <Line number="302">		       (int __dfd, const char *__restrict __dir,</Line>
  <Line number="303">			struct dirent ***__restrict __namelist,</Line>
  <Line number="304">			int (*__selector) (const struct dirent *),</Line>
  <Line number="305">			int (*__cmp) (const struct dirent **,</Line>
  <Line number="306">				      const struct dirent **)),</Line>
  <Line number="307">		       scandirat64) __nonnull ((2, 3));</Line>
  <Line number="308">#   else</Line>
  <Line number="309">#    define scandirat scandirat64</Line>
  <Line number="310">#   endif</Line>
  <Line number="311">#  endif</Line>
  <Line number="312"></Line>
  <Line number="313">/* This function is like `scandir&apos; but it uses the 64bit dirent structure.</Line>
  <Line number="314">   Please note that the CMP function must now work with struct dirent64 **.  */</Line>
  <Line number="315">extern int scandirat64 (int __dfd, const char *__restrict __dir,</Line>
  <Line number="316">			struct dirent64 ***__restrict __namelist,</Line>
  <Line number="317">			int (*__selector) (const struct dirent64 *),</Line>
  <Line number="318">			int (*__cmp) (const struct dirent64 **,</Line>
  <Line number="319">				      const struct dirent64 **))</Line>
  <Line number="320">     __nonnull ((2, 3));</Line>
  <Line number="321"># endif</Line>
  <Line number="322"></Line>
  <Line number="323">/* Function to compare two `struct dirent&apos;s alphabetically.  */</Line>
  <Line number="324"># ifndef __USE_FILE_OFFSET64</Line>
  <Line number="325">extern int alphasort (const struct dirent **__e1,</Line>
  <Line number="326">		      const struct dirent **__e2)</Line>
  <Line number="327">     __THROW __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="328"># else</Line>
  <Line number="329">#  ifdef __REDIRECT</Line>
  <Line number="330">extern int __REDIRECT_NTH (alphasort,</Line>
  <Line number="331">			   (const struct dirent **__e1,</Line>
  <Line number="332">			    const struct dirent **__e2),</Line>
  <Line number="333">			   alphasort64) __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="334">#  else</Line>
  <Line number="335">#   define alphasort alphasort64</Line>
  <Line number="336">#  endif</Line>
  <Line number="337"># endif</Line>
  <Line number="338"></Line>
  <Line number="339"># if defined __USE_GNU &amp;&amp; defined __USE_LARGEFILE64</Line>
  <Line number="340">extern int alphasort64 (const struct dirent64 **__e1,</Line>
  <Line number="341">			const struct dirent64 **__e2)</Line>
  <Line number="342">     __THROW __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="343"># endif</Line>
  <Line number="344">#endif /* Use XPG7.  */</Line>
  <Line number="345"></Line>
  <Line number="346"></Line>
  <Line number="347">#ifdef __USE_MISC</Line>
  <Line number="348">/* Read directory entries from FD into BUF, reading at most NBYTES.</Line>
  <Line number="349">   Reading starts at offset *BASEP, and *BASEP is updated with the new</Line>
  <Line number="350">   position after reading.  Returns the number of bytes read; zero when at</Line>
  <Line number="351">   end of directory; or -1 for errors.  */</Line>
  <Line number="352"># ifndef __USE_FILE_OFFSET64</Line>
  <Line number="353">extern __ssize_t getdirentries (int __fd, char *__restrict __buf,</Line>
  <Line number="354">				size_t __nbytes,</Line>
  <Line number="355">				__off_t *__restrict __basep)</Line>
  <Line number="356">     __THROW __nonnull ((2, 4));</Line>
  <Line number="357"># else</Line>
  <Line number="358">#  ifdef __REDIRECT</Line>
  <Line number="359">extern __ssize_t __REDIRECT_NTH (getdirentries,</Line>
  <Line number="360">				 (int __fd, char *__restrict __buf,</Line>
  <Line number="361">				  size_t __nbytes,</Line>
  <Line number="362">				  __off64_t *__restrict __basep),</Line>
  <Line number="363">				 getdirentries64) __nonnull ((2, 4));</Line>
  <Line number="364">#  else</Line>
  <Line number="365">#   define getdirentries getdirentries64</Line>
  <Line number="366">#  endif</Line>
  <Line number="367"># endif</Line>
  <Line number="368"></Line>
  <Line number="369"># ifdef __USE_LARGEFILE64</Line>
  <Line number="370">extern __ssize_t getdirentries64 (int __fd, char *__restrict __buf,</Line>
  <Line number="371">				  size_t __nbytes,</Line>
  <Line number="372">				  __off64_t *__restrict __basep)</Line>
  <Line number="373">     __THROW __nonnull ((2, 4));</Line>
  <Line number="374"># endif</Line>
  <Line number="375">#endif /* Use misc.  */</Line>
  <Line number="376"></Line>
  <Line number="377">#ifdef __USE_GNU</Line>
  <Line number="378">/* Function to compare two `struct dirent&apos;s by name &amp; version.  */</Line>
  <Line number="379"># ifndef __USE_FILE_OFFSET64</Line>
  <Line number="380">extern int versionsort (const struct dirent **__e1,</Line>
  <Line number="381">			const struct dirent **__e2)</Line>
  <Line number="382">     __THROW __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="383"># else</Line>
  <Line number="384">#  ifdef __REDIRECT</Line>
  <Line number="385">extern int __REDIRECT_NTH (versionsort,</Line>
  <Line number="386">			   (const struct dirent **__e1,</Line>
  <Line number="387">			    const struct dirent **__e2),</Line>
  <Line number="388">			   versionsort64)</Line>
  <Line number="389">     __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="390">#  else</Line>
  <Line number="391">#   define versionsort versionsort64</Line>
  <Line number="392">#  endif</Line>
  <Line number="393"># endif</Line>
  <Line number="394"></Line>
  <Line number="395"># ifdef __USE_LARGEFILE64</Line>
  <Line number="396">extern int versionsort64 (const struct dirent64 **__e1,</Line>
  <Line number="397">			  const struct dirent64 **__e2)</Line>
  <Line number="398">     __THROW __attribute_pure__ __nonnull ((1, 2));</Line>
  <Line number="399"># endif</Line>
  <Line number="400">#endif /* Use GNU.  */</Line>
  <Line number="401"></Line>
  <Line number="402">__END_DECLS</Line>
  <Line number="403"></Line>
  <Line number="404">#include &lt;bits/dirent_ext.h&gt;</Line>
  <Line number="405"></Line>
  <Line number="406">#endif /* dirent.h  */</Line>
</SourceFile>
