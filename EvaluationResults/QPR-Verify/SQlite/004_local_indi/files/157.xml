<SourceFile>
  <Line number="1">/* User functions for run-time dynamic loading.</Line>
  <Line number="2">   Copyright (C) 1995-2020 Free Software Foundation, Inc.</Line>
  <Line number="3">   This file is part of the GNU C Library.</Line>
  <Line number="4"></Line>
  <Line number="5">   The GNU C Library is free software; you can redistribute it and/or</Line>
  <Line number="6">   modify it under the terms of the GNU Lesser General Public</Line>
  <Line number="7">   License as published by the Free Software Foundation; either</Line>
  <Line number="8">   version 2.1 of the License, or (at your option) any later version.</Line>
  <Line number="9"></Line>
  <Line number="10">   The GNU C Library is distributed in the hope that it will be useful,</Line>
  <Line number="11">   but WITHOUT ANY WARRANTY; without even the implied warranty of</Line>
  <Line number="12">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</Line>
  <Line number="13">   Lesser General Public License for more details.</Line>
  <Line number="14"></Line>
  <Line number="15">   You should have received a copy of the GNU Lesser General Public</Line>
  <Line number="16">   License along with the GNU C Library; if not, see</Line>
  <Line number="17">   &lt;https://www.gnu.org/licenses/&gt;.  */</Line>
  <Line number="18"></Line>
  <Line number="19">#ifndef	_DLFCN_H</Line>
  <Line number="20">#define	_DLFCN_H 1</Line>
  <Line number="21"></Line>
  <Line number="22">#include &lt;features.h&gt;</Line>
  <Line number="23">#define __need_size_t</Line>
  <Line number="24">#include &lt;stddef.h&gt;</Line>
  <Line number="25"></Line>
  <Line number="26">/* Collect various system dependent definitions and declarations.  */</Line>
  <Line number="27">#include &lt;bits/dlfcn.h&gt;</Line>
  <Line number="28"></Line>
  <Line number="29"></Line>
  <Line number="30">#ifdef __USE_GNU</Line>
  <Line number="31">/* If the first argument of `dlsym&apos; or `dlvsym&apos; is set to RTLD_NEXT</Line>
  <Line number="32">   the run-time address of the symbol called NAME in the next shared</Line>
  <Line number="33">   object is returned.  The &quot;next&quot; relation is defined by the order</Line>
  <Line number="34">   the shared objects were loaded.  */</Line>
  <Line number="35"># define RTLD_NEXT	((void *) -1l)</Line>
  <Line number="36"></Line>
  <Line number="37">/* If the first argument to `dlsym&apos; or `dlvsym&apos; is set to RTLD_DEFAULT</Line>
  <Line number="38">   the run-time address of the symbol called NAME in the global scope</Line>
  <Line number="39">   is returned.  */</Line>
  <Line number="40"># define RTLD_DEFAULT	((void *) 0)</Line>
  <Line number="41"></Line>
  <Line number="42"></Line>
  <Line number="43">/* Type for namespace indeces.  */</Line>
  <Line number="44">typedef long int Lmid_t;</Line>
  <Line number="45"></Line>
  <Line number="46">/* Special namespace ID values.  */</Line>
  <Line number="47"># define LM_ID_BASE	0	/* Initial namespace.  */</Line>
  <Line number="48"># define LM_ID_NEWLM	-1	/* For dlmopen: request new namespace.  */</Line>
  <Line number="49">#endif</Line>
  <Line number="50"></Line>
  <Line number="51"></Line>
  <Line number="52">__BEGIN_DECLS</Line>
  <Line number="53"></Line>
  <Line number="54">/* Open the shared object FILE and map it in; return a handle that can be</Line>
  <Line number="55">   passed to `dlsym&apos; to get symbol values from it.  */</Line>
  <Line number="56">extern void *dlopen (const char *__file, int __mode) __THROWNL;</Line>
  <Line number="57"></Line>
  <Line number="58">/* Unmap and close a shared object opened by `dlopen&apos;.</Line>
  <Line number="59">   The handle cannot be used again after calling `dlclose&apos;.  */</Line>
  <Line number="60">extern int dlclose (void *__handle) __THROWNL __nonnull ((1));</Line>
  <Line number="61"></Line>
  <Line number="62">/* Find the run-time address in the shared object HANDLE refers to</Line>
  <Line number="63">   of the symbol called NAME.  */</Line>
  <Line number="64">extern void *dlsym (void *__restrict __handle,</Line>
  <Line number="65">		    const char *__restrict __name) __THROW __nonnull ((2));</Line>
  <Line number="66"></Line>
  <Line number="67">#ifdef __USE_GNU</Line>
  <Line number="68">/* Like `dlopen&apos;, but request object to be allocated in a new namespace.  */</Line>
  <Line number="69">extern void *dlmopen (Lmid_t __nsid, const char *__file, int __mode) __THROWNL;</Line>
  <Line number="70"></Line>
  <Line number="71">/* Find the run-time address in the shared object HANDLE refers to</Line>
  <Line number="72">   of the symbol called NAME with VERSION.  */</Line>
  <Line number="73">extern void *dlvsym (void *__restrict __handle,</Line>
  <Line number="74">		     const char *__restrict __name,</Line>
  <Line number="75">		     const char *__restrict __version)</Line>
  <Line number="76">     __THROW __nonnull ((2, 3));</Line>
  <Line number="77">#endif</Line>
  <Line number="78"></Line>
  <Line number="79">/* When any of the above functions fails, call this function</Line>
  <Line number="80">   to return a string describing the error.  Each call resets</Line>
  <Line number="81">   the error string so that a following call returns null.  */</Line>
  <Line number="82">extern char *dlerror (void) __THROW;</Line>
  <Line number="83"></Line>
  <Line number="84"></Line>
  <Line number="85">#ifdef __USE_GNU</Line>
  <Line number="86">/* Structure containing information about object searched using</Line>
  <Line number="87">   `dladdr&apos;.  */</Line>
  <Line number="88">typedef struct</Line>
  <Line number="89">{</Line>
  <Line number="90">  const char *dli_fname;	/* File name of defining object.  */</Line>
  <Line number="91">  void *dli_fbase;		/* Load address of that object.  */</Line>
  <Line number="92">  const char *dli_sname;	/* Name of nearest symbol.  */</Line>
  <Line number="93">  void *dli_saddr;		/* Exact value of nearest symbol.  */</Line>
  <Line number="94">} Dl_info;</Line>
  <Line number="95"></Line>
  <Line number="96">/* Fill in *INFO with the following information about ADDRESS.</Line>
  <Line number="97">   Returns 0 iff no shared object&apos;s segments contain that address.  */</Line>
  <Line number="98">extern int dladdr (const void *__address, Dl_info *__info)</Line>
  <Line number="99">     __THROW __nonnull ((2));</Line>
  <Line number="100"></Line>
  <Line number="101">/* Same as `dladdr&apos;, but additionally sets *EXTRA_INFO according to FLAGS.  */</Line>
  <Line number="102">extern int dladdr1 (const void *__address, Dl_info *__info,</Line>
  <Line number="103">		    void **__extra_info, int __flags) __THROW __nonnull ((2));</Line>
  <Line number="104"></Line>
  <Line number="105">/* These are the possible values for the FLAGS argument to `dladdr1&apos;.</Line>
  <Line number="106">   This indicates what extra information is stored at *EXTRA_INFO.</Line>
  <Line number="107">   It may also be zero, in which case the EXTRA_INFO argument is not used.  */</Line>
  <Line number="108">enum</Line>
  <Line number="109">  {</Line>
  <Line number="110">    /* Matching symbol table entry (const ElfNN_Sym *).  */</Line>
  <Line number="111">    RTLD_DL_SYMENT = 1,</Line>
  <Line number="112"></Line>
  <Line number="113">    /* The object containing the address (struct link_map *).  */</Line>
  <Line number="114">    RTLD_DL_LINKMAP = 2</Line>
  <Line number="115">  };</Line>
  <Line number="116"></Line>
  <Line number="117"></Line>
  <Line number="118">/* Get information about the shared object HANDLE refers to.</Line>
  <Line number="119">   REQUEST is from among the values below, and determines the use of ARG.</Line>
  <Line number="120"></Line>
  <Line number="121">   On success, returns zero.  On failure, returns -1 and records an error</Line>
  <Line number="122">   message to be fetched with `dlerror&apos;.  */</Line>
  <Line number="123">extern int dlinfo (void *__restrict __handle,</Line>
  <Line number="124">		   int __request, void *__restrict __arg)</Line>
  <Line number="125">     __THROW __nonnull ((1, 3));</Line>
  <Line number="126"></Line>
  <Line number="127">/* These are the possible values for the REQUEST argument to `dlinfo&apos;.  */</Line>
  <Line number="128">enum</Line>
  <Line number="129">  {</Line>
  <Line number="130">    /* Treat ARG as `lmid_t *&apos;; store namespace ID for HANDLE there.  */</Line>
  <Line number="131">    RTLD_DI_LMID = 1,</Line>
  <Line number="132"></Line>
  <Line number="133">    /* Treat ARG as `struct link_map **&apos;;</Line>
  <Line number="134">       store the `struct link_map *&apos; for HANDLE there.  */</Line>
  <Line number="135">    RTLD_DI_LINKMAP = 2,</Line>
  <Line number="136"></Line>
  <Line number="137">    RTLD_DI_CONFIGADDR = 3,	/* Unsupported, defined by Solaris.  */</Line>
  <Line number="138"></Line>
  <Line number="139">    /* Treat ARG as `Dl_serinfo *&apos; (see below), and fill in to describe the</Line>
  <Line number="140">       directories that will be searched for dependencies of this object.</Line>
  <Line number="141">       RTLD_DI_SERINFOSIZE fills in just the `dls_cnt&apos; and `dls_size&apos;</Line>
  <Line number="142">       entries to indicate the size of the buffer that must be passed to</Line>
  <Line number="143">       RTLD_DI_SERINFO to fill in the full information.  */</Line>
  <Line number="144">    RTLD_DI_SERINFO = 4,</Line>
  <Line number="145">    RTLD_DI_SERINFOSIZE = 5,</Line>
  <Line number="146"></Line>
  <Line number="147">    /* Treat ARG as `char *&apos;, and store there the directory name used to</Line>
  <Line number="148">       expand $ORIGIN in this shared object&apos;s dependency file names.  */</Line>
  <Line number="149">    RTLD_DI_ORIGIN = 6,</Line>
  <Line number="150"></Line>
  <Line number="151">    RTLD_DI_PROFILENAME = 7,	/* Unsupported, defined by Solaris.  */</Line>
  <Line number="152">    RTLD_DI_PROFILEOUT = 8,	/* Unsupported, defined by Solaris.  */</Line>
  <Line number="153"></Line>
  <Line number="154">    /* Treat ARG as `size_t *&apos;, and store there the TLS module ID</Line>
  <Line number="155">       of this object&apos;s PT_TLS segment, as used in TLS relocations;</Line>
  <Line number="156">       store zero if this object does not define a PT_TLS segment.  */</Line>
  <Line number="157">    RTLD_DI_TLS_MODID = 9,</Line>
  <Line number="158"></Line>
  <Line number="159">    /* Treat ARG as `void **&apos;, and store there a pointer to the calling</Line>
  <Line number="160">       thread&apos;s TLS block corresponding to this object&apos;s PT_TLS segment.</Line>
  <Line number="161">       Store a null pointer if this object does not define a PT_TLS</Line>
  <Line number="162">       segment, or if the calling thread has not allocated a block for it.  */</Line>
  <Line number="163">    RTLD_DI_TLS_DATA = 10,</Line>
  <Line number="164"></Line>
  <Line number="165">    RTLD_DI_MAX = 10</Line>
  <Line number="166">  };</Line>
  <Line number="167"></Line>
  <Line number="168"></Line>
  <Line number="169">/* This is the type of elements in `Dl_serinfo&apos;, below.</Line>
  <Line number="170">   The `dls_name&apos; member points to space in the buffer passed to `dlinfo&apos;.  */</Line>
  <Line number="171">typedef struct</Line>
  <Line number="172">{</Line>
  <Line number="173">  char *dls_name;		/* Name of library search path directory.  */</Line>
  <Line number="174">  unsigned int dls_flags;	/* Indicates where this directory came from. */</Line>
  <Line number="175">} Dl_serpath;</Line>
  <Line number="176"></Line>
  <Line number="177">/* This is the structure that must be passed (by reference) to `dlinfo&apos; for</Line>
  <Line number="178">   the RTLD_DI_SERINFO and RTLD_DI_SERINFOSIZE requests.  */</Line>
  <Line number="179">typedef struct</Line>
  <Line number="180">{</Line>
  <Line number="181">  size_t dls_size;		/* Size in bytes of the whole buffer.  */</Line>
  <Line number="182">  unsigned int dls_cnt;		/* Number of elements in `dls_serpath&apos;.  */</Line>
  <Line number="183"># if __GNUC_PREREQ (3, 0)</Line>
  <Line number="184">  /* The zero-length array avoids an unwanted array subscript check by</Line>
  <Line number="185">     the compiler, while the surrounding anonymous union preserves the</Line>
  <Line number="186">     historic size of the type.  At the time of writing, GNU C does</Line>
  <Line number="187">     not support structs with flexible array members in unions.  */</Line>
  <Line number="188">  __extension__ union</Line>
  <Line number="189">  {</Line>
  <Line number="190">    Dl_serpath dls_serpath[0]; /* Actually longer, dls_cnt elements.  */</Line>
  <Line number="191">    Dl_serpath __dls_serpath_pad[1];</Line>
  <Line number="192">  };</Line>
  <Line number="193"># else</Line>
  <Line number="194">  Dl_serpath dls_serpath[1];	/* Actually longer, dls_cnt elements.  */</Line>
  <Line number="195"># endif</Line>
  <Line number="196">} Dl_serinfo;</Line>
  <Line number="197">#endif /* __USE_GNU */</Line>
  <Line number="198"></Line>
  <Line number="199"></Line>
  <Line number="200">__END_DECLS</Line>
  <Line number="201"></Line>
  <Line number="202">#endif	/* dlfcn.h */</Line>
</SourceFile>
