<SourceFile>
  <Line number="1">/* Definitions for BSD-style memory management.</Line>
  <Line number="2">   Copyright (C) 1994-2020 Free Software Foundation, Inc.</Line>
  <Line number="3">   This file is part of the GNU C Library.</Line>
  <Line number="4"></Line>
  <Line number="5">   The GNU C Library is free software; you can redistribute it and/or</Line>
  <Line number="6">   modify it under the terms of the GNU Lesser General Public</Line>
  <Line number="7">   License as published by the Free Software Foundation; either</Line>
  <Line number="8">   version 2.1 of the License, or (at your option) any later version.</Line>
  <Line number="9"></Line>
  <Line number="10">   The GNU C Library is distributed in the hope that it will be useful,</Line>
  <Line number="11">   but WITHOUT ANY WARRANTY; without even the implied warranty of</Line>
  <Line number="12">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</Line>
  <Line number="13">   Lesser General Public License for more details.</Line>
  <Line number="14"></Line>
  <Line number="15">   You should have received a copy of the GNU Lesser General Public</Line>
  <Line number="16">   License along with the GNU C Library; if not, see</Line>
  <Line number="17">   &lt;https://www.gnu.org/licenses/&gt;.  */</Line>
  <Line number="18"></Line>
  <Line number="19">#ifndef	_SYS_MMAN_H</Line>
  <Line number="20">#define	_SYS_MMAN_H	1</Line>
  <Line number="21"></Line>
  <Line number="22">#include &lt;features.h&gt;</Line>
  <Line number="23">#include &lt;bits/types.h&gt;</Line>
  <Line number="24">#define __need_size_t</Line>
  <Line number="25">#include &lt;stddef.h&gt;</Line>
  <Line number="26"></Line>
  <Line number="27">#ifndef __off_t_defined</Line>
  <Line number="28"># ifndef __USE_FILE_OFFSET64</Line>
  <Line number="29">typedef __off_t off_t;</Line>
  <Line number="30"># else</Line>
  <Line number="31">typedef __off64_t off_t;</Line>
  <Line number="32"># endif</Line>
  <Line number="33"># define __off_t_defined</Line>
  <Line number="34">#endif</Line>
  <Line number="35"></Line>
  <Line number="36">#ifndef __mode_t_defined</Line>
  <Line number="37">typedef __mode_t mode_t;</Line>
  <Line number="38"># define __mode_t_defined</Line>
  <Line number="39">#endif</Line>
  <Line number="40"></Line>
  <Line number="41">#include &lt;bits/mman.h&gt;</Line>
  <Line number="42"></Line>
  <Line number="43">/* Return value of `mmap&apos; in case of an error.  */</Line>
  <Line number="44">#define MAP_FAILED	((void *) -1)</Line>
  <Line number="45"></Line>
  <Line number="46">__BEGIN_DECLS</Line>
  <Line number="47">/* Map addresses starting near ADDR and extending for LEN bytes.  from</Line>
  <Line number="48">   OFFSET into the file FD describes according to PROT and FLAGS.  If ADDR</Line>
  <Line number="49">   is nonzero, it is the desired mapping address.  If the MAP_FIXED bit is</Line>
  <Line number="50">   set in FLAGS, the mapping will be at ADDR exactly (which must be</Line>
  <Line number="51">   page-aligned); otherwise the system chooses a convenient nearby address.</Line>
  <Line number="52">   The return value is the actual mapping address chosen or MAP_FAILED</Line>
  <Line number="53">   for errors (in which case `errno&apos; is set).  A successful `mmap&apos; call</Line>
  <Line number="54">   deallocates any previous mapping for the affected region.  */</Line>
  <Line number="55"></Line>
  <Line number="56">#ifndef __USE_FILE_OFFSET64</Line>
  <Line number="57">extern void *mmap (void *__addr, size_t __len, int __prot,</Line>
  <Line number="58">		   int __flags, int __fd, __off_t __offset) __THROW;</Line>
  <Line number="59">#else</Line>
  <Line number="60"># ifdef __REDIRECT_NTH</Line>
  <Line number="61">extern void * __REDIRECT_NTH (mmap,</Line>
  <Line number="62">			      (void *__addr, size_t __len, int __prot,</Line>
  <Line number="63">			       int __flags, int __fd, __off64_t __offset),</Line>
  <Line number="64">			      mmap64);</Line>
  <Line number="65"># else</Line>
  <Line number="66">#  define mmap mmap64</Line>
  <Line number="67"># endif</Line>
  <Line number="68">#endif</Line>
  <Line number="69">#ifdef __USE_LARGEFILE64</Line>
  <Line number="70">extern void *mmap64 (void *__addr, size_t __len, int __prot,</Line>
  <Line number="71">		     int __flags, int __fd, __off64_t __offset) __THROW;</Line>
  <Line number="72">#endif</Line>
  <Line number="73"></Line>
  <Line number="74">/* Deallocate any mapping for the region starting at ADDR and extending LEN</Line>
  <Line number="75">   bytes.  Returns 0 if successful, -1 for errors (and sets errno).  */</Line>
  <Line number="76">extern int munmap (void *__addr, size_t __len) __THROW;</Line>
  <Line number="77"></Line>
  <Line number="78">/* Change the memory protection of the region starting at ADDR and</Line>
  <Line number="79">   extending LEN bytes to PROT.  Returns 0 if successful, -1 for errors</Line>
  <Line number="80">   (and sets errno).  */</Line>
  <Line number="81">extern int mprotect (void *__addr, size_t __len, int __prot) __THROW;</Line>
  <Line number="82"></Line>
  <Line number="83">/* Synchronize the region starting at ADDR and extending LEN bytes with the</Line>
  <Line number="84">   file it maps.  Filesystem operations on a file being mapped are</Line>
  <Line number="85">   unpredictable before this is done.  Flags are from the MS_* set.</Line>
  <Line number="86"></Line>
  <Line number="87">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="88">   __THROW.  */</Line>
  <Line number="89">extern int msync (void *__addr, size_t __len, int __flags);</Line>
  <Line number="90"></Line>
  <Line number="91">#ifdef __USE_MISC</Line>
  <Line number="92">/* Advise the system about particular usage patterns the program follows</Line>
  <Line number="93">   for the region starting at ADDR and extending LEN bytes.  */</Line>
  <Line number="94">extern int madvise (void *__addr, size_t __len, int __advice) __THROW;</Line>
  <Line number="95">#endif</Line>
  <Line number="96">#ifdef __USE_XOPEN2K</Line>
  <Line number="97">/* This is the POSIX name for this function.  */</Line>
  <Line number="98">extern int posix_madvise (void *__addr, size_t __len, int __advice) __THROW;</Line>
  <Line number="99">#endif</Line>
  <Line number="100"></Line>
  <Line number="101">/* Guarantee all whole pages mapped by the range [ADDR,ADDR+LEN) to</Line>
  <Line number="102">   be memory resident.  */</Line>
  <Line number="103">extern int mlock (const void *__addr, size_t __len) __THROW;</Line>
  <Line number="104"></Line>
  <Line number="105">/* Unlock whole pages previously mapped by the range [ADDR,ADDR+LEN).  */</Line>
  <Line number="106">extern int munlock (const void *__addr, size_t __len) __THROW;</Line>
  <Line number="107"></Line>
  <Line number="108">/* Cause all currently mapped pages of the process to be memory resident</Line>
  <Line number="109">   until unlocked by a call to the `munlockall&apos;, until the process exits,</Line>
  <Line number="110">   or until the process calls `execve&apos;.  */</Line>
  <Line number="111">extern int mlockall (int __flags) __THROW;</Line>
  <Line number="112"></Line>
  <Line number="113">/* All currently mapped pages of the process&apos; address space become</Line>
  <Line number="114">   unlocked.  */</Line>
  <Line number="115">extern int munlockall (void) __THROW;</Line>
  <Line number="116"></Line>
  <Line number="117">#ifdef __USE_MISC</Line>
  <Line number="118">/* mincore returns the memory residency status of the pages in the</Line>
  <Line number="119">   current process&apos;s address space specified by [start, start + len).</Line>
  <Line number="120">   The status is returned in a vector of bytes.  The least significant</Line>
  <Line number="121">   bit of each byte is 1 if the referenced page is in memory, otherwise</Line>
  <Line number="122">   it is zero.  */</Line>
  <Line number="123">extern int mincore (void *__start, size_t __len, unsigned char *__vec)</Line>
  <Line number="124">     __THROW;</Line>
  <Line number="125">#endif</Line>
  <Line number="126"></Line>
  <Line number="127">#ifdef __USE_GNU</Line>
  <Line number="128">/* Remap pages mapped by the range [ADDR,ADDR+OLD_LEN) to new length</Line>
  <Line number="129">   NEW_LEN.  If MREMAP_MAYMOVE is set in FLAGS the returned address</Line>
  <Line number="130">   may differ from ADDR.  If MREMAP_FIXED is set in FLAGS the function</Line>
  <Line number="131">   takes another parameter which is a fixed address at which the block</Line>
  <Line number="132">   resides after a successful call.  */</Line>
  <Line number="133">extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,</Line>
  <Line number="134">		     int __flags, ...) __THROW;</Line>
  <Line number="135"></Line>
  <Line number="136">/* Remap arbitrary pages of a shared backing store within an existing</Line>
  <Line number="137">   VMA.  */</Line>
  <Line number="138">extern int remap_file_pages (void *__start, size_t __size, int __prot,</Line>
  <Line number="139">			     size_t __pgoff, int __flags) __THROW;</Line>
  <Line number="140">#endif</Line>
  <Line number="141"></Line>
  <Line number="142"></Line>
  <Line number="143">/* Open shared memory segment.  */</Line>
  <Line number="144">extern int shm_open (const char *__name, int __oflag, mode_t __mode);</Line>
  <Line number="145"></Line>
  <Line number="146">/* Remove shared memory segment.  */</Line>
  <Line number="147">extern int shm_unlink (const char *__name);</Line>
  <Line number="148"></Line>
  <Line number="149">__END_DECLS</Line>
  <Line number="150"></Line>
  <Line number="151">#endif	/* sys/mman.h */</Line>
</SourceFile>
