<SourceFile>
  <Line number="1">/* Copyright (C) 1992-2020 Free Software Foundation, Inc.</Line>
  <Line number="2">   This file is part of the GNU C Library.</Line>
  <Line number="3"></Line>
  <Line number="4">   The GNU C Library is free software; you can redistribute it and/or</Line>
  <Line number="5">   modify it under the terms of the GNU Lesser General Public</Line>
  <Line number="6">   License as published by the Free Software Foundation; either</Line>
  <Line number="7">   version 2.1 of the License, or (at your option) any later version.</Line>
  <Line number="8"></Line>
  <Line number="9">   The GNU C Library is distributed in the hope that it will be useful,</Line>
  <Line number="10">   but WITHOUT ANY WARRANTY; without even the implied warranty of</Line>
  <Line number="11">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</Line>
  <Line number="12">   Lesser General Public License for more details.</Line>
  <Line number="13"></Line>
  <Line number="14">   You should have received a copy of the GNU Lesser General Public</Line>
  <Line number="15">   License along with the GNU C Library; if not, see</Line>
  <Line number="16">   &lt;https://www.gnu.org/licenses/&gt;.  */</Line>
  <Line number="17"></Line>
  <Line number="18">#ifndef	_SYS_CDEFS_H</Line>
  <Line number="19">#define	_SYS_CDEFS_H	1</Line>
  <Line number="20"></Line>
  <Line number="21">/* We are almost always included from features.h. */</Line>
  <Line number="22">#ifndef _FEATURES_H</Line>
  <Line number="23"># include &lt;features.h&gt;</Line>
  <Line number="24">#endif</Line>
  <Line number="25"></Line>
  <Line number="26">/* The GNU libc does not support any K&amp;R compilers or the traditional mode</Line>
  <Line number="27">   of ISO C compilers anymore.  Check for some of the combinations not</Line>
  <Line number="28">   anymore supported.  */</Line>
  <Line number="29">#if defined __GNUC__ &amp;&amp; !defined __STDC__</Line>
  <Line number="30"># error &quot;You need a ISO C conforming compiler to use the glibc headers&quot;</Line>
  <Line number="31">#endif</Line>
  <Line number="32"></Line>
  <Line number="33">/* Some user header file might have defined this before.  */</Line>
  <Line number="34">#undef	__P</Line>
  <Line number="35">#undef	__PMT</Line>
  <Line number="36"></Line>
  <Line number="37">#ifdef __GNUC__</Line>
  <Line number="38"></Line>
  <Line number="39">/* All functions, except those with callbacks or those that</Line>
  <Line number="40">   synchronize memory, are leaf functions.  */</Line>
  <Line number="41"># if __GNUC_PREREQ (4, 6) &amp;&amp; !defined _LIBC</Line>
  <Line number="42">#  define __LEAF , __leaf__</Line>
  <Line number="43">#  define __LEAF_ATTR __attribute__ ((__leaf__))</Line>
  <Line number="44"># else</Line>
  <Line number="45">#  define __LEAF</Line>
  <Line number="46">#  define __LEAF_ATTR</Line>
  <Line number="47"># endif</Line>
  <Line number="48"></Line>
  <Line number="49">/* GCC can always grok prototypes.  For C++ programs we add throw()</Line>
  <Line number="50">   to help it optimize the function calls.  But this works only with</Line>
  <Line number="51">   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions</Line>
  <Line number="52">   as non-throwing using a function attribute since programs can use</Line>
  <Line number="53">   the -fexceptions options for C code as well.  */</Line>
  <Line number="54"># if !defined __cplusplus &amp;&amp; __GNUC_PREREQ (3, 3)</Line>
  <Line number="55">#  define __THROW	__attribute__ ((__nothrow__ __LEAF))</Line>
  <Line number="56">#  define __THROWNL	__attribute__ ((__nothrow__))</Line>
  <Line number="57">#  define __NTH(fct)	__attribute__ ((__nothrow__ __LEAF)) fct</Line>
  <Line number="58">#  define __NTHNL(fct)  __attribute__ ((__nothrow__)) fct</Line>
  <Line number="59"># else</Line>
  <Line number="60">#  if defined __cplusplus &amp;&amp; __GNUC_PREREQ (2,8)</Line>
  <Line number="61">#   define __THROW	throw ()</Line>
  <Line number="62">#   define __THROWNL	throw ()</Line>
  <Line number="63">#   define __NTH(fct)	__LEAF_ATTR fct throw ()</Line>
  <Line number="64">#   define __NTHNL(fct) fct throw ()</Line>
  <Line number="65">#  else</Line>
  <Line number="66">#   define __THROW</Line>
  <Line number="67">#   define __THROWNL</Line>
  <Line number="68">#   define __NTH(fct)	fct</Line>
  <Line number="69">#   define __NTHNL(fct) fct</Line>
  <Line number="70">#  endif</Line>
  <Line number="71"># endif</Line>
  <Line number="72"></Line>
  <Line number="73">#else	/* Not GCC.  */</Line>
  <Line number="74"></Line>
  <Line number="75"># if (defined __cplusplus						\</Line>
  <Line number="76">      || (defined __STDC_VERSION__ &amp;&amp; __STDC_VERSION__ &gt;= 199901L))</Line>
  <Line number="77">#  define __inline	inline</Line>
  <Line number="78"># else</Line>
  <Line number="79">#  define __inline		/* No inline functions.  */</Line>
  <Line number="80"># endif</Line>
  <Line number="81"></Line>
  <Line number="82"># define __THROW</Line>
  <Line number="83"># define __THROWNL</Line>
  <Line number="84"># define __NTH(fct)	fct</Line>
  <Line number="85"></Line>
  <Line number="86">#endif	/* GCC.  */</Line>
  <Line number="87"></Line>
  <Line number="88">/* Compilers that are not clang may object to</Line>
  <Line number="89">       #if defined __clang__ &amp;&amp; __has_extension(...)</Line>
  <Line number="90">   even though they do not need to evaluate the right-hand side of the &amp;&amp;.  */</Line>
  <Line number="91">#if defined __clang__ &amp;&amp; defined __has_extension</Line>
  <Line number="92"># define __glibc_clang_has_extension(ext) __has_extension (ext)</Line>
  <Line number="93">#else</Line>
  <Line number="94"># define __glibc_clang_has_extension(ext) 0</Line>
  <Line number="95">#endif</Line>
  <Line number="96"></Line>
  <Line number="97">/* These two macros are not used in glibc anymore.  They are kept here</Line>
  <Line number="98">   only because some other projects expect the macros to be defined.  */</Line>
  <Line number="99">#define __P(args)	args</Line>
  <Line number="100">#define __PMT(args)	args</Line>
  <Line number="101"></Line>
  <Line number="102">/* For these things, GCC behaves the ANSI way normally,</Line>
  <Line number="103">   and the non-ANSI way under -traditional.  */</Line>
  <Line number="104"></Line>
  <Line number="105">#define __CONCAT(x,y)	x ## y</Line>
  <Line number="106">#define __STRING(x)	#x</Line>
  <Line number="107"></Line>
  <Line number="108">/* This is not a typedef so `const __ptr_t&apos; does the right thing.  */</Line>
  <Line number="109">#define __ptr_t void *</Line>
  <Line number="110"></Line>
  <Line number="111"></Line>
  <Line number="112">/* C++ needs to know that types and declarations are C, not C++.  */</Line>
  <Line number="113">#ifdef	__cplusplus</Line>
  <Line number="114"># define __BEGIN_DECLS	extern &quot;C&quot; {</Line>
  <Line number="115"># define __END_DECLS	}</Line>
  <Line number="116">#else</Line>
  <Line number="117"># define __BEGIN_DECLS</Line>
  <Line number="118"># define __END_DECLS</Line>
  <Line number="119">#endif</Line>
  <Line number="120"></Line>
  <Line number="121"></Line>
  <Line number="122">/* Fortify support.  */</Line>
  <Line number="123">#define __bos(ptr) __builtin_object_size (ptr, __USE_FORTIFY_LEVEL &gt; 1)</Line>
  <Line number="124">#define __bos0(ptr) __builtin_object_size (ptr, 0)</Line>
  <Line number="125"></Line>
  <Line number="126">#if __GNUC_PREREQ (4,3)</Line>
  <Line number="127"># define __warndecl(name, msg) \</Line>
  <Line number="128">  extern void name (void) __attribute__((__warning__ (msg)))</Line>
  <Line number="129"># define __warnattr(msg) __attribute__((__warning__ (msg)))</Line>
  <Line number="130"># define __errordecl(name, msg) \</Line>
  <Line number="131">  extern void name (void) __attribute__((__error__ (msg)))</Line>
  <Line number="132">#else</Line>
  <Line number="133"># define __warndecl(name, msg) extern void name (void)</Line>
  <Line number="134"># define __warnattr(msg)</Line>
  <Line number="135"># define __errordecl(name, msg) extern void name (void)</Line>
  <Line number="136">#endif</Line>
  <Line number="137"></Line>
  <Line number="138">/* Support for flexible arrays.</Line>
  <Line number="139">   Headers that should use flexible arrays only if they&apos;re &quot;real&quot;</Line>
  <Line number="140">   (e.g. only if they won&apos;t affect sizeof()) should test</Line>
  <Line number="141">   #if __glibc_c99_flexarr_available.  */</Line>
  <Line number="142">#if defined __STDC_VERSION__ &amp;&amp; __STDC_VERSION__ &gt;= 199901L</Line>
  <Line number="143"># define __flexarr	[]</Line>
  <Line number="144"># define __glibc_c99_flexarr_available 1</Line>
  <Line number="145">#elif __GNUC_PREREQ (2,97)</Line>
  <Line number="146">/* GCC 2.97 supports C99 flexible array members as an extension,</Line>
  <Line number="147">   even when in C89 mode or compiling C++ (any version).  */</Line>
  <Line number="148"># define __flexarr	[]</Line>
  <Line number="149"># define __glibc_c99_flexarr_available 1</Line>
  <Line number="150">#elif defined __GNUC__</Line>
  <Line number="151">/* Pre-2.97 GCC did not support C99 flexible arrays but did have</Line>
  <Line number="152">   an equivalent extension with slightly different notation.  */</Line>
  <Line number="153"># define __flexarr	[0]</Line>
  <Line number="154"># define __glibc_c99_flexarr_available 1</Line>
  <Line number="155">#else</Line>
  <Line number="156">/* Some other non-C99 compiler.  Approximate with [1].  */</Line>
  <Line number="157"># define __flexarr	[1]</Line>
  <Line number="158"># define __glibc_c99_flexarr_available 0</Line>
  <Line number="159">#endif</Line>
  <Line number="160"></Line>
  <Line number="161"></Line>
  <Line number="162">/* __asm__ (&quot;xyz&quot;) is used throughout the headers to rename functions</Line>
  <Line number="163">   at the assembly language level.  This is wrapped by the __REDIRECT</Line>
  <Line number="164">   macro, in order to support compilers that can do this some other</Line>
  <Line number="165">   way.  When compilers don&apos;t support asm-names at all, we have to do</Line>
  <Line number="166">   preprocessor tricks instead (which don&apos;t have exactly the right</Line>
  <Line number="167">   semantics, but it&apos;s the best we can do).</Line>
  <Line number="168"></Line>
  <Line number="169">   Example:</Line>
  <Line number="170">   int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); */</Line>
  <Line number="171"></Line>
  <Line number="172">#if defined __GNUC__ &amp;&amp; __GNUC__ &gt;= 2</Line>
  <Line number="173"></Line>
  <Line number="174"># define __REDIRECT(name, proto, alias) name proto __asm__ (__ASMNAME (#alias))</Line>
  <Line number="175"># ifdef __cplusplus</Line>
  <Line number="176">#  define __REDIRECT_NTH(name, proto, alias) \</Line>
  <Line number="177">     name proto __THROW __asm__ (__ASMNAME (#alias))</Line>
  <Line number="178">#  define __REDIRECT_NTHNL(name, proto, alias) \</Line>
  <Line number="179">     name proto __THROWNL __asm__ (__ASMNAME (#alias))</Line>
  <Line number="180"># else</Line>
  <Line number="181">#  define __REDIRECT_NTH(name, proto, alias) \</Line>
  <Line number="182">     name proto __asm__ (__ASMNAME (#alias)) __THROW</Line>
  <Line number="183">#  define __REDIRECT_NTHNL(name, proto, alias) \</Line>
  <Line number="184">     name proto __asm__ (__ASMNAME (#alias)) __THROWNL</Line>
  <Line number="185"># endif</Line>
  <Line number="186"># define __ASMNAME(cname)  __ASMNAME2 (__USER_LABEL_PREFIX__, cname)</Line>
  <Line number="187"># define __ASMNAME2(prefix, cname) __STRING (prefix) cname</Line>
  <Line number="188"></Line>
  <Line number="189">/*</Line>
  <Line number="190">#elif __SOME_OTHER_COMPILER__</Line>
  <Line number="191"></Line>
  <Line number="192"># define __REDIRECT(name, proto, alias) name proto; \</Line>
  <Line number="193">	_Pragma(&quot;let &quot; #name &quot; = &quot; #alias)</Line>
  <Line number="194">*/</Line>
  <Line number="195">#endif</Line>
  <Line number="196"></Line>
  <Line number="197">/* GCC has various useful declarations that can be made with the</Line>
  <Line number="198">   `__attribute__&apos; syntax.  All of the ways we use this do fine if</Line>
  <Line number="199">   they are omitted for compilers that don&apos;t understand it. */</Line>
  <Line number="200">#if !defined __GNUC__ || __GNUC__ &lt; 2</Line>
  <Line number="201"># define __attribute__(xyz)	/* Ignore */</Line>
  <Line number="202">#endif</Line>
  <Line number="203"></Line>
  <Line number="204">/* At some point during the gcc 2.96 development the `malloc&apos; attribute</Line>
  <Line number="205">   for functions was introduced.  We don&apos;t want to use it unconditionally</Line>
  <Line number="206">   (although this would be possible) since it generates warnings.  */</Line>
  <Line number="207">#if __GNUC_PREREQ (2,96)</Line>
  <Line number="208"># define __attribute_malloc__ __attribute__ ((__malloc__))</Line>
  <Line number="209">#else</Line>
  <Line number="210"># define __attribute_malloc__ /* Ignore */</Line>
  <Line number="211">#endif</Line>
  <Line number="212"></Line>
  <Line number="213">/* Tell the compiler which arguments to an allocation function</Line>
  <Line number="214">   indicate the size of the allocation.  */</Line>
  <Line number="215">#if __GNUC_PREREQ (4, 3)</Line>
  <Line number="216"># define __attribute_alloc_size__(params) \</Line>
  <Line number="217">  __attribute__ ((__alloc_size__ params))</Line>
  <Line number="218">#else</Line>
  <Line number="219"># define __attribute_alloc_size__(params) /* Ignore.  */</Line>
  <Line number="220">#endif</Line>
  <Line number="221"></Line>
  <Line number="222">/* At some point during the gcc 2.96 development the `pure&apos; attribute</Line>
  <Line number="223">   for functions was introduced.  We don&apos;t want to use it unconditionally</Line>
  <Line number="224">   (although this would be possible) since it generates warnings.  */</Line>
  <Line number="225">#if __GNUC_PREREQ (2,96)</Line>
  <Line number="226"># define __attribute_pure__ __attribute__ ((__pure__))</Line>
  <Line number="227">#else</Line>
  <Line number="228"># define __attribute_pure__ /* Ignore */</Line>
  <Line number="229">#endif</Line>
  <Line number="230"></Line>
  <Line number="231">/* This declaration tells the compiler that the value is constant.  */</Line>
  <Line number="232">#if __GNUC_PREREQ (2,5)</Line>
  <Line number="233"># define __attribute_const__ __attribute__ ((__const__))</Line>
  <Line number="234">#else</Line>
  <Line number="235"># define __attribute_const__ /* Ignore */</Line>
  <Line number="236">#endif</Line>
  <Line number="237"></Line>
  <Line number="238">/* At some point during the gcc 3.1 development the `used&apos; attribute</Line>
  <Line number="239">   for functions was introduced.  We don&apos;t want to use it unconditionally</Line>
  <Line number="240">   (although this would be possible) since it generates warnings.  */</Line>
  <Line number="241">#if __GNUC_PREREQ (3,1)</Line>
  <Line number="242"># define __attribute_used__ __attribute__ ((__used__))</Line>
  <Line number="243"># define __attribute_noinline__ __attribute__ ((__noinline__))</Line>
  <Line number="244">#else</Line>
  <Line number="245"># define __attribute_used__ __attribute__ ((__unused__))</Line>
  <Line number="246"># define __attribute_noinline__ /* Ignore */</Line>
  <Line number="247">#endif</Line>
  <Line number="248"></Line>
  <Line number="249">/* Since version 3.2, gcc allows marking deprecated functions.  */</Line>
  <Line number="250">#if __GNUC_PREREQ (3,2)</Line>
  <Line number="251"># define __attribute_deprecated__ __attribute__ ((__deprecated__))</Line>
  <Line number="252">#else</Line>
  <Line number="253"># define __attribute_deprecated__ /* Ignore */</Line>
  <Line number="254">#endif</Line>
  <Line number="255"></Line>
  <Line number="256">/* Since version 4.5, gcc also allows one to specify the message printed</Line>
  <Line number="257">   when a deprecated function is used.  clang claims to be gcc 4.2, but</Line>
  <Line number="258">   may also support this feature.  */</Line>
  <Line number="259">#if __GNUC_PREREQ (4,5) \</Line>
  <Line number="260">    || __glibc_clang_has_extension (__attribute_deprecated_with_message__)</Line>
  <Line number="261"># define __attribute_deprecated_msg__(msg) \</Line>
  <Line number="262">	 __attribute__ ((__deprecated__ (msg)))</Line>
  <Line number="263">#else</Line>
  <Line number="264"># define __attribute_deprecated_msg__(msg) __attribute_deprecated__</Line>
  <Line number="265">#endif</Line>
  <Line number="266"></Line>
  <Line number="267">/* At some point during the gcc 2.8 development the `format_arg&apos; attribute</Line>
  <Line number="268">   for functions was introduced.  We don&apos;t want to use it unconditionally</Line>
  <Line number="269">   (although this would be possible) since it generates warnings.</Line>
  <Line number="270">   If several `format_arg&apos; attributes are given for the same function, in</Line>
  <Line number="271">   gcc-3.0 and older, all but the last one are ignored.  In newer gccs,</Line>
  <Line number="272">   all designated arguments are considered.  */</Line>
  <Line number="273">#if __GNUC_PREREQ (2,8)</Line>
  <Line number="274"># define __attribute_format_arg__(x) __attribute__ ((__format_arg__ (x)))</Line>
  <Line number="275">#else</Line>
  <Line number="276"># define __attribute_format_arg__(x) /* Ignore */</Line>
  <Line number="277">#endif</Line>
  <Line number="278"></Line>
  <Line number="279">/* At some point during the gcc 2.97 development the `strfmon&apos; format</Line>
  <Line number="280">   attribute for functions was introduced.  We don&apos;t want to use it</Line>
  <Line number="281">   unconditionally (although this would be possible) since it</Line>
  <Line number="282">   generates warnings.  */</Line>
  <Line number="283">#if __GNUC_PREREQ (2,97)</Line>
  <Line number="284"># define __attribute_format_strfmon__(a,b) \</Line>
  <Line number="285">  __attribute__ ((__format__ (__strfmon__, a, b)))</Line>
  <Line number="286">#else</Line>
  <Line number="287"># define __attribute_format_strfmon__(a,b) /* Ignore */</Line>
  <Line number="288">#endif</Line>
  <Line number="289"></Line>
  <Line number="290">/* The nonull function attribute allows to mark pointer parameters which</Line>
  <Line number="291">   must not be NULL.  */</Line>
  <Line number="292">#if __GNUC_PREREQ (3,3)</Line>
  <Line number="293"># define __nonnull(params) __attribute__ ((__nonnull__ params))</Line>
  <Line number="294">#else</Line>
  <Line number="295"># define __nonnull(params)</Line>
  <Line number="296">#endif</Line>
  <Line number="297"></Line>
  <Line number="298">/* If fortification mode, we warn about unused results of certain</Line>
  <Line number="299">   function calls which can lead to problems.  */</Line>
  <Line number="300">#if __GNUC_PREREQ (3,4)</Line>
  <Line number="301"># define __attribute_warn_unused_result__ \</Line>
  <Line number="302">   __attribute__ ((__warn_unused_result__))</Line>
  <Line number="303"># if __USE_FORTIFY_LEVEL &gt; 0</Line>
  <Line number="304">#  define __wur __attribute_warn_unused_result__</Line>
  <Line number="305"># endif</Line>
  <Line number="306">#else</Line>
  <Line number="307"># define __attribute_warn_unused_result__ /* empty */</Line>
  <Line number="308">#endif</Line>
  <Line number="309">#ifndef __wur</Line>
  <Line number="310"># define __wur /* Ignore */</Line>
  <Line number="311">#endif</Line>
  <Line number="312"></Line>
  <Line number="313">/* Forces a function to be always inlined.  */</Line>
  <Line number="314">#if __GNUC_PREREQ (3,2)</Line>
  <Line number="315">/* The Linux kernel defines __always_inline in stddef.h (283d7573), and</Line>
  <Line number="316">   it conflicts with this definition.  Therefore undefine it first to</Line>
  <Line number="317">   allow either header to be included first.  */</Line>
  <Line number="318"># undef __always_inline</Line>
  <Line number="319"># define __always_inline __inline __attribute__ ((__always_inline__))</Line>
  <Line number="320">#else</Line>
  <Line number="321"># undef __always_inline</Line>
  <Line number="322"># define __always_inline __inline</Line>
  <Line number="323">#endif</Line>
  <Line number="324"></Line>
  <Line number="325">/* Associate error messages with the source location of the call site rather</Line>
  <Line number="326">   than with the source location inside the function.  */</Line>
  <Line number="327">#if __GNUC_PREREQ (4,3)</Line>
  <Line number="328"># define __attribute_artificial__ __attribute__ ((__artificial__))</Line>
  <Line number="329">#else</Line>
  <Line number="330"># define __attribute_artificial__ /* Ignore */</Line>
  <Line number="331">#endif</Line>
  <Line number="332"></Line>
  <Line number="333">/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99</Line>
  <Line number="334">   inline semantics, unless -fgnu89-inline is used.  Using __GNUC_STDC_INLINE__</Line>
  <Line number="335">   or __GNUC_GNU_INLINE is not a good enough check for gcc because gcc versions</Line>
  <Line number="336">   older than 4.3 may define these macros and still not guarantee GNU inlining</Line>
  <Line number="337">   semantics.</Line>
  <Line number="338"></Line>
  <Line number="339">   clang++ identifies itself as gcc-4.2, but has support for GNU inlining</Line>
  <Line number="340">   semantics, that can be checked for by using the __GNUC_STDC_INLINE_ and</Line>
  <Line number="341">   __GNUC_GNU_INLINE__ macro definitions.  */</Line>
  <Line number="342">#if (!defined __cplusplus || __GNUC_PREREQ (4,3) \</Line>
  <Line number="343">     || (defined __clang__ &amp;&amp; (defined __GNUC_STDC_INLINE__ \</Line>
  <Line number="344">			       || defined __GNUC_GNU_INLINE__)))</Line>
  <Line number="345"># if defined __GNUC_STDC_INLINE__ || defined __cplusplus</Line>
  <Line number="346">#  define __extern_inline extern __inline __attribute__ ((__gnu_inline__))</Line>
  <Line number="347">#  define __extern_always_inline \</Line>
  <Line number="348">  extern __always_inline __attribute__ ((__gnu_inline__))</Line>
  <Line number="349"># else</Line>
  <Line number="350">#  define __extern_inline extern __inline</Line>
  <Line number="351">#  define __extern_always_inline extern __always_inline</Line>
  <Line number="352"># endif</Line>
  <Line number="353">#endif</Line>
  <Line number="354"></Line>
  <Line number="355">#ifdef __extern_always_inline</Line>
  <Line number="356"># define __fortify_function __extern_always_inline __attribute_artificial__</Line>
  <Line number="357">#endif</Line>
  <Line number="358"></Line>
  <Line number="359">/* GCC 4.3 and above allow passing all anonymous arguments of an</Line>
  <Line number="360">   __extern_always_inline function to some other vararg function.  */</Line>
  <Line number="361">#if __GNUC_PREREQ (4,3)</Line>
  <Line number="362"># define __va_arg_pack() __builtin_va_arg_pack ()</Line>
  <Line number="363"># define __va_arg_pack_len() __builtin_va_arg_pack_len ()</Line>
  <Line number="364">#endif</Line>
  <Line number="365"></Line>
  <Line number="366">/* It is possible to compile containing GCC extensions even if GCC is</Line>
  <Line number="367">   run in pedantic mode if the uses are carefully marked using the</Line>
  <Line number="368">   `__extension__&apos; keyword.  But this is not generally available before</Line>
  <Line number="369">   version 2.8.  */</Line>
  <Line number="370">#if !__GNUC_PREREQ (2,8)</Line>
  <Line number="371"># define __extension__		/* Ignore */</Line>
  <Line number="372">#endif</Line>
  <Line number="373"></Line>
  <Line number="374">/* __restrict is known in EGCS 1.2 and above. */</Line>
  <Line number="375">#if !__GNUC_PREREQ (2,92)</Line>
  <Line number="376"># if defined __STDC_VERSION__ &amp;&amp; __STDC_VERSION__ &gt;= 199901L</Line>
  <Line number="377">#  define __restrict	restrict</Line>
  <Line number="378"># else</Line>
  <Line number="379">#  define __restrict	/* Ignore */</Line>
  <Line number="380"># endif</Line>
  <Line number="381">#endif</Line>
  <Line number="382"></Line>
  <Line number="383">/* ISO C99 also allows to declare arrays as non-overlapping.  The syntax is</Line>
  <Line number="384">     array_name[restrict]</Line>
  <Line number="385">   GCC 3.1 supports this.  */</Line>
  <Line number="386">#if __GNUC_PREREQ (3,1) &amp;&amp; !defined __GNUG__</Line>
  <Line number="387"># define __restrict_arr	__restrict</Line>
  <Line number="388">#else</Line>
  <Line number="389"># ifdef __GNUC__</Line>
  <Line number="390">#  define __restrict_arr	/* Not supported in old GCC.  */</Line>
  <Line number="391"># else</Line>
  <Line number="392">#  if defined __STDC_VERSION__ &amp;&amp; __STDC_VERSION__ &gt;= 199901L</Line>
  <Line number="393">#   define __restrict_arr	restrict</Line>
  <Line number="394">#  else</Line>
  <Line number="395">/* Some other non-C99 compiler.  */</Line>
  <Line number="396">#   define __restrict_arr	/* Not supported.  */</Line>
  <Line number="397">#  endif</Line>
  <Line number="398"># endif</Line>
  <Line number="399">#endif</Line>
  <Line number="400"></Line>
  <Line number="401">#if __GNUC__ &gt;= 3</Line>
  <Line number="402"># define __glibc_unlikely(cond)	__builtin_expect ((cond), 0)</Line>
  <Line number="403"># define __glibc_likely(cond)	__builtin_expect ((cond), 1)</Line>
  <Line number="404">#else</Line>
  <Line number="405"># define __glibc_unlikely(cond)	(cond)</Line>
  <Line number="406"># define __glibc_likely(cond)	(cond)</Line>
  <Line number="407">#endif</Line>
  <Line number="408"></Line>
  <Line number="409">#ifdef __has_attribute</Line>
  <Line number="410"># define __glibc_has_attribute(attr)	__has_attribute (attr)</Line>
  <Line number="411">#else</Line>
  <Line number="412"># define __glibc_has_attribute(attr)	0</Line>
  <Line number="413">#endif</Line>
  <Line number="414"></Line>
  <Line number="415">#if (!defined _Noreturn \</Line>
  <Line number="416">     &amp;&amp; (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0) &lt; 201112 \</Line>
  <Line number="417">     &amp;&amp;  !__GNUC_PREREQ (4,7))</Line>
  <Line number="418"># if __GNUC_PREREQ (2,8)</Line>
  <Line number="419">#  define _Noreturn __attribute__ ((__noreturn__))</Line>
  <Line number="420"># else</Line>
  <Line number="421">#  define _Noreturn</Line>
  <Line number="422"># endif</Line>
  <Line number="423">#endif</Line>
  <Line number="424"></Line>
  <Line number="425">#if __GNUC_PREREQ (8, 0)</Line>
  <Line number="426">/* Describes a char array whose address can safely be passed as the first</Line>
  <Line number="427">   argument to strncpy and strncat, as the char array is not necessarily</Line>
  <Line number="428">   a NUL-terminated string.  */</Line>
  <Line number="429"># define __attribute_nonstring__ __attribute__ ((__nonstring__))</Line>
  <Line number="430">#else</Line>
  <Line number="431"># define __attribute_nonstring__</Line>
  <Line number="432">#endif</Line>
  <Line number="433"></Line>
  <Line number="434">/* Undefine (also defined in libc-symbols.h).  */</Line>
  <Line number="435">#undef __attribute_copy__</Line>
  <Line number="436">#if __GNUC_PREREQ (9, 0)</Line>
  <Line number="437">/* Copies attributes from the declaration or type referenced by</Line>
  <Line number="438">   the argument.  */</Line>
  <Line number="439"># define __attribute_copy__(arg) __attribute__ ((__copy__ (arg)))</Line>
  <Line number="440">#else</Line>
  <Line number="441"># define __attribute_copy__(arg)</Line>
  <Line number="442">#endif</Line>
  <Line number="443"></Line>
  <Line number="444">#if (!defined _Static_assert &amp;&amp; !defined __cplusplus \</Line>
  <Line number="445">     &amp;&amp; (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0) &lt; 201112 \</Line>
  <Line number="446">     &amp;&amp; (!__GNUC_PREREQ (4, 6) || defined __STRICT_ANSI__))</Line>
  <Line number="447"># define _Static_assert(expr, diagnostic) \</Line>
  <Line number="448">    extern int (*__Static_assert_function (void)) \</Line>
  <Line number="449">      [!!sizeof (struct { int __error_if_negative: (expr) ? 2 : -1; })]</Line>
  <Line number="450">#endif</Line>
  <Line number="451"></Line>
  <Line number="452">#include &lt;bits/wordsize.h&gt;</Line>
  <Line number="453">#include &lt;bits/long-double.h&gt;</Line>
  <Line number="454"></Line>
  <Line number="455">#if defined __LONG_DOUBLE_MATH_OPTIONAL &amp;&amp; defined __NO_LONG_DOUBLE_MATH</Line>
  <Line number="456"># define __LDBL_COMPAT 1</Line>
  <Line number="457"># ifdef __REDIRECT</Line>
  <Line number="458">#  define __LDBL_REDIR1(name, proto, alias) __REDIRECT (name, proto, alias)</Line>
  <Line number="459">#  define __LDBL_REDIR(name, proto) \</Line>
  <Line number="460">  __LDBL_REDIR1 (name, proto, __nldbl_##name)</Line>
  <Line number="461">#  define __LDBL_REDIR1_NTH(name, proto, alias) __REDIRECT_NTH (name, proto, alias)</Line>
  <Line number="462">#  define __LDBL_REDIR_NTH(name, proto) \</Line>
  <Line number="463">  __LDBL_REDIR1_NTH (name, proto, __nldbl_##name)</Line>
  <Line number="464">#  define __LDBL_REDIR1_DECL(name, alias) \</Line>
  <Line number="465">  extern __typeof (name) name __asm (__ASMNAME (#alias));</Line>
  <Line number="466">#  define __LDBL_REDIR_DECL(name) \</Line>
  <Line number="467">  extern __typeof (name) name __asm (__ASMNAME (&quot;__nldbl_&quot; #name));</Line>
  <Line number="468">#  define __REDIRECT_LDBL(name, proto, alias) \</Line>
  <Line number="469">  __LDBL_REDIR1 (name, proto, __nldbl_##alias)</Line>
  <Line number="470">#  define __REDIRECT_NTH_LDBL(name, proto, alias) \</Line>
  <Line number="471">  __LDBL_REDIR1_NTH (name, proto, __nldbl_##alias)</Line>
  <Line number="472"># endif</Line>
  <Line number="473">#endif</Line>
  <Line number="474">#if !defined __LDBL_COMPAT || !defined __REDIRECT</Line>
  <Line number="475"># define __LDBL_REDIR1(name, proto, alias) name proto</Line>
  <Line number="476"># define __LDBL_REDIR(name, proto) name proto</Line>
  <Line number="477"># define __LDBL_REDIR1_NTH(name, proto, alias) name proto __THROW</Line>
  <Line number="478"># define __LDBL_REDIR_NTH(name, proto) name proto __THROW</Line>
  <Line number="479"># define __LDBL_REDIR_DECL(name)</Line>
  <Line number="480"># ifdef __REDIRECT</Line>
  <Line number="481">#  define __REDIRECT_LDBL(name, proto, alias) __REDIRECT (name, proto, alias)</Line>
  <Line number="482">#  define __REDIRECT_NTH_LDBL(name, proto, alias) \</Line>
  <Line number="483">  __REDIRECT_NTH (name, proto, alias)</Line>
  <Line number="484"># endif</Line>
  <Line number="485">#endif</Line>
  <Line number="486"></Line>
  <Line number="487">/* __glibc_macro_warning (MESSAGE) issues warning MESSAGE.  This is</Line>
  <Line number="488">   intended for use in preprocessor macros.</Line>
  <Line number="489"></Line>
  <Line number="490">   Note: MESSAGE must be a _single_ string; concatenation of string</Line>
  <Line number="491">   literals is not supported.  */</Line>
  <Line number="492">#if __GNUC_PREREQ (4,8) || __glibc_clang_prereq (3,5)</Line>
  <Line number="493"># define __glibc_macro_warning1(message) _Pragma (#message)</Line>
  <Line number="494"># define __glibc_macro_warning(message) \</Line>
  <Line number="495">  __glibc_macro_warning1 (GCC warning message)</Line>
  <Line number="496">#else</Line>
  <Line number="497"># define __glibc_macro_warning(msg)</Line>
  <Line number="498">#endif</Line>
  <Line number="499"></Line>
  <Line number="500">/* Generic selection (ISO C11) is a C-only feature, available in GCC</Line>
  <Line number="501">   since version 4.9.  Previous versions do not provide generic</Line>
  <Line number="502">   selection, even though they might set __STDC_VERSION__ to 201112L,</Line>
  <Line number="503">   when in -std=c11 mode.  Thus, we must check for !defined __GNUC__</Line>
  <Line number="504">   when testing __STDC_VERSION__ for generic selection support.</Line>
  <Line number="505">   On the other hand, Clang also defines __GNUC__, so a clang-specific</Line>
  <Line number="506">   check is required to enable the use of generic selection.  */</Line>
  <Line number="507">#if !defined __cplusplus \</Line>
  <Line number="508">    &amp;&amp; (__GNUC_PREREQ (4, 9) \</Line>
  <Line number="509">	|| __glibc_clang_has_extension (c_generic_selections) \</Line>
  <Line number="510">	|| (!defined __GNUC__ &amp;&amp; defined __STDC_VERSION__ \</Line>
  <Line number="511">	    &amp;&amp; __STDC_VERSION__ &gt;= 201112L))</Line>
  <Line number="512"># define __HAVE_GENERIC_SELECTION 1</Line>
  <Line number="513">#else</Line>
  <Line number="514"># define __HAVE_GENERIC_SELECTION 0</Line>
  <Line number="515">#endif</Line>
  <Line number="516"></Line>
  <Line number="517">#endif	 /* sys/cdefs.h */</Line>
</SourceFile>
