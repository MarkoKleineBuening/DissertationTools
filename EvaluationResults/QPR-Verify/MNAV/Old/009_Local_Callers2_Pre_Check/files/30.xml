<SourceFile>
  <Line number="1">/* Copyright (C) 2002-2020 Free Software Foundation, Inc.</Line>
  <Line number="2">   This file is part of the GNU C Library.</Line>
  <Line number="3"></Line>
  <Line number="4">   The GNU C Library is free software; you can redistribute it and/or</Line>
  <Line number="5">   modify it under the terms of the GNU Lesser General Public</Line>
  <Line number="6">   License as published by the Free Software Foundation; either</Line>
  <Line number="7">   version 2.1 of the License, or (at your option) any later version.</Line>
  <Line number="8"></Line>
  <Line number="9">   The GNU C Library is distributed in the hope that it will be useful,</Line>
  <Line number="10">   but WITHOUT ANY WARRANTY; without even the implied warranty of</Line>
  <Line number="11">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</Line>
  <Line number="12">   Lesser General Public License for more details.</Line>
  <Line number="13"></Line>
  <Line number="14">   You should have received a copy of the GNU Lesser General Public</Line>
  <Line number="15">   License along with the GNU C Library; if not, see</Line>
  <Line number="16">   &lt;https://www.gnu.org/licenses/&gt;.  */</Line>
  <Line number="17"></Line>
  <Line number="18">#ifndef _PTHREAD_H</Line>
  <Line number="19">#define _PTHREAD_H	1</Line>
  <Line number="20"></Line>
  <Line number="21">#include &lt;features.h&gt;</Line>
  <Line number="22">#include &lt;sched.h&gt;</Line>
  <Line number="23">#include &lt;time.h&gt;</Line>
  <Line number="24"></Line>
  <Line number="25">#include &lt;bits/endian.h&gt;</Line>
  <Line number="26">#include &lt;bits/pthreadtypes.h&gt;</Line>
  <Line number="27">#include &lt;bits/setjmp.h&gt;</Line>
  <Line number="28">#include &lt;bits/wordsize.h&gt;</Line>
  <Line number="29">#include &lt;bits/types/struct_timespec.h&gt;</Line>
  <Line number="30"></Line>
  <Line number="31"></Line>
  <Line number="32">/* Detach state.  */</Line>
  <Line number="33">enum</Line>
  <Line number="34">{</Line>
  <Line number="35">  PTHREAD_CREATE_JOINABLE,</Line>
  <Line number="36">#define PTHREAD_CREATE_JOINABLE	PTHREAD_CREATE_JOINABLE</Line>
  <Line number="37">  PTHREAD_CREATE_DETACHED</Line>
  <Line number="38">#define PTHREAD_CREATE_DETACHED	PTHREAD_CREATE_DETACHED</Line>
  <Line number="39">};</Line>
  <Line number="40"></Line>
  <Line number="41"></Line>
  <Line number="42">/* Mutex types.  */</Line>
  <Line number="43">enum</Line>
  <Line number="44">{</Line>
  <Line number="45">  PTHREAD_MUTEX_TIMED_NP,</Line>
  <Line number="46">  PTHREAD_MUTEX_RECURSIVE_NP,</Line>
  <Line number="47">  PTHREAD_MUTEX_ERRORCHECK_NP,</Line>
  <Line number="48">  PTHREAD_MUTEX_ADAPTIVE_NP</Line>
  <Line number="49">#if defined __USE_UNIX98 || defined __USE_XOPEN2K8</Line>
  <Line number="50">  ,</Line>
  <Line number="51">  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,</Line>
  <Line number="52">  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,</Line>
  <Line number="53">  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,</Line>
  <Line number="54">  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL</Line>
  <Line number="55">#endif</Line>
  <Line number="56">#ifdef __USE_GNU</Line>
  <Line number="57">  /* For compatibility.  */</Line>
  <Line number="58">  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP</Line>
  <Line number="59">#endif</Line>
  <Line number="60">};</Line>
  <Line number="61"></Line>
  <Line number="62"></Line>
  <Line number="63">#ifdef __USE_XOPEN2K</Line>
  <Line number="64">/* Robust mutex or not flags.  */</Line>
  <Line number="65">enum</Line>
  <Line number="66">{</Line>
  <Line number="67">  PTHREAD_MUTEX_STALLED,</Line>
  <Line number="68">  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,</Line>
  <Line number="69">  PTHREAD_MUTEX_ROBUST,</Line>
  <Line number="70">  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST</Line>
  <Line number="71">};</Line>
  <Line number="72">#endif</Line>
  <Line number="73"></Line>
  <Line number="74"></Line>
  <Line number="75">#if defined __USE_POSIX199506 || defined __USE_UNIX98</Line>
  <Line number="76">/* Mutex protocols.  */</Line>
  <Line number="77">enum</Line>
  <Line number="78">{</Line>
  <Line number="79">  PTHREAD_PRIO_NONE,</Line>
  <Line number="80">  PTHREAD_PRIO_INHERIT,</Line>
  <Line number="81">  PTHREAD_PRIO_PROTECT</Line>
  <Line number="82">};</Line>
  <Line number="83">#endif</Line>
  <Line number="84"></Line>
  <Line number="85"></Line>
  <Line number="86">#define PTHREAD_MUTEX_INITIALIZER \</Line>
  <Line number="87"> { {  __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_TIMED_NP) } }</Line>
  <Line number="88">#ifdef __USE_GNU</Line>
  <Line number="89"># define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP \</Line>
  <Line number="90"> { {  __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_RECURSIVE_NP) } }</Line>
  <Line number="91"># define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP \</Line>
  <Line number="92"> { {  __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_ERRORCHECK_NP) } }</Line>
  <Line number="93"># define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP \</Line>
  <Line number="94"> { {  __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_ADAPTIVE_NP) } }</Line>
  <Line number="95">#endif</Line>
  <Line number="96"></Line>
  <Line number="97"></Line>
  <Line number="98">/* Read-write lock types.  */</Line>
  <Line number="99">#if defined __USE_UNIX98 || defined __USE_XOPEN2K</Line>
  <Line number="100">enum</Line>
  <Line number="101">{</Line>
  <Line number="102">  PTHREAD_RWLOCK_PREFER_READER_NP,</Line>
  <Line number="103">  PTHREAD_RWLOCK_PREFER_WRITER_NP,</Line>
  <Line number="104">  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,</Line>
  <Line number="105">  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP</Line>
  <Line number="106">};</Line>
  <Line number="107"></Line>
  <Line number="108"></Line>
  <Line number="109">/* Read-write lock initializers.  */</Line>
  <Line number="110"># define PTHREAD_RWLOCK_INITIALIZER \</Line>
  <Line number="111">  { { __PTHREAD_RWLOCK_INITIALIZER (PTHREAD_RWLOCK_DEFAULT_NP) } }</Line>
  <Line number="112"># ifdef __USE_GNU</Line>
  <Line number="113">#  define PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP \</Line>
  <Line number="114">  { { __PTHREAD_RWLOCK_INITIALIZER (PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP) } }</Line>
  <Line number="115"># endif</Line>
  <Line number="116">#endif  /* Unix98 or XOpen2K */</Line>
  <Line number="117"></Line>
  <Line number="118"></Line>
  <Line number="119">/* Scheduler inheritance.  */</Line>
  <Line number="120">enum</Line>
  <Line number="121">{</Line>
  <Line number="122">  PTHREAD_INHERIT_SCHED,</Line>
  <Line number="123">#define PTHREAD_INHERIT_SCHED   PTHREAD_INHERIT_SCHED</Line>
  <Line number="124">  PTHREAD_EXPLICIT_SCHED</Line>
  <Line number="125">#define PTHREAD_EXPLICIT_SCHED  PTHREAD_EXPLICIT_SCHED</Line>
  <Line number="126">};</Line>
  <Line number="127"></Line>
  <Line number="128"></Line>
  <Line number="129">/* Scope handling.  */</Line>
  <Line number="130">enum</Line>
  <Line number="131">{</Line>
  <Line number="132">  PTHREAD_SCOPE_SYSTEM,</Line>
  <Line number="133">#define PTHREAD_SCOPE_SYSTEM    PTHREAD_SCOPE_SYSTEM</Line>
  <Line number="134">  PTHREAD_SCOPE_PROCESS</Line>
  <Line number="135">#define PTHREAD_SCOPE_PROCESS   PTHREAD_SCOPE_PROCESS</Line>
  <Line number="136">};</Line>
  <Line number="137"></Line>
  <Line number="138"></Line>
  <Line number="139">/* Process shared or private flag.  */</Line>
  <Line number="140">enum</Line>
  <Line number="141">{</Line>
  <Line number="142">  PTHREAD_PROCESS_PRIVATE,</Line>
  <Line number="143">#define PTHREAD_PROCESS_PRIVATE PTHREAD_PROCESS_PRIVATE</Line>
  <Line number="144">  PTHREAD_PROCESS_SHARED</Line>
  <Line number="145">#define PTHREAD_PROCESS_SHARED  PTHREAD_PROCESS_SHARED</Line>
  <Line number="146">};</Line>
  <Line number="147"></Line>
  <Line number="148"></Line>
  <Line number="149"></Line>
  <Line number="150">/* Conditional variable handling.  */</Line>
  <Line number="151">#define PTHREAD_COND_INITIALIZER { { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } }</Line>
  <Line number="152"></Line>
  <Line number="153"></Line>
  <Line number="154">/* Cleanup buffers */</Line>
  <Line number="155">struct _pthread_cleanup_buffer</Line>
  <Line number="156">{</Line>
  <Line number="157">  void (*__routine) (void *);             /* Function to call.  */</Line>
  <Line number="158">  void *__arg;                            /* Its argument.  */</Line>
  <Line number="159">  int __canceltype;                       /* Saved cancellation type. */</Line>
  <Line number="160">  struct _pthread_cleanup_buffer *__prev; /* Chaining of cleanup functions.  */</Line>
  <Line number="161">};</Line>
  <Line number="162"></Line>
  <Line number="163">/* Cancellation */</Line>
  <Line number="164">enum</Line>
  <Line number="165">{</Line>
  <Line number="166">  PTHREAD_CANCEL_ENABLE,</Line>
  <Line number="167">#define PTHREAD_CANCEL_ENABLE   PTHREAD_CANCEL_ENABLE</Line>
  <Line number="168">  PTHREAD_CANCEL_DISABLE</Line>
  <Line number="169">#define PTHREAD_CANCEL_DISABLE  PTHREAD_CANCEL_DISABLE</Line>
  <Line number="170">};</Line>
  <Line number="171">enum</Line>
  <Line number="172">{</Line>
  <Line number="173">  PTHREAD_CANCEL_DEFERRED,</Line>
  <Line number="174">#define PTHREAD_CANCEL_DEFERRED	PTHREAD_CANCEL_DEFERRED</Line>
  <Line number="175">  PTHREAD_CANCEL_ASYNCHRONOUS</Line>
  <Line number="176">#define PTHREAD_CANCEL_ASYNCHRONOUS	PTHREAD_CANCEL_ASYNCHRONOUS</Line>
  <Line number="177">};</Line>
  <Line number="178">#define PTHREAD_CANCELED ((void *) -1)</Line>
  <Line number="179"></Line>
  <Line number="180"></Line>
  <Line number="181">/* Single execution handling.  */</Line>
  <Line number="182">#define PTHREAD_ONCE_INIT 0</Line>
  <Line number="183"></Line>
  <Line number="184"></Line>
  <Line number="185">#ifdef __USE_XOPEN2K</Line>
  <Line number="186">/* Value returned by &apos;pthread_barrier_wait&apos; for one of the threads after</Line>
  <Line number="187">   the required number of threads have called this function.</Line>
  <Line number="188">   -1 is distinct from 0 and all errno constants */</Line>
  <Line number="189"># define PTHREAD_BARRIER_SERIAL_THREAD -1</Line>
  <Line number="190">#endif</Line>
  <Line number="191"></Line>
  <Line number="192"></Line>
  <Line number="193">__BEGIN_DECLS</Line>
  <Line number="194"></Line>
  <Line number="195">/* Create a new thread, starting with execution of START-ROUTINE</Line>
  <Line number="196">   getting passed ARG.  Creation attributed come from ATTR.  The new</Line>
  <Line number="197">   handle is stored in *NEWTHREAD.  */</Line>
  <Line number="198">extern int pthread_create (pthread_t *__restrict __newthread,</Line>
  <Line number="199">			   const pthread_attr_t *__restrict __attr,</Line>
  <Line number="200">			   void *(*__start_routine) (void *),</Line>
  <Line number="201">			   void *__restrict __arg) __THROWNL __nonnull ((1, 3));</Line>
  <Line number="202"></Line>
  <Line number="203">/* Terminate calling thread.</Line>
  <Line number="204"></Line>
  <Line number="205">   The registered cleanup handlers are called via exception handling</Line>
  <Line number="206">   so we cannot mark this function with __THROW.*/</Line>
  <Line number="207">extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));</Line>
  <Line number="208"></Line>
  <Line number="209">/* Make calling thread wait for termination of the thread TH.  The</Line>
  <Line number="210">   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN</Line>
  <Line number="211">   is not NULL.</Line>
  <Line number="212"></Line>
  <Line number="213">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="214">   __THROW.  */</Line>
  <Line number="215">extern int pthread_join (pthread_t __th, void **__thread_return);</Line>
  <Line number="216"></Line>
  <Line number="217">#ifdef __USE_GNU</Line>
  <Line number="218">/* Check whether thread TH has terminated.  If yes return the status of</Line>
  <Line number="219">   the thread in *THREAD_RETURN, if THREAD_RETURN is not NULL.  */</Line>
  <Line number="220">extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __THROW;</Line>
  <Line number="221"></Line>
  <Line number="222">/* Make calling thread wait for termination of the thread TH, but only</Line>
  <Line number="223">   until TIMEOUT.  The exit status of the thread is stored in</Line>
  <Line number="224">   *THREAD_RETURN, if THREAD_RETURN is not NULL.</Line>
  <Line number="225"></Line>
  <Line number="226">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="227">   __THROW.  */</Line>
  <Line number="228">extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,</Line>
  <Line number="229">				 const struct timespec *__abstime);</Line>
  <Line number="230"></Line>
  <Line number="231">/* Make calling thread wait for termination of the thread TH, but only</Line>
  <Line number="232">   until TIMEOUT measured against the clock specified by CLOCKID.  The</Line>
  <Line number="233">   exit status of the thread is stored in *THREAD_RETURN, if</Line>
  <Line number="234">   THREAD_RETURN is not NULL.</Line>
  <Line number="235"></Line>
  <Line number="236">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="237">   __THROW.  */</Line>
  <Line number="238">extern int pthread_clockjoin_np (pthread_t __th, void **__thread_return,</Line>
  <Line number="239">                                 clock_t __clockid,</Line>
  <Line number="240">				 const struct timespec *__abstime);</Line>
  <Line number="241">#endif</Line>
  <Line number="242"></Line>
  <Line number="243">/* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.</Line>
  <Line number="244">   The resources of TH will therefore be freed immediately when it</Line>
  <Line number="245">   terminates, instead of waiting for another thread to perform PTHREAD_JOIN</Line>
  <Line number="246">   on it.  */</Line>
  <Line number="247">extern int pthread_detach (pthread_t __th) __THROW;</Line>
  <Line number="248"></Line>
  <Line number="249"></Line>
  <Line number="250">/* Obtain the identifier of the current thread.  */</Line>
  <Line number="251">extern pthread_t pthread_self (void) __THROW __attribute__ ((__const__));</Line>
  <Line number="252"></Line>
  <Line number="253">/* Compare two thread identifiers.  */</Line>
  <Line number="254">extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)</Line>
  <Line number="255">  __THROW __attribute__ ((__const__));</Line>
  <Line number="256"></Line>
  <Line number="257"></Line>
  <Line number="258">/* Thread attribute handling.  */</Line>
  <Line number="259"></Line>
  <Line number="260">/* Initialize thread attribute *ATTR with default attributes</Line>
  <Line number="261">   (detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,</Line>
  <Line number="262">    no user-provided stack).  */</Line>
  <Line number="263">extern int pthread_attr_init (pthread_attr_t *__attr) __THROW __nonnull ((1));</Line>
  <Line number="264"></Line>
  <Line number="265">/* Destroy thread attribute *ATTR.  */</Line>
  <Line number="266">extern int pthread_attr_destroy (pthread_attr_t *__attr)</Line>
  <Line number="267">     __THROW __nonnull ((1));</Line>
  <Line number="268"></Line>
  <Line number="269">/* Get detach state attribute.  */</Line>
  <Line number="270">extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,</Line>
  <Line number="271">					int *__detachstate)</Line>
  <Line number="272">     __THROW __nonnull ((1, 2));</Line>
  <Line number="273"></Line>
  <Line number="274">/* Set detach state attribute.  */</Line>
  <Line number="275">extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,</Line>
  <Line number="276">					int __detachstate)</Line>
  <Line number="277">     __THROW __nonnull ((1));</Line>
  <Line number="278"></Line>
  <Line number="279"></Line>
  <Line number="280">/* Get the size of the guard area created for stack overflow protection.  */</Line>
  <Line number="281">extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,</Line>
  <Line number="282">				      size_t *__guardsize)</Line>
  <Line number="283">     __THROW __nonnull ((1, 2));</Line>
  <Line number="284"></Line>
  <Line number="285">/* Set the size of the guard area created for stack overflow protection.  */</Line>
  <Line number="286">extern int pthread_attr_setguardsize (pthread_attr_t *__attr,</Line>
  <Line number="287">				      size_t __guardsize)</Line>
  <Line number="288">     __THROW __nonnull ((1));</Line>
  <Line number="289"></Line>
  <Line number="290"></Line>
  <Line number="291">/* Return in *PARAM the scheduling parameters of *ATTR.  */</Line>
  <Line number="292">extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,</Line>
  <Line number="293">				       struct sched_param *__restrict __param)</Line>
  <Line number="294">     __THROW __nonnull ((1, 2));</Line>
  <Line number="295"></Line>
  <Line number="296">/* Set scheduling parameters (priority, etc) in *ATTR according to PARAM.  */</Line>
  <Line number="297">extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,</Line>
  <Line number="298">				       const struct sched_param *__restrict</Line>
  <Line number="299">				       __param) __THROW __nonnull ((1, 2));</Line>
  <Line number="300"></Line>
  <Line number="301">/* Return in *POLICY the scheduling policy of *ATTR.  */</Line>
  <Line number="302">extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict</Line>
  <Line number="303">					__attr, int *__restrict __policy)</Line>
  <Line number="304">     __THROW __nonnull ((1, 2));</Line>
  <Line number="305"></Line>
  <Line number="306">/* Set scheduling policy in *ATTR according to POLICY.  */</Line>
  <Line number="307">extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)</Line>
  <Line number="308">     __THROW __nonnull ((1));</Line>
  <Line number="309"></Line>
  <Line number="310">/* Return in *INHERIT the scheduling inheritance mode of *ATTR.  */</Line>
  <Line number="311">extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict</Line>
  <Line number="312">					 __attr, int *__restrict __inherit)</Line>
  <Line number="313">     __THROW __nonnull ((1, 2));</Line>
  <Line number="314"></Line>
  <Line number="315">/* Set scheduling inheritance mode in *ATTR according to INHERIT.  */</Line>
  <Line number="316">extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,</Line>
  <Line number="317">					 int __inherit)</Line>
  <Line number="318">     __THROW __nonnull ((1));</Line>
  <Line number="319"></Line>
  <Line number="320"></Line>
  <Line number="321">/* Return in *SCOPE the scheduling contention scope of *ATTR.  */</Line>
  <Line number="322">extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,</Line>
  <Line number="323">				  int *__restrict __scope)</Line>
  <Line number="324">     __THROW __nonnull ((1, 2));</Line>
  <Line number="325"></Line>
  <Line number="326">/* Set scheduling contention scope in *ATTR according to SCOPE.  */</Line>
  <Line number="327">extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)</Line>
  <Line number="328">     __THROW __nonnull ((1));</Line>
  <Line number="329"></Line>
  <Line number="330">/* Return the previously set address for the stack.  */</Line>
  <Line number="331">extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict</Line>
  <Line number="332">				      __attr, void **__restrict __stackaddr)</Line>
  <Line number="333">     __THROW __nonnull ((1, 2)) __attribute_deprecated__;</Line>
  <Line number="334"></Line>
  <Line number="335">/* Set the starting address of the stack of the thread to be created.</Line>
  <Line number="336">   Depending on whether the stack grows up or down the value must either</Line>
  <Line number="337">   be higher or lower than all the address in the memory block.  The</Line>
  <Line number="338">   minimal size of the block must be PTHREAD_STACK_MIN.  */</Line>
  <Line number="339">extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,</Line>
  <Line number="340">				      void *__stackaddr)</Line>
  <Line number="341">     __THROW __nonnull ((1)) __attribute_deprecated__;</Line>
  <Line number="342"></Line>
  <Line number="343">/* Return the currently used minimal stack size.  */</Line>
  <Line number="344">extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict</Line>
  <Line number="345">				      __attr, size_t *__restrict __stacksize)</Line>
  <Line number="346">     __THROW __nonnull ((1, 2));</Line>
  <Line number="347"></Line>
  <Line number="348">/* Add information about the minimum stack size needed for the thread</Line>
  <Line number="349">   to be started.  This size must never be less than PTHREAD_STACK_MIN</Line>
  <Line number="350">   and must also not exceed the system limits.  */</Line>
  <Line number="351">extern int pthread_attr_setstacksize (pthread_attr_t *__attr,</Line>
  <Line number="352">				      size_t __stacksize)</Line>
  <Line number="353">     __THROW __nonnull ((1));</Line>
  <Line number="354"></Line>
  <Line number="355">#ifdef __USE_XOPEN2K</Line>
  <Line number="356">/* Return the previously set address for the stack.  */</Line>
  <Line number="357">extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,</Line>
  <Line number="358">				  void **__restrict __stackaddr,</Line>
  <Line number="359">				  size_t *__restrict __stacksize)</Line>
  <Line number="360">     __THROW __nonnull ((1, 2, 3));</Line>
  <Line number="361"></Line>
  <Line number="362">/* The following two interfaces are intended to replace the last two.  They</Line>
  <Line number="363">   require setting the address as well as the size since only setting the</Line>
  <Line number="364">   address will make the implementation on some architectures impossible.  */</Line>
  <Line number="365">extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,</Line>
  <Line number="366">				  size_t __stacksize) __THROW __nonnull ((1));</Line>
  <Line number="367">#endif</Line>
  <Line number="368"></Line>
  <Line number="369">#ifdef __USE_GNU</Line>
  <Line number="370">/* Thread created with attribute ATTR will be limited to run only on</Line>
  <Line number="371">   the processors represented in CPUSET.  */</Line>
  <Line number="372">extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,</Line>
  <Line number="373">					size_t __cpusetsize,</Line>
  <Line number="374">					const cpu_set_t *__cpuset)</Line>
  <Line number="375">     __THROW __nonnull ((1, 3));</Line>
  <Line number="376"></Line>
  <Line number="377">/* Get bit set in CPUSET representing the processors threads created with</Line>
  <Line number="378">   ATTR can run on.  */</Line>
  <Line number="379">extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,</Line>
  <Line number="380">					size_t __cpusetsize,</Line>
  <Line number="381">					cpu_set_t *__cpuset)</Line>
  <Line number="382">     __THROW __nonnull ((1, 3));</Line>
  <Line number="383"></Line>
  <Line number="384">/* Get the default attributes used by pthread_create in this process.  */</Line>
  <Line number="385">extern int pthread_getattr_default_np (pthread_attr_t *__attr)</Line>
  <Line number="386">     __THROW __nonnull ((1));</Line>
  <Line number="387"></Line>
  <Line number="388">/* Set the default attributes to be used by pthread_create in this</Line>
  <Line number="389">   process.  */</Line>
  <Line number="390">extern int pthread_setattr_default_np (const pthread_attr_t *__attr)</Line>
  <Line number="391">     __THROW __nonnull ((1));</Line>
  <Line number="392"></Line>
  <Line number="393">/* Initialize thread attribute *ATTR with attributes corresponding to the</Line>
  <Line number="394">   already running thread TH.  It shall be called on uninitialized ATTR</Line>
  <Line number="395">   and destroyed with pthread_attr_destroy when no longer needed.  */</Line>
  <Line number="396">extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)</Line>
  <Line number="397">     __THROW __nonnull ((2));</Line>
  <Line number="398">#endif</Line>
  <Line number="399"></Line>
  <Line number="400"></Line>
  <Line number="401">/* Functions for scheduling control.  */</Line>
  <Line number="402"></Line>
  <Line number="403">/* Set the scheduling parameters for TARGET_THREAD according to POLICY</Line>
  <Line number="404">   and *PARAM.  */</Line>
  <Line number="405">extern int pthread_setschedparam (pthread_t __target_thread, int __policy,</Line>
  <Line number="406">				  const struct sched_param *__param)</Line>
  <Line number="407">     __THROW __nonnull ((3));</Line>
  <Line number="408"></Line>
  <Line number="409">/* Return in *POLICY and *PARAM the scheduling parameters for TARGET_THREAD. */</Line>
  <Line number="410">extern int pthread_getschedparam (pthread_t __target_thread,</Line>
  <Line number="411">				  int *__restrict __policy,</Line>
  <Line number="412">				  struct sched_param *__restrict __param)</Line>
  <Line number="413">     __THROW __nonnull ((2, 3));</Line>
  <Line number="414"></Line>
  <Line number="415">/* Set the scheduling priority for TARGET_THREAD.  */</Line>
  <Line number="416">extern int pthread_setschedprio (pthread_t __target_thread, int __prio)</Line>
  <Line number="417">     __THROW;</Line>
  <Line number="418"></Line>
  <Line number="419"></Line>
  <Line number="420">#ifdef __USE_GNU</Line>
  <Line number="421">/* Get thread name visible in the kernel and its interfaces.  */</Line>
  <Line number="422">extern int pthread_getname_np (pthread_t __target_thread, char *__buf,</Line>
  <Line number="423">			       size_t __buflen)</Line>
  <Line number="424">     __THROW __nonnull ((2));</Line>
  <Line number="425"></Line>
  <Line number="426">/* Set thread name visible in the kernel and its interfaces.  */</Line>
  <Line number="427">extern int pthread_setname_np (pthread_t __target_thread, const char *__name)</Line>
  <Line number="428">     __THROW __nonnull ((2));</Line>
  <Line number="429">#endif</Line>
  <Line number="430"></Line>
  <Line number="431"></Line>
  <Line number="432">#ifdef __USE_UNIX98</Line>
  <Line number="433">/* Determine level of concurrency.  */</Line>
  <Line number="434">extern int pthread_getconcurrency (void) __THROW;</Line>
  <Line number="435"></Line>
  <Line number="436">/* Set new concurrency level to LEVEL.  */</Line>
  <Line number="437">extern int pthread_setconcurrency (int __level) __THROW;</Line>
  <Line number="438">#endif</Line>
  <Line number="439"></Line>
  <Line number="440">#ifdef __USE_GNU</Line>
  <Line number="441">/* Yield the processor to another thread or process.</Line>
  <Line number="442">   This function is similar to the POSIX `sched_yield&apos; function but</Line>
  <Line number="443">   might be differently implemented in the case of a m-on-n thread</Line>
  <Line number="444">   implementation.  */</Line>
  <Line number="445">extern int pthread_yield (void) __THROW;</Line>
  <Line number="446"></Line>
  <Line number="447"></Line>
  <Line number="448">/* Limit specified thread TH to run only on the processors represented</Line>
  <Line number="449">   in CPUSET.  */</Line>
  <Line number="450">extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,</Line>
  <Line number="451">				   const cpu_set_t *__cpuset)</Line>
  <Line number="452">     __THROW __nonnull ((3));</Line>
  <Line number="453"></Line>
  <Line number="454">/* Get bit set in CPUSET representing the processors TH can run on.  */</Line>
  <Line number="455">extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,</Line>
  <Line number="456">				   cpu_set_t *__cpuset)</Line>
  <Line number="457">     __THROW __nonnull ((3));</Line>
  <Line number="458">#endif</Line>
  <Line number="459"></Line>
  <Line number="460"></Line>
  <Line number="461">/* Functions for handling initialization.  */</Line>
  <Line number="462"></Line>
  <Line number="463">/* Guarantee that the initialization function INIT_ROUTINE will be called</Line>
  <Line number="464">   only once, even if pthread_once is executed several times with the</Line>
  <Line number="465">   same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or</Line>
  <Line number="466">   extern variable initialized to PTHREAD_ONCE_INIT.</Line>
  <Line number="467"></Line>
  <Line number="468">   The initialization functions might throw exception which is why</Line>
  <Line number="469">   this function is not marked with __THROW.  */</Line>
  <Line number="470">extern int pthread_once (pthread_once_t *__once_control,</Line>
  <Line number="471">			 void (*__init_routine) (void)) __nonnull ((1, 2));</Line>
  <Line number="472"></Line>
  <Line number="473"></Line>
  <Line number="474">/* Functions for handling cancellation.</Line>
  <Line number="475"></Line>
  <Line number="476">   Note that these functions are explicitly not marked to not throw an</Line>
  <Line number="477">   exception in C++ code.  If cancellation is implemented by unwinding</Line>
  <Line number="478">   this is necessary to have the compiler generate the unwind information.  */</Line>
  <Line number="479"></Line>
  <Line number="480">/* Set cancelability state of current thread to STATE, returning old</Line>
  <Line number="481">   state in *OLDSTATE if OLDSTATE is not NULL.  */</Line>
  <Line number="482">extern int pthread_setcancelstate (int __state, int *__oldstate);</Line>
  <Line number="483"></Line>
  <Line number="484">/* Set cancellation state of current thread to TYPE, returning the old</Line>
  <Line number="485">   type in *OLDTYPE if OLDTYPE is not NULL.  */</Line>
  <Line number="486">extern int pthread_setcanceltype (int __type, int *__oldtype);</Line>
  <Line number="487"></Line>
  <Line number="488">/* Cancel THREAD immediately or at the next possibility.  */</Line>
  <Line number="489">extern int pthread_cancel (pthread_t __th);</Line>
  <Line number="490"></Line>
  <Line number="491">/* Test for pending cancellation for the current thread and terminate</Line>
  <Line number="492">   the thread as per pthread_exit(PTHREAD_CANCELED) if it has been</Line>
  <Line number="493">   cancelled.  */</Line>
  <Line number="494">extern void pthread_testcancel (void);</Line>
  <Line number="495"></Line>
  <Line number="496"></Line>
  <Line number="497">/* Cancellation handling with integration into exception handling.  */</Line>
  <Line number="498"></Line>
  <Line number="499">typedef struct</Line>
  <Line number="500">{</Line>
  <Line number="501">  struct</Line>
  <Line number="502">  {</Line>
  <Line number="503">    __jmp_buf __cancel_jmp_buf;</Line>
  <Line number="504">    int __mask_was_saved;</Line>
  <Line number="505">  } __cancel_jmp_buf[1];</Line>
  <Line number="506">  void *__pad[4];</Line>
  <Line number="507">} __pthread_unwind_buf_t __attribute__ ((__aligned__));</Line>
  <Line number="508"></Line>
  <Line number="509">/* No special attributes by default.  */</Line>
  <Line number="510">#ifndef __cleanup_fct_attribute</Line>
  <Line number="511"># define __cleanup_fct_attribute</Line>
  <Line number="512">#endif</Line>
  <Line number="513"></Line>
  <Line number="514"></Line>
  <Line number="515">/* Structure to hold the cleanup handler information.  */</Line>
  <Line number="516">struct __pthread_cleanup_frame</Line>
  <Line number="517">{</Line>
  <Line number="518">  void (*__cancel_routine) (void *);</Line>
  <Line number="519">  void *__cancel_arg;</Line>
  <Line number="520">  int __do_it;</Line>
  <Line number="521">  int __cancel_type;</Line>
  <Line number="522">};</Line>
  <Line number="523"></Line>
  <Line number="524">#if defined __GNUC__ &amp;&amp; defined __EXCEPTIONS</Line>
  <Line number="525"># ifdef __cplusplus</Line>
  <Line number="526">/* Class to handle cancellation handler invocation.  */</Line>
  <Line number="527">class __pthread_cleanup_class</Line>
  <Line number="528">{</Line>
  <Line number="529">  void (*__cancel_routine) (void *);</Line>
  <Line number="530">  void *__cancel_arg;</Line>
  <Line number="531">  int __do_it;</Line>
  <Line number="532">  int __cancel_type;</Line>
  <Line number="533"></Line>
  <Line number="534"> public:</Line>
  <Line number="535">  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)</Line>
  <Line number="536">    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }</Line>
  <Line number="537">  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }</Line>
  <Line number="538">  void __setdoit (int __newval) { __do_it = __newval; }</Line>
  <Line number="539">  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,</Line>
  <Line number="540">					   &amp;__cancel_type); }</Line>
  <Line number="541">  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }</Line>
  <Line number="542">};</Line>
  <Line number="543"></Line>
  <Line number="544">/* Install a cleanup handler: ROUTINE will be called with arguments ARG</Line>
  <Line number="545">   when the thread is canceled or calls pthread_exit.  ROUTINE will also</Line>
  <Line number="546">   be called with arguments ARG when the matching pthread_cleanup_pop</Line>
  <Line number="547">   is executed with non-zero EXECUTE argument.</Line>
  <Line number="548"></Line>
  <Line number="549">   pthread_cleanup_push and pthread_cleanup_pop are macros and must always</Line>
  <Line number="550">   be used in matching pairs at the same nesting level of braces.  */</Line>
  <Line number="551">#  define pthread_cleanup_push(routine, arg) \</Line>
  <Line number="552">  do {									      \</Line>
  <Line number="553">    __pthread_cleanup_class __clframe (routine, arg)</Line>
  <Line number="554"></Line>
  <Line number="555">/* Remove a cleanup handler installed by the matching pthread_cleanup_push.</Line>
  <Line number="556">   If EXECUTE is non-zero, the handler function is called. */</Line>
  <Line number="557">#  define pthread_cleanup_pop(execute) \</Line>
  <Line number="558">    __clframe.__setdoit (execute);					      \</Line>
  <Line number="559">  } while (0)</Line>
  <Line number="560"></Line>
  <Line number="561">#  ifdef __USE_GNU</Line>
  <Line number="562">/* Install a cleanup handler as pthread_cleanup_push does, but also</Line>
  <Line number="563">   saves the current cancellation type and sets it to deferred</Line>
  <Line number="564">   cancellation.  */</Line>
  <Line number="565">#   define pthread_cleanup_push_defer_np(routine, arg) \</Line>
  <Line number="566">  do {									      \</Line>
  <Line number="567">    __pthread_cleanup_class __clframe (routine, arg);			      \</Line>
  <Line number="568">    __clframe.__defer ()</Line>
  <Line number="569"></Line>
  <Line number="570">/* Remove a cleanup handler as pthread_cleanup_pop does, but also</Line>
  <Line number="571">   restores the cancellation type that was in effect when the matching</Line>
  <Line number="572">   pthread_cleanup_push_defer was called.  */</Line>
  <Line number="573">#   define pthread_cleanup_pop_restore_np(execute) \</Line>
  <Line number="574">    __clframe.__restore ();						      \</Line>
  <Line number="575">    __clframe.__setdoit (execute);					      \</Line>
  <Line number="576">  } while (0)</Line>
  <Line number="577">#  endif</Line>
  <Line number="578"># else</Line>
  <Line number="579">/* Function called to call the cleanup handler.  As an extern inline</Line>
  <Line number="580">   function the compiler is free to decide inlining the change when</Line>
  <Line number="581">   needed or fall back on the copy which must exist somewhere</Line>
  <Line number="582">   else.  */</Line>
  <Line number="583">__extern_inline void</Line>
  <Line number="584">__pthread_cleanup_routine (struct __pthread_cleanup_frame *__frame)</Line>
  <Line number="585">{</Line>
  <Line number="586">  if (__frame-&gt;__do_it)</Line>
  <Line number="587">    __frame-&gt;__cancel_routine (__frame-&gt;__cancel_arg);</Line>
  <Line number="588">}</Line>
  <Line number="589"></Line>
  <Line number="590">/* Install a cleanup handler: ROUTINE will be called with arguments ARG</Line>
  <Line number="591">   when the thread is canceled or calls pthread_exit.  ROUTINE will also</Line>
  <Line number="592">   be called with arguments ARG when the matching pthread_cleanup_pop</Line>
  <Line number="593">   is executed with non-zero EXECUTE argument.</Line>
  <Line number="594"></Line>
  <Line number="595">   pthread_cleanup_push and pthread_cleanup_pop are macros and must always</Line>
  <Line number="596">   be used in matching pairs at the same nesting level of braces.  */</Line>
  <Line number="597">#  define pthread_cleanup_push(routine, arg) \</Line>
  <Line number="598">  do {									      \</Line>
  <Line number="599">    struct __pthread_cleanup_frame __clframe				      \</Line>
  <Line number="600">      __attribute__ ((__cleanup__ (__pthread_cleanup_routine)))		      \</Line>
  <Line number="601">      = { .__cancel_routine = (routine), .__cancel_arg = (arg),	 	      \</Line>
  <Line number="602">	  .__do_it = 1 };</Line>
  <Line number="603"></Line>
  <Line number="604">/* Remove a cleanup handler installed by the matching pthread_cleanup_push.</Line>
  <Line number="605">   If EXECUTE is non-zero, the handler function is called. */</Line>
  <Line number="606">#  define pthread_cleanup_pop(execute) \</Line>
  <Line number="607">    __clframe.__do_it = (execute);					      \</Line>
  <Line number="608">  } while (0)</Line>
  <Line number="609"></Line>
  <Line number="610">#  ifdef __USE_GNU</Line>
  <Line number="611">/* Install a cleanup handler as pthread_cleanup_push does, but also</Line>
  <Line number="612">   saves the current cancellation type and sets it to deferred</Line>
  <Line number="613">   cancellation.  */</Line>
  <Line number="614">#   define pthread_cleanup_push_defer_np(routine, arg) \</Line>
  <Line number="615">  do {									      \</Line>
  <Line number="616">    struct __pthread_cleanup_frame __clframe				      \</Line>
  <Line number="617">      __attribute__ ((__cleanup__ (__pthread_cleanup_routine)))		      \</Line>
  <Line number="618">      = { .__cancel_routine = (routine), .__cancel_arg = (arg),		      \</Line>
  <Line number="619">	  .__do_it = 1 };						      \</Line>
  <Line number="620">    (void) pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,		      \</Line>
  <Line number="621">				  &amp;__clframe.__cancel_type)</Line>
  <Line number="622"></Line>
  <Line number="623">/* Remove a cleanup handler as pthread_cleanup_pop does, but also</Line>
  <Line number="624">   restores the cancellation type that was in effect when the matching</Line>
  <Line number="625">   pthread_cleanup_push_defer was called.  */</Line>
  <Line number="626">#   define pthread_cleanup_pop_restore_np(execute) \</Line>
  <Line number="627">    (void) pthread_setcanceltype (__clframe.__cancel_type, NULL);	      \</Line>
  <Line number="628">    __clframe.__do_it = (execute);					      \</Line>
  <Line number="629">  } while (0)</Line>
  <Line number="630">#  endif</Line>
  <Line number="631"># endif</Line>
  <Line number="632">#else</Line>
  <Line number="633">/* Install a cleanup handler: ROUTINE will be called with arguments ARG</Line>
  <Line number="634">   when the thread is canceled or calls pthread_exit.  ROUTINE will also</Line>
  <Line number="635">   be called with arguments ARG when the matching pthread_cleanup_pop</Line>
  <Line number="636">   is executed with non-zero EXECUTE argument.</Line>
  <Line number="637"></Line>
  <Line number="638">   pthread_cleanup_push and pthread_cleanup_pop are macros and must always</Line>
  <Line number="639">   be used in matching pairs at the same nesting level of braces.  */</Line>
  <Line number="640"># define pthread_cleanup_push(routine, arg) \</Line>
  <Line number="641">  do {									      \</Line>
  <Line number="642">    __pthread_unwind_buf_t __cancel_buf;				      \</Line>
  <Line number="643">    void (*__cancel_routine) (void *) = (routine);			      \</Line>
  <Line number="644">    void *__cancel_arg = (arg);						      \</Line>
  <Line number="645">    int __not_first_call = __sigsetjmp ((struct __jmp_buf_tag *) (void *)     \</Line>
  <Line number="646">					__cancel_buf.__cancel_jmp_buf, 0);    \</Line>
  <Line number="647">    if (__glibc_unlikely (__not_first_call))				      \</Line>
  <Line number="648">      {									      \</Line>
  <Line number="649">	__cancel_routine (__cancel_arg);				      \</Line>
  <Line number="650">	__pthread_unwind_next (&amp;__cancel_buf);				      \</Line>
  <Line number="651">	/* NOTREACHED */						      \</Line>
  <Line number="652">      }									      \</Line>
  <Line number="653">									      \</Line>
  <Line number="654">    __pthread_register_cancel (&amp;__cancel_buf);				      \</Line>
  <Line number="655">    do {</Line>
  <Line number="656">extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)</Line>
  <Line number="657">     __cleanup_fct_attribute;</Line>
  <Line number="658"></Line>
  <Line number="659">/* Remove a cleanup handler installed by the matching pthread_cleanup_push.</Line>
  <Line number="660">   If EXECUTE is non-zero, the handler function is called. */</Line>
  <Line number="661"># define pthread_cleanup_pop(execute) \</Line>
  <Line number="662">      do { } while (0);/* Empty to allow label before pthread_cleanup_pop.  */\</Line>
  <Line number="663">    } while (0);							      \</Line>
  <Line number="664">    __pthread_unregister_cancel (&amp;__cancel_buf);			      \</Line>
  <Line number="665">    if (execute)							      \</Line>
  <Line number="666">      __cancel_routine (__cancel_arg);					      \</Line>
  <Line number="667">  } while (0)</Line>
  <Line number="668">extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)</Line>
  <Line number="669">  __cleanup_fct_attribute;</Line>
  <Line number="670"></Line>
  <Line number="671"># ifdef __USE_GNU</Line>
  <Line number="672">/* Install a cleanup handler as pthread_cleanup_push does, but also</Line>
  <Line number="673">   saves the current cancellation type and sets it to deferred</Line>
  <Line number="674">   cancellation.  */</Line>
  <Line number="675">#  define pthread_cleanup_push_defer_np(routine, arg) \</Line>
  <Line number="676">  do {									      \</Line>
  <Line number="677">    __pthread_unwind_buf_t __cancel_buf;				      \</Line>
  <Line number="678">    void (*__cancel_routine) (void *) = (routine);			      \</Line>
  <Line number="679">    void *__cancel_arg = (arg);						      \</Line>
  <Line number="680">    int __not_first_call = __sigsetjmp ((struct __jmp_buf_tag *) (void *)     \</Line>
  <Line number="681">					__cancel_buf.__cancel_jmp_buf, 0);    \</Line>
  <Line number="682">    if (__glibc_unlikely (__not_first_call))				      \</Line>
  <Line number="683">      {									      \</Line>
  <Line number="684">	__cancel_routine (__cancel_arg);				      \</Line>
  <Line number="685">	__pthread_unwind_next (&amp;__cancel_buf);				      \</Line>
  <Line number="686">	/* NOTREACHED */						      \</Line>
  <Line number="687">      }									      \</Line>
  <Line number="688">									      \</Line>
  <Line number="689">    __pthread_register_cancel_defer (&amp;__cancel_buf);			      \</Line>
  <Line number="690">    do {</Line>
  <Line number="691">extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)</Line>
  <Line number="692">     __cleanup_fct_attribute;</Line>
  <Line number="693"></Line>
  <Line number="694">/* Remove a cleanup handler as pthread_cleanup_pop does, but also</Line>
  <Line number="695">   restores the cancellation type that was in effect when the matching</Line>
  <Line number="696">   pthread_cleanup_push_defer was called.  */</Line>
  <Line number="697">#  define pthread_cleanup_pop_restore_np(execute) \</Line>
  <Line number="698">      do { } while (0);/* Empty to allow label before pthread_cleanup_pop.  */\</Line>
  <Line number="699">    } while (0);							      \</Line>
  <Line number="700">    __pthread_unregister_cancel_restore (&amp;__cancel_buf);		      \</Line>
  <Line number="701">    if (execute)							      \</Line>
  <Line number="702">      __cancel_routine (__cancel_arg);					      \</Line>
  <Line number="703">  } while (0)</Line>
  <Line number="704">extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)</Line>
  <Line number="705">  __cleanup_fct_attribute;</Line>
  <Line number="706"># endif</Line>
  <Line number="707"></Line>
  <Line number="708">/* Internal interface to initiate cleanup.  */</Line>
  <Line number="709">extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)</Line>
  <Line number="710">     __cleanup_fct_attribute __attribute__ ((__noreturn__))</Line>
  <Line number="711"># ifndef SHARED</Line>
  <Line number="712">     __attribute__ ((__weak__))</Line>
  <Line number="713"># endif</Line>
  <Line number="714">     ;</Line>
  <Line number="715">#endif</Line>
  <Line number="716"></Line>
  <Line number="717">/* Function used in the macros.  */</Line>
  <Line number="718">struct __jmp_buf_tag;</Line>
  <Line number="719">extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __THROWNL;</Line>
  <Line number="720"></Line>
  <Line number="721"></Line>
  <Line number="722">/* Mutex handling.  */</Line>
  <Line number="723"></Line>
  <Line number="724">/* Initialize a mutex.  */</Line>
  <Line number="725">extern int pthread_mutex_init (pthread_mutex_t *__mutex,</Line>
  <Line number="726">			       const pthread_mutexattr_t *__mutexattr)</Line>
  <Line number="727">     __THROW __nonnull ((1));</Line>
  <Line number="728"></Line>
  <Line number="729">/* Destroy a mutex.  */</Line>
  <Line number="730">extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)</Line>
  <Line number="731">     __THROW __nonnull ((1));</Line>
  <Line number="732"></Line>
  <Line number="733">/* Try locking a mutex.  */</Line>
  <Line number="734">extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)</Line>
  <Line number="735">     __THROWNL __nonnull ((1));</Line>
  <Line number="736"></Line>
  <Line number="737">/* Lock a mutex.  */</Line>
  <Line number="738">extern int pthread_mutex_lock (pthread_mutex_t *__mutex)</Line>
  <Line number="739">     __THROWNL __nonnull ((1));</Line>
  <Line number="740"></Line>
  <Line number="741">#ifdef __USE_XOPEN2K</Line>
  <Line number="742">/* Wait until lock becomes available, or specified time passes. */</Line>
  <Line number="743">extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,</Line>
  <Line number="744">				    const struct timespec *__restrict</Line>
  <Line number="745">				    __abstime) __THROWNL __nonnull ((1, 2));</Line>
  <Line number="746">#endif</Line>
  <Line number="747"></Line>
  <Line number="748">#ifdef __USE_GNU</Line>
  <Line number="749">extern int pthread_mutex_clocklock (pthread_mutex_t *__restrict __mutex,</Line>
  <Line number="750">				    clockid_t __clockid,</Line>
  <Line number="751">				    const struct timespec *__restrict</Line>
  <Line number="752">				    __abstime) __THROWNL __nonnull ((1, 3));</Line>
  <Line number="753">#endif</Line>
  <Line number="754"></Line>
  <Line number="755">/* Unlock a mutex.  */</Line>
  <Line number="756">extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)</Line>
  <Line number="757">     __THROWNL __nonnull ((1));</Line>
  <Line number="758"></Line>
  <Line number="759"></Line>
  <Line number="760">/* Get the priority ceiling of MUTEX.  */</Line>
  <Line number="761">extern int pthread_mutex_getprioceiling (const pthread_mutex_t *</Line>
  <Line number="762">					 __restrict __mutex,</Line>
  <Line number="763">					 int *__restrict __prioceiling)</Line>
  <Line number="764">     __THROW __nonnull ((1, 2));</Line>
  <Line number="765"></Line>
  <Line number="766">/* Set the priority ceiling of MUTEX to PRIOCEILING, return old</Line>
  <Line number="767">   priority ceiling value in *OLD_CEILING.  */</Line>
  <Line number="768">extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,</Line>
  <Line number="769">					 int __prioceiling,</Line>
  <Line number="770">					 int *__restrict __old_ceiling)</Line>
  <Line number="771">     __THROW __nonnull ((1, 3));</Line>
  <Line number="772"></Line>
  <Line number="773"></Line>
  <Line number="774">#ifdef __USE_XOPEN2K8</Line>
  <Line number="775">/* Declare the state protected by MUTEX as consistent.  */</Line>
  <Line number="776">extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)</Line>
  <Line number="777">     __THROW __nonnull ((1));</Line>
  <Line number="778"># ifdef __USE_GNU</Line>
  <Line number="779">extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)</Line>
  <Line number="780">     __THROW __nonnull ((1));</Line>
  <Line number="781"># endif</Line>
  <Line number="782">#endif</Line>
  <Line number="783"></Line>
  <Line number="784"></Line>
  <Line number="785">/* Functions for handling mutex attributes.  */</Line>
  <Line number="786"></Line>
  <Line number="787">/* Initialize mutex attribute object ATTR with default attributes</Line>
  <Line number="788">   (kind is PTHREAD_MUTEX_TIMED_NP).  */</Line>
  <Line number="789">extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)</Line>
  <Line number="790">     __THROW __nonnull ((1));</Line>
  <Line number="791"></Line>
  <Line number="792">/* Destroy mutex attribute object ATTR.  */</Line>
  <Line number="793">extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)</Line>
  <Line number="794">     __THROW __nonnull ((1));</Line>
  <Line number="795"></Line>
  <Line number="796">/* Get the process-shared flag of the mutex attribute ATTR.  */</Line>
  <Line number="797">extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *</Line>
  <Line number="798">					 __restrict __attr,</Line>
  <Line number="799">					 int *__restrict __pshared)</Line>
  <Line number="800">     __THROW __nonnull ((1, 2));</Line>
  <Line number="801"></Line>
  <Line number="802">/* Set the process-shared flag of the mutex attribute ATTR.  */</Line>
  <Line number="803">extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,</Line>
  <Line number="804">					 int __pshared)</Line>
  <Line number="805">     __THROW __nonnull ((1));</Line>
  <Line number="806"></Line>
  <Line number="807">#if defined __USE_UNIX98 || defined __USE_XOPEN2K8</Line>
  <Line number="808">/* Return in *KIND the mutex kind attribute in *ATTR.  */</Line>
  <Line number="809">extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict</Line>
  <Line number="810">				      __attr, int *__restrict __kind)</Line>
  <Line number="811">     __THROW __nonnull ((1, 2));</Line>
  <Line number="812"></Line>
  <Line number="813">/* Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,</Line>
  <Line number="814">   PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or</Line>
  <Line number="815">   PTHREAD_MUTEX_DEFAULT).  */</Line>
  <Line number="816">extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)</Line>
  <Line number="817">     __THROW __nonnull ((1));</Line>
  <Line number="818">#endif</Line>
  <Line number="819"></Line>
  <Line number="820">/* Return in *PROTOCOL the mutex protocol attribute in *ATTR.  */</Line>
  <Line number="821">extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *</Line>
  <Line number="822">					  __restrict __attr,</Line>
  <Line number="823">					  int *__restrict __protocol)</Line>
  <Line number="824">     __THROW __nonnull ((1, 2));</Line>
  <Line number="825"></Line>
  <Line number="826">/* Set the mutex protocol attribute in *ATTR to PROTOCOL (either</Line>
  <Line number="827">   PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, or PTHREAD_PRIO_PROTECT).  */</Line>
  <Line number="828">extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,</Line>
  <Line number="829">					  int __protocol)</Line>
  <Line number="830">     __THROW __nonnull ((1));</Line>
  <Line number="831"></Line>
  <Line number="832">/* Return in *PRIOCEILING the mutex prioceiling attribute in *ATTR.  */</Line>
  <Line number="833">extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *</Line>
  <Line number="834">					     __restrict __attr,</Line>
  <Line number="835">					     int *__restrict __prioceiling)</Line>
  <Line number="836">     __THROW __nonnull ((1, 2));</Line>
  <Line number="837"></Line>
  <Line number="838">/* Set the mutex prioceiling attribute in *ATTR to PRIOCEILING.  */</Line>
  <Line number="839">extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,</Line>
  <Line number="840">					     int __prioceiling)</Line>
  <Line number="841">     __THROW __nonnull ((1));</Line>
  <Line number="842"></Line>
  <Line number="843">#ifdef __USE_XOPEN2K</Line>
  <Line number="844">/* Get the robustness flag of the mutex attribute ATTR.  */</Line>
  <Line number="845">extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,</Line>
  <Line number="846">					int *__robustness)</Line>
  <Line number="847">     __THROW __nonnull ((1, 2));</Line>
  <Line number="848"># ifdef __USE_GNU</Line>
  <Line number="849">extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,</Line>
  <Line number="850">					   int *__robustness)</Line>
  <Line number="851">     __THROW __nonnull ((1, 2));</Line>
  <Line number="852"># endif</Line>
  <Line number="853"></Line>
  <Line number="854">/* Set the robustness flag of the mutex attribute ATTR.  */</Line>
  <Line number="855">extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,</Line>
  <Line number="856">					int __robustness)</Line>
  <Line number="857">     __THROW __nonnull ((1));</Line>
  <Line number="858"># ifdef __USE_GNU</Line>
  <Line number="859">extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,</Line>
  <Line number="860">					   int __robustness)</Line>
  <Line number="861">     __THROW __nonnull ((1));</Line>
  <Line number="862"># endif</Line>
  <Line number="863">#endif</Line>
  <Line number="864"></Line>
  <Line number="865"></Line>
  <Line number="866">#if defined __USE_UNIX98 || defined __USE_XOPEN2K</Line>
  <Line number="867">/* Functions for handling read-write locks.  */</Line>
  <Line number="868"></Line>
  <Line number="869">/* Initialize read-write lock RWLOCK using attributes ATTR, or use</Line>
  <Line number="870">   the default values if later is NULL.  */</Line>
  <Line number="871">extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,</Line>
  <Line number="872">				const pthread_rwlockattr_t *__restrict</Line>
  <Line number="873">				__attr) __THROW __nonnull ((1));</Line>
  <Line number="874"></Line>
  <Line number="875">/* Destroy read-write lock RWLOCK.  */</Line>
  <Line number="876">extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)</Line>
  <Line number="877">     __THROW __nonnull ((1));</Line>
  <Line number="878"></Line>
  <Line number="879">/* Acquire read lock for RWLOCK.  */</Line>
  <Line number="880">extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)</Line>
  <Line number="881">     __THROWNL __nonnull ((1));</Line>
  <Line number="882"></Line>
  <Line number="883">/* Try to acquire read lock for RWLOCK.  */</Line>
  <Line number="884">extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)</Line>
  <Line number="885">  __THROWNL __nonnull ((1));</Line>
  <Line number="886"></Line>
  <Line number="887"># ifdef __USE_XOPEN2K</Line>
  <Line number="888">/* Try to acquire read lock for RWLOCK or return after specfied time.  */</Line>
  <Line number="889">extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,</Line>
  <Line number="890">				       const struct timespec *__restrict</Line>
  <Line number="891">				       __abstime) __THROWNL __nonnull ((1, 2));</Line>
  <Line number="892"># endif</Line>
  <Line number="893"></Line>
  <Line number="894"># ifdef __USE_GNU</Line>
  <Line number="895">extern int pthread_rwlock_clockrdlock (pthread_rwlock_t *__restrict __rwlock,</Line>
  <Line number="896">				       clockid_t __clockid,</Line>
  <Line number="897">				       const struct timespec *__restrict</Line>
  <Line number="898">				       __abstime) __THROWNL __nonnull ((1, 3));</Line>
  <Line number="899"># endif</Line>
  <Line number="900"></Line>
  <Line number="901">/* Acquire write lock for RWLOCK.  */</Line>
  <Line number="902">extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)</Line>
  <Line number="903">     __THROWNL __nonnull ((1));</Line>
  <Line number="904"></Line>
  <Line number="905">/* Try to acquire write lock for RWLOCK.  */</Line>
  <Line number="906">extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)</Line>
  <Line number="907">     __THROWNL __nonnull ((1));</Line>
  <Line number="908"></Line>
  <Line number="909"># ifdef __USE_XOPEN2K</Line>
  <Line number="910">/* Try to acquire write lock for RWLOCK or return after specfied time.  */</Line>
  <Line number="911">extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,</Line>
  <Line number="912">				       const struct timespec *__restrict</Line>
  <Line number="913">				       __abstime) __THROWNL __nonnull ((1, 2));</Line>
  <Line number="914"># endif</Line>
  <Line number="915"></Line>
  <Line number="916"># ifdef __USE_GNU</Line>
  <Line number="917">extern int pthread_rwlock_clockwrlock (pthread_rwlock_t *__restrict __rwlock,</Line>
  <Line number="918">				       clockid_t __clockid,</Line>
  <Line number="919">				       const struct timespec *__restrict</Line>
  <Line number="920">				       __abstime) __THROWNL __nonnull ((1, 3));</Line>
  <Line number="921"># endif</Line>
  <Line number="922"></Line>
  <Line number="923">/* Unlock RWLOCK.  */</Line>
  <Line number="924">extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)</Line>
  <Line number="925">     __THROWNL __nonnull ((1));</Line>
  <Line number="926"></Line>
  <Line number="927"></Line>
  <Line number="928">/* Functions for handling read-write lock attributes.  */</Line>
  <Line number="929"></Line>
  <Line number="930">/* Initialize attribute object ATTR with default values.  */</Line>
  <Line number="931">extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)</Line>
  <Line number="932">     __THROW __nonnull ((1));</Line>
  <Line number="933"></Line>
  <Line number="934">/* Destroy attribute object ATTR.  */</Line>
  <Line number="935">extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)</Line>
  <Line number="936">     __THROW __nonnull ((1));</Line>
  <Line number="937"></Line>
  <Line number="938">/* Return current setting of process-shared attribute of ATTR in PSHARED.  */</Line>
  <Line number="939">extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *</Line>
  <Line number="940">					  __restrict __attr,</Line>
  <Line number="941">					  int *__restrict __pshared)</Line>
  <Line number="942">     __THROW __nonnull ((1, 2));</Line>
  <Line number="943"></Line>
  <Line number="944">/* Set process-shared attribute of ATTR to PSHARED.  */</Line>
  <Line number="945">extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,</Line>
  <Line number="946">					  int __pshared)</Line>
  <Line number="947">     __THROW __nonnull ((1));</Line>
  <Line number="948"></Line>
  <Line number="949">/* Return current setting of reader/writer preference.  */</Line>
  <Line number="950">extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *</Line>
  <Line number="951">					  __restrict __attr,</Line>
  <Line number="952">					  int *__restrict __pref)</Line>
  <Line number="953">     __THROW __nonnull ((1, 2));</Line>
  <Line number="954"></Line>
  <Line number="955">/* Set reader/write preference.  */</Line>
  <Line number="956">extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,</Line>
  <Line number="957">					  int __pref) __THROW __nonnull ((1));</Line>
  <Line number="958">#endif</Line>
  <Line number="959"></Line>
  <Line number="960"></Line>
  <Line number="961">/* Functions for handling conditional variables.  */</Line>
  <Line number="962"></Line>
  <Line number="963">/* Initialize condition variable COND using attributes ATTR, or use</Line>
  <Line number="964">   the default values if later is NULL.  */</Line>
  <Line number="965">extern int pthread_cond_init (pthread_cond_t *__restrict __cond,</Line>
  <Line number="966">			      const pthread_condattr_t *__restrict __cond_attr)</Line>
  <Line number="967">     __THROW __nonnull ((1));</Line>
  <Line number="968"></Line>
  <Line number="969">/* Destroy condition variable COND.  */</Line>
  <Line number="970">extern int pthread_cond_destroy (pthread_cond_t *__cond)</Line>
  <Line number="971">     __THROW __nonnull ((1));</Line>
  <Line number="972"></Line>
  <Line number="973">/* Wake up one thread waiting for condition variable COND.  */</Line>
  <Line number="974">extern int pthread_cond_signal (pthread_cond_t *__cond)</Line>
  <Line number="975">     __THROWNL __nonnull ((1));</Line>
  <Line number="976"></Line>
  <Line number="977">/* Wake up all threads waiting for condition variables COND.  */</Line>
  <Line number="978">extern int pthread_cond_broadcast (pthread_cond_t *__cond)</Line>
  <Line number="979">     __THROWNL __nonnull ((1));</Line>
  <Line number="980"></Line>
  <Line number="981">/* Wait for condition variable COND to be signaled or broadcast.</Line>
  <Line number="982">   MUTEX is assumed to be locked before.</Line>
  <Line number="983"></Line>
  <Line number="984">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="985">   __THROW.  */</Line>
  <Line number="986">extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,</Line>
  <Line number="987">			      pthread_mutex_t *__restrict __mutex)</Line>
  <Line number="988">     __nonnull ((1, 2));</Line>
  <Line number="989"></Line>
  <Line number="990">/* Wait for condition variable COND to be signaled or broadcast until</Line>
  <Line number="991">   ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an</Line>
  <Line number="992">   absolute time specification; zero is the beginning of the epoch</Line>
  <Line number="993">   (00:00:00 GMT, January 1, 1970).</Line>
  <Line number="994"></Line>
  <Line number="995">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="996">   __THROW.  */</Line>
  <Line number="997">extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,</Line>
  <Line number="998">				   pthread_mutex_t *__restrict __mutex,</Line>
  <Line number="999">				   const struct timespec *__restrict __abstime)</Line>
  <Line number="1000">     __nonnull ((1, 2, 3));</Line>
  <Line number="1001"></Line>
  <Line number="1002"># ifdef __USE_GNU</Line>
  <Line number="1003">/* Wait for condition variable COND to be signaled or broadcast until</Line>
  <Line number="1004">   ABSTIME measured by the specified clock. MUTEX is assumed to be</Line>
  <Line number="1005">   locked before. CLOCK is the clock to use. ABSTIME is an absolute</Line>
  <Line number="1006">   time specification against CLOCK&apos;s epoch.</Line>
  <Line number="1007"></Line>
  <Line number="1008">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="1009">   __THROW. */</Line>
  <Line number="1010">extern int pthread_cond_clockwait (pthread_cond_t *__restrict __cond,</Line>
  <Line number="1011">				   pthread_mutex_t *__restrict __mutex,</Line>
  <Line number="1012">				   __clockid_t __clock_id,</Line>
  <Line number="1013">				   const struct timespec *__restrict __abstime)</Line>
  <Line number="1014">     __nonnull ((1, 2, 4));</Line>
  <Line number="1015"># endif</Line>
  <Line number="1016"></Line>
  <Line number="1017">/* Functions for handling condition variable attributes.  */</Line>
  <Line number="1018"></Line>
  <Line number="1019">/* Initialize condition variable attribute ATTR.  */</Line>
  <Line number="1020">extern int pthread_condattr_init (pthread_condattr_t *__attr)</Line>
  <Line number="1021">     __THROW __nonnull ((1));</Line>
  <Line number="1022"></Line>
  <Line number="1023">/* Destroy condition variable attribute ATTR.  */</Line>
  <Line number="1024">extern int pthread_condattr_destroy (pthread_condattr_t *__attr)</Line>
  <Line number="1025">     __THROW __nonnull ((1));</Line>
  <Line number="1026"></Line>
  <Line number="1027">/* Get the process-shared flag of the condition variable attribute ATTR.  */</Line>
  <Line number="1028">extern int pthread_condattr_getpshared (const pthread_condattr_t *</Line>
  <Line number="1029">					__restrict __attr,</Line>
  <Line number="1030">					int *__restrict __pshared)</Line>
  <Line number="1031">     __THROW __nonnull ((1, 2));</Line>
  <Line number="1032"></Line>
  <Line number="1033">/* Set the process-shared flag of the condition variable attribute ATTR.  */</Line>
  <Line number="1034">extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,</Line>
  <Line number="1035">					int __pshared) __THROW __nonnull ((1));</Line>
  <Line number="1036"></Line>
  <Line number="1037">#ifdef __USE_XOPEN2K</Line>
  <Line number="1038">/* Get the clock selected for the condition variable attribute ATTR.  */</Line>
  <Line number="1039">extern int pthread_condattr_getclock (const pthread_condattr_t *</Line>
  <Line number="1040">				      __restrict __attr,</Line>
  <Line number="1041">				      __clockid_t *__restrict __clock_id)</Line>
  <Line number="1042">     __THROW __nonnull ((1, 2));</Line>
  <Line number="1043"></Line>
  <Line number="1044">/* Set the clock selected for the condition variable attribute ATTR.  */</Line>
  <Line number="1045">extern int pthread_condattr_setclock (pthread_condattr_t *__attr,</Line>
  <Line number="1046">				      __clockid_t __clock_id)</Line>
  <Line number="1047">     __THROW __nonnull ((1));</Line>
  <Line number="1048">#endif</Line>
  <Line number="1049"></Line>
  <Line number="1050"></Line>
  <Line number="1051">#ifdef __USE_XOPEN2K</Line>
  <Line number="1052">/* Functions to handle spinlocks.  */</Line>
  <Line number="1053"></Line>
  <Line number="1054">/* Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can</Line>
  <Line number="1055">   be shared between different processes.  */</Line>
  <Line number="1056">extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)</Line>
  <Line number="1057">     __THROW __nonnull ((1));</Line>
  <Line number="1058"></Line>
  <Line number="1059">/* Destroy the spinlock LOCK.  */</Line>
  <Line number="1060">extern int pthread_spin_destroy (pthread_spinlock_t *__lock)</Line>
  <Line number="1061">     __THROW __nonnull ((1));</Line>
  <Line number="1062"></Line>
  <Line number="1063">/* Wait until spinlock LOCK is retrieved.  */</Line>
  <Line number="1064">extern int pthread_spin_lock (pthread_spinlock_t *__lock)</Line>
  <Line number="1065">     __THROWNL __nonnull ((1));</Line>
  <Line number="1066"></Line>
  <Line number="1067">/* Try to lock spinlock LOCK.  */</Line>
  <Line number="1068">extern int pthread_spin_trylock (pthread_spinlock_t *__lock)</Line>
  <Line number="1069">     __THROWNL __nonnull ((1));</Line>
  <Line number="1070"></Line>
  <Line number="1071">/* Release spinlock LOCK.  */</Line>
  <Line number="1072">extern int pthread_spin_unlock (pthread_spinlock_t *__lock)</Line>
  <Line number="1073">     __THROWNL __nonnull ((1));</Line>
  <Line number="1074"></Line>
  <Line number="1075"></Line>
  <Line number="1076">/* Functions to handle barriers.  */</Line>
  <Line number="1077"></Line>
  <Line number="1078">/* Initialize BARRIER with the attributes in ATTR.  The barrier is</Line>
  <Line number="1079">   opened when COUNT waiters arrived.  */</Line>
  <Line number="1080">extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,</Line>
  <Line number="1081">				 const pthread_barrierattr_t *__restrict</Line>
  <Line number="1082">				 __attr, unsigned int __count)</Line>
  <Line number="1083">     __THROW __nonnull ((1));</Line>
  <Line number="1084"></Line>
  <Line number="1085">/* Destroy a previously dynamically initialized barrier BARRIER.  */</Line>
  <Line number="1086">extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)</Line>
  <Line number="1087">     __THROW __nonnull ((1));</Line>
  <Line number="1088"></Line>
  <Line number="1089">/* Wait on barrier BARRIER.  */</Line>
  <Line number="1090">extern int pthread_barrier_wait (pthread_barrier_t *__barrier)</Line>
  <Line number="1091">     __THROWNL __nonnull ((1));</Line>
  <Line number="1092"></Line>
  <Line number="1093"></Line>
  <Line number="1094">/* Initialize barrier attribute ATTR.  */</Line>
  <Line number="1095">extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)</Line>
  <Line number="1096">     __THROW __nonnull ((1));</Line>
  <Line number="1097"></Line>
  <Line number="1098">/* Destroy previously dynamically initialized barrier attribute ATTR.  */</Line>
  <Line number="1099">extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)</Line>
  <Line number="1100">     __THROW __nonnull ((1));</Line>
  <Line number="1101"></Line>
  <Line number="1102">/* Get the process-shared flag of the barrier attribute ATTR.  */</Line>
  <Line number="1103">extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *</Line>
  <Line number="1104">					   __restrict __attr,</Line>
  <Line number="1105">					   int *__restrict __pshared)</Line>
  <Line number="1106">     __THROW __nonnull ((1, 2));</Line>
  <Line number="1107"></Line>
  <Line number="1108">/* Set the process-shared flag of the barrier attribute ATTR.  */</Line>
  <Line number="1109">extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,</Line>
  <Line number="1110">					   int __pshared)</Line>
  <Line number="1111">     __THROW __nonnull ((1));</Line>
  <Line number="1112">#endif</Line>
  <Line number="1113"></Line>
  <Line number="1114"></Line>
  <Line number="1115">/* Functions for handling thread-specific data.  */</Line>
  <Line number="1116"></Line>
  <Line number="1117">/* Create a key value identifying a location in the thread-specific</Line>
  <Line number="1118">   data area.  Each thread maintains a distinct thread-specific data</Line>
  <Line number="1119">   area.  DESTR_FUNCTION, if non-NULL, is called with the value</Line>
  <Line number="1120">   associated to that key when the key is destroyed.</Line>
  <Line number="1121">   DESTR_FUNCTION is not called if the value associated is NULL when</Line>
  <Line number="1122">   the key is destroyed.  */</Line>
  <Line number="1123">extern int pthread_key_create (pthread_key_t *__key,</Line>
  <Line number="1124">			       void (*__destr_function) (void *))</Line>
  <Line number="1125">     __THROW __nonnull ((1));</Line>
  <Line number="1126"></Line>
  <Line number="1127">/* Destroy KEY.  */</Line>
  <Line number="1128">extern int pthread_key_delete (pthread_key_t __key) __THROW;</Line>
  <Line number="1129"></Line>
  <Line number="1130">/* Return current value of the thread-specific data slot identified by KEY.  */</Line>
  <Line number="1131">extern void *pthread_getspecific (pthread_key_t __key) __THROW;</Line>
  <Line number="1132"></Line>
  <Line number="1133">/* Store POINTER in the thread-specific data slot identified by KEY. */</Line>
  <Line number="1134">extern int pthread_setspecific (pthread_key_t __key,</Line>
  <Line number="1135">				const void *__pointer) __THROW ;</Line>
  <Line number="1136"></Line>
  <Line number="1137"></Line>
  <Line number="1138">#ifdef __USE_XOPEN2K</Line>
  <Line number="1139">/* Get ID of CPU-time clock for thread THREAD_ID.  */</Line>
  <Line number="1140">extern int pthread_getcpuclockid (pthread_t __thread_id,</Line>
  <Line number="1141">				  __clockid_t *__clock_id)</Line>
  <Line number="1142">     __THROW __nonnull ((2));</Line>
  <Line number="1143">#endif</Line>
  <Line number="1144"></Line>
  <Line number="1145"></Line>
  <Line number="1146">/* Install handlers to be called when a new process is created with FORK.</Line>
  <Line number="1147">   The PREPARE handler is called in the parent process just before performing</Line>
  <Line number="1148">   FORK. The PARENT handler is called in the parent process just after FORK.</Line>
  <Line number="1149">   The CHILD handler is called in the child process.  Each of the three</Line>
  <Line number="1150">   handlers can be NULL, meaning that no handler needs to be called at that</Line>
  <Line number="1151">   point.</Line>
  <Line number="1152">   PTHREAD_ATFORK can be called several times, in which case the PREPARE</Line>
  <Line number="1153">   handlers are called in LIFO order (last added with PTHREAD_ATFORK,</Line>
  <Line number="1154">   first called before FORK), and the PARENT and CHILD handlers are called</Line>
  <Line number="1155">   in FIFO (first added, first called).  */</Line>
  <Line number="1156"></Line>
  <Line number="1157">extern int pthread_atfork (void (*__prepare) (void),</Line>
  <Line number="1158">			   void (*__parent) (void),</Line>
  <Line number="1159">			   void (*__child) (void)) __THROW;</Line>
  <Line number="1160"></Line>
  <Line number="1161"></Line>
  <Line number="1162">#ifdef __USE_EXTERN_INLINES</Line>
  <Line number="1163">/* Optimizations.  */</Line>
  <Line number="1164">__extern_inline int</Line>
  <Line number="1165">__NTH (pthread_equal (pthread_t __thread1, pthread_t __thread2))</Line>
  <Line number="1166">{</Line>
  <Line number="1167">  return __thread1 == __thread2;</Line>
  <Line number="1168">}</Line>
  <Line number="1169">#endif</Line>
  <Line number="1170"></Line>
  <Line number="1171">__END_DECLS</Line>
  <Line number="1172"></Line>
  <Line number="1173">#endif	/* pthread.h */</Line>
</SourceFile>
