<SourceFile>
  <Line number="1">/* Prototype declarations for math functions; helper file for &lt;math.h&gt;.</Line>
  <Line number="2">   Copyright (C) 1996-2020 Free Software Foundation, Inc.</Line>
  <Line number="3">   This file is part of the GNU C Library.</Line>
  <Line number="4"></Line>
  <Line number="5">   The GNU C Library is free software; you can redistribute it and/or</Line>
  <Line number="6">   modify it under the terms of the GNU Lesser General Public</Line>
  <Line number="7">   License as published by the Free Software Foundation; either</Line>
  <Line number="8">   version 2.1 of the License, or (at your option) any later version.</Line>
  <Line number="9"></Line>
  <Line number="10">   The GNU C Library is distributed in the hope that it will be useful,</Line>
  <Line number="11">   but WITHOUT ANY WARRANTY; without even the implied warranty of</Line>
  <Line number="12">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</Line>
  <Line number="13">   Lesser General Public License for more details.</Line>
  <Line number="14"></Line>
  <Line number="15">   You should have received a copy of the GNU Lesser General Public</Line>
  <Line number="16">   License along with the GNU C Library; if not, see</Line>
  <Line number="17">   &lt;https://www.gnu.org/licenses/&gt;.  */</Line>
  <Line number="18"></Line>
  <Line number="19">/* NOTE: Because of the special way this file is used by &lt;math.h&gt;, this</Line>
  <Line number="20">   file must NOT be protected from multiple inclusion as header files</Line>
  <Line number="21">   usually are.</Line>
  <Line number="22"></Line>
  <Line number="23">   This file provides prototype declarations for the math functions.</Line>
  <Line number="24">   Most functions are declared using the macro:</Line>
  <Line number="25"></Line>
  <Line number="26">   __MATHCALL (NAME,[_r], (ARGS...));</Line>
  <Line number="27"></Line>
  <Line number="28">   This means there is a function `NAME&apos; returning `double&apos; and a function</Line>
  <Line number="29">   `NAMEf&apos; returning `float&apos;.  Each place `_Mdouble_&apos; appears in the</Line>
  <Line number="30">   prototype, that is actually `double&apos; in the prototype for `NAME&apos; and</Line>
  <Line number="31">   `float&apos; in the prototype for `NAMEf&apos;.  Reentrant variant functions are</Line>
  <Line number="32">   called `NAME_r&apos; and `NAMEf_r&apos;.</Line>
  <Line number="33"></Line>
  <Line number="34">   Functions returning other types like `int&apos; are declared using the macro:</Line>
  <Line number="35"></Line>
  <Line number="36">   __MATHDECL (TYPE, NAME,[_r], (ARGS...));</Line>
  <Line number="37"></Line>
  <Line number="38">   This is just like __MATHCALL but for a function returning `TYPE&apos;</Line>
  <Line number="39">   instead of `_Mdouble_&apos;.  In all of these cases, there is still</Line>
  <Line number="40">   both a `NAME&apos; and a `NAMEf&apos; that takes `float&apos; arguments.</Line>
  <Line number="41"></Line>
  <Line number="42">   Note that there must be no whitespace before the argument passed for</Line>
  <Line number="43">   NAME, to make token pasting work with -traditional.  */</Line>
  <Line number="44"></Line>
  <Line number="45">#ifndef _MATH_H</Line>
  <Line number="46"># error &quot;Never include &lt;bits/mathcalls.h&gt; directly; include &lt;math.h&gt; instead.&quot;</Line>
  <Line number="47">#endif</Line>
  <Line number="48"></Line>
  <Line number="49"></Line>
  <Line number="50">/* Trigonometric functions.  */</Line>
  <Line number="51"></Line>
  <Line number="52">/* Arc cosine of X.  */</Line>
  <Line number="53">__MATHCALL (acos,, (_Mdouble_ __x));</Line>
  <Line number="54">/* Arc sine of X.  */</Line>
  <Line number="55">__MATHCALL (asin,, (_Mdouble_ __x));</Line>
  <Line number="56">/* Arc tangent of X.  */</Line>
  <Line number="57">__MATHCALL (atan,, (_Mdouble_ __x));</Line>
  <Line number="58">/* Arc tangent of Y/X.  */</Line>
  <Line number="59">__MATHCALL (atan2,, (_Mdouble_ __y, _Mdouble_ __x));</Line>
  <Line number="60"></Line>
  <Line number="61">/* Cosine of X.  */</Line>
  <Line number="62">__MATHCALL_VEC (cos,, (_Mdouble_ __x));</Line>
  <Line number="63">/* Sine of X.  */</Line>
  <Line number="64">__MATHCALL_VEC (sin,, (_Mdouble_ __x));</Line>
  <Line number="65">/* Tangent of X.  */</Line>
  <Line number="66">__MATHCALL (tan,, (_Mdouble_ __x));</Line>
  <Line number="67"></Line>
  <Line number="68">/* Hyperbolic functions.  */</Line>
  <Line number="69"></Line>
  <Line number="70">/* Hyperbolic cosine of X.  */</Line>
  <Line number="71">__MATHCALL (cosh,, (_Mdouble_ __x));</Line>
  <Line number="72">/* Hyperbolic sine of X.  */</Line>
  <Line number="73">__MATHCALL (sinh,, (_Mdouble_ __x));</Line>
  <Line number="74">/* Hyperbolic tangent of X.  */</Line>
  <Line number="75">__MATHCALL (tanh,, (_Mdouble_ __x));</Line>
  <Line number="76"></Line>
  <Line number="77">#ifdef __USE_GNU</Line>
  <Line number="78">/* Cosine and sine of X.  */</Line>
  <Line number="79">__MATHDECL_VEC (void,sincos,,</Line>
  <Line number="80">		(_Mdouble_ __x, _Mdouble_ *__sinx, _Mdouble_ *__cosx));</Line>
  <Line number="81">#endif</Line>
  <Line number="82"></Line>
  <Line number="83">#if defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99</Line>
  <Line number="84">/* Hyperbolic arc cosine of X.  */</Line>
  <Line number="85">__MATHCALL (acosh,, (_Mdouble_ __x));</Line>
  <Line number="86">/* Hyperbolic arc sine of X.  */</Line>
  <Line number="87">__MATHCALL (asinh,, (_Mdouble_ __x));</Line>
  <Line number="88">/* Hyperbolic arc tangent of X.  */</Line>
  <Line number="89">__MATHCALL (atanh,, (_Mdouble_ __x));</Line>
  <Line number="90">#endif</Line>
  <Line number="91"></Line>
  <Line number="92">/* Exponential and logarithmic functions.  */</Line>
  <Line number="93"></Line>
  <Line number="94">/* Exponential function of X.  */</Line>
  <Line number="95">__MATHCALL_VEC (exp,, (_Mdouble_ __x));</Line>
  <Line number="96"></Line>
  <Line number="97">/* Break VALUE into a normalized fraction and an integral power of 2.  */</Line>
  <Line number="98">__MATHCALL (frexp,, (_Mdouble_ __x, int *__exponent));</Line>
  <Line number="99"></Line>
  <Line number="100">/* X times (two to the EXP power).  */</Line>
  <Line number="101">__MATHCALL (ldexp,, (_Mdouble_ __x, int __exponent));</Line>
  <Line number="102"></Line>
  <Line number="103">/* Natural logarithm of X.  */</Line>
  <Line number="104">__MATHCALL_VEC (log,, (_Mdouble_ __x));</Line>
  <Line number="105"></Line>
  <Line number="106">/* Base-ten logarithm of X.  */</Line>
  <Line number="107">__MATHCALL (log10,, (_Mdouble_ __x));</Line>
  <Line number="108"></Line>
  <Line number="109">/* Break VALUE into integral and fractional parts.  */</Line>
  <Line number="110">__MATHCALL (modf,, (_Mdouble_ __x, _Mdouble_ *__iptr)) __nonnull ((2));</Line>
  <Line number="111"></Line>
  <Line number="112">#if __GLIBC_USE (IEC_60559_FUNCS_EXT_C2X)</Line>
  <Line number="113">/* Compute exponent to base ten.  */</Line>
  <Line number="114">__MATHCALL (exp10,, (_Mdouble_ __x));</Line>
  <Line number="115">#endif</Line>
  <Line number="116"></Line>
  <Line number="117">#if defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99</Line>
  <Line number="118">/* Return exp(X) - 1.  */</Line>
  <Line number="119">__MATHCALL (expm1,, (_Mdouble_ __x));</Line>
  <Line number="120"></Line>
  <Line number="121">/* Return log(1 + X).  */</Line>
  <Line number="122">__MATHCALL (log1p,, (_Mdouble_ __x));</Line>
  <Line number="123"></Line>
  <Line number="124">/* Return the base 2 signed integral exponent of X.  */</Line>
  <Line number="125">__MATHCALL (logb,, (_Mdouble_ __x));</Line>
  <Line number="126">#endif</Line>
  <Line number="127"></Line>
  <Line number="128">#ifdef __USE_ISOC99</Line>
  <Line number="129">/* Compute base-2 exponential of X.  */</Line>
  <Line number="130">__MATHCALL (exp2,, (_Mdouble_ __x));</Line>
  <Line number="131"></Line>
  <Line number="132">/* Compute base-2 logarithm of X.  */</Line>
  <Line number="133">__MATHCALL (log2,, (_Mdouble_ __x));</Line>
  <Line number="134">#endif</Line>
  <Line number="135"></Line>
  <Line number="136"></Line>
  <Line number="137">/* Power functions.  */</Line>
  <Line number="138"></Line>
  <Line number="139">/* Return X to the Y power.  */</Line>
  <Line number="140">__MATHCALL_VEC (pow,, (_Mdouble_ __x, _Mdouble_ __y));</Line>
  <Line number="141"></Line>
  <Line number="142">/* Return the square root of X.  */</Line>
  <Line number="143">__MATHCALL (sqrt,, (_Mdouble_ __x));</Line>
  <Line number="144"></Line>
  <Line number="145">#if defined __USE_XOPEN || defined __USE_ISOC99</Line>
  <Line number="146">/* Return `sqrt(X*X + Y*Y)&apos;.  */</Line>
  <Line number="147">__MATHCALL (hypot,, (_Mdouble_ __x, _Mdouble_ __y));</Line>
  <Line number="148">#endif</Line>
  <Line number="149"></Line>
  <Line number="150">#if defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99</Line>
  <Line number="151">/* Return the cube root of X.  */</Line>
  <Line number="152">__MATHCALL (cbrt,, (_Mdouble_ __x));</Line>
  <Line number="153">#endif</Line>
  <Line number="154"></Line>
  <Line number="155"></Line>
  <Line number="156">/* Nearest integer, absolute value, and remainder functions.  */</Line>
  <Line number="157"></Line>
  <Line number="158">/* Smallest integral value not less than X.  */</Line>
  <Line number="159">__MATHCALLX (ceil,, (_Mdouble_ __x), (__const__));</Line>
  <Line number="160"></Line>
  <Line number="161">/* Absolute value of X.  */</Line>
  <Line number="162">__MATHCALLX (fabs,, (_Mdouble_ __x), (__const__));</Line>
  <Line number="163"></Line>
  <Line number="164">/* Largest integer not greater than X.  */</Line>
  <Line number="165">__MATHCALLX (floor,, (_Mdouble_ __x), (__const__));</Line>
  <Line number="166"></Line>
  <Line number="167">/* Floating-point modulo remainder of X/Y.  */</Line>
  <Line number="168">__MATHCALL (fmod,, (_Mdouble_ __x, _Mdouble_ __y));</Line>
  <Line number="169"></Line>
  <Line number="170">#ifdef __USE_MISC</Line>
  <Line number="171"># if ((!defined __cplusplus \</Line>
  <Line number="172">       || __cplusplus &lt; 201103L /* isinf conflicts with C++11.  */ \</Line>
  <Line number="173">       || __MATH_DECLARING_DOUBLE == 0)) /* isinff or isinfl don&apos;t.  */ \</Line>
  <Line number="174">      &amp;&amp; !__MATH_DECLARING_FLOATN</Line>
  <Line number="175">/* Return 0 if VALUE is finite or NaN, +1 if it</Line>
  <Line number="176">   is +Infinity, -1 if it is -Infinity.  */</Line>
  <Line number="177">__MATHDECL_1 (int,isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));</Line>
  <Line number="178"># endif</Line>
  <Line number="179"></Line>
  <Line number="180"># if !__MATH_DECLARING_FLOATN</Line>
  <Line number="181">/* Return nonzero if VALUE is finite and not NaN.  */</Line>
  <Line number="182">__MATHDECL_1 (int,finite,, (_Mdouble_ __value)) __attribute__ ((__const__));</Line>
  <Line number="183"></Line>
  <Line number="184">/* Return the remainder of X/Y.  */</Line>
  <Line number="185">__MATHCALL (drem,, (_Mdouble_ __x, _Mdouble_ __y));</Line>
  <Line number="186"></Line>
  <Line number="187"></Line>
  <Line number="188">/* Return the fractional part of X after dividing out `ilogb (X)&apos;.  */</Line>
  <Line number="189">__MATHCALL (significand,, (_Mdouble_ __x));</Line>
  <Line number="190"># endif</Line>
  <Line number="191"></Line>
  <Line number="192">#endif /* Use misc.  */</Line>
  <Line number="193"></Line>
  <Line number="194">#ifdef __USE_ISOC99</Line>
  <Line number="195">/* Return X with its signed changed to Y&apos;s.  */</Line>
  <Line number="196">__MATHCALLX (copysign,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));</Line>
  <Line number="197">#endif</Line>
  <Line number="198"></Line>
  <Line number="199">#ifdef __USE_ISOC99</Line>
  <Line number="200">/* Return representation of qNaN for double type.  */</Line>
  <Line number="201">__MATHCALL (nan,, (const char *__tagb));</Line>
  <Line number="202">#endif</Line>
  <Line number="203"></Line>
  <Line number="204"></Line>
  <Line number="205">#if defined __USE_MISC || (defined __USE_XOPEN &amp;&amp; !defined __USE_XOPEN2K)</Line>
  <Line number="206"># if ((!defined __cplusplus \</Line>
  <Line number="207">       || __cplusplus &lt; 201103L /* isnan conflicts with C++11.  */ \</Line>
  <Line number="208">       || __MATH_DECLARING_DOUBLE == 0)) /* isnanf or isnanl don&apos;t.  */ \</Line>
  <Line number="209">      &amp;&amp; !__MATH_DECLARING_FLOATN</Line>
  <Line number="210">/* Return nonzero if VALUE is not a number.  */</Line>
  <Line number="211">__MATHDECL_1 (int,isnan,, (_Mdouble_ __value)) __attribute__ ((__const__));</Line>
  <Line number="212"># endif</Line>
  <Line number="213">#endif</Line>
  <Line number="214"></Line>
  <Line number="215">#if defined __USE_MISC || (defined __USE_XOPEN &amp;&amp; __MATH_DECLARING_DOUBLE)</Line>
  <Line number="216">/* Bessel functions.  */</Line>
  <Line number="217">__MATHCALL (j0,, (_Mdouble_));</Line>
  <Line number="218">__MATHCALL (j1,, (_Mdouble_));</Line>
  <Line number="219">__MATHCALL (jn,, (int, _Mdouble_));</Line>
  <Line number="220">__MATHCALL (y0,, (_Mdouble_));</Line>
  <Line number="221">__MATHCALL (y1,, (_Mdouble_));</Line>
  <Line number="222">__MATHCALL (yn,, (int, _Mdouble_));</Line>
  <Line number="223">#endif</Line>
  <Line number="224"></Line>
  <Line number="225"></Line>
  <Line number="226">#if defined __USE_XOPEN || defined __USE_ISOC99</Line>
  <Line number="227">/* Error and gamma functions.  */</Line>
  <Line number="228">__MATHCALL (erf,, (_Mdouble_));</Line>
  <Line number="229">__MATHCALL (erfc,, (_Mdouble_));</Line>
  <Line number="230">__MATHCALL (lgamma,, (_Mdouble_));</Line>
  <Line number="231">#endif</Line>
  <Line number="232"></Line>
  <Line number="233">#ifdef __USE_ISOC99</Line>
  <Line number="234">/* True gamma function.  */</Line>
  <Line number="235">__MATHCALL (tgamma,, (_Mdouble_));</Line>
  <Line number="236">#endif</Line>
  <Line number="237"></Line>
  <Line number="238">#if defined __USE_MISC || (defined __USE_XOPEN &amp;&amp; !defined __USE_XOPEN2K)</Line>
  <Line number="239"># if !__MATH_DECLARING_FLOATN</Line>
  <Line number="240">/* Obsolete alias for `lgamma&apos;.  */</Line>
  <Line number="241">__MATHCALL (gamma,, (_Mdouble_));</Line>
  <Line number="242"># endif</Line>
  <Line number="243">#endif</Line>
  <Line number="244"></Line>
  <Line number="245">#ifdef __USE_MISC</Line>
  <Line number="246">/* Reentrant version of lgamma.  This function uses the global variable</Line>
  <Line number="247">   `signgam&apos;.  The reentrant version instead takes a pointer and stores</Line>
  <Line number="248">   the value through it.  */</Line>
  <Line number="249">__MATHCALL (lgamma,_r, (_Mdouble_, int *__signgamp));</Line>
  <Line number="250">#endif</Line>
  <Line number="251"></Line>
  <Line number="252"></Line>
  <Line number="253">#if defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99</Line>
  <Line number="254">/* Return the integer nearest X in the direction of the</Line>
  <Line number="255">   prevailing rounding mode.  */</Line>
  <Line number="256">__MATHCALL (rint,, (_Mdouble_ __x));</Line>
  <Line number="257"></Line>
  <Line number="258">/* Return X + epsilon if X &lt; Y, X - epsilon if X &gt; Y.  */</Line>
  <Line number="259">__MATHCALL (nextafter,, (_Mdouble_ __x, _Mdouble_ __y));</Line>
  <Line number="260"># if defined __USE_ISOC99 &amp;&amp; !defined __LDBL_COMPAT &amp;&amp; !__MATH_DECLARING_FLOATN</Line>
  <Line number="261">__MATHCALL (nexttoward,, (_Mdouble_ __x, long double __y));</Line>
  <Line number="262"># endif</Line>
  <Line number="263"></Line>
  <Line number="264"># if __GLIBC_USE (IEC_60559_BFP_EXT_C2X) || __MATH_DECLARING_FLOATN</Line>
  <Line number="265">/* Return X - epsilon.  */</Line>
  <Line number="266">__MATHCALL (nextdown,, (_Mdouble_ __x));</Line>
  <Line number="267">/* Return X + epsilon.  */</Line>
  <Line number="268">__MATHCALL (nextup,, (_Mdouble_ __x));</Line>
  <Line number="269"># endif</Line>
  <Line number="270"></Line>
  <Line number="271">/* Return the remainder of integer divison X / Y with infinite precision.  */</Line>
  <Line number="272">__MATHCALL (remainder,, (_Mdouble_ __x, _Mdouble_ __y));</Line>
  <Line number="273"></Line>
  <Line number="274"># ifdef __USE_ISOC99</Line>
  <Line number="275">/* Return X times (2 to the Nth power).  */</Line>
  <Line number="276">__MATHCALL (scalbn,, (_Mdouble_ __x, int __n));</Line>
  <Line number="277"># endif</Line>
  <Line number="278"></Line>
  <Line number="279">/* Return the binary exponent of X, which must be nonzero.  */</Line>
  <Line number="280">__MATHDECL (int,ilogb,, (_Mdouble_ __x));</Line>
  <Line number="281">#endif</Line>
  <Line number="282"></Line>
  <Line number="283">#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X) || __MATH_DECLARING_FLOATN</Line>
  <Line number="284">/* Like ilogb, but returning long int.  */</Line>
  <Line number="285">__MATHDECL (long int, llogb,, (_Mdouble_ __x));</Line>
  <Line number="286">#endif</Line>
  <Line number="287"></Line>
  <Line number="288">#ifdef __USE_ISOC99</Line>
  <Line number="289">/* Return X times (2 to the Nth power).  */</Line>
  <Line number="290">__MATHCALL (scalbln,, (_Mdouble_ __x, long int __n));</Line>
  <Line number="291"></Line>
  <Line number="292">/* Round X to integral value in floating-point format using current</Line>
  <Line number="293">   rounding direction, but do not raise inexact exception.  */</Line>
  <Line number="294">__MATHCALL (nearbyint,, (_Mdouble_ __x));</Line>
  <Line number="295"></Line>
  <Line number="296">/* Round X to nearest integral value, rounding halfway cases away from</Line>
  <Line number="297">   zero.  */</Line>
  <Line number="298">__MATHCALLX (round,, (_Mdouble_ __x), (__const__));</Line>
  <Line number="299"></Line>
  <Line number="300">/* Round X to the integral value in floating-point format nearest but</Line>
  <Line number="301">   not larger in magnitude.  */</Line>
  <Line number="302">__MATHCALLX (trunc,, (_Mdouble_ __x), (__const__));</Line>
  <Line number="303"></Line>
  <Line number="304">/* Compute remainder of X and Y and put in *QUO a value with sign of x/y</Line>
  <Line number="305">   and magnitude congruent `mod 2^n&apos; to the magnitude of the integral</Line>
  <Line number="306">   quotient x/y, with n &gt;= 3.  */</Line>
  <Line number="307">__MATHCALL (remquo,, (_Mdouble_ __x, _Mdouble_ __y, int *__quo));</Line>
  <Line number="308"></Line>
  <Line number="309"></Line>
  <Line number="310">/* Conversion functions.  */</Line>
  <Line number="311"></Line>
  <Line number="312">/* Round X to nearest integral value according to current rounding</Line>
  <Line number="313">   direction.  */</Line>
  <Line number="314">__MATHDECL (long int,lrint,, (_Mdouble_ __x));</Line>
  <Line number="315">__extension__</Line>
  <Line number="316">__MATHDECL (long long int,llrint,, (_Mdouble_ __x));</Line>
  <Line number="317"></Line>
  <Line number="318">/* Round X to nearest integral value, rounding halfway cases away from</Line>
  <Line number="319">   zero.  */</Line>
  <Line number="320">__MATHDECL (long int,lround,, (_Mdouble_ __x));</Line>
  <Line number="321">__extension__</Line>
  <Line number="322">__MATHDECL (long long int,llround,, (_Mdouble_ __x));</Line>
  <Line number="323"></Line>
  <Line number="324"></Line>
  <Line number="325">/* Return positive difference between X and Y.  */</Line>
  <Line number="326">__MATHCALL (fdim,, (_Mdouble_ __x, _Mdouble_ __y));</Line>
  <Line number="327"></Line>
  <Line number="328">/* Return maximum numeric value from X and Y.  */</Line>
  <Line number="329">__MATHCALLX (fmax,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));</Line>
  <Line number="330"></Line>
  <Line number="331">/* Return minimum numeric value from X and Y.  */</Line>
  <Line number="332">__MATHCALLX (fmin,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));</Line>
  <Line number="333"></Line>
  <Line number="334">/* Multiply-add function computed as a ternary operation.  */</Line>
  <Line number="335">__MATHCALL (fma,, (_Mdouble_ __x, _Mdouble_ __y, _Mdouble_ __z));</Line>
  <Line number="336">#endif /* Use ISO C99.  */</Line>
  <Line number="337"></Line>
  <Line number="338">#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X) || __MATH_DECLARING_FLOATN</Line>
  <Line number="339">/* Round X to nearest integer value, rounding halfway cases to even.  */</Line>
  <Line number="340">__MATHCALLX (roundeven,, (_Mdouble_ __x), (__const__));</Line>
  <Line number="341"></Line>
  <Line number="342">/* Round X to nearest signed integer value, not raising inexact, with</Line>
  <Line number="343">   control of rounding direction and width of result.  */</Line>
  <Line number="344">__MATHDECL (__intmax_t, fromfp,, (_Mdouble_ __x, int __round,</Line>
  <Line number="345">				  unsigned int __width));</Line>
  <Line number="346"></Line>
  <Line number="347">/* Round X to nearest unsigned integer value, not raising inexact,</Line>
  <Line number="348">   with control of rounding direction and width of result.  */</Line>
  <Line number="349">__MATHDECL (__uintmax_t, ufromfp,, (_Mdouble_ __x, int __round,</Line>
  <Line number="350">				    unsigned int __width));</Line>
  <Line number="351"></Line>
  <Line number="352">/* Round X to nearest signed integer value, raising inexact for</Line>
  <Line number="353">   non-integers, with control of rounding direction and width of</Line>
  <Line number="354">   result.  */</Line>
  <Line number="355">__MATHDECL (__intmax_t, fromfpx,, (_Mdouble_ __x, int __round,</Line>
  <Line number="356">				   unsigned int __width));</Line>
  <Line number="357"></Line>
  <Line number="358">/* Round X to nearest unsigned integer value, raising inexact for</Line>
  <Line number="359">   non-integers, with control of rounding direction and width of</Line>
  <Line number="360">   result.  */</Line>
  <Line number="361">__MATHDECL (__uintmax_t, ufromfpx,, (_Mdouble_ __x, int __round,</Line>
  <Line number="362">				     unsigned int __width));</Line>
  <Line number="363"></Line>
  <Line number="364">/* Return value with maximum magnitude.  */</Line>
  <Line number="365">__MATHCALLX (fmaxmag,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));</Line>
  <Line number="366"></Line>
  <Line number="367">/* Return value with minimum magnitude.  */</Line>
  <Line number="368">__MATHCALLX (fminmag,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));</Line>
  <Line number="369"></Line>
  <Line number="370">/* Canonicalize floating-point representation.  */</Line>
  <Line number="371">__MATHDECL_1 (int, canonicalize,, (_Mdouble_ *__cx, const _Mdouble_ *__x));</Line>
  <Line number="372">#endif</Line>
  <Line number="373"></Line>
  <Line number="374">#if __GLIBC_USE (IEC_60559_BFP_EXT) || __MATH_DECLARING_FLOATN</Line>
  <Line number="375">/* Total order operation.  */</Line>
  <Line number="376">__MATHDECL_1 (int, totalorder,, (const _Mdouble_ *__x,</Line>
  <Line number="377">				 const _Mdouble_ *__y))</Line>
  <Line number="378">     __attribute_pure__;</Line>
  <Line number="379"></Line>
  <Line number="380">/* Total order operation on absolute values.  */</Line>
  <Line number="381">__MATHDECL_1 (int, totalordermag,, (const _Mdouble_ *__x,</Line>
  <Line number="382">				    const _Mdouble_ *__y))</Line>
  <Line number="383">     __attribute_pure__;</Line>
  <Line number="384"></Line>
  <Line number="385">/* Get NaN payload.  */</Line>
  <Line number="386">__MATHCALL (getpayload,, (const _Mdouble_ *__x));</Line>
  <Line number="387"></Line>
  <Line number="388">/* Set quiet NaN payload.  */</Line>
  <Line number="389">__MATHDECL_1 (int, setpayload,, (_Mdouble_ *__x, _Mdouble_ __payload));</Line>
  <Line number="390"></Line>
  <Line number="391">/* Set signaling NaN payload.  */</Line>
  <Line number="392">__MATHDECL_1 (int, setpayloadsig,, (_Mdouble_ *__x, _Mdouble_ __payload));</Line>
  <Line number="393">#endif</Line>
  <Line number="394"></Line>
  <Line number="395">#if (defined __USE_MISC || (defined __USE_XOPEN_EXTENDED \</Line>
  <Line number="396">			    &amp;&amp; __MATH_DECLARING_DOUBLE	  \</Line>
  <Line number="397">			    &amp;&amp; !defined __USE_XOPEN2K8))  \</Line>
  <Line number="398">     &amp;&amp; !__MATH_DECLARING_FLOATN</Line>
  <Line number="399">/* Return X times (2 to the Nth power).  */</Line>
  <Line number="400">__MATHCALL (scalb,, (_Mdouble_ __x, _Mdouble_ __n));</Line>
  <Line number="401">#endif</Line>
</SourceFile>
