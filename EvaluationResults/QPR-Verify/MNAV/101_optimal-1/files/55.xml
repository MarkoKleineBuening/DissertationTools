<SourceFile>
  <Line number="1">/* Copyright (C) 1991-2020 Free Software Foundation, Inc.</Line>
  <Line number="2">   This file is part of the GNU C Library.</Line>
  <Line number="3"></Line>
  <Line number="4">   The GNU C Library is free software; you can redistribute it and/or</Line>
  <Line number="5">   modify it under the terms of the GNU Lesser General Public</Line>
  <Line number="6">   License as published by the Free Software Foundation; either</Line>
  <Line number="7">   version 2.1 of the License, or (at your option) any later version.</Line>
  <Line number="8"></Line>
  <Line number="9">   The GNU C Library is distributed in the hope that it will be useful,</Line>
  <Line number="10">   but WITHOUT ANY WARRANTY; without even the implied warranty of</Line>
  <Line number="11">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</Line>
  <Line number="12">   Lesser General Public License for more details.</Line>
  <Line number="13"></Line>
  <Line number="14">   You should have received a copy of the GNU Lesser General Public</Line>
  <Line number="15">   License along with the GNU C Library; if not, see</Line>
  <Line number="16">   &lt;https://www.gnu.org/licenses/&gt;.  */</Line>
  <Line number="17"></Line>
  <Line number="18">/*</Line>
  <Line number="19"> *	POSIX Standard: 2.10 Symbolic Constants		&lt;unistd.h&gt;</Line>
  <Line number="20"> */</Line>
  <Line number="21"></Line>
  <Line number="22">#ifndef	_UNISTD_H</Line>
  <Line number="23">#define	_UNISTD_H	1</Line>
  <Line number="24"></Line>
  <Line number="25">#include &lt;features.h&gt;</Line>
  <Line number="26"></Line>
  <Line number="27">__BEGIN_DECLS</Line>
  <Line number="28"></Line>
  <Line number="29">/* These may be used to determine what facilities are present at compile time.</Line>
  <Line number="30">   Their values can be obtained at run time from `sysconf&apos;.  */</Line>
  <Line number="31"></Line>
  <Line number="32">#ifdef __USE_XOPEN2K8</Line>
  <Line number="33">/* POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.  */</Line>
  <Line number="34"># define _POSIX_VERSION	200809L</Line>
  <Line number="35">#elif defined __USE_XOPEN2K</Line>
  <Line number="36">/* POSIX Standard approved as ISO/IEC 9945-1 as of December 2001.  */</Line>
  <Line number="37"># define _POSIX_VERSION	200112L</Line>
  <Line number="38">#elif defined __USE_POSIX199506</Line>
  <Line number="39">/* POSIX Standard approved as ISO/IEC 9945-1 as of June 1995.  */</Line>
  <Line number="40"># define _POSIX_VERSION	199506L</Line>
  <Line number="41">#elif defined __USE_POSIX199309</Line>
  <Line number="42">/* POSIX Standard approved as ISO/IEC 9945-1 as of September 1993.  */</Line>
  <Line number="43"># define _POSIX_VERSION	199309L</Line>
  <Line number="44">#else</Line>
  <Line number="45">/* POSIX Standard approved as ISO/IEC 9945-1 as of September 1990.  */</Line>
  <Line number="46"># define _POSIX_VERSION	199009L</Line>
  <Line number="47">#endif</Line>
  <Line number="48"></Line>
  <Line number="49">/* These are not #ifdef __USE_POSIX2 because they are</Line>
  <Line number="50">   in the theoretically application-owned namespace.  */</Line>
  <Line number="51"></Line>
  <Line number="52">#ifdef __USE_XOPEN2K8</Line>
  <Line number="53"># define __POSIX2_THIS_VERSION	200809L</Line>
  <Line number="54">/* The utilities on GNU systems also correspond to this version.  */</Line>
  <Line number="55">#elif defined __USE_XOPEN2K</Line>
  <Line number="56">/* The utilities on GNU systems also correspond to this version.  */</Line>
  <Line number="57"># define __POSIX2_THIS_VERSION	200112L</Line>
  <Line number="58">#elif defined __USE_POSIX199506</Line>
  <Line number="59">/* The utilities on GNU systems also correspond to this version.  */</Line>
  <Line number="60"># define __POSIX2_THIS_VERSION	199506L</Line>
  <Line number="61">#else</Line>
  <Line number="62">/* The utilities on GNU systems also correspond to this version.  */</Line>
  <Line number="63"># define __POSIX2_THIS_VERSION	199209L</Line>
  <Line number="64">#endif</Line>
  <Line number="65"></Line>
  <Line number="66">/* The utilities on GNU systems also correspond to this version.  */</Line>
  <Line number="67">#define _POSIX2_VERSION	__POSIX2_THIS_VERSION</Line>
  <Line number="68"></Line>
  <Line number="69">/* This symbol was required until the 2001 edition of POSIX.  */</Line>
  <Line number="70">#define	_POSIX2_C_VERSION	__POSIX2_THIS_VERSION</Line>
  <Line number="71"></Line>
  <Line number="72">/* If defined, the implementation supports the</Line>
  <Line number="73">   C Language Bindings Option.  */</Line>
  <Line number="74">#define	_POSIX2_C_BIND	__POSIX2_THIS_VERSION</Line>
  <Line number="75"></Line>
  <Line number="76">/* If defined, the implementation supports the</Line>
  <Line number="77">   C Language Development Utilities Option.  */</Line>
  <Line number="78">#define	_POSIX2_C_DEV	__POSIX2_THIS_VERSION</Line>
  <Line number="79"></Line>
  <Line number="80">/* If defined, the implementation supports the</Line>
  <Line number="81">   Software Development Utilities Option.  */</Line>
  <Line number="82">#define	_POSIX2_SW_DEV	__POSIX2_THIS_VERSION</Line>
  <Line number="83"></Line>
  <Line number="84">/* If defined, the implementation supports the</Line>
  <Line number="85">   creation of locales with the localedef utility.  */</Line>
  <Line number="86">#define _POSIX2_LOCALEDEF       __POSIX2_THIS_VERSION</Line>
  <Line number="87"></Line>
  <Line number="88">/* X/Open version number to which the library conforms.  It is selectable.  */</Line>
  <Line number="89">#ifdef __USE_XOPEN2K8</Line>
  <Line number="90"># define _XOPEN_VERSION	700</Line>
  <Line number="91">#elif defined __USE_XOPEN2K</Line>
  <Line number="92"># define _XOPEN_VERSION	600</Line>
  <Line number="93">#elif defined __USE_UNIX98</Line>
  <Line number="94"># define _XOPEN_VERSION	500</Line>
  <Line number="95">#else</Line>
  <Line number="96"># define _XOPEN_VERSION	4</Line>
  <Line number="97">#endif</Line>
  <Line number="98"></Line>
  <Line number="99">/* Commands and utilities from XPG4 are available.  */</Line>
  <Line number="100">#define _XOPEN_XCU_VERSION	4</Line>
  <Line number="101"></Line>
  <Line number="102">/* We are compatible with the old published standards as well.  */</Line>
  <Line number="103">#define _XOPEN_XPG2	1</Line>
  <Line number="104">#define _XOPEN_XPG3	1</Line>
  <Line number="105">#define _XOPEN_XPG4	1</Line>
  <Line number="106"></Line>
  <Line number="107">/* The X/Open Unix extensions are available.  */</Line>
  <Line number="108">#define _XOPEN_UNIX	1</Line>
  <Line number="109"></Line>
  <Line number="110">/* The enhanced internationalization capabilities according to XPG4.2</Line>
  <Line number="111">   are present.  */</Line>
  <Line number="112">#define	_XOPEN_ENH_I18N	1</Line>
  <Line number="113"></Line>
  <Line number="114">/* The legacy interfaces are also available.  */</Line>
  <Line number="115">#define _XOPEN_LEGACY	1</Line>
  <Line number="116"></Line>
  <Line number="117"></Line>
  <Line number="118">/* Get values of POSIX options:</Line>
  <Line number="119"></Line>
  <Line number="120">   If these symbols are defined, the corresponding features are</Line>
  <Line number="121">   always available.  If not, they may be available sometimes.</Line>
  <Line number="122">   The current values can be obtained with `sysconf&apos;.</Line>
  <Line number="123"></Line>
  <Line number="124">   _POSIX_JOB_CONTROL		Job control is supported.</Line>
  <Line number="125">   _POSIX_SAVED_IDS		Processes have a saved set-user-ID</Line>
  <Line number="126">				and a saved set-group-ID.</Line>
  <Line number="127">   _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.</Line>
  <Line number="128">   _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.</Line>
  <Line number="129">   _POSIX_TIMERS		POSIX.4 clocks and timers are supported.</Line>
  <Line number="130">   _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.</Line>
  <Line number="131">   _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.</Line>
  <Line number="132">   _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.</Line>
  <Line number="133">   _POSIX_FSYNC			The fsync function is present.</Line>
  <Line number="134">   _POSIX_MAPPED_FILES		Mapping of files to memory is supported.</Line>
  <Line number="135">   _POSIX_MEMLOCK		Locking of all memory is supported.</Line>
  <Line number="136">   _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.</Line>
  <Line number="137">   _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.</Line>
  <Line number="138">   _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.</Line>
  <Line number="139">   _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.</Line>
  <Line number="140">   _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.</Line>
  <Line number="141">   _POSIX_THREADS		POSIX.1c pthreads are supported.</Line>
  <Line number="142">   _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.</Line>
  <Line number="143">   _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.</Line>
  <Line number="144">   _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.</Line>
  <Line number="145">   _POSIX_THREAD_PRIORITY_SCHEDULING</Line>
  <Line number="146">				POSIX.1c thread execution scheduling supported.</Line>
  <Line number="147">   _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.</Line>
  <Line number="148">   _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.</Line>
  <Line number="149">   _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.</Line>
  <Line number="150">   _POSIX_PII			Protocol-independent interfaces are supported.</Line>
  <Line number="151">   _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.</Line>
  <Line number="152">   _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.</Line>
  <Line number="153">   _POSIX_PII_INTERNET		Internet family of protocols supported.</Line>
  <Line number="154">   _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.</Line>
  <Line number="155">   _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.</Line>
  <Line number="156">   _POSIX_PII_OSI		ISO/OSI family of protocols supported.</Line>
  <Line number="157">   _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.</Line>
  <Line number="158">   _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.</Line>
  <Line number="159">   _POSIX_POLL			Implementation supports `poll&apos; function.</Line>
  <Line number="160">   _POSIX_SELECT		Implementation supports `select&apos; and `pselect&apos;.</Line>
  <Line number="161"></Line>
  <Line number="162">   _XOPEN_REALTIME		X/Open realtime support is available.</Line>
  <Line number="163">   _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.</Line>
  <Line number="164">   _XOPEN_SHM			Shared memory interface according to XPG4.2.</Line>
  <Line number="165"></Line>
  <Line number="166">   _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit</Line>
  <Line number="167">				int, long, pointer, and off_t types.</Line>
  <Line number="168">   _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit</Line>
  <Line number="169">				int, long, and pointer and off_t with at least</Line>
  <Line number="170">				64 bits.</Line>
  <Line number="171">   _XBS5_LP64_OFF64		Implementation provides environment with 32-bit</Line>
  <Line number="172">				int, and 64-bit long, pointer, and off_t types.</Line>
  <Line number="173">   _XBS5_LPBIG_OFFBIG		Implementation provides environment with at</Line>
  <Line number="174">				least 32 bits int and long, pointer, and off_t</Line>
  <Line number="175">				with at least 64 bits.</Line>
  <Line number="176"></Line>
  <Line number="177">   If any of these symbols is defined as -1, the corresponding option is not</Line>
  <Line number="178">   true for any file.  If any is defined as other than -1, the corresponding</Line>
  <Line number="179">   option is true for all files.  If a symbol is not defined at all, the value</Line>
  <Line number="180">   for a specific file can be obtained from `pathconf&apos; and `fpathconf&apos;.</Line>
  <Line number="181"></Line>
  <Line number="182">   _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown&apos; to change</Line>
  <Line number="183">				the owner of a file.  `chown&apos; can only be used</Line>
  <Line number="184">				to change the group ID of a file to a group of</Line>
  <Line number="185">				which the calling process is a member.</Line>
  <Line number="186">   _POSIX_NO_TRUNC		Pathname components longer than</Line>
  <Line number="187">				NAME_MAX generate an error.</Line>
  <Line number="188">   _POSIX_VDISABLE		If defined, if the value of an element of the</Line>
  <Line number="189">				`c_cc&apos; member of `struct termios&apos; is</Line>
  <Line number="190">				_POSIX_VDISABLE, no character will have the</Line>
  <Line number="191">				effect associated with that element.</Line>
  <Line number="192">   _POSIX_SYNC_IO		Synchronous I/O may be performed.</Line>
  <Line number="193">   _POSIX_ASYNC_IO		Asynchronous I/O may be performed.</Line>
  <Line number="194">   _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.</Line>
  <Line number="195"></Line>
  <Line number="196">   Support for the Large File Support interface is not generally available.</Line>
  <Line number="197">   If it is available the following constants are defined to one.</Line>
  <Line number="198">   _LFS64_LARGEFILE		Low-level I/O supports large files.</Line>
  <Line number="199">   _LFS64_STDIO			Standard I/O supports large files.</Line>
  <Line number="200">   */</Line>
  <Line number="201"></Line>
  <Line number="202">#include &lt;bits/posix_opt.h&gt;</Line>
  <Line number="203"></Line>
  <Line number="204">/* Get the environment definitions from Unix98.  */</Line>
  <Line number="205">#if defined __USE_UNIX98 || defined __USE_XOPEN2K</Line>
  <Line number="206"># include &lt;bits/environments.h&gt;</Line>
  <Line number="207">#endif</Line>
  <Line number="208"></Line>
  <Line number="209">/* Standard file descriptors.  */</Line>
  <Line number="210">#define	STDIN_FILENO	0	/* Standard input.  */</Line>
  <Line number="211">#define	STDOUT_FILENO	1	/* Standard output.  */</Line>
  <Line number="212">#define	STDERR_FILENO	2	/* Standard error output.  */</Line>
  <Line number="213"></Line>
  <Line number="214"></Line>
  <Line number="215">/* All functions that are not declared anywhere else.  */</Line>
  <Line number="216"></Line>
  <Line number="217">#include &lt;bits/types.h&gt;</Line>
  <Line number="218"></Line>
  <Line number="219">#ifndef	__ssize_t_defined</Line>
  <Line number="220">typedef __ssize_t ssize_t;</Line>
  <Line number="221"># define __ssize_t_defined</Line>
  <Line number="222">#endif</Line>
  <Line number="223"></Line>
  <Line number="224">#define	__need_size_t</Line>
  <Line number="225">#define __need_NULL</Line>
  <Line number="226">#include &lt;stddef.h&gt;</Line>
  <Line number="227"></Line>
  <Line number="228">#if defined __USE_XOPEN || defined __USE_XOPEN2K</Line>
  <Line number="229">/* The Single Unix specification says that some more types are</Line>
  <Line number="230">   available here.  */</Line>
  <Line number="231"># ifndef __gid_t_defined</Line>
  <Line number="232">typedef __gid_t gid_t;</Line>
  <Line number="233">#  define __gid_t_defined</Line>
  <Line number="234"># endif</Line>
  <Line number="235"></Line>
  <Line number="236"># ifndef __uid_t_defined</Line>
  <Line number="237">typedef __uid_t uid_t;</Line>
  <Line number="238">#  define __uid_t_defined</Line>
  <Line number="239"># endif</Line>
  <Line number="240"></Line>
  <Line number="241"># ifndef __off_t_defined</Line>
  <Line number="242">#  ifndef __USE_FILE_OFFSET64</Line>
  <Line number="243">typedef __off_t off_t;</Line>
  <Line number="244">#  else</Line>
  <Line number="245">typedef __off64_t off_t;</Line>
  <Line number="246">#  endif</Line>
  <Line number="247">#  define __off_t_defined</Line>
  <Line number="248"># endif</Line>
  <Line number="249"># if defined __USE_LARGEFILE64 &amp;&amp; !defined __off64_t_defined</Line>
  <Line number="250">typedef __off64_t off64_t;</Line>
  <Line number="251">#  define __off64_t_defined</Line>
  <Line number="252"># endif</Line>
  <Line number="253"></Line>
  <Line number="254"># ifndef __useconds_t_defined</Line>
  <Line number="255">typedef __useconds_t useconds_t;</Line>
  <Line number="256">#  define __useconds_t_defined</Line>
  <Line number="257"># endif</Line>
  <Line number="258"></Line>
  <Line number="259"># ifndef __pid_t_defined</Line>
  <Line number="260">typedef __pid_t pid_t;</Line>
  <Line number="261">#  define __pid_t_defined</Line>
  <Line number="262"># endif</Line>
  <Line number="263">#endif	/* X/Open */</Line>
  <Line number="264"></Line>
  <Line number="265">#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K</Line>
  <Line number="266"># ifndef __intptr_t_defined</Line>
  <Line number="267">typedef __intptr_t intptr_t;</Line>
  <Line number="268">#  define __intptr_t_defined</Line>
  <Line number="269"># endif</Line>
  <Line number="270">#endif</Line>
  <Line number="271"></Line>
  <Line number="272">#if defined __USE_MISC || defined __USE_XOPEN</Line>
  <Line number="273"># ifndef __socklen_t_defined</Line>
  <Line number="274">typedef __socklen_t socklen_t;</Line>
  <Line number="275">#  define __socklen_t_defined</Line>
  <Line number="276"># endif</Line>
  <Line number="277">#endif</Line>
  <Line number="278"></Line>
  <Line number="279">/* Values for the second argument to access.</Line>
  <Line number="280">   These may be OR&apos;d together.  */</Line>
  <Line number="281">#define	R_OK	4		/* Test for read permission.  */</Line>
  <Line number="282">#define	W_OK	2		/* Test for write permission.  */</Line>
  <Line number="283">#define	X_OK	1		/* Test for execute permission.  */</Line>
  <Line number="284">#define	F_OK	0		/* Test for existence.  */</Line>
  <Line number="285"></Line>
  <Line number="286">/* Test for access to NAME using the real UID and real GID.  */</Line>
  <Line number="287">extern int access (const char *__name, int __type) __THROW __nonnull ((1));</Line>
  <Line number="288"></Line>
  <Line number="289">#ifdef __USE_GNU</Line>
  <Line number="290">/* Test for access to NAME using the effective UID and GID</Line>
  <Line number="291">   (as normal file operations use).  */</Line>
  <Line number="292">extern int euidaccess (const char *__name, int __type)</Line>
  <Line number="293">     __THROW __nonnull ((1));</Line>
  <Line number="294"></Line>
  <Line number="295">/* An alias for `euidaccess&apos;, used by some other systems.  */</Line>
  <Line number="296">extern int eaccess (const char *__name, int __type)</Line>
  <Line number="297">     __THROW __nonnull ((1));</Line>
  <Line number="298">#endif</Line>
  <Line number="299"></Line>
  <Line number="300">#ifdef __USE_ATFILE</Line>
  <Line number="301">/* Test for access to FILE relative to the directory FD is open on.</Line>
  <Line number="302">   If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess&apos;,</Line>
  <Line number="303">   otherwise use real IDs like `access&apos;.  */</Line>
  <Line number="304">extern int faccessat (int __fd, const char *__file, int __type, int __flag)</Line>
  <Line number="305">     __THROW __nonnull ((2)) __wur;</Line>
  <Line number="306">#endif /* Use GNU.  */</Line>
  <Line number="307"></Line>
  <Line number="308"></Line>
  <Line number="309">/* Values for the WHENCE argument to lseek.  */</Line>
  <Line number="310">#ifndef	_STDIO_H		/* &lt;stdio.h&gt; has the same definitions.  */</Line>
  <Line number="311"># define SEEK_SET	0	/* Seek from beginning of file.  */</Line>
  <Line number="312"># define SEEK_CUR	1	/* Seek from current position.  */</Line>
  <Line number="313"># define SEEK_END	2	/* Seek from end of file.  */</Line>
  <Line number="314"># ifdef __USE_GNU</Line>
  <Line number="315">#  define SEEK_DATA	3	/* Seek to next data.  */</Line>
  <Line number="316">#  define SEEK_HOLE	4	/* Seek to next hole.  */</Line>
  <Line number="317"># endif</Line>
  <Line number="318">#endif</Line>
  <Line number="319"></Line>
  <Line number="320">#if defined __USE_MISC &amp;&amp; !defined L_SET</Line>
  <Line number="321">/* Old BSD names for the same constants; just for compatibility.  */</Line>
  <Line number="322"># define L_SET		SEEK_SET</Line>
  <Line number="323"># define L_INCR		SEEK_CUR</Line>
  <Line number="324"># define L_XTND		SEEK_END</Line>
  <Line number="325">#endif</Line>
  <Line number="326"></Line>
  <Line number="327"></Line>
  <Line number="328">/* Move FD&apos;s file position to OFFSET bytes from the</Line>
  <Line number="329">   beginning of the file (if WHENCE is SEEK_SET),</Line>
  <Line number="330">   the current position (if WHENCE is SEEK_CUR),</Line>
  <Line number="331">   or the end of the file (if WHENCE is SEEK_END).</Line>
  <Line number="332">   Return the new file position.  */</Line>
  <Line number="333">#ifndef __USE_FILE_OFFSET64</Line>
  <Line number="334">extern __off_t lseek (int __fd, __off_t __offset, int __whence) __THROW;</Line>
  <Line number="335">#else</Line>
  <Line number="336"># ifdef __REDIRECT_NTH</Line>
  <Line number="337">extern __off64_t __REDIRECT_NTH (lseek,</Line>
  <Line number="338">				 (int __fd, __off64_t __offset, int __whence),</Line>
  <Line number="339">				 lseek64);</Line>
  <Line number="340"># else</Line>
  <Line number="341">#  define lseek lseek64</Line>
  <Line number="342"># endif</Line>
  <Line number="343">#endif</Line>
  <Line number="344">#ifdef __USE_LARGEFILE64</Line>
  <Line number="345">extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)</Line>
  <Line number="346">     __THROW;</Line>
  <Line number="347">#endif</Line>
  <Line number="348"></Line>
  <Line number="349">/* Close the file descriptor FD.</Line>
  <Line number="350"></Line>
  <Line number="351">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="352">   __THROW.  */</Line>
  <Line number="353">extern int close (int __fd);</Line>
  <Line number="354"></Line>
  <Line number="355">/* Read NBYTES into BUF from FD.  Return the</Line>
  <Line number="356">   number read, -1 for errors or 0 for EOF.</Line>
  <Line number="357"></Line>
  <Line number="358">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="359">   __THROW.  */</Line>
  <Line number="360">extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __wur;</Line>
  <Line number="361"></Line>
  <Line number="362">/* Write N bytes of BUF to FD.  Return the number written, or -1.</Line>
  <Line number="363"></Line>
  <Line number="364">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="365">   __THROW.  */</Line>
  <Line number="366">extern ssize_t write (int __fd, const void *__buf, size_t __n) __wur;</Line>
  <Line number="367"></Line>
  <Line number="368">#if defined __USE_UNIX98 || defined __USE_XOPEN2K8</Line>
  <Line number="369"># ifndef __USE_FILE_OFFSET64</Line>
  <Line number="370">/* Read NBYTES into BUF from FD at the given position OFFSET without</Line>
  <Line number="371">   changing the file pointer.  Return the number read, -1 for errors</Line>
  <Line number="372">   or 0 for EOF.</Line>
  <Line number="373"></Line>
  <Line number="374">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="375">   __THROW.  */</Line>
  <Line number="376">extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,</Line>
  <Line number="377">		      __off_t __offset) __wur;</Line>
  <Line number="378"></Line>
  <Line number="379">/* Write N bytes of BUF to FD at the given position OFFSET without</Line>
  <Line number="380">   changing the file pointer.  Return the number written, or -1.</Line>
  <Line number="381"></Line>
  <Line number="382">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="383">   __THROW.  */</Line>
  <Line number="384">extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,</Line>
  <Line number="385">		       __off_t __offset) __wur;</Line>
  <Line number="386"># else</Line>
  <Line number="387">#  ifdef __REDIRECT</Line>
  <Line number="388">extern ssize_t __REDIRECT (pread, (int __fd, void *__buf, size_t __nbytes,</Line>
  <Line number="389">				   __off64_t __offset),</Line>
  <Line number="390">			   pread64) __wur;</Line>
  <Line number="391">extern ssize_t __REDIRECT (pwrite, (int __fd, const void *__buf,</Line>
  <Line number="392">				    size_t __nbytes, __off64_t __offset),</Line>
  <Line number="393">			   pwrite64) __wur;</Line>
  <Line number="394">#  else</Line>
  <Line number="395">#   define pread pread64</Line>
  <Line number="396">#   define pwrite pwrite64</Line>
  <Line number="397">#  endif</Line>
  <Line number="398"># endif</Line>
  <Line number="399"></Line>
  <Line number="400"># ifdef __USE_LARGEFILE64</Line>
  <Line number="401">/* Read NBYTES into BUF from FD at the given position OFFSET without</Line>
  <Line number="402">   changing the file pointer.  Return the number read, -1 for errors</Line>
  <Line number="403">   or 0 for EOF.  */</Line>
  <Line number="404">extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,</Line>
  <Line number="405">			__off64_t __offset) __wur;</Line>
  <Line number="406">/* Write N bytes of BUF to FD at the given position OFFSET without</Line>
  <Line number="407">   changing the file pointer.  Return the number written, or -1.  */</Line>
  <Line number="408">extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,</Line>
  <Line number="409">			 __off64_t __offset) __wur;</Line>
  <Line number="410"># endif</Line>
  <Line number="411">#endif</Line>
  <Line number="412"></Line>
  <Line number="413">/* Create a one-way communication channel (pipe).</Line>
  <Line number="414">   If successful, two file descriptors are stored in PIPEDES;</Line>
  <Line number="415">   bytes written on PIPEDES[1] can be read from PIPEDES[0].</Line>
  <Line number="416">   Returns 0 if successful, -1 if not.  */</Line>
  <Line number="417">extern int pipe (int __pipedes[2]) __THROW __wur;</Line>
  <Line number="418"></Line>
  <Line number="419">#ifdef __USE_GNU</Line>
  <Line number="420">/* Same as pipe but apply flags passed in FLAGS to the new file</Line>
  <Line number="421">   descriptors.  */</Line>
  <Line number="422">extern int pipe2 (int __pipedes[2], int __flags) __THROW __wur;</Line>
  <Line number="423">#endif</Line>
  <Line number="424"></Line>
  <Line number="425">/* Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.</Line>
  <Line number="426">   If SECONDS is zero, any currently scheduled alarm will be cancelled.</Line>
  <Line number="427">   The function returns the number of seconds remaining until the last</Line>
  <Line number="428">   alarm scheduled would have signaled, or zero if there wasn&apos;t one.</Line>
  <Line number="429">   There is no return value to indicate an error, but you can set `errno&apos;</Line>
  <Line number="430">   to 0 and check its value after calling `alarm&apos;, and this might tell you.</Line>
  <Line number="431">   The signal may come late due to processor scheduling.  */</Line>
  <Line number="432">extern unsigned int alarm (unsigned int __seconds) __THROW;</Line>
  <Line number="433"></Line>
  <Line number="434">/* Make the process sleep for SECONDS seconds, or until a signal arrives</Line>
  <Line number="435">   and is not ignored.  The function returns the number of seconds less</Line>
  <Line number="436">   than SECONDS which it actually slept (thus zero if it slept the full time).</Line>
  <Line number="437">   If a signal handler does a `longjmp&apos; or modifies the handling of the</Line>
  <Line number="438">   SIGALRM signal while inside `sleep&apos; call, the handling of the SIGALRM</Line>
  <Line number="439">   signal afterwards is undefined.  There is no return value to indicate</Line>
  <Line number="440">   error, but if `sleep&apos; returns SECONDS, it probably didn&apos;t work.</Line>
  <Line number="441"></Line>
  <Line number="442">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="443">   __THROW.  */</Line>
  <Line number="444">extern unsigned int sleep (unsigned int __seconds);</Line>
  <Line number="445"></Line>
  <Line number="446">#if (defined __USE_XOPEN_EXTENDED &amp;&amp; !defined __USE_XOPEN2K8) \</Line>
  <Line number="447">    || defined __USE_MISC</Line>
  <Line number="448">/* Set an alarm to go off (generating a SIGALRM signal) in VALUE</Line>
  <Line number="449">   microseconds.  If INTERVAL is nonzero, when the alarm goes off, the</Line>
  <Line number="450">   timer is reset to go off every INTERVAL microseconds thereafter.</Line>
  <Line number="451">   Returns the number of microseconds remaining before the alarm.  */</Line>
  <Line number="452">extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)</Line>
  <Line number="453">     __THROW;</Line>
  <Line number="454"></Line>
  <Line number="455">/* Sleep USECONDS microseconds, or until a signal arrives that is not blocked</Line>
  <Line number="456">   or ignored.</Line>
  <Line number="457"></Line>
  <Line number="458">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="459">   __THROW.  */</Line>
  <Line number="460">extern int usleep (__useconds_t __useconds);</Line>
  <Line number="461">#endif</Line>
  <Line number="462"></Line>
  <Line number="463"></Line>
  <Line number="464">/* Suspend the process until a signal arrives.</Line>
  <Line number="465">   This always returns -1 and sets `errno&apos; to EINTR.</Line>
  <Line number="466"></Line>
  <Line number="467">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="468">   __THROW.  */</Line>
  <Line number="469">extern int pause (void);</Line>
  <Line number="470"></Line>
  <Line number="471"></Line>
  <Line number="472">/* Change the owner and group of FILE.  */</Line>
  <Line number="473">extern int chown (const char *__file, __uid_t __owner, __gid_t __group)</Line>
  <Line number="474">     __THROW __nonnull ((1)) __wur;</Line>
  <Line number="475"></Line>
  <Line number="476">#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8</Line>
  <Line number="477">/* Change the owner and group of the file that FD is open on.  */</Line>
  <Line number="478">extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __THROW __wur;</Line>
  <Line number="479"></Line>
  <Line number="480"></Line>
  <Line number="481">/* Change owner and group of FILE, if it is a symbolic</Line>
  <Line number="482">   link the ownership of the symbolic link is changed.  */</Line>
  <Line number="483">extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)</Line>
  <Line number="484">     __THROW __nonnull ((1)) __wur;</Line>
  <Line number="485"></Line>
  <Line number="486">#endif /* Use X/Open Unix.  */</Line>
  <Line number="487"></Line>
  <Line number="488">#ifdef __USE_ATFILE</Line>
  <Line number="489">/* Change the owner and group of FILE relative to the directory FD is open</Line>
  <Line number="490">   on.  */</Line>
  <Line number="491">extern int fchownat (int __fd, const char *__file, __uid_t __owner,</Line>
  <Line number="492">		     __gid_t __group, int __flag)</Line>
  <Line number="493">     __THROW __nonnull ((2)) __wur;</Line>
  <Line number="494">#endif /* Use GNU.  */</Line>
  <Line number="495"></Line>
  <Line number="496">/* Change the process&apos;s working directory to PATH.  */</Line>
  <Line number="497">extern int chdir (const char *__path) __THROW __nonnull ((1)) __wur;</Line>
  <Line number="498"></Line>
  <Line number="499">#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8</Line>
  <Line number="500">/* Change the process&apos;s working directory to the one FD is open on.  */</Line>
  <Line number="501">extern int fchdir (int __fd) __THROW __wur;</Line>
  <Line number="502">#endif</Line>
  <Line number="503"></Line>
  <Line number="504">/* Get the pathname of the current working directory,</Line>
  <Line number="505">   and put it in SIZE bytes of BUF.  Returns NULL if the</Line>
  <Line number="506">   directory couldn&apos;t be determined or SIZE was too small.</Line>
  <Line number="507">   If successful, returns BUF.  In GNU, if BUF is NULL,</Line>
  <Line number="508">   an array is allocated with `malloc&apos;; the array is SIZE</Line>
  <Line number="509">   bytes long, unless SIZE == 0, in which case it is as</Line>
  <Line number="510">   big as necessary.  */</Line>
  <Line number="511">extern char *getcwd (char *__buf, size_t __size) __THROW __wur;</Line>
  <Line number="512"></Line>
  <Line number="513">#ifdef	__USE_GNU</Line>
  <Line number="514">/* Return a malloc&apos;d string containing the current directory name.</Line>
  <Line number="515">   If the environment variable `PWD&apos; is set, and its value is correct,</Line>
  <Line number="516">   that value is used.  */</Line>
  <Line number="517">extern char *get_current_dir_name (void) __THROW;</Line>
  <Line number="518">#endif</Line>
  <Line number="519"></Line>
  <Line number="520">#if (defined __USE_XOPEN_EXTENDED &amp;&amp; !defined __USE_XOPEN2K8) \</Line>
  <Line number="521">    || defined __USE_MISC</Line>
  <Line number="522">/* Put the absolute pathname of the current working directory in BUF.</Line>
  <Line number="523">   If successful, return BUF.  If not, put an error message in</Line>
  <Line number="524">   BUF and return NULL.  BUF should be at least PATH_MAX bytes long.  */</Line>
  <Line number="525">extern char *getwd (char *__buf)</Line>
  <Line number="526">     __THROW __nonnull ((1)) __attribute_deprecated__ __wur;</Line>
  <Line number="527">#endif</Line>
  <Line number="528"></Line>
  <Line number="529"></Line>
  <Line number="530">/* Duplicate FD, returning a new file descriptor on the same file.  */</Line>
  <Line number="531">extern int dup (int __fd) __THROW __wur;</Line>
  <Line number="532"></Line>
  <Line number="533">/* Duplicate FD to FD2, closing FD2 and making it open on the same file.  */</Line>
  <Line number="534">extern int dup2 (int __fd, int __fd2) __THROW;</Line>
  <Line number="535"></Line>
  <Line number="536">#ifdef __USE_GNU</Line>
  <Line number="537">/* Duplicate FD to FD2, closing FD2 and making it open on the same</Line>
  <Line number="538">   file while setting flags according to FLAGS.  */</Line>
  <Line number="539">extern int dup3 (int __fd, int __fd2, int __flags) __THROW;</Line>
  <Line number="540">#endif</Line>
  <Line number="541"></Line>
  <Line number="542">/* NULL-terminated array of &quot;NAME=VALUE&quot; environment variables.  */</Line>
  <Line number="543">extern char **__environ;</Line>
  <Line number="544">#ifdef __USE_GNU</Line>
  <Line number="545">extern char **environ;</Line>
  <Line number="546">#endif</Line>
  <Line number="547"></Line>
  <Line number="548"></Line>
  <Line number="549">/* Replace the current process, executing PATH with arguments ARGV and</Line>
  <Line number="550">   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */</Line>
  <Line number="551">extern int execve (const char *__path, char *const __argv[],</Line>
  <Line number="552">		   char *const __envp[]) __THROW __nonnull ((1, 2));</Line>
  <Line number="553"></Line>
  <Line number="554">#ifdef __USE_XOPEN2K8</Line>
  <Line number="555">/* Execute the file FD refers to, overlaying the running program image.</Line>
  <Line number="556">   ARGV and ENVP are passed to the new program, as for `execve&apos;.  */</Line>
  <Line number="557">extern int fexecve (int __fd, char *const __argv[], char *const __envp[])</Line>
  <Line number="558">     __THROW __nonnull ((2));</Line>
  <Line number="559">#endif</Line>
  <Line number="560"></Line>
  <Line number="561"></Line>
  <Line number="562">/* Execute PATH with arguments ARGV and environment from `environ&apos;.  */</Line>
  <Line number="563">extern int execv (const char *__path, char *const __argv[])</Line>
  <Line number="564">     __THROW __nonnull ((1, 2));</Line>
  <Line number="565"></Line>
  <Line number="566">/* Execute PATH with all arguments after PATH until a NULL pointer,</Line>
  <Line number="567">   and the argument after that for environment.  */</Line>
  <Line number="568">extern int execle (const char *__path, const char *__arg, ...)</Line>
  <Line number="569">     __THROW __nonnull ((1, 2));</Line>
  <Line number="570"></Line>
  <Line number="571">/* Execute PATH with all arguments after PATH until</Line>
  <Line number="572">   a NULL pointer and environment from `environ&apos;.  */</Line>
  <Line number="573">extern int execl (const char *__path, const char *__arg, ...)</Line>
  <Line number="574">     __THROW __nonnull ((1, 2));</Line>
  <Line number="575"></Line>
  <Line number="576">/* Execute FILE, searching in the `PATH&apos; environment variable if it contains</Line>
  <Line number="577">   no slashes, with arguments ARGV and environment from `environ&apos;.  */</Line>
  <Line number="578">extern int execvp (const char *__file, char *const __argv[])</Line>
  <Line number="579">     __THROW __nonnull ((1, 2));</Line>
  <Line number="580"></Line>
  <Line number="581">/* Execute FILE, searching in the `PATH&apos; environment variable if</Line>
  <Line number="582">   it contains no slashes, with all arguments after FILE until a</Line>
  <Line number="583">   NULL pointer and environment from `environ&apos;.  */</Line>
  <Line number="584">extern int execlp (const char *__file, const char *__arg, ...)</Line>
  <Line number="585">     __THROW __nonnull ((1, 2));</Line>
  <Line number="586"></Line>
  <Line number="587">#ifdef __USE_GNU</Line>
  <Line number="588">/* Execute FILE, searching in the `PATH&apos; environment variable if it contains</Line>
  <Line number="589">   no slashes, with arguments ARGV and environment from `environ&apos;.  */</Line>
  <Line number="590">extern int execvpe (const char *__file, char *const __argv[],</Line>
  <Line number="591">		    char *const __envp[])</Line>
  <Line number="592">     __THROW __nonnull ((1, 2));</Line>
  <Line number="593">#endif</Line>
  <Line number="594"></Line>
  <Line number="595"></Line>
  <Line number="596">#if defined __USE_MISC || defined __USE_XOPEN</Line>
  <Line number="597">/* Add INC to priority of the current process.  */</Line>
  <Line number="598">extern int nice (int __inc) __THROW __wur;</Line>
  <Line number="599">#endif</Line>
  <Line number="600"></Line>
  <Line number="601"></Line>
  <Line number="602">/* Terminate program execution with the low-order 8 bits of STATUS.  */</Line>
  <Line number="603">extern void _exit (int __status) __attribute__ ((__noreturn__));</Line>
  <Line number="604"></Line>
  <Line number="605"></Line>
  <Line number="606">/* Get the `_PC_*&apos; symbols for the NAME argument to `pathconf&apos; and `fpathconf&apos;;</Line>
  <Line number="607">   the `_SC_*&apos; symbols for the NAME argument to `sysconf&apos;;</Line>
  <Line number="608">   and the `_CS_*&apos; symbols for the NAME argument to `confstr&apos;.  */</Line>
  <Line number="609">#include &lt;bits/confname.h&gt;</Line>
  <Line number="610"></Line>
  <Line number="611">/* Get file-specific configuration information about PATH.  */</Line>
  <Line number="612">extern long int pathconf (const char *__path, int __name)</Line>
  <Line number="613">     __THROW __nonnull ((1));</Line>
  <Line number="614"></Line>
  <Line number="615">/* Get file-specific configuration about descriptor FD.  */</Line>
  <Line number="616">extern long int fpathconf (int __fd, int __name) __THROW;</Line>
  <Line number="617"></Line>
  <Line number="618">/* Get the value of the system variable NAME.  */</Line>
  <Line number="619">extern long int sysconf (int __name) __THROW;</Line>
  <Line number="620"></Line>
  <Line number="621">#ifdef	__USE_POSIX2</Line>
  <Line number="622">/* Get the value of the string-valued system variable NAME.  */</Line>
  <Line number="623">extern size_t confstr (int __name, char *__buf, size_t __len) __THROW;</Line>
  <Line number="624">#endif</Line>
  <Line number="625"></Line>
  <Line number="626"></Line>
  <Line number="627">/* Get the process ID of the calling process.  */</Line>
  <Line number="628">extern __pid_t getpid (void) __THROW;</Line>
  <Line number="629"></Line>
  <Line number="630">/* Get the process ID of the calling process&apos;s parent.  */</Line>
  <Line number="631">extern __pid_t getppid (void) __THROW;</Line>
  <Line number="632"></Line>
  <Line number="633">/* Get the process group ID of the calling process.  */</Line>
  <Line number="634">extern __pid_t getpgrp (void) __THROW;</Line>
  <Line number="635"></Line>
  <Line number="636">/* Get the process group ID of process PID.  */</Line>
  <Line number="637">extern __pid_t __getpgid (__pid_t __pid) __THROW;</Line>
  <Line number="638">#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8</Line>
  <Line number="639">extern __pid_t getpgid (__pid_t __pid) __THROW;</Line>
  <Line number="640">#endif</Line>
  <Line number="641"></Line>
  <Line number="642"></Line>
  <Line number="643">/* Set the process group ID of the process matching PID to PGID.</Line>
  <Line number="644">   If PID is zero, the current process&apos;s process group ID is set.</Line>
  <Line number="645">   If PGID is zero, the process ID of the process is used.  */</Line>
  <Line number="646">extern int setpgid (__pid_t __pid, __pid_t __pgid) __THROW;</Line>
  <Line number="647"></Line>
  <Line number="648">#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED</Line>
  <Line number="649">/* Both System V and BSD have `setpgrp&apos; functions, but with different</Line>
  <Line number="650">   calling conventions.  The BSD function is the same as POSIX.1 `setpgid&apos;</Line>
  <Line number="651">   (above).  The System V function takes no arguments and puts the calling</Line>
  <Line number="652">   process in its on group like `setpgid (0, 0)&apos;.</Line>
  <Line number="653"></Line>
  <Line number="654">   New programs should always use `setpgid&apos; instead.</Line>
  <Line number="655"></Line>
  <Line number="656">   GNU provides the POSIX.1 function.  */</Line>
  <Line number="657"></Line>
  <Line number="658">/* Set the process group ID of the calling process to its own PID.</Line>
  <Line number="659">   This is exactly the same as `setpgid (0, 0)&apos;.  */</Line>
  <Line number="660">extern int setpgrp (void) __THROW;</Line>
  <Line number="661"></Line>
  <Line number="662">#endif	/* Use misc or X/Open.  */</Line>
  <Line number="663"></Line>
  <Line number="664">/* Create a new session with the calling process as its leader.</Line>
  <Line number="665">   The process group IDs of the session and the calling process</Line>
  <Line number="666">   are set to the process ID of the calling process, which is returned.  */</Line>
  <Line number="667">extern __pid_t setsid (void) __THROW;</Line>
  <Line number="668"></Line>
  <Line number="669">#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8</Line>
  <Line number="670">/* Return the session ID of the given process.  */</Line>
  <Line number="671">extern __pid_t getsid (__pid_t __pid) __THROW;</Line>
  <Line number="672">#endif</Line>
  <Line number="673"></Line>
  <Line number="674">/* Get the real user ID of the calling process.  */</Line>
  <Line number="675">extern __uid_t getuid (void) __THROW;</Line>
  <Line number="676"></Line>
  <Line number="677">/* Get the effective user ID of the calling process.  */</Line>
  <Line number="678">extern __uid_t geteuid (void) __THROW;</Line>
  <Line number="679"></Line>
  <Line number="680">/* Get the real group ID of the calling process.  */</Line>
  <Line number="681">extern __gid_t getgid (void) __THROW;</Line>
  <Line number="682"></Line>
  <Line number="683">/* Get the effective group ID of the calling process.  */</Line>
  <Line number="684">extern __gid_t getegid (void) __THROW;</Line>
  <Line number="685"></Line>
  <Line number="686">/* If SIZE is zero, return the number of supplementary groups</Line>
  <Line number="687">   the calling process is in.  Otherwise, fill in the group IDs</Line>
  <Line number="688">   of its supplementary groups in LIST and return the number written.  */</Line>
  <Line number="689">extern int getgroups (int __size, __gid_t __list[]) __THROW __wur;</Line>
  <Line number="690"></Line>
  <Line number="691">#ifdef	__USE_GNU</Line>
  <Line number="692">/* Return nonzero iff the calling process is in group GID.  */</Line>
  <Line number="693">extern int group_member (__gid_t __gid) __THROW;</Line>
  <Line number="694">#endif</Line>
  <Line number="695"></Line>
  <Line number="696">/* Set the user ID of the calling process to UID.</Line>
  <Line number="697">   If the calling process is the super-user, set the real</Line>
  <Line number="698">   and effective user IDs, and the saved set-user-ID to UID;</Line>
  <Line number="699">   if not, the effective user ID is set to UID.  */</Line>
  <Line number="700">extern int setuid (__uid_t __uid) __THROW __wur;</Line>
  <Line number="701"></Line>
  <Line number="702">#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED</Line>
  <Line number="703">/* Set the real user ID of the calling process to RUID,</Line>
  <Line number="704">   and the effective user ID of the calling process to EUID.  */</Line>
  <Line number="705">extern int setreuid (__uid_t __ruid, __uid_t __euid) __THROW __wur;</Line>
  <Line number="706">#endif</Line>
  <Line number="707"></Line>
  <Line number="708">#ifdef __USE_XOPEN2K</Line>
  <Line number="709">/* Set the effective user ID of the calling process to UID.  */</Line>
  <Line number="710">extern int seteuid (__uid_t __uid) __THROW __wur;</Line>
  <Line number="711">#endif /* Use POSIX.1-2001.  */</Line>
  <Line number="712"></Line>
  <Line number="713">/* Set the group ID of the calling process to GID.</Line>
  <Line number="714">   If the calling process is the super-user, set the real</Line>
  <Line number="715">   and effective group IDs, and the saved set-group-ID to GID;</Line>
  <Line number="716">   if not, the effective group ID is set to GID.  */</Line>
  <Line number="717">extern int setgid (__gid_t __gid) __THROW __wur;</Line>
  <Line number="718"></Line>
  <Line number="719">#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED</Line>
  <Line number="720">/* Set the real group ID of the calling process to RGID,</Line>
  <Line number="721">   and the effective group ID of the calling process to EGID.  */</Line>
  <Line number="722">extern int setregid (__gid_t __rgid, __gid_t __egid) __THROW __wur;</Line>
  <Line number="723">#endif</Line>
  <Line number="724"></Line>
  <Line number="725">#ifdef __USE_XOPEN2K</Line>
  <Line number="726">/* Set the effective group ID of the calling process to GID.  */</Line>
  <Line number="727">extern int setegid (__gid_t __gid) __THROW __wur;</Line>
  <Line number="728">#endif /* Use POSIX.1-2001.  */</Line>
  <Line number="729"></Line>
  <Line number="730">#ifdef __USE_GNU</Line>
  <Line number="731">/* Fetch the real user ID, effective user ID, and saved-set user ID,</Line>
  <Line number="732">   of the calling process.  */</Line>
  <Line number="733">extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)</Line>
  <Line number="734">     __THROW;</Line>
  <Line number="735"></Line>
  <Line number="736">/* Fetch the real group ID, effective group ID, and saved-set group ID,</Line>
  <Line number="737">   of the calling process.  */</Line>
  <Line number="738">extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)</Line>
  <Line number="739">     __THROW;</Line>
  <Line number="740"></Line>
  <Line number="741">/* Set the real user ID, effective user ID, and saved-set user ID,</Line>
  <Line number="742">   of the calling process to RUID, EUID, and SUID, respectively.  */</Line>
  <Line number="743">extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)</Line>
  <Line number="744">     __THROW __wur;</Line>
  <Line number="745"></Line>
  <Line number="746">/* Set the real group ID, effective group ID, and saved-set group ID,</Line>
  <Line number="747">   of the calling process to RGID, EGID, and SGID, respectively.  */</Line>
  <Line number="748">extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)</Line>
  <Line number="749">     __THROW __wur;</Line>
  <Line number="750">#endif</Line>
  <Line number="751"></Line>
  <Line number="752"></Line>
  <Line number="753">/* Clone the calling process, creating an exact copy.</Line>
  <Line number="754">   Return -1 for errors, 0 to the new process,</Line>
  <Line number="755">   and the process ID of the new process to the old process.  */</Line>
  <Line number="756">extern __pid_t fork (void) __THROWNL;</Line>
  <Line number="757"></Line>
  <Line number="758">#if (defined __USE_XOPEN_EXTENDED &amp;&amp; !defined __USE_XOPEN2K8) \</Line>
  <Line number="759">    || defined __USE_MISC</Line>
  <Line number="760">/* Clone the calling process, but without copying the whole address space.</Line>
  <Line number="761">   The calling process is suspended until the new process exits or is</Line>
  <Line number="762">   replaced by a call to `execve&apos;.  Return -1 for errors, 0 to the new process,</Line>
  <Line number="763">   and the process ID of the new process to the old process.  */</Line>
  <Line number="764">extern __pid_t vfork (void) __THROW;</Line>
  <Line number="765">#endif /* Use misc or XPG &lt; 7. */</Line>
  <Line number="766"></Line>
  <Line number="767"></Line>
  <Line number="768">/* Return the pathname of the terminal FD is open on, or NULL on errors.</Line>
  <Line number="769">   The returned storage is good only until the next call to this function.  */</Line>
  <Line number="770">extern char *ttyname (int __fd) __THROW;</Line>
  <Line number="771"></Line>
  <Line number="772">/* Store at most BUFLEN characters of the pathname of the terminal FD is</Line>
  <Line number="773">   open on in BUF.  Return 0 on success, otherwise an error number.  */</Line>
  <Line number="774">extern int ttyname_r (int __fd, char *__buf, size_t __buflen)</Line>
  <Line number="775">     __THROW __nonnull ((2)) __wur;</Line>
  <Line number="776"></Line>
  <Line number="777">/* Return 1 if FD is a valid descriptor associated</Line>
  <Line number="778">   with a terminal, zero if not.  */</Line>
  <Line number="779">extern int isatty (int __fd) __THROW;</Line>
  <Line number="780"></Line>
  <Line number="781">#ifdef __USE_MISC</Line>
  <Line number="782">/* Return the index into the active-logins file (utmp) for</Line>
  <Line number="783">   the controlling terminal.  */</Line>
  <Line number="784">extern int ttyslot (void) __THROW;</Line>
  <Line number="785">#endif</Line>
  <Line number="786"></Line>
  <Line number="787"></Line>
  <Line number="788">/* Make a link to FROM named TO.  */</Line>
  <Line number="789">extern int link (const char *__from, const char *__to)</Line>
  <Line number="790">     __THROW __nonnull ((1, 2)) __wur;</Line>
  <Line number="791"></Line>
  <Line number="792">#ifdef __USE_ATFILE</Line>
  <Line number="793">/* Like link but relative paths in TO and FROM are interpreted relative</Line>
  <Line number="794">   to FROMFD and TOFD respectively.  */</Line>
  <Line number="795">extern int linkat (int __fromfd, const char *__from, int __tofd,</Line>
  <Line number="796">		   const char *__to, int __flags)</Line>
  <Line number="797">     __THROW __nonnull ((2, 4)) __wur;</Line>
  <Line number="798">#endif</Line>
  <Line number="799"></Line>
  <Line number="800">#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K</Line>
  <Line number="801">/* Make a symbolic link to FROM named TO.  */</Line>
  <Line number="802">extern int symlink (const char *__from, const char *__to)</Line>
  <Line number="803">     __THROW __nonnull ((1, 2)) __wur;</Line>
  <Line number="804"></Line>
  <Line number="805">/* Read the contents of the symbolic link PATH into no more than</Line>
  <Line number="806">   LEN bytes of BUF.  The contents are not null-terminated.</Line>
  <Line number="807">   Returns the number of characters read, or -1 for errors.  */</Line>
  <Line number="808">extern ssize_t readlink (const char *__restrict __path,</Line>
  <Line number="809">			 char *__restrict __buf, size_t __len)</Line>
  <Line number="810">     __THROW __nonnull ((1, 2)) __wur;</Line>
  <Line number="811">#endif /* Use POSIX.1-2001.  */</Line>
  <Line number="812"></Line>
  <Line number="813">#ifdef __USE_ATFILE</Line>
  <Line number="814">/* Like symlink but a relative path in TO is interpreted relative to TOFD.  */</Line>
  <Line number="815">extern int symlinkat (const char *__from, int __tofd,</Line>
  <Line number="816">		      const char *__to) __THROW __nonnull ((1, 3)) __wur;</Line>
  <Line number="817"></Line>
  <Line number="818">/* Like readlink but a relative PATH is interpreted relative to FD.  */</Line>
  <Line number="819">extern ssize_t readlinkat (int __fd, const char *__restrict __path,</Line>
  <Line number="820">			   char *__restrict __buf, size_t __len)</Line>
  <Line number="821">     __THROW __nonnull ((2, 3)) __wur;</Line>
  <Line number="822">#endif</Line>
  <Line number="823"></Line>
  <Line number="824">/* Remove the link NAME.  */</Line>
  <Line number="825">extern int unlink (const char *__name) __THROW __nonnull ((1));</Line>
  <Line number="826"></Line>
  <Line number="827">#ifdef __USE_ATFILE</Line>
  <Line number="828">/* Remove the link NAME relative to FD.  */</Line>
  <Line number="829">extern int unlinkat (int __fd, const char *__name, int __flag)</Line>
  <Line number="830">     __THROW __nonnull ((2));</Line>
  <Line number="831">#endif</Line>
  <Line number="832"></Line>
  <Line number="833">/* Remove the directory PATH.  */</Line>
  <Line number="834">extern int rmdir (const char *__path) __THROW __nonnull ((1));</Line>
  <Line number="835"></Line>
  <Line number="836"></Line>
  <Line number="837">/* Return the foreground process group ID of FD.  */</Line>
  <Line number="838">extern __pid_t tcgetpgrp (int __fd) __THROW;</Line>
  <Line number="839"></Line>
  <Line number="840">/* Set the foreground process group ID of FD set PGRP_ID.  */</Line>
  <Line number="841">extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __THROW;</Line>
  <Line number="842"></Line>
  <Line number="843"></Line>
  <Line number="844">/* Return the login name of the user.</Line>
  <Line number="845"></Line>
  <Line number="846">   This function is a possible cancellation point and therefore not</Line>
  <Line number="847">   marked with __THROW.  */</Line>
  <Line number="848">extern char *getlogin (void);</Line>
  <Line number="849">#ifdef __USE_POSIX199506</Line>
  <Line number="850">/* Return at most NAME_LEN characters of the login name of the user in NAME.</Line>
  <Line number="851">   If it cannot be determined or some other error occurred, return the error</Line>
  <Line number="852">   code.  Otherwise return 0.</Line>
  <Line number="853"></Line>
  <Line number="854">   This function is a possible cancellation point and therefore not</Line>
  <Line number="855">   marked with __THROW.  */</Line>
  <Line number="856">extern int getlogin_r (char *__name, size_t __name_len) __nonnull ((1));</Line>
  <Line number="857">#endif</Line>
  <Line number="858"></Line>
  <Line number="859">#ifdef	__USE_MISC</Line>
  <Line number="860">/* Set the login name returned by `getlogin&apos;.  */</Line>
  <Line number="861">extern int setlogin (const char *__name) __THROW __nonnull ((1));</Line>
  <Line number="862">#endif</Line>
  <Line number="863"></Line>
  <Line number="864"></Line>
  <Line number="865">#ifdef	__USE_POSIX2</Line>
  <Line number="866">/* Get definitions and prototypes for functions to process the</Line>
  <Line number="867">   arguments in ARGV (ARGC of them, minus the program name) for</Line>
  <Line number="868">   options given in OPTS.  */</Line>
  <Line number="869"># include &lt;bits/getopt_posix.h&gt;</Line>
  <Line number="870">#endif</Line>
  <Line number="871"></Line>
  <Line number="872"></Line>
  <Line number="873">#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K</Line>
  <Line number="874">/* Put the name of the current host in no more than LEN bytes of NAME.</Line>
  <Line number="875">   The result is null-terminated if LEN is large enough for the full</Line>
  <Line number="876">   name and the terminator.  */</Line>
  <Line number="877">extern int gethostname (char *__name, size_t __len) __THROW __nonnull ((1));</Line>
  <Line number="878">#endif</Line>
  <Line number="879"></Line>
  <Line number="880"></Line>
  <Line number="881">#if defined __USE_MISC</Line>
  <Line number="882">/* Set the name of the current host to NAME, which is LEN bytes long.</Line>
  <Line number="883">   This call is restricted to the super-user.  */</Line>
  <Line number="884">extern int sethostname (const char *__name, size_t __len)</Line>
  <Line number="885">     __THROW __nonnull ((1)) __wur;</Line>
  <Line number="886"></Line>
  <Line number="887">/* Set the current machine&apos;s Internet number to ID.</Line>
  <Line number="888">   This call is restricted to the super-user.  */</Line>
  <Line number="889">extern int sethostid (long int __id) __THROW __wur;</Line>
  <Line number="890"></Line>
  <Line number="891"></Line>
  <Line number="892">/* Get and set the NIS (aka YP) domain name, if any.</Line>
  <Line number="893">   Called just like `gethostname&apos; and `sethostname&apos;.</Line>
  <Line number="894">   The NIS domain name is usually the empty string when not using NIS.  */</Line>
  <Line number="895">extern int getdomainname (char *__name, size_t __len)</Line>
  <Line number="896">     __THROW __nonnull ((1)) __wur;</Line>
  <Line number="897">extern int setdomainname (const char *__name, size_t __len)</Line>
  <Line number="898">     __THROW __nonnull ((1)) __wur;</Line>
  <Line number="899"></Line>
  <Line number="900"></Line>
  <Line number="901">/* Revoke access permissions to all processes currently communicating</Line>
  <Line number="902">   with the control terminal, and then send a SIGHUP signal to the process</Line>
  <Line number="903">   group of the control terminal.  */</Line>
  <Line number="904">extern int vhangup (void) __THROW;</Line>
  <Line number="905"></Line>
  <Line number="906">/* Revoke the access of all descriptors currently open on FILE.  */</Line>
  <Line number="907">extern int revoke (const char *__file) __THROW __nonnull ((1)) __wur;</Line>
  <Line number="908"></Line>
  <Line number="909"></Line>
  <Line number="910">/* Enable statistical profiling, writing samples of the PC into at most</Line>
  <Line number="911">   SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling</Line>
  <Line number="912">   is enabled, the system examines the user PC and increments</Line>
  <Line number="913">   SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,</Line>
  <Line number="914">   disable profiling.  Returns zero on success, -1 on error.  */</Line>
  <Line number="915">extern int profil (unsigned short int *__sample_buffer, size_t __size,</Line>
  <Line number="916">		   size_t __offset, unsigned int __scale)</Line>
  <Line number="917">     __THROW __nonnull ((1));</Line>
  <Line number="918"></Line>
  <Line number="919"></Line>
  <Line number="920">/* Turn accounting on if NAME is an existing file.  The system will then write</Line>
  <Line number="921">   a record for each process as it terminates, to this file.  If NAME is NULL,</Line>
  <Line number="922">   turn accounting off.  This call is restricted to the super-user.  */</Line>
  <Line number="923">extern int acct (const char *__name) __THROW;</Line>
  <Line number="924"></Line>
  <Line number="925"></Line>
  <Line number="926">/* Successive calls return the shells listed in `/etc/shells&apos;.  */</Line>
  <Line number="927">extern char *getusershell (void) __THROW;</Line>
  <Line number="928">extern void endusershell (void) __THROW; /* Discard cached info.  */</Line>
  <Line number="929">extern void setusershell (void) __THROW; /* Rewind and re-read the file.  */</Line>
  <Line number="930"></Line>
  <Line number="931"></Line>
  <Line number="932">/* Put the program in the background, and dissociate from the controlling</Line>
  <Line number="933">   terminal.  If NOCHDIR is zero, do `chdir (&quot;/&quot;)&apos;.  If NOCLOSE is zero,</Line>
  <Line number="934">   redirects stdin, stdout, and stderr to /dev/null.  */</Line>
  <Line number="935">extern int daemon (int __nochdir, int __noclose) __THROW __wur;</Line>
  <Line number="936">#endif /* Use misc.  */</Line>
  <Line number="937"></Line>
  <Line number="938"></Line>
  <Line number="939">#if defined __USE_MISC || (defined __USE_XOPEN &amp;&amp; !defined __USE_XOPEN2K)</Line>
  <Line number="940">/* Make PATH be the root directory (the starting point for absolute paths).</Line>
  <Line number="941">   This call is restricted to the super-user.  */</Line>
  <Line number="942">extern int chroot (const char *__path) __THROW __nonnull ((1)) __wur;</Line>
  <Line number="943"></Line>
  <Line number="944">/* Prompt with PROMPT and read a string from the terminal without echoing.</Line>
  <Line number="945">   Uses /dev/tty if possible; otherwise stderr and stdin.  */</Line>
  <Line number="946">extern char *getpass (const char *__prompt) __nonnull ((1));</Line>
  <Line number="947">#endif /* Use misc || X/Open.  */</Line>
  <Line number="948"></Line>
  <Line number="949"></Line>
  <Line number="950">/* Make all changes done to FD actually appear on disk.</Line>
  <Line number="951"></Line>
  <Line number="952">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="953">   __THROW.  */</Line>
  <Line number="954">extern int fsync (int __fd);</Line>
  <Line number="955"></Line>
  <Line number="956"></Line>
  <Line number="957">#ifdef __USE_GNU</Line>
  <Line number="958">/* Make all changes done to all files on the file system associated</Line>
  <Line number="959">   with FD actually appear on disk.  */</Line>
  <Line number="960">extern int syncfs (int __fd) __THROW;</Line>
  <Line number="961">#endif</Line>
  <Line number="962"></Line>
  <Line number="963"></Line>
  <Line number="964">#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED</Line>
  <Line number="965"></Line>
  <Line number="966">/* Return identifier for the current host.  */</Line>
  <Line number="967">extern long int gethostid (void);</Line>
  <Line number="968"></Line>
  <Line number="969">/* Make all changes done to all files actually appear on disk.  */</Line>
  <Line number="970">extern void sync (void) __THROW;</Line>
  <Line number="971"></Line>
  <Line number="972"></Line>
  <Line number="973"># if defined __USE_MISC || !defined __USE_XOPEN2K</Line>
  <Line number="974">/* Return the number of bytes in a page.  This is the system&apos;s page size,</Line>
  <Line number="975">   which is not necessarily the same as the hardware page size.  */</Line>
  <Line number="976">extern int getpagesize (void)  __THROW __attribute__ ((__const__));</Line>
  <Line number="977"></Line>
  <Line number="978"></Line>
  <Line number="979">/* Return the maximum number of file descriptors</Line>
  <Line number="980">   the current process could possibly have.  */</Line>
  <Line number="981">extern int getdtablesize (void) __THROW;</Line>
  <Line number="982"># endif</Line>
  <Line number="983"></Line>
  <Line number="984">#endif /* Use misc || X/Open Unix.  */</Line>
  <Line number="985"></Line>
  <Line number="986"></Line>
  <Line number="987">#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8</Line>
  <Line number="988"></Line>
  <Line number="989">/* Truncate FILE to LENGTH bytes.  */</Line>
  <Line number="990"># ifndef __USE_FILE_OFFSET64</Line>
  <Line number="991">extern int truncate (const char *__file, __off_t __length)</Line>
  <Line number="992">     __THROW __nonnull ((1)) __wur;</Line>
  <Line number="993"># else</Line>
  <Line number="994">#  ifdef __REDIRECT_NTH</Line>
  <Line number="995">extern int __REDIRECT_NTH (truncate,</Line>
  <Line number="996">			   (const char *__file, __off64_t __length),</Line>
  <Line number="997">			   truncate64) __nonnull ((1)) __wur;</Line>
  <Line number="998">#  else</Line>
  <Line number="999">#   define truncate truncate64</Line>
  <Line number="1000">#  endif</Line>
  <Line number="1001"># endif</Line>
  <Line number="1002"># ifdef __USE_LARGEFILE64</Line>
  <Line number="1003">extern int truncate64 (const char *__file, __off64_t __length)</Line>
  <Line number="1004">     __THROW __nonnull ((1)) __wur;</Line>
  <Line number="1005"># endif</Line>
  <Line number="1006"></Line>
  <Line number="1007">#endif /* Use X/Open Unix || POSIX 2008.  */</Line>
  <Line number="1008"></Line>
  <Line number="1009">#if defined __USE_POSIX199309 \</Line>
  <Line number="1010">    || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K</Line>
  <Line number="1011"></Line>
  <Line number="1012">/* Truncate the file FD is open on to LENGTH bytes.  */</Line>
  <Line number="1013"># ifndef __USE_FILE_OFFSET64</Line>
  <Line number="1014">extern int ftruncate (int __fd, __off_t __length) __THROW __wur;</Line>
  <Line number="1015"># else</Line>
  <Line number="1016">#  ifdef __REDIRECT_NTH</Line>
  <Line number="1017">extern int __REDIRECT_NTH (ftruncate, (int __fd, __off64_t __length),</Line>
  <Line number="1018">			   ftruncate64) __wur;</Line>
  <Line number="1019">#  else</Line>
  <Line number="1020">#   define ftruncate ftruncate64</Line>
  <Line number="1021">#  endif</Line>
  <Line number="1022"># endif</Line>
  <Line number="1023"># ifdef __USE_LARGEFILE64</Line>
  <Line number="1024">extern int ftruncate64 (int __fd, __off64_t __length) __THROW __wur;</Line>
  <Line number="1025"># endif</Line>
  <Line number="1026"></Line>
  <Line number="1027">#endif /* Use POSIX.1b || X/Open Unix || XPG6.  */</Line>
  <Line number="1028"></Line>
  <Line number="1029"></Line>
  <Line number="1030">#if (defined __USE_XOPEN_EXTENDED &amp;&amp; !defined __USE_XOPEN2K) \</Line>
  <Line number="1031">    || defined __USE_MISC</Line>
  <Line number="1032"></Line>
  <Line number="1033">/* Set the end of accessible data space (aka &quot;the break&quot;) to ADDR.</Line>
  <Line number="1034">   Returns zero on success and -1 for errors (with errno set).  */</Line>
  <Line number="1035">extern int brk (void *__addr) __THROW __wur;</Line>
  <Line number="1036"></Line>
  <Line number="1037">/* Increase or decrease the end of accessible data space by DELTA bytes.</Line>
  <Line number="1038">   If successful, returns the address the previous end of data space</Line>
  <Line number="1039">   (i.e. the beginning of the new space, if DELTA &gt; 0);</Line>
  <Line number="1040">   returns (void *) -1 for errors (with errno set).  */</Line>
  <Line number="1041">extern void *sbrk (intptr_t __delta) __THROW;</Line>
  <Line number="1042">#endif</Line>
  <Line number="1043"></Line>
  <Line number="1044"></Line>
  <Line number="1045">#ifdef __USE_MISC</Line>
  <Line number="1046">/* Invoke `system call&apos; number SYSNO, passing it the remaining arguments.</Line>
  <Line number="1047">   This is completely system-dependent, and not often useful.</Line>
  <Line number="1048"></Line>
  <Line number="1049">   In Unix, `syscall&apos; sets `errno&apos; for all errors and most calls return -1</Line>
  <Line number="1050">   for errors; in many systems you cannot pass arguments or get return</Line>
  <Line number="1051">   values for all system calls (`pipe&apos;, `fork&apos;, and `getppid&apos; typically</Line>
  <Line number="1052">   among them).</Line>
  <Line number="1053"></Line>
  <Line number="1054">   In Mach, all system calls take normal arguments and always return an</Line>
  <Line number="1055">   error code (zero for success).  */</Line>
  <Line number="1056">extern long int syscall (long int __sysno, ...) __THROW;</Line>
  <Line number="1057"></Line>
  <Line number="1058">#endif	/* Use misc.  */</Line>
  <Line number="1059"></Line>
  <Line number="1060"></Line>
  <Line number="1061">#if (defined __USE_MISC || defined __USE_XOPEN_EXTENDED) &amp;&amp; !defined F_LOCK</Line>
  <Line number="1062">/* NOTE: These declarations also appear in &lt;fcntl.h&gt;; be sure to keep both</Line>
  <Line number="1063">   files consistent.  Some systems have them there and some here, and some</Line>
  <Line number="1064">   software depends on the macros being defined without including both.  */</Line>
  <Line number="1065"></Line>
  <Line number="1066">/* `lockf&apos; is a simpler interface to the locking facilities of `fcntl&apos;.</Line>
  <Line number="1067">   LEN is always relative to the current file position.</Line>
  <Line number="1068">   The CMD argument is one of the following.</Line>
  <Line number="1069"></Line>
  <Line number="1070">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="1071">   __THROW.  */</Line>
  <Line number="1072"></Line>
  <Line number="1073"># define F_ULOCK 0	/* Unlock a previously locked region.  */</Line>
  <Line number="1074"># define F_LOCK  1	/* Lock a region for exclusive use.  */</Line>
  <Line number="1075"># define F_TLOCK 2	/* Test and lock a region for exclusive use.  */</Line>
  <Line number="1076"># define F_TEST  3	/* Test a region for other processes locks.  */</Line>
  <Line number="1077"></Line>
  <Line number="1078"># ifndef __USE_FILE_OFFSET64</Line>
  <Line number="1079">extern int lockf (int __fd, int __cmd, __off_t __len) __wur;</Line>
  <Line number="1080"># else</Line>
  <Line number="1081">#  ifdef __REDIRECT</Line>
  <Line number="1082">extern int __REDIRECT (lockf, (int __fd, int __cmd, __off64_t __len),</Line>
  <Line number="1083">		       lockf64) __wur;</Line>
  <Line number="1084">#  else</Line>
  <Line number="1085">#   define lockf lockf64</Line>
  <Line number="1086">#  endif</Line>
  <Line number="1087"># endif</Line>
  <Line number="1088"># ifdef __USE_LARGEFILE64</Line>
  <Line number="1089">extern int lockf64 (int __fd, int __cmd, __off64_t __len) __wur;</Line>
  <Line number="1090"># endif</Line>
  <Line number="1091">#endif /* Use misc and F_LOCK not already defined.  */</Line>
  <Line number="1092"></Line>
  <Line number="1093"></Line>
  <Line number="1094">#ifdef __USE_GNU</Line>
  <Line number="1095"></Line>
  <Line number="1096">/* Evaluate EXPRESSION, and repeat as long as it returns -1 with `errno&apos;</Line>
  <Line number="1097">   set to EINTR.  */</Line>
  <Line number="1098"></Line>
  <Line number="1099"># define TEMP_FAILURE_RETRY(expression) \</Line>
  <Line number="1100">  (__extension__							      \</Line>
  <Line number="1101">    ({ long int __result;						      \</Line>
  <Line number="1102">       do __result = (long int) (expression);				      \</Line>
  <Line number="1103">       while (__result == -1L &amp;&amp; errno == EINTR);			      \</Line>
  <Line number="1104">       __result; }))</Line>
  <Line number="1105"></Line>
  <Line number="1106">/* Copy LENGTH bytes from INFD to OUTFD.  */</Line>
  <Line number="1107">ssize_t copy_file_range (int __infd, __off64_t *__pinoff,</Line>
  <Line number="1108">			 int __outfd, __off64_t *__poutoff,</Line>
  <Line number="1109">			 size_t __length, unsigned int __flags);</Line>
  <Line number="1110">#endif /* __USE_GNU */</Line>
  <Line number="1111"></Line>
  <Line number="1112">#if defined __USE_POSIX199309 || defined __USE_UNIX98</Line>
  <Line number="1113">/* Synchronize at least the data part of a file with the underlying</Line>
  <Line number="1114">   media.  */</Line>
  <Line number="1115">extern int fdatasync (int __fildes);</Line>
  <Line number="1116">#endif /* Use POSIX199309 */</Line>
  <Line number="1117"></Line>
  <Line number="1118">#ifdef __USE_MISC</Line>
  <Line number="1119">/* One-way hash PHRASE, returning a string suitable for storage in the</Line>
  <Line number="1120">   user database.  SALT selects the one-way function to use, and</Line>
  <Line number="1121">   ensures that no two users&apos; hashes are the same, even if they use</Line>
  <Line number="1122">   the same passphrase.  The return value points to static storage</Line>
  <Line number="1123">   which will be overwritten by the next call to crypt.  */</Line>
  <Line number="1124">extern char *crypt (const char *__key, const char *__salt)</Line>
  <Line number="1125">     __THROW __nonnull ((1, 2));</Line>
  <Line number="1126">#endif</Line>
  <Line number="1127"></Line>
  <Line number="1128">#ifdef	__USE_XOPEN</Line>
  <Line number="1129">/* Swab pairs bytes in the first N bytes of the area pointed to by</Line>
  <Line number="1130">   FROM and copy the result to TO.  The value of TO must not be in the</Line>
  <Line number="1131">   range [FROM - N + 1, FROM - 1].  If N is odd the first byte in FROM</Line>
  <Line number="1132">   is without partner.  */</Line>
  <Line number="1133">extern void swab (const void *__restrict __from, void *__restrict __to,</Line>
  <Line number="1134">		  ssize_t __n) __THROW __nonnull ((1, 2));</Line>
  <Line number="1135">#endif</Line>
  <Line number="1136"></Line>
  <Line number="1137"></Line>
  <Line number="1138">/* Prior to Issue 6, the Single Unix Specification required these</Line>
  <Line number="1139">   prototypes to appear in this header.  They are also found in</Line>
  <Line number="1140">   &lt;stdio.h&gt;.  */</Line>
  <Line number="1141">#if defined __USE_XOPEN &amp;&amp; !defined __USE_XOPEN2K</Line>
  <Line number="1142">/* Return the name of the controlling terminal.  */</Line>
  <Line number="1143">extern char *ctermid (char *__s) __THROW;</Line>
  <Line number="1144"></Line>
  <Line number="1145">/* Return the name of the current user.  */</Line>
  <Line number="1146">extern char *cuserid (char *__s);</Line>
  <Line number="1147">#endif</Line>
  <Line number="1148"></Line>
  <Line number="1149"></Line>
  <Line number="1150">/* Unix98 requires this function to be declared here.  In other</Line>
  <Line number="1151">   standards it is in &lt;pthread.h&gt;.  */</Line>
  <Line number="1152">#if defined __USE_UNIX98 &amp;&amp; !defined __USE_XOPEN2K</Line>
  <Line number="1153">extern int pthread_atfork (void (*__prepare) (void),</Line>
  <Line number="1154">			   void (*__parent) (void),</Line>
  <Line number="1155">			   void (*__child) (void)) __THROW;</Line>
  <Line number="1156">#endif</Line>
  <Line number="1157"></Line>
  <Line number="1158">#ifdef __USE_MISC</Line>
  <Line number="1159">/* Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on</Line>
  <Line number="1160">   success or -1 on error.  */</Line>
  <Line number="1161">int getentropy (void *__buffer, size_t __length) __wur;</Line>
  <Line number="1162">#endif</Line>
  <Line number="1163"></Line>
  <Line number="1164">/* Define some macros helping to catch buffer overflows.  */</Line>
  <Line number="1165">#if __USE_FORTIFY_LEVEL &gt; 0 &amp;&amp; defined __fortify_function</Line>
  <Line number="1166"># include &lt;bits/unistd.h&gt;</Line>
  <Line number="1167">#endif</Line>
  <Line number="1168"></Line>
  <Line number="1169">/* System-specific extensions.  */</Line>
  <Line number="1170">#include &lt;bits/unistd_ext.h&gt;</Line>
  <Line number="1171"></Line>
  <Line number="1172">__END_DECLS</Line>
  <Line number="1173"></Line>
  <Line number="1174">#endif /* unistd.h  */</Line>
</SourceFile>
