<SourceFile>
  <Line number="1">/* Declarations of socket constants, types, and functions.</Line>
  <Line number="2">   Copyright (C) 1991-2020 Free Software Foundation, Inc.</Line>
  <Line number="3">   This file is part of the GNU C Library.</Line>
  <Line number="4"></Line>
  <Line number="5">   The GNU C Library is free software; you can redistribute it and/or</Line>
  <Line number="6">   modify it under the terms of the GNU Lesser General Public</Line>
  <Line number="7">   License as published by the Free Software Foundation; either</Line>
  <Line number="8">   version 2.1 of the License, or (at your option) any later version.</Line>
  <Line number="9"></Line>
  <Line number="10">   The GNU C Library is distributed in the hope that it will be useful,</Line>
  <Line number="11">   but WITHOUT ANY WARRANTY; without even the implied warranty of</Line>
  <Line number="12">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</Line>
  <Line number="13">   Lesser General Public License for more details.</Line>
  <Line number="14"></Line>
  <Line number="15">   You should have received a copy of the GNU Lesser General Public</Line>
  <Line number="16">   License along with the GNU C Library; if not, see</Line>
  <Line number="17">   &lt;https://www.gnu.org/licenses/&gt;.  */</Line>
  <Line number="18"></Line>
  <Line number="19">#ifndef	_SYS_SOCKET_H</Line>
  <Line number="20">#define	_SYS_SOCKET_H	1</Line>
  <Line number="21"></Line>
  <Line number="22">#include &lt;features.h&gt;</Line>
  <Line number="23"></Line>
  <Line number="24">__BEGIN_DECLS</Line>
  <Line number="25"></Line>
  <Line number="26">#include &lt;bits/types/struct_iovec.h&gt;</Line>
  <Line number="27">#define	__need_size_t</Line>
  <Line number="28">#include &lt;stddef.h&gt;</Line>
  <Line number="29"></Line>
  <Line number="30">/* This operating system-specific header file defines the SOCK_*, PF_*,</Line>
  <Line number="31">   AF_*, MSG_*, SOL_*, and SO_* constants, and the `struct sockaddr&apos;,</Line>
  <Line number="32">   `struct msghdr&apos;, and `struct linger&apos; types.  */</Line>
  <Line number="33">#include &lt;bits/socket.h&gt;</Line>
  <Line number="34"></Line>
  <Line number="35">#ifdef __USE_MISC</Line>
  <Line number="36"># include &lt;bits/types/struct_osockaddr.h&gt;</Line>
  <Line number="37">#endif</Line>
  <Line number="38"></Line>
  <Line number="39">/* The following constants should be used for the second parameter of</Line>
  <Line number="40">   `shutdown&apos;.  */</Line>
  <Line number="41">enum</Line>
  <Line number="42">{</Line>
  <Line number="43">  SHUT_RD = 0,		/* No more receptions.  */</Line>
  <Line number="44">#define SHUT_RD		SHUT_RD</Line>
  <Line number="45">  SHUT_WR,		/* No more transmissions.  */</Line>
  <Line number="46">#define SHUT_WR		SHUT_WR</Line>
  <Line number="47">  SHUT_RDWR		/* No more receptions or transmissions.  */</Line>
  <Line number="48">#define SHUT_RDWR	SHUT_RDWR</Line>
  <Line number="49">};</Line>
  <Line number="50"></Line>
  <Line number="51">/* This is the type we use for generic socket address arguments.</Line>
  <Line number="52"></Line>
  <Line number="53">   With GCC 2.7 and later, the funky union causes redeclarations or</Line>
  <Line number="54">   uses with any of the listed types to be allowed without complaint.</Line>
  <Line number="55">   G++ 2.7 does not support transparent unions so there we want the</Line>
  <Line number="56">   old-style declaration, too.  */</Line>
  <Line number="57">#if defined __cplusplus || !__GNUC_PREREQ (2, 7) || !defined __USE_GNU</Line>
  <Line number="58"># define __SOCKADDR_ARG		struct sockaddr *__restrict</Line>
  <Line number="59"># define __CONST_SOCKADDR_ARG	const struct sockaddr *</Line>
  <Line number="60">#else</Line>
  <Line number="61">/* Add more `struct sockaddr_AF&apos; types here as necessary.</Line>
  <Line number="62">   These are all the ones I found on NetBSD and Linux.  */</Line>
  <Line number="63"># define __SOCKADDR_ALLTYPES \</Line>
  <Line number="64">  __SOCKADDR_ONETYPE (sockaddr) \</Line>
  <Line number="65">  __SOCKADDR_ONETYPE (sockaddr_at) \</Line>
  <Line number="66">  __SOCKADDR_ONETYPE (sockaddr_ax25) \</Line>
  <Line number="67">  __SOCKADDR_ONETYPE (sockaddr_dl) \</Line>
  <Line number="68">  __SOCKADDR_ONETYPE (sockaddr_eon) \</Line>
  <Line number="69">  __SOCKADDR_ONETYPE (sockaddr_in) \</Line>
  <Line number="70">  __SOCKADDR_ONETYPE (sockaddr_in6) \</Line>
  <Line number="71">  __SOCKADDR_ONETYPE (sockaddr_inarp) \</Line>
  <Line number="72">  __SOCKADDR_ONETYPE (sockaddr_ipx) \</Line>
  <Line number="73">  __SOCKADDR_ONETYPE (sockaddr_iso) \</Line>
  <Line number="74">  __SOCKADDR_ONETYPE (sockaddr_ns) \</Line>
  <Line number="75">  __SOCKADDR_ONETYPE (sockaddr_un) \</Line>
  <Line number="76">  __SOCKADDR_ONETYPE (sockaddr_x25)</Line>
  <Line number="77"></Line>
  <Line number="78"># define __SOCKADDR_ONETYPE(type) struct type *__restrict __##type##__;</Line>
  <Line number="79">typedef union { __SOCKADDR_ALLTYPES</Line>
  <Line number="80">	      } __SOCKADDR_ARG __attribute__ ((__transparent_union__));</Line>
  <Line number="81"># undef __SOCKADDR_ONETYPE</Line>
  <Line number="82"># define __SOCKADDR_ONETYPE(type) const struct type *__restrict __##type##__;</Line>
  <Line number="83">typedef union { __SOCKADDR_ALLTYPES</Line>
  <Line number="84">	      } __CONST_SOCKADDR_ARG __attribute__ ((__transparent_union__));</Line>
  <Line number="85"># undef __SOCKADDR_ONETYPE</Line>
  <Line number="86">#endif</Line>
  <Line number="87"></Line>
  <Line number="88">#ifdef __USE_GNU</Line>
  <Line number="89">/* For `recvmmsg&apos; and `sendmmsg&apos;.  */</Line>
  <Line number="90">struct mmsghdr</Line>
  <Line number="91">  {</Line>
  <Line number="92">    struct msghdr msg_hdr;	/* Actual message header.  */</Line>
  <Line number="93">    unsigned int msg_len;	/* Number of received or sent bytes for the</Line>
  <Line number="94">				   entry.  */</Line>
  <Line number="95">  };</Line>
  <Line number="96">#endif</Line>
  <Line number="97"></Line>
  <Line number="98"></Line>
  <Line number="99">/* Create a new socket of type TYPE in domain DOMAIN, using</Line>
  <Line number="100">   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.</Line>
  <Line number="101">   Returns a file descriptor for the new socket, or -1 for errors.  */</Line>
  <Line number="102">extern int socket (int __domain, int __type, int __protocol) __THROW;</Line>
  <Line number="103"></Line>
  <Line number="104">/* Create two new sockets, of type TYPE in domain DOMAIN and using</Line>
  <Line number="105">   protocol PROTOCOL, which are connected to each other, and put file</Line>
  <Line number="106">   descriptors for them in FDS[0] and FDS[1].  If PROTOCOL is zero,</Line>
  <Line number="107">   one will be chosen automatically.  Returns 0 on success, -1 for errors.  */</Line>
  <Line number="108">extern int socketpair (int __domain, int __type, int __protocol,</Line>
  <Line number="109">		       int __fds[2]) __THROW;</Line>
  <Line number="110"></Line>
  <Line number="111">/* Give the socket FD the local address ADDR (which is LEN bytes long).  */</Line>
  <Line number="112">extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)</Line>
  <Line number="113">     __THROW;</Line>
  <Line number="114"></Line>
  <Line number="115">/* Put the local address of FD into *ADDR and its length in *LEN.  */</Line>
  <Line number="116">extern int getsockname (int __fd, __SOCKADDR_ARG __addr,</Line>
  <Line number="117">			socklen_t *__restrict __len) __THROW;</Line>
  <Line number="118"></Line>
  <Line number="119">/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).</Line>
  <Line number="120">   For connectionless socket types, just set the default address to send to</Line>
  <Line number="121">   and the only address from which to accept transmissions.</Line>
  <Line number="122">   Return 0 on success, -1 for errors.</Line>
  <Line number="123"></Line>
  <Line number="124">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="125">   __THROW.  */</Line>
  <Line number="126">extern int connect (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len);</Line>
  <Line number="127"></Line>
  <Line number="128">/* Put the address of the peer connected to socket FD into *ADDR</Line>
  <Line number="129">   (which is *LEN bytes long), and its actual length into *LEN.  */</Line>
  <Line number="130">extern int getpeername (int __fd, __SOCKADDR_ARG __addr,</Line>
  <Line number="131">			socklen_t *__restrict __len) __THROW;</Line>
  <Line number="132"></Line>
  <Line number="133"></Line>
  <Line number="134">/* Send N bytes of BUF to socket FD.  Returns the number sent or -1.</Line>
  <Line number="135"></Line>
  <Line number="136">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="137">   __THROW.  */</Line>
  <Line number="138">extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);</Line>
  <Line number="139"></Line>
  <Line number="140">/* Read N bytes into BUF from socket FD.</Line>
  <Line number="141">   Returns the number read or -1 for errors.</Line>
  <Line number="142"></Line>
  <Line number="143">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="144">   __THROW.  */</Line>
  <Line number="145">extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);</Line>
  <Line number="146"></Line>
  <Line number="147">/* Send N bytes of BUF on socket FD to peer at address ADDR (which is</Line>
  <Line number="148">   ADDR_LEN bytes long).  Returns the number sent, or -1 for errors.</Line>
  <Line number="149"></Line>
  <Line number="150">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="151">   __THROW.  */</Line>
  <Line number="152">extern ssize_t sendto (int __fd, const void *__buf, size_t __n,</Line>
  <Line number="153">		       int __flags, __CONST_SOCKADDR_ARG __addr,</Line>
  <Line number="154">		       socklen_t __addr_len);</Line>
  <Line number="155"></Line>
  <Line number="156">/* Read N bytes into BUF through socket FD.</Line>
  <Line number="157">   If ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of</Line>
  <Line number="158">   the sender, and store the actual size of the address in *ADDR_LEN.</Line>
  <Line number="159">   Returns the number of bytes read or -1 for errors.</Line>
  <Line number="160"></Line>
  <Line number="161">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="162">   __THROW.  */</Line>
  <Line number="163">extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,</Line>
  <Line number="164">			 int __flags, __SOCKADDR_ARG __addr,</Line>
  <Line number="165">			 socklen_t *__restrict __addr_len);</Line>
  <Line number="166"></Line>
  <Line number="167"></Line>
  <Line number="168">/* Send a message described MESSAGE on socket FD.</Line>
  <Line number="169">   Returns the number of bytes sent, or -1 for errors.</Line>
  <Line number="170"></Line>
  <Line number="171">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="172">   __THROW.  */</Line>
  <Line number="173">extern ssize_t sendmsg (int __fd, const struct msghdr *__message,</Line>
  <Line number="174">			int __flags);</Line>
  <Line number="175"></Line>
  <Line number="176">#ifdef __USE_GNU</Line>
  <Line number="177">/* Send a VLEN messages as described by VMESSAGES to socket FD.</Line>
  <Line number="178">   Returns the number of datagrams successfully written or -1 for errors.</Line>
  <Line number="179"></Line>
  <Line number="180">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="181">   __THROW.  */</Line>
  <Line number="182">extern int sendmmsg (int __fd, struct mmsghdr *__vmessages,</Line>
  <Line number="183">		     unsigned int __vlen, int __flags);</Line>
  <Line number="184">#endif</Line>
  <Line number="185"></Line>
  <Line number="186">/* Receive a message as described by MESSAGE from socket FD.</Line>
  <Line number="187">   Returns the number of bytes read or -1 for errors.</Line>
  <Line number="188"></Line>
  <Line number="189">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="190">   __THROW.  */</Line>
  <Line number="191">extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);</Line>
  <Line number="192"></Line>
  <Line number="193">#ifdef __USE_GNU</Line>
  <Line number="194">/* Receive up to VLEN messages as described by VMESSAGES from socket FD.</Line>
  <Line number="195">   Returns the number of messages received or -1 for errors.</Line>
  <Line number="196"></Line>
  <Line number="197">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="198">   __THROW.  */</Line>
  <Line number="199">extern int recvmmsg (int __fd, struct mmsghdr *__vmessages,</Line>
  <Line number="200">		     unsigned int __vlen, int __flags,</Line>
  <Line number="201">		     struct timespec *__tmo);</Line>
  <Line number="202">#endif</Line>
  <Line number="203"></Line>
  <Line number="204"></Line>
  <Line number="205">/* Put the current value for socket FD&apos;s option OPTNAME at protocol level LEVEL</Line>
  <Line number="206">   into OPTVAL (which is *OPTLEN bytes long), and set *OPTLEN to the value&apos;s</Line>
  <Line number="207">   actual length.  Returns 0 on success, -1 for errors.  */</Line>
  <Line number="208">extern int getsockopt (int __fd, int __level, int __optname,</Line>
  <Line number="209">		       void *__restrict __optval,</Line>
  <Line number="210">		       socklen_t *__restrict __optlen) __THROW;</Line>
  <Line number="211"></Line>
  <Line number="212">/* Set socket FD&apos;s option OPTNAME at protocol level LEVEL</Line>
  <Line number="213">   to *OPTVAL (which is OPTLEN bytes long).</Line>
  <Line number="214">   Returns 0 on success, -1 for errors.  */</Line>
  <Line number="215">extern int setsockopt (int __fd, int __level, int __optname,</Line>
  <Line number="216">		       const void *__optval, socklen_t __optlen) __THROW;</Line>
  <Line number="217"></Line>
  <Line number="218"></Line>
  <Line number="219">/* Prepare to accept connections on socket FD.</Line>
  <Line number="220">   N connection requests will be queued before further requests are refused.</Line>
  <Line number="221">   Returns 0 on success, -1 for errors.  */</Line>
  <Line number="222">extern int listen (int __fd, int __n) __THROW;</Line>
  <Line number="223"></Line>
  <Line number="224">/* Await a connection on socket FD.</Line>
  <Line number="225">   When a connection arrives, open a new socket to communicate with it,</Line>
  <Line number="226">   set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting</Line>
  <Line number="227">   peer and *ADDR_LEN to the address&apos;s actual length, and return the</Line>
  <Line number="228">   new socket&apos;s descriptor, or -1 for errors.</Line>
  <Line number="229"></Line>
  <Line number="230">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="231">   __THROW.  */</Line>
  <Line number="232">extern int accept (int __fd, __SOCKADDR_ARG __addr,</Line>
  <Line number="233">		   socklen_t *__restrict __addr_len);</Line>
  <Line number="234"></Line>
  <Line number="235">#ifdef __USE_GNU</Line>
  <Line number="236">/* Similar to &apos;accept&apos; but takes an additional parameter to specify flags.</Line>
  <Line number="237"></Line>
  <Line number="238">   This function is a cancellation point and therefore not marked with</Line>
  <Line number="239">   __THROW.  */</Line>
  <Line number="240">extern int accept4 (int __fd, __SOCKADDR_ARG __addr,</Line>
  <Line number="241">		    socklen_t *__restrict __addr_len, int __flags);</Line>
  <Line number="242">#endif</Line>
  <Line number="243"></Line>
  <Line number="244">/* Shut down all or part of the connection open on socket FD.</Line>
  <Line number="245">   HOW determines what to shut down:</Line>
  <Line number="246">     SHUT_RD   = No more receptions;</Line>
  <Line number="247">     SHUT_WR   = No more transmissions;</Line>
  <Line number="248">     SHUT_RDWR = No more receptions or transmissions.</Line>
  <Line number="249">   Returns 0 on success, -1 for errors.  */</Line>
  <Line number="250">extern int shutdown (int __fd, int __how) __THROW;</Line>
  <Line number="251"></Line>
  <Line number="252"></Line>
  <Line number="253">#ifdef __USE_XOPEN2K</Line>
  <Line number="254">/* Determine whether socket is at a out-of-band mark.  */</Line>
  <Line number="255">extern int sockatmark (int __fd) __THROW;</Line>
  <Line number="256">#endif</Line>
  <Line number="257"></Line>
  <Line number="258"></Line>
  <Line number="259">#ifdef __USE_MISC</Line>
  <Line number="260">/* FDTYPE is S_IFSOCK or another S_IF* macro defined in &lt;sys/stat.h&gt;;</Line>
  <Line number="261">   returns 1 if FD is open on an object of the indicated type, 0 if not,</Line>
  <Line number="262">   or -1 for errors (setting errno).  */</Line>
  <Line number="263">extern int isfdtype (int __fd, int __fdtype) __THROW;</Line>
  <Line number="264">#endif</Line>
  <Line number="265"></Line>
  <Line number="266"></Line>
  <Line number="267">/* Define some macros helping to catch buffer overflows.  */</Line>
  <Line number="268">#if __USE_FORTIFY_LEVEL &gt; 0 &amp;&amp; defined __fortify_function</Line>
  <Line number="269"># include &lt;bits/socket2.h&gt;</Line>
  <Line number="270">#endif</Line>
  <Line number="271"></Line>
  <Line number="272">__END_DECLS</Line>
  <Line number="273"></Line>
  <Line number="274">#endif /* sys/socket.h */</Line>
</SourceFile>
