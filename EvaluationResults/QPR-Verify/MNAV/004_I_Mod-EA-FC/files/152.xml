<SourceFile>
  <Line number="1">/* Declarations for math functions.</Line>
  <Line number="2">   Copyright (C) 1991-2020 Free Software Foundation, Inc.</Line>
  <Line number="3">   This file is part of the GNU C Library.</Line>
  <Line number="4"></Line>
  <Line number="5">   The GNU C Library is free software; you can redistribute it and/or</Line>
  <Line number="6">   modify it under the terms of the GNU Lesser General Public</Line>
  <Line number="7">   License as published by the Free Software Foundation; either</Line>
  <Line number="8">   version 2.1 of the License, or (at your option) any later version.</Line>
  <Line number="9"></Line>
  <Line number="10">   The GNU C Library is distributed in the hope that it will be useful,</Line>
  <Line number="11">   but WITHOUT ANY WARRANTY; without even the implied warranty of</Line>
  <Line number="12">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</Line>
  <Line number="13">   Lesser General Public License for more details.</Line>
  <Line number="14"></Line>
  <Line number="15">   You should have received a copy of the GNU Lesser General Public</Line>
  <Line number="16">   License along with the GNU C Library; if not, see</Line>
  <Line number="17">   &lt;https://www.gnu.org/licenses/&gt;.  */</Line>
  <Line number="18"></Line>
  <Line number="19">/*</Line>
  <Line number="20"> *	ISO C99 Standard: 7.12 Mathematics	&lt;math.h&gt;</Line>
  <Line number="21"> */</Line>
  <Line number="22"></Line>
  <Line number="23">#ifndef	_MATH_H</Line>
  <Line number="24">#define	_MATH_H	1</Line>
  <Line number="25"></Line>
  <Line number="26">#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION</Line>
  <Line number="27">#include &lt;bits/libc-header-start.h&gt;</Line>
  <Line number="28"></Line>
  <Line number="29">#if defined log &amp;&amp; defined __GNUC__</Line>
  <Line number="30"># warning A macro called log was already defined when &lt;math.h&gt; was included.</Line>
  <Line number="31"># warning This will cause compilation problems.</Line>
  <Line number="32">#endif</Line>
  <Line number="33"></Line>
  <Line number="34">__BEGIN_DECLS</Line>
  <Line number="35"></Line>
  <Line number="36">/* Get definitions of __intmax_t and __uintmax_t.  */</Line>
  <Line number="37">#include &lt;bits/types.h&gt;</Line>
  <Line number="38"></Line>
  <Line number="39">/* Get machine-dependent vector math functions declarations.  */</Line>
  <Line number="40">#include &lt;bits/math-vector.h&gt;</Line>
  <Line number="41"></Line>
  <Line number="42">/* Gather machine dependent type support.  */</Line>
  <Line number="43">#include &lt;bits/floatn.h&gt;</Line>
  <Line number="44"></Line>
  <Line number="45">/* Value returned on overflow.  With IEEE 754 floating point, this is</Line>
  <Line number="46">   +Infinity, otherwise the largest representable positive value.  */</Line>
  <Line number="47">#if __GNUC_PREREQ (3, 3)</Line>
  <Line number="48"># define HUGE_VAL (__builtin_huge_val ())</Line>
  <Line number="49">#else</Line>
  <Line number="50">/* This may provoke compiler warnings, and may not be rounded to</Line>
  <Line number="51">   +Infinity in all IEEE 754 rounding modes, but is the best that can</Line>
  <Line number="52">   be done in ISO C while remaining a constant expression.  10,000 is</Line>
  <Line number="53">   greater than the maximum (decimal) exponent for all supported</Line>
  <Line number="54">   floating-point formats and widths.  */</Line>
  <Line number="55"># define HUGE_VAL 1e10000</Line>
  <Line number="56">#endif</Line>
  <Line number="57">#ifdef __USE_ISOC99</Line>
  <Line number="58"># if __GNUC_PREREQ (3, 3)</Line>
  <Line number="59">#  define HUGE_VALF (__builtin_huge_valf ())</Line>
  <Line number="60">#  define HUGE_VALL (__builtin_huge_vall ())</Line>
  <Line number="61"># else</Line>
  <Line number="62">#  define HUGE_VALF 1e10000f</Line>
  <Line number="63">#  define HUGE_VALL 1e10000L</Line>
  <Line number="64"># endif</Line>
  <Line number="65">#endif</Line>
  <Line number="66">#if __HAVE_FLOAT16 &amp;&amp; __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="67"># define HUGE_VAL_F16 (__builtin_huge_valf16 ())</Line>
  <Line number="68">#endif</Line>
  <Line number="69">#if __HAVE_FLOAT32 &amp;&amp; __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="70"># define HUGE_VAL_F32 (__builtin_huge_valf32 ())</Line>
  <Line number="71">#endif</Line>
  <Line number="72">#if __HAVE_FLOAT64 &amp;&amp; __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="73"># define HUGE_VAL_F64 (__builtin_huge_valf64 ())</Line>
  <Line number="74">#endif</Line>
  <Line number="75">#if __HAVE_FLOAT128 &amp;&amp; __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="76"># define HUGE_VAL_F128 (__builtin_huge_valf128 ())</Line>
  <Line number="77">#endif</Line>
  <Line number="78">#if __HAVE_FLOAT32X &amp;&amp; __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="79"># define HUGE_VAL_F32X (__builtin_huge_valf32x ())</Line>
  <Line number="80">#endif</Line>
  <Line number="81">#if __HAVE_FLOAT64X &amp;&amp; __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="82"># define HUGE_VAL_F64X (__builtin_huge_valf64x ())</Line>
  <Line number="83">#endif</Line>
  <Line number="84">#if __HAVE_FLOAT128X &amp;&amp; __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="85"># define HUGE_VAL_F128X (__builtin_huge_valf128x ())</Line>
  <Line number="86">#endif</Line>
  <Line number="87"></Line>
  <Line number="88">#ifdef __USE_ISOC99</Line>
  <Line number="89">/* IEEE positive infinity.  */</Line>
  <Line number="90"># if __GNUC_PREREQ (3, 3)</Line>
  <Line number="91">#  define INFINITY (__builtin_inff ())</Line>
  <Line number="92"># else</Line>
  <Line number="93">#  define INFINITY HUGE_VALF</Line>
  <Line number="94"># endif</Line>
  <Line number="95"></Line>
  <Line number="96">/* IEEE Not A Number.  */</Line>
  <Line number="97"># if __GNUC_PREREQ (3, 3)</Line>
  <Line number="98">#  define NAN (__builtin_nanf (&quot;&quot;))</Line>
  <Line number="99"># else</Line>
  <Line number="100">/* This will raise an &quot;invalid&quot; exception outside static initializers,</Line>
  <Line number="101">   but is the best that can be done in ISO C while remaining a</Line>
  <Line number="102">   constant expression.  */</Line>
  <Line number="103">#  define NAN (0.0f / 0.0f)</Line>
  <Line number="104"># endif</Line>
  <Line number="105">#endif /* __USE_ISOC99 */</Line>
  <Line number="106"></Line>
  <Line number="107">#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X)</Line>
  <Line number="108">/* Signaling NaN macros, if supported.  */</Line>
  <Line number="109"># if __GNUC_PREREQ (3, 3)</Line>
  <Line number="110">#  define SNANF (__builtin_nansf (&quot;&quot;))</Line>
  <Line number="111">#  define SNAN (__builtin_nans (&quot;&quot;))</Line>
  <Line number="112">#  define SNANL (__builtin_nansl (&quot;&quot;))</Line>
  <Line number="113"># endif</Line>
  <Line number="114">#endif</Line>
  <Line number="115">#if __HAVE_FLOAT16 &amp;&amp; __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="116"># define SNANF16 (__builtin_nansf16 (&quot;&quot;))</Line>
  <Line number="117">#endif</Line>
  <Line number="118">#if __HAVE_FLOAT32 &amp;&amp; __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="119"># define SNANF32 (__builtin_nansf32 (&quot;&quot;))</Line>
  <Line number="120">#endif</Line>
  <Line number="121">#if __HAVE_FLOAT64 &amp;&amp; __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="122"># define SNANF64 (__builtin_nansf64 (&quot;&quot;))</Line>
  <Line number="123">#endif</Line>
  <Line number="124">#if __HAVE_FLOAT128 &amp;&amp; __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="125"># define SNANF128 (__builtin_nansf128 (&quot;&quot;))</Line>
  <Line number="126">#endif</Line>
  <Line number="127">#if __HAVE_FLOAT32X &amp;&amp; __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="128"># define SNANF32X (__builtin_nansf32x (&quot;&quot;))</Line>
  <Line number="129">#endif</Line>
  <Line number="130">#if __HAVE_FLOAT64X &amp;&amp; __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="131"># define SNANF64X (__builtin_nansf64x (&quot;&quot;))</Line>
  <Line number="132">#endif</Line>
  <Line number="133">#if __HAVE_FLOAT128X &amp;&amp; __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="134"># define SNANF128X (__builtin_nansf128x (&quot;&quot;))</Line>
  <Line number="135">#endif</Line>
  <Line number="136"></Line>
  <Line number="137">/* Get __GLIBC_FLT_EVAL_METHOD.  */</Line>
  <Line number="138">#include &lt;bits/flt-eval-method.h&gt;</Line>
  <Line number="139"></Line>
  <Line number="140">#ifdef __USE_ISOC99</Line>
  <Line number="141">/* Define the following typedefs.</Line>
  <Line number="142"></Line>
  <Line number="143">    float_t	floating-point type at least as wide as `float&apos; used</Line>
  <Line number="144">		to evaluate `float&apos; expressions</Line>
  <Line number="145">    double_t	floating-point type at least as wide as `double&apos; used</Line>
  <Line number="146">		to evaluate `double&apos; expressions</Line>
  <Line number="147">*/</Line>
  <Line number="148"># if __GLIBC_FLT_EVAL_METHOD == 0 || __GLIBC_FLT_EVAL_METHOD == 16</Line>
  <Line number="149">typedef float float_t;</Line>
  <Line number="150">typedef double double_t;</Line>
  <Line number="151"># elif __GLIBC_FLT_EVAL_METHOD == 1</Line>
  <Line number="152">typedef double float_t;</Line>
  <Line number="153">typedef double double_t;</Line>
  <Line number="154"># elif __GLIBC_FLT_EVAL_METHOD == 2</Line>
  <Line number="155">typedef long double float_t;</Line>
  <Line number="156">typedef long double double_t;</Line>
  <Line number="157"># elif __GLIBC_FLT_EVAL_METHOD == 32</Line>
  <Line number="158">typedef _Float32 float_t;</Line>
  <Line number="159">typedef double double_t;</Line>
  <Line number="160"># elif __GLIBC_FLT_EVAL_METHOD == 33</Line>
  <Line number="161">typedef _Float32x float_t;</Line>
  <Line number="162">typedef _Float32x double_t;</Line>
  <Line number="163"># elif __GLIBC_FLT_EVAL_METHOD == 64</Line>
  <Line number="164">typedef _Float64 float_t;</Line>
  <Line number="165">typedef _Float64 double_t;</Line>
  <Line number="166"># elif __GLIBC_FLT_EVAL_METHOD == 65</Line>
  <Line number="167">typedef _Float64x float_t;</Line>
  <Line number="168">typedef _Float64x double_t;</Line>
  <Line number="169"># elif __GLIBC_FLT_EVAL_METHOD == 128</Line>
  <Line number="170">typedef _Float128 float_t;</Line>
  <Line number="171">typedef _Float128 double_t;</Line>
  <Line number="172"># elif __GLIBC_FLT_EVAL_METHOD == 129</Line>
  <Line number="173">typedef _Float128x float_t;</Line>
  <Line number="174">typedef _Float128x double_t;</Line>
  <Line number="175"># else</Line>
  <Line number="176">#  error &quot;Unknown __GLIBC_FLT_EVAL_METHOD&quot;</Line>
  <Line number="177"># endif</Line>
  <Line number="178">#endif</Line>
  <Line number="179"></Line>
  <Line number="180">/* Define macros for the return values of ilogb and llogb, based on</Line>
  <Line number="181">   __FP_LOGB0_IS_MIN and __FP_LOGBNAN_IS_MIN.</Line>
  <Line number="182"></Line>
  <Line number="183">    FP_ILOGB0	Expands to a value returned by `ilogb (0.0)&apos;.</Line>
  <Line number="184">    FP_ILOGBNAN	Expands to a value returned by `ilogb (NAN)&apos;.</Line>
  <Line number="185">    FP_LLOGB0	Expands to a value returned by `llogb (0.0)&apos;.</Line>
  <Line number="186">    FP_LLOGBNAN	Expands to a value returned by `llogb (NAN)&apos;.</Line>
  <Line number="187"></Line>
  <Line number="188">*/</Line>
  <Line number="189"></Line>
  <Line number="190">#include &lt;bits/fp-logb.h&gt;</Line>
  <Line number="191">#ifdef __USE_ISOC99</Line>
  <Line number="192"># if __FP_LOGB0_IS_MIN</Line>
  <Line number="193">#  define FP_ILOGB0	(-2147483647 - 1)</Line>
  <Line number="194"># else</Line>
  <Line number="195">#  define FP_ILOGB0	(-2147483647)</Line>
  <Line number="196"># endif</Line>
  <Line number="197"># if __FP_LOGBNAN_IS_MIN</Line>
  <Line number="198">#  define FP_ILOGBNAN	(-2147483647 - 1)</Line>
  <Line number="199"># else</Line>
  <Line number="200">#  define FP_ILOGBNAN	2147483647</Line>
  <Line number="201"># endif</Line>
  <Line number="202">#endif</Line>
  <Line number="203">#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X)</Line>
  <Line number="204"># if __WORDSIZE == 32</Line>
  <Line number="205">#  define __FP_LONG_MAX 0x7fffffffL</Line>
  <Line number="206"># else</Line>
  <Line number="207">#  define __FP_LONG_MAX 0x7fffffffffffffffL</Line>
  <Line number="208"># endif</Line>
  <Line number="209"># if __FP_LOGB0_IS_MIN</Line>
  <Line number="210">#  define FP_LLOGB0	(-__FP_LONG_MAX - 1)</Line>
  <Line number="211"># else</Line>
  <Line number="212">#  define FP_LLOGB0	(-__FP_LONG_MAX)</Line>
  <Line number="213"># endif</Line>
  <Line number="214"># if __FP_LOGBNAN_IS_MIN</Line>
  <Line number="215">#  define FP_LLOGBNAN	(-__FP_LONG_MAX - 1)</Line>
  <Line number="216"># else</Line>
  <Line number="217">#  define FP_LLOGBNAN	__FP_LONG_MAX</Line>
  <Line number="218"># endif</Line>
  <Line number="219">#endif</Line>
  <Line number="220"></Line>
  <Line number="221">/* Get the architecture specific values describing the floating-point</Line>
  <Line number="222">   evaluation.  The following symbols will get defined:</Line>
  <Line number="223"></Line>
  <Line number="224">    FP_FAST_FMA</Line>
  <Line number="225">    FP_FAST_FMAF</Line>
  <Line number="226">    FP_FAST_FMAL</Line>
  <Line number="227">		If defined it indicates that the `fma&apos; function</Line>
  <Line number="228">		generally executes about as fast as a multiply and an add.</Line>
  <Line number="229">		This macro is defined only iff the `fma&apos; function is</Line>
  <Line number="230">		implemented directly with a hardware multiply-add instructions.</Line>
  <Line number="231">*/</Line>
  <Line number="232"></Line>
  <Line number="233">#include &lt;bits/fp-fast.h&gt;</Line>
  <Line number="234"></Line>
  <Line number="235">#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X)</Line>
  <Line number="236">/* Rounding direction macros for fromfp functions.  */</Line>
  <Line number="237">enum</Line>
  <Line number="238">  {</Line>
  <Line number="239">    FP_INT_UPWARD =</Line>
  <Line number="240"># define FP_INT_UPWARD 0</Line>
  <Line number="241">      FP_INT_UPWARD,</Line>
  <Line number="242">    FP_INT_DOWNWARD =</Line>
  <Line number="243"># define FP_INT_DOWNWARD 1</Line>
  <Line number="244">      FP_INT_DOWNWARD,</Line>
  <Line number="245">    FP_INT_TOWARDZERO =</Line>
  <Line number="246"># define FP_INT_TOWARDZERO 2</Line>
  <Line number="247">      FP_INT_TOWARDZERO,</Line>
  <Line number="248">    FP_INT_TONEARESTFROMZERO =</Line>
  <Line number="249"># define FP_INT_TONEARESTFROMZERO 3</Line>
  <Line number="250">      FP_INT_TONEARESTFROMZERO,</Line>
  <Line number="251">    FP_INT_TONEAREST =</Line>
  <Line number="252"># define FP_INT_TONEAREST 4</Line>
  <Line number="253">      FP_INT_TONEAREST,</Line>
  <Line number="254">  };</Line>
  <Line number="255">#endif</Line>
  <Line number="256"></Line>
  <Line number="257">/* The file &lt;bits/mathcalls.h&gt; contains the prototypes for all the</Line>
  <Line number="258">   actual math functions.  These macros are used for those prototypes,</Line>
  <Line number="259">   so we can easily declare each function as both `name&apos; and `__name&apos;,</Line>
  <Line number="260">   and can declare the float versions `namef&apos; and `__namef&apos;.  */</Line>
  <Line number="261"></Line>
  <Line number="262">#define __SIMD_DECL(function) __CONCAT (__DECL_SIMD_, function)</Line>
  <Line number="263"></Line>
  <Line number="264">#define __MATHCALL_VEC(function, suffix, args) 	\</Line>
  <Line number="265">  __SIMD_DECL (__MATH_PRECNAME (function, suffix)) \</Line>
  <Line number="266">  __MATHCALL (function, suffix, args)</Line>
  <Line number="267"></Line>
  <Line number="268">#define __MATHDECL_VEC(type, function,suffix, args) \</Line>
  <Line number="269">  __SIMD_DECL (__MATH_PRECNAME (function, suffix)) \</Line>
  <Line number="270">  __MATHDECL(type, function,suffix, args)</Line>
  <Line number="271"></Line>
  <Line number="272">#define __MATHCALL(function,suffix, args)	\</Line>
  <Line number="273">  __MATHDECL (_Mdouble_,function,suffix, args)</Line>
  <Line number="274">#define __MATHDECL(type, function,suffix, args) \</Line>
  <Line number="275">  __MATHDECL_1(type, function,suffix, args); \</Line>
  <Line number="276">  __MATHDECL_1(type, __CONCAT(__,function),suffix, args)</Line>
  <Line number="277">#define __MATHCALLX(function,suffix, args, attrib)	\</Line>
  <Line number="278">  __MATHDECLX (_Mdouble_,function,suffix, args, attrib)</Line>
  <Line number="279">#define __MATHDECLX(type, function,suffix, args, attrib) \</Line>
  <Line number="280">  __MATHDECL_1(type, function,suffix, args) __attribute__ (attrib); \</Line>
  <Line number="281">  __MATHDECL_1(type, __CONCAT(__,function),suffix, args) __attribute__ (attrib)</Line>
  <Line number="282">#define __MATHDECL_1(type, function,suffix, args) \</Line>
  <Line number="283">  extern type __MATH_PRECNAME(function,suffix) args __THROW</Line>
  <Line number="284"></Line>
  <Line number="285">#define _Mdouble_		double</Line>
  <Line number="286">#define __MATH_PRECNAME(name,r)	__CONCAT(name,r)</Line>
  <Line number="287">#define __MATH_DECLARING_DOUBLE  1</Line>
  <Line number="288">#define __MATH_DECLARING_FLOATN  0</Line>
  <Line number="289">#include &lt;bits/mathcalls-helper-functions.h&gt;</Line>
  <Line number="290">#include &lt;bits/mathcalls.h&gt;</Line>
  <Line number="291">#undef	_Mdouble_</Line>
  <Line number="292">#undef	__MATH_PRECNAME</Line>
  <Line number="293">#undef __MATH_DECLARING_DOUBLE</Line>
  <Line number="294">#undef __MATH_DECLARING_FLOATN</Line>
  <Line number="295"></Line>
  <Line number="296">#ifdef __USE_ISOC99</Line>
  <Line number="297"></Line>
  <Line number="298"></Line>
  <Line number="299">/* Include the file of declarations again, this time using `float&apos;</Line>
  <Line number="300">   instead of `double&apos; and appending f to each function name.  */</Line>
  <Line number="301"></Line>
  <Line number="302"># define _Mdouble_		float</Line>
  <Line number="303"># define __MATH_PRECNAME(name,r) name##f##r</Line>
  <Line number="304"># define __MATH_DECLARING_DOUBLE  0</Line>
  <Line number="305"># define __MATH_DECLARING_FLOATN  0</Line>
  <Line number="306"># include &lt;bits/mathcalls-helper-functions.h&gt;</Line>
  <Line number="307"># include &lt;bits/mathcalls.h&gt;</Line>
  <Line number="308"># undef	_Mdouble_</Line>
  <Line number="309"># undef	__MATH_PRECNAME</Line>
  <Line number="310"># undef __MATH_DECLARING_DOUBLE</Line>
  <Line number="311"># undef __MATH_DECLARING_FLOATN</Line>
  <Line number="312"></Line>
  <Line number="313"># if !(defined __NO_LONG_DOUBLE_MATH &amp;&amp; defined _LIBC) \</Line>
  <Line number="314">     || defined __LDBL_COMPAT \</Line>
  <Line number="315">     || defined _LIBC_TEST</Line>
  <Line number="316">#  ifdef __LDBL_COMPAT</Line>
  <Line number="317"></Line>
  <Line number="318">#   ifdef __USE_ISOC99</Line>
  <Line number="319">extern float __nldbl_nexttowardf (float __x, long double __y)</Line>
  <Line number="320">				  __THROW __attribute__ ((__const__));</Line>
  <Line number="321">#    ifdef __REDIRECT_NTH</Line>
  <Line number="322">extern float __REDIRECT_NTH (nexttowardf, (float __x, long double __y),</Line>
  <Line number="323">			     __nldbl_nexttowardf)</Line>
  <Line number="324">     __attribute__ ((__const__));</Line>
  <Line number="325">extern double __REDIRECT_NTH (nexttoward, (double __x, long double __y),</Line>
  <Line number="326">			      nextafter) __attribute__ ((__const__));</Line>
  <Line number="327">extern long double __REDIRECT_NTH (nexttowardl,</Line>
  <Line number="328">				   (long double __x, long double __y),</Line>
  <Line number="329">				   nextafter) __attribute__ ((__const__));</Line>
  <Line number="330">#    endif</Line>
  <Line number="331">#   endif</Line>
  <Line number="332"></Line>
  <Line number="333">#   undef __MATHDECL_1</Line>
  <Line number="334">#   define __MATHDECL_2(type, function,suffix, args, alias) \</Line>
  <Line number="335">  extern type __REDIRECT_NTH(__MATH_PRECNAME(function,suffix), \</Line>
  <Line number="336">			     args, alias)</Line>
  <Line number="337">#   define __MATHDECL_1(type, function,suffix, args) \</Line>
  <Line number="338">  __MATHDECL_2(type, function,suffix, args, __CONCAT(function,suffix))</Line>
  <Line number="339">#  endif</Line>
  <Line number="340"></Line>
  <Line number="341">/* Include the file of declarations again, this time using `long double&apos;</Line>
  <Line number="342">   instead of `double&apos; and appending l to each function name.  */</Line>
  <Line number="343"></Line>
  <Line number="344">#  define _Mdouble_		long double</Line>
  <Line number="345">#  define __MATH_PRECNAME(name,r) name##l##r</Line>
  <Line number="346">#  define __MATH_DECLARING_DOUBLE  0</Line>
  <Line number="347">#  define __MATH_DECLARING_FLOATN  0</Line>
  <Line number="348">#  define __MATH_DECLARE_LDOUBLE   1</Line>
  <Line number="349">#  include &lt;bits/mathcalls-helper-functions.h&gt;</Line>
  <Line number="350">#  include &lt;bits/mathcalls.h&gt;</Line>
  <Line number="351">#  undef _Mdouble_</Line>
  <Line number="352">#  undef __MATH_PRECNAME</Line>
  <Line number="353">#  undef __MATH_DECLARING_DOUBLE</Line>
  <Line number="354">#  undef __MATH_DECLARING_FLOATN</Line>
  <Line number="355"></Line>
  <Line number="356"># endif /* !(__NO_LONG_DOUBLE_MATH &amp;&amp; _LIBC) || __LDBL_COMPAT */</Line>
  <Line number="357"></Line>
  <Line number="358">#endif	/* Use ISO C99.  */</Line>
  <Line number="359"></Line>
  <Line number="360">/* Include the file of declarations for _FloatN and _FloatNx</Line>
  <Line number="361">   types.  */</Line>
  <Line number="362"></Line>
  <Line number="363">#if __HAVE_DISTINCT_FLOAT16 || (__HAVE_FLOAT16 &amp;&amp; !defined _LIBC)</Line>
  <Line number="364"># define _Mdouble_		_Float16</Line>
  <Line number="365"># define __MATH_PRECNAME(name,r) name##f16##r</Line>
  <Line number="366"># define __MATH_DECLARING_DOUBLE  0</Line>
  <Line number="367"># define __MATH_DECLARING_FLOATN  1</Line>
  <Line number="368"># if __HAVE_DISTINCT_FLOAT16</Line>
  <Line number="369">#  include &lt;bits/mathcalls-helper-functions.h&gt;</Line>
  <Line number="370"># endif</Line>
  <Line number="371"># if __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="372">#  include &lt;bits/mathcalls.h&gt;</Line>
  <Line number="373"># endif</Line>
  <Line number="374"># undef _Mdouble_</Line>
  <Line number="375"># undef __MATH_PRECNAME</Line>
  <Line number="376"># undef __MATH_DECLARING_DOUBLE</Line>
  <Line number="377"># undef __MATH_DECLARING_FLOATN</Line>
  <Line number="378">#endif /* __HAVE_DISTINCT_FLOAT16 || (__HAVE_FLOAT16 &amp;&amp; !_LIBC).  */</Line>
  <Line number="379"></Line>
  <Line number="380">#if __HAVE_DISTINCT_FLOAT32 || (__HAVE_FLOAT32 &amp;&amp; !defined _LIBC)</Line>
  <Line number="381"># define _Mdouble_		_Float32</Line>
  <Line number="382"># define __MATH_PRECNAME(name,r) name##f32##r</Line>
  <Line number="383"># define __MATH_DECLARING_DOUBLE  0</Line>
  <Line number="384"># define __MATH_DECLARING_FLOATN  1</Line>
  <Line number="385"># if __HAVE_DISTINCT_FLOAT32</Line>
  <Line number="386">#  include &lt;bits/mathcalls-helper-functions.h&gt;</Line>
  <Line number="387"># endif</Line>
  <Line number="388"># if __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="389">#  include &lt;bits/mathcalls.h&gt;</Line>
  <Line number="390"># endif</Line>
  <Line number="391"># undef _Mdouble_</Line>
  <Line number="392"># undef __MATH_PRECNAME</Line>
  <Line number="393"># undef __MATH_DECLARING_DOUBLE</Line>
  <Line number="394"># undef __MATH_DECLARING_FLOATN</Line>
  <Line number="395">#endif /* __HAVE_DISTINCT_FLOAT32 || (__HAVE_FLOAT32 &amp;&amp; !_LIBC).  */</Line>
  <Line number="396"></Line>
  <Line number="397">#if __HAVE_DISTINCT_FLOAT64 || (__HAVE_FLOAT64 &amp;&amp; !defined _LIBC)</Line>
  <Line number="398"># define _Mdouble_		_Float64</Line>
  <Line number="399"># define __MATH_PRECNAME(name,r) name##f64##r</Line>
  <Line number="400"># define __MATH_DECLARING_DOUBLE  0</Line>
  <Line number="401"># define __MATH_DECLARING_FLOATN  1</Line>
  <Line number="402"># if __HAVE_DISTINCT_FLOAT64</Line>
  <Line number="403">#  include &lt;bits/mathcalls-helper-functions.h&gt;</Line>
  <Line number="404"># endif</Line>
  <Line number="405"># if __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="406">#  include &lt;bits/mathcalls.h&gt;</Line>
  <Line number="407"># endif</Line>
  <Line number="408"># undef _Mdouble_</Line>
  <Line number="409"># undef __MATH_PRECNAME</Line>
  <Line number="410"># undef __MATH_DECLARING_DOUBLE</Line>
  <Line number="411"># undef __MATH_DECLARING_FLOATN</Line>
  <Line number="412">#endif /* __HAVE_DISTINCT_FLOAT64 || (__HAVE_FLOAT64 &amp;&amp; !_LIBC).  */</Line>
  <Line number="413"></Line>
  <Line number="414">#if __HAVE_DISTINCT_FLOAT128 || (__HAVE_FLOAT128 &amp;&amp; !defined _LIBC)</Line>
  <Line number="415"># define _Mdouble_		_Float128</Line>
  <Line number="416"># define __MATH_PRECNAME(name,r) name##f128##r</Line>
  <Line number="417"># define __MATH_DECLARING_DOUBLE  0</Line>
  <Line number="418"># define __MATH_DECLARING_FLOATN  1</Line>
  <Line number="419"># if __HAVE_DISTINCT_FLOAT128</Line>
  <Line number="420">#  include &lt;bits/mathcalls-helper-functions.h&gt;</Line>
  <Line number="421"># endif</Line>
  <Line number="422"># if __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="423">#  include &lt;bits/mathcalls.h&gt;</Line>
  <Line number="424"># endif</Line>
  <Line number="425"># undef _Mdouble_</Line>
  <Line number="426"># undef __MATH_PRECNAME</Line>
  <Line number="427"># undef __MATH_DECLARING_DOUBLE</Line>
  <Line number="428"># undef __MATH_DECLARING_FLOATN</Line>
  <Line number="429">#endif /* __HAVE_DISTINCT_FLOAT128 || (__HAVE_FLOAT128 &amp;&amp; !_LIBC).  */</Line>
  <Line number="430"></Line>
  <Line number="431">#if __HAVE_DISTINCT_FLOAT32X || (__HAVE_FLOAT32X &amp;&amp; !defined _LIBC)</Line>
  <Line number="432"># define _Mdouble_		_Float32x</Line>
  <Line number="433"># define __MATH_PRECNAME(name,r) name##f32x##r</Line>
  <Line number="434"># define __MATH_DECLARING_DOUBLE  0</Line>
  <Line number="435"># define __MATH_DECLARING_FLOATN  1</Line>
  <Line number="436"># if __HAVE_DISTINCT_FLOAT32X</Line>
  <Line number="437">#  include &lt;bits/mathcalls-helper-functions.h&gt;</Line>
  <Line number="438"># endif</Line>
  <Line number="439"># if __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="440">#  include &lt;bits/mathcalls.h&gt;</Line>
  <Line number="441"># endif</Line>
  <Line number="442"># undef _Mdouble_</Line>
  <Line number="443"># undef __MATH_PRECNAME</Line>
  <Line number="444"># undef __MATH_DECLARING_DOUBLE</Line>
  <Line number="445"># undef __MATH_DECLARING_FLOATN</Line>
  <Line number="446">#endif /* __HAVE_DISTINCT_FLOAT32X || (__HAVE_FLOAT32X &amp;&amp; !_LIBC).  */</Line>
  <Line number="447"></Line>
  <Line number="448">#if __HAVE_DISTINCT_FLOAT64X || (__HAVE_FLOAT64X &amp;&amp; !defined _LIBC)</Line>
  <Line number="449"># define _Mdouble_		_Float64x</Line>
  <Line number="450"># define __MATH_PRECNAME(name,r) name##f64x##r</Line>
  <Line number="451"># define __MATH_DECLARING_DOUBLE  0</Line>
  <Line number="452"># define __MATH_DECLARING_FLOATN  1</Line>
  <Line number="453"># if __HAVE_DISTINCT_FLOAT64X</Line>
  <Line number="454">#  include &lt;bits/mathcalls-helper-functions.h&gt;</Line>
  <Line number="455"># endif</Line>
  <Line number="456"># if __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="457">#  include &lt;bits/mathcalls.h&gt;</Line>
  <Line number="458"># endif</Line>
  <Line number="459"># undef _Mdouble_</Line>
  <Line number="460"># undef __MATH_PRECNAME</Line>
  <Line number="461"># undef __MATH_DECLARING_DOUBLE</Line>
  <Line number="462"># undef __MATH_DECLARING_FLOATN</Line>
  <Line number="463">#endif /* __HAVE_DISTINCT_FLOAT64X || (__HAVE_FLOAT64X &amp;&amp; !_LIBC).  */</Line>
  <Line number="464"></Line>
  <Line number="465">#if __HAVE_DISTINCT_FLOAT128X || (__HAVE_FLOAT128X &amp;&amp; !defined _LIBC)</Line>
  <Line number="466"># define _Mdouble_		_Float128x</Line>
  <Line number="467"># define __MATH_PRECNAME(name,r) name##f128x##r</Line>
  <Line number="468"># define __MATH_DECLARING_DOUBLE  0</Line>
  <Line number="469"># define __MATH_DECLARING_FLOATN  1</Line>
  <Line number="470"># if __HAVE_DISTINCT_FLOAT128X</Line>
  <Line number="471">#  include &lt;bits/mathcalls-helper-functions.h&gt;</Line>
  <Line number="472"># endif</Line>
  <Line number="473"># if __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="474">#  include &lt;bits/mathcalls.h&gt;</Line>
  <Line number="475"># endif</Line>
  <Line number="476"># undef _Mdouble_</Line>
  <Line number="477"># undef __MATH_PRECNAME</Line>
  <Line number="478"># undef __MATH_DECLARING_DOUBLE</Line>
  <Line number="479"># undef __MATH_DECLARING_FLOATN</Line>
  <Line number="480">#endif /* __HAVE_DISTINCT_FLOAT128X || (__HAVE_FLOAT128X &amp;&amp; !_LIBC).  */</Line>
  <Line number="481"></Line>
  <Line number="482">#undef	__MATHDECL_1</Line>
  <Line number="483">#undef	__MATHDECL</Line>
  <Line number="484">#undef	__MATHCALL</Line>
  <Line number="485"></Line>
  <Line number="486">/* Declare functions returning a narrower type.  */</Line>
  <Line number="487">#define __MATHCALL_NARROW_ARGS_1 (_Marg_ __x)</Line>
  <Line number="488">#define __MATHCALL_NARROW_ARGS_2 (_Marg_ __x, _Marg_ __y)</Line>
  <Line number="489">#define __MATHCALL_NARROW_ARGS_3 (_Marg_ __x, _Marg_ __y, _Marg_ __z)</Line>
  <Line number="490">#define __MATHCALL_NARROW_NORMAL(func, nargs)			\</Line>
  <Line number="491">  extern _Mret_ func __MATHCALL_NARROW_ARGS_ ## nargs __THROW</Line>
  <Line number="492">#define __MATHCALL_NARROW_REDIR(func, redir, nargs)			\</Line>
  <Line number="493">  extern _Mret_ __REDIRECT_NTH (func, __MATHCALL_NARROW_ARGS_ ## nargs, \</Line>
  <Line number="494">				redir)</Line>
  <Line number="495">#define __MATHCALL_NARROW(func, redir, nargs)	\</Line>
  <Line number="496">  __MATHCALL_NARROW_NORMAL (func, nargs)</Line>
  <Line number="497"></Line>
  <Line number="498">#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X)</Line>
  <Line number="499"></Line>
  <Line number="500"># define _Mret_ float</Line>
  <Line number="501"># define _Marg_ double</Line>
  <Line number="502"># define __MATHCALL_NAME(name) f ## name</Line>
  <Line number="503"># include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="504"># undef _Mret_</Line>
  <Line number="505"># undef _Marg_</Line>
  <Line number="506"># undef __MATHCALL_NAME</Line>
  <Line number="507"></Line>
  <Line number="508"># define _Mret_ float</Line>
  <Line number="509"># define _Marg_ long double</Line>
  <Line number="510"># define __MATHCALL_NAME(name) f ## name ## l</Line>
  <Line number="511"># ifdef __LDBL_COMPAT</Line>
  <Line number="512">#  define __MATHCALL_REDIR_NAME(name) f ## name</Line>
  <Line number="513">#  undef __MATHCALL_NARROW</Line>
  <Line number="514">#  define __MATHCALL_NARROW(func, redir, nargs) \</Line>
  <Line number="515">  __MATHCALL_NARROW_REDIR (func, redir, nargs)</Line>
  <Line number="516"># endif</Line>
  <Line number="517"># include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="518"># undef _Mret_</Line>
  <Line number="519"># undef _Marg_</Line>
  <Line number="520"># undef __MATHCALL_NAME</Line>
  <Line number="521"># ifdef __LDBL_COMPAT</Line>
  <Line number="522">#  undef __MATHCALL_REDIR_NAME</Line>
  <Line number="523">#  undef __MATHCALL_NARROW</Line>
  <Line number="524">#  define __MATHCALL_NARROW(func, redir, nargs) \</Line>
  <Line number="525">  __MATHCALL_NARROW_NORMAL (func, nargs)</Line>
  <Line number="526"># endif</Line>
  <Line number="527"></Line>
  <Line number="528"># define _Mret_ double</Line>
  <Line number="529"># define _Marg_ long double</Line>
  <Line number="530"># define __MATHCALL_NAME(name) d ## name ## l</Line>
  <Line number="531"># ifdef __LDBL_COMPAT</Line>
  <Line number="532">#  define __MATHCALL_REDIR_NAME(name) __nldbl_d ## name ## l</Line>
  <Line number="533">#  undef __MATHCALL_NARROW</Line>
  <Line number="534">#  define __MATHCALL_NARROW(func, redir, nargs) \</Line>
  <Line number="535">  __MATHCALL_NARROW_REDIR (func, redir, nargs)</Line>
  <Line number="536"># endif</Line>
  <Line number="537"># include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="538"># undef _Mret_</Line>
  <Line number="539"># undef _Marg_</Line>
  <Line number="540"># undef __MATHCALL_NAME</Line>
  <Line number="541"># ifdef __LDBL_COMPAT</Line>
  <Line number="542">#  undef __MATHCALL_REDIR_NAME</Line>
  <Line number="543">#  undef __MATHCALL_NARROW</Line>
  <Line number="544">#  define __MATHCALL_NARROW(func, redir, nargs) \</Line>
  <Line number="545">  __MATHCALL_NARROW_NORMAL (func, nargs)</Line>
  <Line number="546"># endif</Line>
  <Line number="547"></Line>
  <Line number="548">#endif</Line>
  <Line number="549"></Line>
  <Line number="550">#if __GLIBC_USE (IEC_60559_TYPES_EXT)</Line>
  <Line number="551"></Line>
  <Line number="552"># if __HAVE_FLOAT16 &amp;&amp; __HAVE_FLOAT32</Line>
  <Line number="553">#  define _Mret_ _Float16</Line>
  <Line number="554">#  define _Marg_ _Float32</Line>
  <Line number="555">#  define __MATHCALL_NAME(name) f16 ## name ## f32</Line>
  <Line number="556">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="557">#  undef _Mret_</Line>
  <Line number="558">#  undef _Marg_</Line>
  <Line number="559">#  undef __MATHCALL_NAME</Line>
  <Line number="560"># endif</Line>
  <Line number="561"></Line>
  <Line number="562"># if __HAVE_FLOAT16 &amp;&amp; __HAVE_FLOAT32X</Line>
  <Line number="563">#  define _Mret_ _Float16</Line>
  <Line number="564">#  define _Marg_ _Float32x</Line>
  <Line number="565">#  define __MATHCALL_NAME(name) f16 ## name ## f32x</Line>
  <Line number="566">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="567">#  undef _Mret_</Line>
  <Line number="568">#  undef _Marg_</Line>
  <Line number="569">#  undef __MATHCALL_NAME</Line>
  <Line number="570"># endif</Line>
  <Line number="571"></Line>
  <Line number="572"># if __HAVE_FLOAT16 &amp;&amp; __HAVE_FLOAT64</Line>
  <Line number="573">#  define _Mret_ _Float16</Line>
  <Line number="574">#  define _Marg_ _Float64</Line>
  <Line number="575">#  define __MATHCALL_NAME(name) f16 ## name ## f64</Line>
  <Line number="576">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="577">#  undef _Mret_</Line>
  <Line number="578">#  undef _Marg_</Line>
  <Line number="579">#  undef __MATHCALL_NAME</Line>
  <Line number="580"># endif</Line>
  <Line number="581"></Line>
  <Line number="582"># if __HAVE_FLOAT16 &amp;&amp; __HAVE_FLOAT64X</Line>
  <Line number="583">#  define _Mret_ _Float16</Line>
  <Line number="584">#  define _Marg_ _Float64x</Line>
  <Line number="585">#  define __MATHCALL_NAME(name) f16 ## name ## f64x</Line>
  <Line number="586">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="587">#  undef _Mret_</Line>
  <Line number="588">#  undef _Marg_</Line>
  <Line number="589">#  undef __MATHCALL_NAME</Line>
  <Line number="590"># endif</Line>
  <Line number="591"></Line>
  <Line number="592"># if __HAVE_FLOAT16 &amp;&amp; __HAVE_FLOAT128</Line>
  <Line number="593">#  define _Mret_ _Float16</Line>
  <Line number="594">#  define _Marg_ _Float128</Line>
  <Line number="595">#  define __MATHCALL_NAME(name) f16 ## name ## f128</Line>
  <Line number="596">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="597">#  undef _Mret_</Line>
  <Line number="598">#  undef _Marg_</Line>
  <Line number="599">#  undef __MATHCALL_NAME</Line>
  <Line number="600"># endif</Line>
  <Line number="601"></Line>
  <Line number="602"># if __HAVE_FLOAT16 &amp;&amp; __HAVE_FLOAT128X</Line>
  <Line number="603">#  define _Mret_ _Float16</Line>
  <Line number="604">#  define _Marg_ _Float128x</Line>
  <Line number="605">#  define __MATHCALL_NAME(name) f16 ## name ## f128x</Line>
  <Line number="606">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="607">#  undef _Mret_</Line>
  <Line number="608">#  undef _Marg_</Line>
  <Line number="609">#  undef __MATHCALL_NAME</Line>
  <Line number="610"># endif</Line>
  <Line number="611"></Line>
  <Line number="612"># if __HAVE_FLOAT32 &amp;&amp; __HAVE_FLOAT32X</Line>
  <Line number="613">#  define _Mret_ _Float32</Line>
  <Line number="614">#  define _Marg_ _Float32x</Line>
  <Line number="615">#  define __MATHCALL_NAME(name) f32 ## name ## f32x</Line>
  <Line number="616">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="617">#  undef _Mret_</Line>
  <Line number="618">#  undef _Marg_</Line>
  <Line number="619">#  undef __MATHCALL_NAME</Line>
  <Line number="620"># endif</Line>
  <Line number="621"></Line>
  <Line number="622"># if __HAVE_FLOAT32 &amp;&amp; __HAVE_FLOAT64</Line>
  <Line number="623">#  define _Mret_ _Float32</Line>
  <Line number="624">#  define _Marg_ _Float64</Line>
  <Line number="625">#  define __MATHCALL_NAME(name) f32 ## name ## f64</Line>
  <Line number="626">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="627">#  undef _Mret_</Line>
  <Line number="628">#  undef _Marg_</Line>
  <Line number="629">#  undef __MATHCALL_NAME</Line>
  <Line number="630"># endif</Line>
  <Line number="631"></Line>
  <Line number="632"># if __HAVE_FLOAT32 &amp;&amp; __HAVE_FLOAT64X</Line>
  <Line number="633">#  define _Mret_ _Float32</Line>
  <Line number="634">#  define _Marg_ _Float64x</Line>
  <Line number="635">#  define __MATHCALL_NAME(name) f32 ## name ## f64x</Line>
  <Line number="636">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="637">#  undef _Mret_</Line>
  <Line number="638">#  undef _Marg_</Line>
  <Line number="639">#  undef __MATHCALL_NAME</Line>
  <Line number="640"># endif</Line>
  <Line number="641"></Line>
  <Line number="642"># if __HAVE_FLOAT32 &amp;&amp; __HAVE_FLOAT128</Line>
  <Line number="643">#  define _Mret_ _Float32</Line>
  <Line number="644">#  define _Marg_ _Float128</Line>
  <Line number="645">#  define __MATHCALL_NAME(name) f32 ## name ## f128</Line>
  <Line number="646">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="647">#  undef _Mret_</Line>
  <Line number="648">#  undef _Marg_</Line>
  <Line number="649">#  undef __MATHCALL_NAME</Line>
  <Line number="650"># endif</Line>
  <Line number="651"></Line>
  <Line number="652"># if __HAVE_FLOAT32 &amp;&amp; __HAVE_FLOAT128X</Line>
  <Line number="653">#  define _Mret_ _Float32</Line>
  <Line number="654">#  define _Marg_ _Float128x</Line>
  <Line number="655">#  define __MATHCALL_NAME(name) f32 ## name ## f128x</Line>
  <Line number="656">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="657">#  undef _Mret_</Line>
  <Line number="658">#  undef _Marg_</Line>
  <Line number="659">#  undef __MATHCALL_NAME</Line>
  <Line number="660"># endif</Line>
  <Line number="661"></Line>
  <Line number="662"># if __HAVE_FLOAT32X &amp;&amp; __HAVE_FLOAT64</Line>
  <Line number="663">#  define _Mret_ _Float32x</Line>
  <Line number="664">#  define _Marg_ _Float64</Line>
  <Line number="665">#  define __MATHCALL_NAME(name) f32x ## name ## f64</Line>
  <Line number="666">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="667">#  undef _Mret_</Line>
  <Line number="668">#  undef _Marg_</Line>
  <Line number="669">#  undef __MATHCALL_NAME</Line>
  <Line number="670"># endif</Line>
  <Line number="671"></Line>
  <Line number="672"># if __HAVE_FLOAT32X &amp;&amp; __HAVE_FLOAT64X</Line>
  <Line number="673">#  define _Mret_ _Float32x</Line>
  <Line number="674">#  define _Marg_ _Float64x</Line>
  <Line number="675">#  define __MATHCALL_NAME(name) f32x ## name ## f64x</Line>
  <Line number="676">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="677">#  undef _Mret_</Line>
  <Line number="678">#  undef _Marg_</Line>
  <Line number="679">#  undef __MATHCALL_NAME</Line>
  <Line number="680"># endif</Line>
  <Line number="681"></Line>
  <Line number="682"># if __HAVE_FLOAT32X &amp;&amp; __HAVE_FLOAT128</Line>
  <Line number="683">#  define _Mret_ _Float32x</Line>
  <Line number="684">#  define _Marg_ _Float128</Line>
  <Line number="685">#  define __MATHCALL_NAME(name) f32x ## name ## f128</Line>
  <Line number="686">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="687">#  undef _Mret_</Line>
  <Line number="688">#  undef _Marg_</Line>
  <Line number="689">#  undef __MATHCALL_NAME</Line>
  <Line number="690"># endif</Line>
  <Line number="691"></Line>
  <Line number="692"># if __HAVE_FLOAT32X &amp;&amp; __HAVE_FLOAT128X</Line>
  <Line number="693">#  define _Mret_ _Float32x</Line>
  <Line number="694">#  define _Marg_ _Float128x</Line>
  <Line number="695">#  define __MATHCALL_NAME(name) f32x ## name ## f128x</Line>
  <Line number="696">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="697">#  undef _Mret_</Line>
  <Line number="698">#  undef _Marg_</Line>
  <Line number="699">#  undef __MATHCALL_NAME</Line>
  <Line number="700"># endif</Line>
  <Line number="701"></Line>
  <Line number="702"># if __HAVE_FLOAT64 &amp;&amp; __HAVE_FLOAT64X</Line>
  <Line number="703">#  define _Mret_ _Float64</Line>
  <Line number="704">#  define _Marg_ _Float64x</Line>
  <Line number="705">#  define __MATHCALL_NAME(name) f64 ## name ## f64x</Line>
  <Line number="706">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="707">#  undef _Mret_</Line>
  <Line number="708">#  undef _Marg_</Line>
  <Line number="709">#  undef __MATHCALL_NAME</Line>
  <Line number="710"># endif</Line>
  <Line number="711"></Line>
  <Line number="712"># if __HAVE_FLOAT64 &amp;&amp; __HAVE_FLOAT128</Line>
  <Line number="713">#  define _Mret_ _Float64</Line>
  <Line number="714">#  define _Marg_ _Float128</Line>
  <Line number="715">#  define __MATHCALL_NAME(name) f64 ## name ## f128</Line>
  <Line number="716">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="717">#  undef _Mret_</Line>
  <Line number="718">#  undef _Marg_</Line>
  <Line number="719">#  undef __MATHCALL_NAME</Line>
  <Line number="720"># endif</Line>
  <Line number="721"></Line>
  <Line number="722"># if __HAVE_FLOAT64 &amp;&amp; __HAVE_FLOAT128X</Line>
  <Line number="723">#  define _Mret_ _Float64</Line>
  <Line number="724">#  define _Marg_ _Float128x</Line>
  <Line number="725">#  define __MATHCALL_NAME(name) f64 ## name ## f128x</Line>
  <Line number="726">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="727">#  undef _Mret_</Line>
  <Line number="728">#  undef _Marg_</Line>
  <Line number="729">#  undef __MATHCALL_NAME</Line>
  <Line number="730"># endif</Line>
  <Line number="731"></Line>
  <Line number="732"># if __HAVE_FLOAT64X &amp;&amp; __HAVE_FLOAT128</Line>
  <Line number="733">#  define _Mret_ _Float64x</Line>
  <Line number="734">#  define _Marg_ _Float128</Line>
  <Line number="735">#  define __MATHCALL_NAME(name) f64x ## name ## f128</Line>
  <Line number="736">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="737">#  undef _Mret_</Line>
  <Line number="738">#  undef _Marg_</Line>
  <Line number="739">#  undef __MATHCALL_NAME</Line>
  <Line number="740"># endif</Line>
  <Line number="741"></Line>
  <Line number="742"># if __HAVE_FLOAT64X &amp;&amp; __HAVE_FLOAT128X</Line>
  <Line number="743">#  define _Mret_ _Float64x</Line>
  <Line number="744">#  define _Marg_ _Float128x</Line>
  <Line number="745">#  define __MATHCALL_NAME(name) f64x ## name ## f128x</Line>
  <Line number="746">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="747">#  undef _Mret_</Line>
  <Line number="748">#  undef _Marg_</Line>
  <Line number="749">#  undef __MATHCALL_NAME</Line>
  <Line number="750"># endif</Line>
  <Line number="751"></Line>
  <Line number="752"># if __HAVE_FLOAT128 &amp;&amp; __HAVE_FLOAT128X</Line>
  <Line number="753">#  define _Mret_ _Float128</Line>
  <Line number="754">#  define _Marg_ _Float128x</Line>
  <Line number="755">#  define __MATHCALL_NAME(name) f128 ## name ## f128x</Line>
  <Line number="756">#  include &lt;bits/mathcalls-narrow.h&gt;</Line>
  <Line number="757">#  undef _Mret_</Line>
  <Line number="758">#  undef _Marg_</Line>
  <Line number="759">#  undef __MATHCALL_NAME</Line>
  <Line number="760"># endif</Line>
  <Line number="761"></Line>
  <Line number="762">#endif</Line>
  <Line number="763"></Line>
  <Line number="764">#undef __MATHCALL_NARROW_ARGS_1</Line>
  <Line number="765">#undef __MATHCALL_NARROW_ARGS_2</Line>
  <Line number="766">#undef __MATHCALL_NARROW_ARGS_3</Line>
  <Line number="767">#undef __MATHCALL_NARROW_NORMAL</Line>
  <Line number="768">#undef __MATHCALL_NARROW_REDIR</Line>
  <Line number="769">#undef __MATHCALL_NARROW</Line>
  <Line number="770"></Line>
  <Line number="771">#if defined __USE_MISC || defined __USE_XOPEN</Line>
  <Line number="772">/* This variable is used by `gamma&apos; and `lgamma&apos;.  */</Line>
  <Line number="773">extern int signgam;</Line>
  <Line number="774">#endif</Line>
  <Line number="775"></Line>
  <Line number="776">#if (__HAVE_DISTINCT_FLOAT16			\</Line>
  <Line number="777">     || __HAVE_DISTINCT_FLOAT32			\</Line>
  <Line number="778">     || __HAVE_DISTINCT_FLOAT64			\</Line>
  <Line number="779">     || __HAVE_DISTINCT_FLOAT32X		\</Line>
  <Line number="780">     || __HAVE_DISTINCT_FLOAT64X		\</Line>
  <Line number="781">     || __HAVE_DISTINCT_FLOAT128X)</Line>
  <Line number="782"># error &quot;Unsupported _FloatN or _FloatNx types for &lt;math.h&gt;.&quot;</Line>
  <Line number="783">#endif</Line>
  <Line number="784"></Line>
  <Line number="785">/* Depending on the type of TG_ARG, call an appropriately suffixed</Line>
  <Line number="786">   version of FUNC with arguments (including parentheses) ARGS.</Line>
  <Line number="787">   Suffixed functions may not exist for long double if it has the same</Line>
  <Line number="788">   format as double, or for other types with the same format as float,</Line>
  <Line number="789">   double or long double.  The behavior is undefined if the argument</Line>
  <Line number="790">   does not have a real floating type.  The definition may use a</Line>
  <Line number="791">   conditional expression, so all suffixed versions of FUNC must</Line>
  <Line number="792">   return the same type (FUNC may include a cast if necessary rather</Line>
  <Line number="793">   than being a single identifier).  */</Line>
  <Line number="794">#ifdef __NO_LONG_DOUBLE_MATH</Line>
  <Line number="795"># if __HAVE_DISTINCT_FLOAT128</Line>
  <Line number="796">#  error &quot;Distinct _Float128 without distinct long double not supported.&quot;</Line>
  <Line number="797"># endif</Line>
  <Line number="798"># define __MATH_TG(TG_ARG, FUNC, ARGS)					\</Line>
  <Line number="799">  (sizeof (TG_ARG) == sizeof (float) ? FUNC ## f ARGS : FUNC ARGS)</Line>
  <Line number="800">#elif __HAVE_DISTINCT_FLOAT128</Line>
  <Line number="801"># if __HAVE_GENERIC_SELECTION</Line>
  <Line number="802">#  if __HAVE_FLOATN_NOT_TYPEDEF &amp;&amp; __HAVE_FLOAT32</Line>
  <Line number="803">#   define __MATH_TG_F32(FUNC, ARGS) _Float32: FUNC ## f ARGS,</Line>
  <Line number="804">#  else</Line>
  <Line number="805">#   define __MATH_TG_F32(FUNC, ARGS)</Line>
  <Line number="806">#  endif</Line>
  <Line number="807">#  if __HAVE_FLOATN_NOT_TYPEDEF &amp;&amp; __HAVE_FLOAT64X</Line>
  <Line number="808">#   if __HAVE_FLOAT64X_LONG_DOUBLE</Line>
  <Line number="809">#    define __MATH_TG_F64X(FUNC, ARGS) _Float64x: FUNC ## l ARGS,</Line>
  <Line number="810">#   else</Line>
  <Line number="811">#    define __MATH_TG_F64X(FUNC, ARGS) _Float64x: FUNC ## f128 ARGS,</Line>
  <Line number="812">#   endif</Line>
  <Line number="813">#  else</Line>
  <Line number="814">#   define __MATH_TG_F64X(FUNC, ARGS)</Line>
  <Line number="815">#  endif</Line>
  <Line number="816">#  define __MATH_TG(TG_ARG, FUNC, ARGS)	\</Line>
  <Line number="817">     _Generic ((TG_ARG),			\</Line>
  <Line number="818">	       float: FUNC ## f ARGS,		\</Line>
  <Line number="819">	       __MATH_TG_F32 (FUNC, ARGS)	\</Line>
  <Line number="820">	       default: FUNC ARGS,		\</Line>
  <Line number="821">	       long double: FUNC ## l ARGS,	\</Line>
  <Line number="822">	       __MATH_TG_F64X (FUNC, ARGS)	\</Line>
  <Line number="823">	       _Float128: FUNC ## f128 ARGS)</Line>
  <Line number="824"># else</Line>
  <Line number="825">#  if __HAVE_FLOATN_NOT_TYPEDEF</Line>
  <Line number="826">#   error &quot;Non-typedef _FloatN but no _Generic.&quot;</Line>
  <Line number="827">#  endif</Line>
  <Line number="828">#  define __MATH_TG(TG_ARG, FUNC, ARGS)					\</Line>
  <Line number="829">     __builtin_choose_expr						\</Line>
  <Line number="830">     (__builtin_types_compatible_p (__typeof (TG_ARG), float),		\</Line>
  <Line number="831">      FUNC ## f ARGS,							\</Line>
  <Line number="832">      __builtin_choose_expr						\</Line>
  <Line number="833">      (__builtin_types_compatible_p (__typeof (TG_ARG), double),	\</Line>
  <Line number="834">       FUNC ARGS,							\</Line>
  <Line number="835">       __builtin_choose_expr						\</Line>
  <Line number="836">       (__builtin_types_compatible_p (__typeof (TG_ARG), long double),	\</Line>
  <Line number="837">	FUNC ## l ARGS,							\</Line>
  <Line number="838">	FUNC ## f128 ARGS)))</Line>
  <Line number="839"># endif</Line>
  <Line number="840">#else</Line>
  <Line number="841"># define __MATH_TG(TG_ARG, FUNC, ARGS)		\</Line>
  <Line number="842">  (sizeof (TG_ARG) == sizeof (float)		\</Line>
  <Line number="843">   ? FUNC ## f ARGS				\</Line>
  <Line number="844">   : sizeof (TG_ARG) == sizeof (double)		\</Line>
  <Line number="845">   ? FUNC ARGS					\</Line>
  <Line number="846">   : FUNC ## l ARGS)</Line>
  <Line number="847">#endif</Line>
  <Line number="848"></Line>
  <Line number="849">/* ISO C99 defines some generic macros which work on any data type.  */</Line>
  <Line number="850">#ifdef __USE_ISOC99</Line>
  <Line number="851"></Line>
  <Line number="852">/* All floating-point numbers can be put in one of these categories.  */</Line>
  <Line number="853">enum</Line>
  <Line number="854">  {</Line>
  <Line number="855">    FP_NAN =</Line>
  <Line number="856"># define FP_NAN 0</Line>
  <Line number="857">      FP_NAN,</Line>
  <Line number="858">    FP_INFINITE =</Line>
  <Line number="859"># define FP_INFINITE 1</Line>
  <Line number="860">      FP_INFINITE,</Line>
  <Line number="861">    FP_ZERO =</Line>
  <Line number="862"># define FP_ZERO 2</Line>
  <Line number="863">      FP_ZERO,</Line>
  <Line number="864">    FP_SUBNORMAL =</Line>
  <Line number="865"># define FP_SUBNORMAL 3</Line>
  <Line number="866">      FP_SUBNORMAL,</Line>
  <Line number="867">    FP_NORMAL =</Line>
  <Line number="868"># define FP_NORMAL 4</Line>
  <Line number="869">      FP_NORMAL</Line>
  <Line number="870">  };</Line>
  <Line number="871"></Line>
  <Line number="872">/* GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,</Line>
  <Line number="873">   so disable builtins if this is enabled.  When fixed in a newer GCC,</Line>
  <Line number="874">   the __SUPPORT_SNAN__ check may be skipped for those versions.  */</Line>
  <Line number="875"></Line>
  <Line number="876">/* Return number of classification appropriate for X.  */</Line>
  <Line number="877"># if ((__GNUC_PREREQ (4,4) &amp;&amp; !defined __SUPPORT_SNAN__)		      \</Line>
  <Line number="878">      || __glibc_clang_prereq (2,8))					      \</Line>
  <Line number="879">     &amp;&amp; (!defined __OPTIMIZE_SIZE__ || defined __cplusplus)</Line>
  <Line number="880">     /* The check for __cplusplus allows the use of the builtin, even</Line>
  <Line number="881">	when optimization for size is on.  This is provided for</Line>
  <Line number="882">	libstdc++, only to let its configure test work when it is built</Line>
  <Line number="883">	with -Os.  No further use of this definition of fpclassify is</Line>
  <Line number="884">	expected in C++ mode, since libstdc++ provides its own version</Line>
  <Line number="885">	of fpclassify in cmath (which undefines fpclassify).  */</Line>
  <Line number="886">#  define fpclassify(x) __builtin_fpclassify (FP_NAN, FP_INFINITE,	      \</Line>
  <Line number="887">     FP_NORMAL, FP_SUBNORMAL, FP_ZERO, x)</Line>
  <Line number="888"># else</Line>
  <Line number="889">#  define fpclassify(x) __MATH_TG ((x), __fpclassify, (x))</Line>
  <Line number="890"># endif</Line>
  <Line number="891"></Line>
  <Line number="892">/* Return nonzero value if sign of X is negative.  */</Line>
  <Line number="893"># if __GNUC_PREREQ (6,0) || __glibc_clang_prereq (3,3)</Line>
  <Line number="894">#  define signbit(x) __builtin_signbit (x)</Line>
  <Line number="895"># elif defined __cplusplus</Line>
  <Line number="896">  /* In C++ mode, __MATH_TG cannot be used, because it relies on</Line>
  <Line number="897">     __builtin_types_compatible_p, which is a C-only builtin.</Line>
  <Line number="898">     The check for __cplusplus allows the use of the builtin instead of</Line>
  <Line number="899">     __MATH_TG. This is provided for libstdc++, only to let its configure</Line>
  <Line number="900">     test work. No further use of this definition of signbit is expected</Line>
  <Line number="901">     in C++ mode, since libstdc++ provides its own version of signbit</Line>
  <Line number="902">     in cmath (which undefines signbit). */</Line>
  <Line number="903">#  define signbit(x) __builtin_signbitl (x)</Line>
  <Line number="904"># elif __GNUC_PREREQ (4,0)</Line>
  <Line number="905">#  define signbit(x) __MATH_TG ((x), __builtin_signbit, (x))</Line>
  <Line number="906"># else</Line>
  <Line number="907">#  define signbit(x) __MATH_TG ((x), __signbit, (x))</Line>
  <Line number="908"># endif</Line>
  <Line number="909"></Line>
  <Line number="910">/* Return nonzero value if X is not +-Inf or NaN.  */</Line>
  <Line number="911"># if (__GNUC_PREREQ (4,4) &amp;&amp; !defined __SUPPORT_SNAN__) \</Line>
  <Line number="912">     || __glibc_clang_prereq (2,8)</Line>
  <Line number="913">#  define isfinite(x) __builtin_isfinite (x)</Line>
  <Line number="914"># else</Line>
  <Line number="915">#  define isfinite(x) __MATH_TG ((x), __finite, (x))</Line>
  <Line number="916"># endif</Line>
  <Line number="917"></Line>
  <Line number="918">/* Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.  */</Line>
  <Line number="919"># if (__GNUC_PREREQ (4,4) &amp;&amp; !defined __SUPPORT_SNAN__) \</Line>
  <Line number="920">     || __glibc_clang_prereq (2,8)</Line>
  <Line number="921">#  define isnormal(x) __builtin_isnormal (x)</Line>
  <Line number="922"># else</Line>
  <Line number="923">#  define isnormal(x) (fpclassify (x) == FP_NORMAL)</Line>
  <Line number="924"># endif</Line>
  <Line number="925"></Line>
  <Line number="926">/* Return nonzero value if X is a NaN.  We could use `fpclassify&apos; but</Line>
  <Line number="927">   we already have this functions `__isnan&apos; and it is faster.  */</Line>
  <Line number="928"># if (__GNUC_PREREQ (4,4) &amp;&amp; !defined __SUPPORT_SNAN__) \</Line>
  <Line number="929">     || __glibc_clang_prereq (2,8)</Line>
  <Line number="930">#  define isnan(x) __builtin_isnan (x)</Line>
  <Line number="931"># else</Line>
  <Line number="932">#  define isnan(x) __MATH_TG ((x), __isnan, (x))</Line>
  <Line number="933"># endif</Line>
  <Line number="934"></Line>
  <Line number="935">/* Return nonzero value if X is positive or negative infinity.  */</Line>
  <Line number="936"># if __HAVE_DISTINCT_FLOAT128 &amp;&amp; !__GNUC_PREREQ (7,0) \</Line>
  <Line number="937">     &amp;&amp; !defined __SUPPORT_SNAN__ &amp;&amp; !defined __cplusplus</Line>
  <Line number="938">   /* Since __builtin_isinf_sign is broken for float128 before GCC 7.0,</Line>
  <Line number="939">      use the helper function, __isinff128, with older compilers.  This is</Line>
  <Line number="940">      only provided for C mode, because in C++ mode, GCC has no support</Line>
  <Line number="941">      for __builtin_types_compatible_p (and when in C++ mode, this macro is</Line>
  <Line number="942">      not used anyway, because libstdc++ headers undefine it).  */</Line>
  <Line number="943">#  define isinf(x) \</Line>
  <Line number="944">    (__builtin_types_compatible_p (__typeof (x), _Float128) \</Line>
  <Line number="945">     ? __isinff128 (x) : __builtin_isinf_sign (x))</Line>
  <Line number="946"># elif (__GNUC_PREREQ (4,4) &amp;&amp; !defined __SUPPORT_SNAN__) \</Line>
  <Line number="947">       || __glibc_clang_prereq (3,7)</Line>
  <Line number="948">#  define isinf(x) __builtin_isinf_sign (x)</Line>
  <Line number="949"># else</Line>
  <Line number="950">#  define isinf(x) __MATH_TG ((x), __isinf, (x))</Line>
  <Line number="951"># endif</Line>
  <Line number="952"></Line>
  <Line number="953">/* Bitmasks for the math_errhandling macro.  */</Line>
  <Line number="954"># define MATH_ERRNO	1	/* errno set by math functions.  */</Line>
  <Line number="955"># define MATH_ERREXCEPT	2	/* Exceptions raised by math functions.  */</Line>
  <Line number="956"></Line>
  <Line number="957">/* By default all math functions support both errno and exception handling</Line>
  <Line number="958">   (except for soft floating point implementations which may only support</Line>
  <Line number="959">   errno handling).  If errno handling is disabled, exceptions are still</Line>
  <Line number="960">   supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is</Line>
  <Line number="961">   nonconforming but it is more useful than leaving it undefined).  */</Line>
  <Line number="962"># ifdef __FAST_MATH__</Line>
  <Line number="963">#  define math_errhandling	0</Line>
  <Line number="964"># elif defined __NO_MATH_ERRNO__</Line>
  <Line number="965">#  define math_errhandling	(MATH_ERREXCEPT)</Line>
  <Line number="966"># else</Line>
  <Line number="967">#  define math_errhandling	(MATH_ERRNO | MATH_ERREXCEPT)</Line>
  <Line number="968"># endif</Line>
  <Line number="969"></Line>
  <Line number="970">#endif /* Use ISO C99.  */</Line>
  <Line number="971"></Line>
  <Line number="972">#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X)</Line>
  <Line number="973"># include &lt;bits/iscanonical.h&gt;</Line>
  <Line number="974"></Line>
  <Line number="975">/* Return nonzero value if X is a signaling NaN.  */</Line>
  <Line number="976"># ifndef __cplusplus</Line>
  <Line number="977">#  define issignaling(x) __MATH_TG ((x), __issignaling, (x))</Line>
  <Line number="978"># else</Line>
  <Line number="979">   /* In C++ mode, __MATH_TG cannot be used, because it relies on</Line>
  <Line number="980">      __builtin_types_compatible_p, which is a C-only builtin.  On the</Line>
  <Line number="981">      other hand, overloading provides the means to distinguish between</Line>
  <Line number="982">      the floating-point types.  The overloading resolution will match</Line>
  <Line number="983">      the correct parameter (regardless of type qualifiers (i.e.: const</Line>
  <Line number="984">      and volatile)).  */</Line>
  <Line number="985">extern &quot;C++&quot; {</Line>
  <Line number="986">inline int issignaling (float __val) { return __issignalingf (__val); }</Line>
  <Line number="987">inline int issignaling (double __val) { return __issignaling (__val); }</Line>
  <Line number="988">inline int</Line>
  <Line number="989">issignaling (long double __val)</Line>
  <Line number="990">{</Line>
  <Line number="991">#  ifdef __NO_LONG_DOUBLE_MATH</Line>
  <Line number="992">  return __issignaling (__val);</Line>
  <Line number="993">#  else</Line>
  <Line number="994">  return __issignalingl (__val);</Line>
  <Line number="995">#  endif</Line>
  <Line number="996">}</Line>
  <Line number="997">#  if __HAVE_FLOAT128_UNLIKE_LDBL</Line>
  <Line number="998">/* When using an IEEE 128-bit long double, _Float128 is defined as long double</Line>
  <Line number="999">   in C++.  */</Line>
  <Line number="1000">inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }</Line>
  <Line number="1001">#  endif</Line>
  <Line number="1002">} /* extern C++ */</Line>
  <Line number="1003"># endif</Line>
  <Line number="1004"></Line>
  <Line number="1005">/* Return nonzero value if X is subnormal.  */</Line>
  <Line number="1006"># define issubnormal(x) (fpclassify (x) == FP_SUBNORMAL)</Line>
  <Line number="1007"></Line>
  <Line number="1008">/* Return nonzero value if X is zero.  */</Line>
  <Line number="1009"># ifndef __cplusplus</Line>
  <Line number="1010">#  ifdef __SUPPORT_SNAN__</Line>
  <Line number="1011">#   define iszero(x) (fpclassify (x) == FP_ZERO)</Line>
  <Line number="1012">#  else</Line>
  <Line number="1013">#   define iszero(x) (((__typeof (x)) (x)) == 0)</Line>
  <Line number="1014">#  endif</Line>
  <Line number="1015"># else	/* __cplusplus */</Line>
  <Line number="1016">extern &quot;C++&quot; {</Line>
  <Line number="1017">#  ifdef __SUPPORT_SNAN__</Line>
  <Line number="1018">inline int</Line>
  <Line number="1019">iszero (float __val)</Line>
  <Line number="1020">{</Line>
  <Line number="1021">  return __fpclassifyf (__val) == FP_ZERO;</Line>
  <Line number="1022">}</Line>
  <Line number="1023">inline int</Line>
  <Line number="1024">iszero (double __val)</Line>
  <Line number="1025">{</Line>
  <Line number="1026">  return __fpclassify (__val) == FP_ZERO;</Line>
  <Line number="1027">}</Line>
  <Line number="1028">inline int</Line>
  <Line number="1029">iszero (long double __val)</Line>
  <Line number="1030">{</Line>
  <Line number="1031">#   ifdef __NO_LONG_DOUBLE_MATH</Line>
  <Line number="1032">  return __fpclassify (__val) == FP_ZERO;</Line>
  <Line number="1033">#   else</Line>
  <Line number="1034">  return __fpclassifyl (__val) == FP_ZERO;</Line>
  <Line number="1035">#   endif</Line>
  <Line number="1036">}</Line>
  <Line number="1037">#   if __HAVE_FLOAT128_UNLIKE_LDBL</Line>
  <Line number="1038">  /* When using an IEEE 128-bit long double, _Float128 is defined as long double</Line>
  <Line number="1039">     in C++.  */</Line>
  <Line number="1040">inline int</Line>
  <Line number="1041">iszero (_Float128 __val)</Line>
  <Line number="1042">{</Line>
  <Line number="1043">  return __fpclassifyf128 (__val) == FP_ZERO;</Line>
  <Line number="1044">}</Line>
  <Line number="1045">#   endif</Line>
  <Line number="1046">#  else</Line>
  <Line number="1047">template &lt;class __T&gt; inline bool</Line>
  <Line number="1048">iszero (__T __val)</Line>
  <Line number="1049">{</Line>
  <Line number="1050">  return __val == 0;</Line>
  <Line number="1051">}</Line>
  <Line number="1052">#  endif</Line>
  <Line number="1053">} /* extern C++ */</Line>
  <Line number="1054"># endif	/* __cplusplus */</Line>
  <Line number="1055">#endif /* Use IEC_60559_BFP_EXT.  */</Line>
  <Line number="1056"></Line>
  <Line number="1057">#ifdef __USE_XOPEN</Line>
  <Line number="1058">/* X/Open wants another strange constant.  */</Line>
  <Line number="1059"># define MAXFLOAT	3.40282347e+38F</Line>
  <Line number="1060">#endif</Line>
  <Line number="1061"></Line>
  <Line number="1062"></Line>
  <Line number="1063">/* Some useful constants.  */</Line>
  <Line number="1064">#if defined __USE_MISC || defined __USE_XOPEN</Line>
  <Line number="1065"># define M_E		2.7182818284590452354	/* e */</Line>
  <Line number="1066"># define M_LOG2E	1.4426950408889634074	/* log_2 e */</Line>
  <Line number="1067"># define M_LOG10E	0.43429448190325182765	/* log_10 e */</Line>
  <Line number="1068"># define M_LN2		0.69314718055994530942	/* log_e 2 */</Line>
  <Line number="1069"># define M_LN10		2.30258509299404568402	/* log_e 10 */</Line>
  <Line number="1070"># define M_PI		3.14159265358979323846	/* pi */</Line>
  <Line number="1071"># define M_PI_2		1.57079632679489661923	/* pi/2 */</Line>
  <Line number="1072"># define M_PI_4		0.78539816339744830962	/* pi/4 */</Line>
  <Line number="1073"># define M_1_PI		0.31830988618379067154	/* 1/pi */</Line>
  <Line number="1074"># define M_2_PI		0.63661977236758134308	/* 2/pi */</Line>
  <Line number="1075"># define M_2_SQRTPI	1.12837916709551257390	/* 2/sqrt(pi) */</Line>
  <Line number="1076"># define M_SQRT2	1.41421356237309504880	/* sqrt(2) */</Line>
  <Line number="1077"># define M_SQRT1_2	0.70710678118654752440	/* 1/sqrt(2) */</Line>
  <Line number="1078">#endif</Line>
  <Line number="1079"></Line>
  <Line number="1080">/* The above constants are not adequate for computation using `long double&apos;s.</Line>
  <Line number="1081">   Therefore we provide as an extension constants with similar names as a</Line>
  <Line number="1082">   GNU extension.  Provide enough digits for the 128-bit IEEE quad.  */</Line>
  <Line number="1083">#ifdef __USE_GNU</Line>
  <Line number="1084"># define M_El		2.718281828459045235360287471352662498L /* e */</Line>
  <Line number="1085"># define M_LOG2El	1.442695040888963407359924681001892137L /* log_2 e */</Line>
  <Line number="1086"># define M_LOG10El	0.434294481903251827651128918916605082L /* log_10 e */</Line>
  <Line number="1087"># define M_LN2l		0.693147180559945309417232121458176568L /* log_e 2 */</Line>
  <Line number="1088"># define M_LN10l	2.302585092994045684017991454684364208L /* log_e 10 */</Line>
  <Line number="1089"># define M_PIl		3.141592653589793238462643383279502884L /* pi */</Line>
  <Line number="1090"># define M_PI_2l	1.570796326794896619231321691639751442L /* pi/2 */</Line>
  <Line number="1091"># define M_PI_4l	0.785398163397448309615660845819875721L /* pi/4 */</Line>
  <Line number="1092"># define M_1_PIl	0.318309886183790671537767526745028724L /* 1/pi */</Line>
  <Line number="1093"># define M_2_PIl	0.636619772367581343075535053490057448L /* 2/pi */</Line>
  <Line number="1094"># define M_2_SQRTPIl	1.128379167095512573896158903121545172L /* 2/sqrt(pi) */</Line>
  <Line number="1095"># define M_SQRT2l	1.414213562373095048801688724209698079L /* sqrt(2) */</Line>
  <Line number="1096"># define M_SQRT1_2l	0.707106781186547524400844362104849039L /* 1/sqrt(2) */</Line>
  <Line number="1097">#endif</Line>
  <Line number="1098"></Line>
  <Line number="1099">#if __HAVE_FLOAT16 &amp;&amp; defined __USE_GNU</Line>
  <Line number="1100"># define M_Ef16		__f16 (2.718281828459045235360287471352662498) /* e */</Line>
  <Line number="1101"># define M_LOG2Ef16	__f16 (1.442695040888963407359924681001892137) /* log_2 e */</Line>
  <Line number="1102"># define M_LOG10Ef16	__f16 (0.434294481903251827651128918916605082) /* log_10 e */</Line>
  <Line number="1103"># define M_LN2f16	__f16 (0.693147180559945309417232121458176568) /* log_e 2 */</Line>
  <Line number="1104"># define M_LN10f16	__f16 (2.302585092994045684017991454684364208) /* log_e 10 */</Line>
  <Line number="1105"># define M_PIf16	__f16 (3.141592653589793238462643383279502884) /* pi */</Line>
  <Line number="1106"># define M_PI_2f16	__f16 (1.570796326794896619231321691639751442) /* pi/2 */</Line>
  <Line number="1107"># define M_PI_4f16	__f16 (0.785398163397448309615660845819875721) /* pi/4 */</Line>
  <Line number="1108"># define M_1_PIf16	__f16 (0.318309886183790671537767526745028724) /* 1/pi */</Line>
  <Line number="1109"># define M_2_PIf16	__f16 (0.636619772367581343075535053490057448) /* 2/pi */</Line>
  <Line number="1110"># define M_2_SQRTPIf16	__f16 (1.128379167095512573896158903121545172) /* 2/sqrt(pi) */</Line>
  <Line number="1111"># define M_SQRT2f16	__f16 (1.414213562373095048801688724209698079) /* sqrt(2) */</Line>
  <Line number="1112"># define M_SQRT1_2f16	__f16 (0.707106781186547524400844362104849039) /* 1/sqrt(2) */</Line>
  <Line number="1113">#endif</Line>
  <Line number="1114"></Line>
  <Line number="1115">#if __HAVE_FLOAT32 &amp;&amp; defined __USE_GNU</Line>
  <Line number="1116"># define M_Ef32		__f32 (2.718281828459045235360287471352662498) /* e */</Line>
  <Line number="1117"># define M_LOG2Ef32	__f32 (1.442695040888963407359924681001892137) /* log_2 e */</Line>
  <Line number="1118"># define M_LOG10Ef32	__f32 (0.434294481903251827651128918916605082) /* log_10 e */</Line>
  <Line number="1119"># define M_LN2f32	__f32 (0.693147180559945309417232121458176568) /* log_e 2 */</Line>
  <Line number="1120"># define M_LN10f32	__f32 (2.302585092994045684017991454684364208) /* log_e 10 */</Line>
  <Line number="1121"># define M_PIf32	__f32 (3.141592653589793238462643383279502884) /* pi */</Line>
  <Line number="1122"># define M_PI_2f32	__f32 (1.570796326794896619231321691639751442) /* pi/2 */</Line>
  <Line number="1123"># define M_PI_4f32	__f32 (0.785398163397448309615660845819875721) /* pi/4 */</Line>
  <Line number="1124"># define M_1_PIf32	__f32 (0.318309886183790671537767526745028724) /* 1/pi */</Line>
  <Line number="1125"># define M_2_PIf32	__f32 (0.636619772367581343075535053490057448) /* 2/pi */</Line>
  <Line number="1126"># define M_2_SQRTPIf32	__f32 (1.128379167095512573896158903121545172) /* 2/sqrt(pi) */</Line>
  <Line number="1127"># define M_SQRT2f32	__f32 (1.414213562373095048801688724209698079) /* sqrt(2) */</Line>
  <Line number="1128"># define M_SQRT1_2f32	__f32 (0.707106781186547524400844362104849039) /* 1/sqrt(2) */</Line>
  <Line number="1129">#endif</Line>
  <Line number="1130"></Line>
  <Line number="1131">#if __HAVE_FLOAT64 &amp;&amp; defined __USE_GNU</Line>
  <Line number="1132"># define M_Ef64		__f64 (2.718281828459045235360287471352662498) /* e */</Line>
  <Line number="1133"># define M_LOG2Ef64	__f64 (1.442695040888963407359924681001892137) /* log_2 e */</Line>
  <Line number="1134"># define M_LOG10Ef64	__f64 (0.434294481903251827651128918916605082) /* log_10 e */</Line>
  <Line number="1135"># define M_LN2f64	__f64 (0.693147180559945309417232121458176568) /* log_e 2 */</Line>
  <Line number="1136"># define M_LN10f64	__f64 (2.302585092994045684017991454684364208) /* log_e 10 */</Line>
  <Line number="1137"># define M_PIf64	__f64 (3.141592653589793238462643383279502884) /* pi */</Line>
  <Line number="1138"># define M_PI_2f64	__f64 (1.570796326794896619231321691639751442) /* pi/2 */</Line>
  <Line number="1139"># define M_PI_4f64	__f64 (0.785398163397448309615660845819875721) /* pi/4 */</Line>
  <Line number="1140"># define M_1_PIf64	__f64 (0.318309886183790671537767526745028724) /* 1/pi */</Line>
  <Line number="1141"># define M_2_PIf64	__f64 (0.636619772367581343075535053490057448) /* 2/pi */</Line>
  <Line number="1142"># define M_2_SQRTPIf64	__f64 (1.128379167095512573896158903121545172) /* 2/sqrt(pi) */</Line>
  <Line number="1143"># define M_SQRT2f64	__f64 (1.414213562373095048801688724209698079) /* sqrt(2) */</Line>
  <Line number="1144"># define M_SQRT1_2f64	__f64 (0.707106781186547524400844362104849039) /* 1/sqrt(2) */</Line>
  <Line number="1145">#endif</Line>
  <Line number="1146"></Line>
  <Line number="1147">#if __HAVE_FLOAT128 &amp;&amp; defined __USE_GNU</Line>
  <Line number="1148"># define M_Ef128	__f128 (2.718281828459045235360287471352662498) /* e */</Line>
  <Line number="1149"># define M_LOG2Ef128	__f128 (1.442695040888963407359924681001892137) /* log_2 e */</Line>
  <Line number="1150"># define M_LOG10Ef128	__f128 (0.434294481903251827651128918916605082) /* log_10 e */</Line>
  <Line number="1151"># define M_LN2f128	__f128 (0.693147180559945309417232121458176568) /* log_e 2 */</Line>
  <Line number="1152"># define M_LN10f128	__f128 (2.302585092994045684017991454684364208) /* log_e 10 */</Line>
  <Line number="1153"># define M_PIf128	__f128 (3.141592653589793238462643383279502884) /* pi */</Line>
  <Line number="1154"># define M_PI_2f128	__f128 (1.570796326794896619231321691639751442) /* pi/2 */</Line>
  <Line number="1155"># define M_PI_4f128	__f128 (0.785398163397448309615660845819875721) /* pi/4 */</Line>
  <Line number="1156"># define M_1_PIf128	__f128 (0.318309886183790671537767526745028724) /* 1/pi */</Line>
  <Line number="1157"># define M_2_PIf128	__f128 (0.636619772367581343075535053490057448) /* 2/pi */</Line>
  <Line number="1158"># define M_2_SQRTPIf128	__f128 (1.128379167095512573896158903121545172) /* 2/sqrt(pi) */</Line>
  <Line number="1159"># define M_SQRT2f128	__f128 (1.414213562373095048801688724209698079) /* sqrt(2) */</Line>
  <Line number="1160"># define M_SQRT1_2f128	__f128 (0.707106781186547524400844362104849039) /* 1/sqrt(2) */</Line>
  <Line number="1161">#endif</Line>
  <Line number="1162"></Line>
  <Line number="1163">#if __HAVE_FLOAT32X &amp;&amp; defined __USE_GNU</Line>
  <Line number="1164"># define M_Ef32x	__f32x (2.718281828459045235360287471352662498) /* e */</Line>
  <Line number="1165"># define M_LOG2Ef32x	__f32x (1.442695040888963407359924681001892137) /* log_2 e */</Line>
  <Line number="1166"># define M_LOG10Ef32x	__f32x (0.434294481903251827651128918916605082) /* log_10 e */</Line>
  <Line number="1167"># define M_LN2f32x	__f32x (0.693147180559945309417232121458176568) /* log_e 2 */</Line>
  <Line number="1168"># define M_LN10f32x	__f32x (2.302585092994045684017991454684364208) /* log_e 10 */</Line>
  <Line number="1169"># define M_PIf32x	__f32x (3.141592653589793238462643383279502884) /* pi */</Line>
  <Line number="1170"># define M_PI_2f32x	__f32x (1.570796326794896619231321691639751442) /* pi/2 */</Line>
  <Line number="1171"># define M_PI_4f32x	__f32x (0.785398163397448309615660845819875721) /* pi/4 */</Line>
  <Line number="1172"># define M_1_PIf32x	__f32x (0.318309886183790671537767526745028724) /* 1/pi */</Line>
  <Line number="1173"># define M_2_PIf32x	__f32x (0.636619772367581343075535053490057448) /* 2/pi */</Line>
  <Line number="1174"># define M_2_SQRTPIf32x	__f32x (1.128379167095512573896158903121545172) /* 2/sqrt(pi) */</Line>
  <Line number="1175"># define M_SQRT2f32x	__f32x (1.414213562373095048801688724209698079) /* sqrt(2) */</Line>
  <Line number="1176"># define M_SQRT1_2f32x	__f32x (0.707106781186547524400844362104849039) /* 1/sqrt(2) */</Line>
  <Line number="1177">#endif</Line>
  <Line number="1178"></Line>
  <Line number="1179">#if __HAVE_FLOAT64X &amp;&amp; defined __USE_GNU</Line>
  <Line number="1180"># define M_Ef64x	__f64x (2.718281828459045235360287471352662498) /* e */</Line>
  <Line number="1181"># define M_LOG2Ef64x	__f64x (1.442695040888963407359924681001892137) /* log_2 e */</Line>
  <Line number="1182"># define M_LOG10Ef64x	__f64x (0.434294481903251827651128918916605082) /* log_10 e */</Line>
  <Line number="1183"># define M_LN2f64x	__f64x (0.693147180559945309417232121458176568) /* log_e 2 */</Line>
  <Line number="1184"># define M_LN10f64x	__f64x (2.302585092994045684017991454684364208) /* log_e 10 */</Line>
  <Line number="1185"># define M_PIf64x	__f64x (3.141592653589793238462643383279502884) /* pi */</Line>
  <Line number="1186"># define M_PI_2f64x	__f64x (1.570796326794896619231321691639751442) /* pi/2 */</Line>
  <Line number="1187"># define M_PI_4f64x	__f64x (0.785398163397448309615660845819875721) /* pi/4 */</Line>
  <Line number="1188"># define M_1_PIf64x	__f64x (0.318309886183790671537767526745028724) /* 1/pi */</Line>
  <Line number="1189"># define M_2_PIf64x	__f64x (0.636619772367581343075535053490057448) /* 2/pi */</Line>
  <Line number="1190"># define M_2_SQRTPIf64x	__f64x (1.128379167095512573896158903121545172) /* 2/sqrt(pi) */</Line>
  <Line number="1191"># define M_SQRT2f64x	__f64x (1.414213562373095048801688724209698079) /* sqrt(2) */</Line>
  <Line number="1192"># define M_SQRT1_2f64x	__f64x (0.707106781186547524400844362104849039) /* 1/sqrt(2) */</Line>
  <Line number="1193">#endif</Line>
  <Line number="1194"></Line>
  <Line number="1195">#if __HAVE_FLOAT128X &amp;&amp; defined __USE_GNU</Line>
  <Line number="1196"># error &quot;M_* values needed for _Float128x&quot;</Line>
  <Line number="1197">#endif</Line>
  <Line number="1198"></Line>
  <Line number="1199">/* When compiling in strict ISO C compatible mode we must not use the</Line>
  <Line number="1200">   inline functions since they, among other things, do not set the</Line>
  <Line number="1201">   `errno&apos; variable correctly.  */</Line>
  <Line number="1202">#if defined __STRICT_ANSI__ &amp;&amp; !defined __NO_MATH_INLINES</Line>
  <Line number="1203"># define __NO_MATH_INLINES	1</Line>
  <Line number="1204">#endif</Line>
  <Line number="1205"></Line>
  <Line number="1206">#ifdef __USE_ISOC99</Line>
  <Line number="1207"># if __GNUC_PREREQ (3, 1)</Line>
  <Line number="1208">/* ISO C99 defines some macros to compare number while taking care for</Line>
  <Line number="1209">   unordered numbers.  Many FPUs provide special instructions to support</Line>
  <Line number="1210">   these operations.  Generic support in GCC for these as builtins went</Line>
  <Line number="1211">   in 2.97, but not all cpus added their patterns until 3.1.  Therefore</Line>
  <Line number="1212">   we enable the builtins from 3.1 onwards and use a generic implementation</Line>
  <Line number="1213">   othwerwise.  */</Line>
  <Line number="1214">#  define isgreater(x, y)	__builtin_isgreater(x, y)</Line>
  <Line number="1215">#  define isgreaterequal(x, y)	__builtin_isgreaterequal(x, y)</Line>
  <Line number="1216">#  define isless(x, y)		__builtin_isless(x, y)</Line>
  <Line number="1217">#  define islessequal(x, y)	__builtin_islessequal(x, y)</Line>
  <Line number="1218">#  define islessgreater(x, y)	__builtin_islessgreater(x, y)</Line>
  <Line number="1219">#  define isunordered(x, y)	__builtin_isunordered(x, y)</Line>
  <Line number="1220"># else</Line>
  <Line number="1221">#  define isgreater(x, y) \</Line>
  <Line number="1222">  (__extension__ ({ __typeof__ (x) __x = (x); __typeof__ (y) __y = (y); \</Line>
  <Line number="1223">		    !isunordered (__x, __y) &amp;&amp; __x &gt; __y; }))</Line>
  <Line number="1224">#  define isgreaterequal(x, y) \</Line>
  <Line number="1225">  (__extension__ ({ __typeof__ (x) __x = (x); __typeof__ (y) __y = (y); \</Line>
  <Line number="1226">		    !isunordered (__x, __y) &amp;&amp; __x &gt;= __y; }))</Line>
  <Line number="1227">#  define isless(x, y) \</Line>
  <Line number="1228">  (__extension__ ({ __typeof__ (x) __x = (x); __typeof__ (y) __y = (y); \</Line>
  <Line number="1229">		    !isunordered (__x, __y) &amp;&amp; __x &lt; __y; }))</Line>
  <Line number="1230">#  define islessequal(x, y) \</Line>
  <Line number="1231">  (__extension__ ({ __typeof__ (x) __x = (x); __typeof__ (y) __y = (y); \</Line>
  <Line number="1232">		    !isunordered (__x, __y) &amp;&amp; __x &lt;= __y; }))</Line>
  <Line number="1233">#  define islessgreater(x, y) \</Line>
  <Line number="1234">  (__extension__ ({ __typeof__ (x) __x = (x); __typeof__ (y) __y = (y); \</Line>
  <Line number="1235">		    !isunordered (__x, __y) &amp;&amp; __x != __y; }))</Line>
  <Line number="1236">/* isunordered must always check both operands first for signaling NaNs.  */</Line>
  <Line number="1237">#  define isunordered(x, y) \</Line>
  <Line number="1238">  (__extension__ ({ __typeof__ (x) __u = (x); __typeof__ (y) __v = (y); \</Line>
  <Line number="1239">		    __u != __v &amp;&amp; (__u != __u || __v != __v); }))</Line>
  <Line number="1240"># endif</Line>
  <Line number="1241">#endif</Line>
  <Line number="1242"></Line>
  <Line number="1243">/* Get machine-dependent inline versions (if there are any).  */</Line>
  <Line number="1244">#ifdef __USE_EXTERN_INLINES</Line>
  <Line number="1245"># include &lt;bits/mathinline.h&gt;</Line>
  <Line number="1246">#endif</Line>
  <Line number="1247"></Line>
  <Line number="1248"></Line>
  <Line number="1249">#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X)</Line>
  <Line number="1250">/* An expression whose type has the widest of the evaluation formats</Line>
  <Line number="1251">   of X and Y (which are of floating-point types).  */</Line>
  <Line number="1252"># if __FLT_EVAL_METHOD__ == 2 || __FLT_EVAL_METHOD__ &gt; 64</Line>
  <Line number="1253">#  define __MATH_EVAL_FMT2(x, y) ((x) + (y) + 0.0L)</Line>
  <Line number="1254"># elif __FLT_EVAL_METHOD__ == 1 || __FLT_EVAL_METHOD__ &gt; 32</Line>
  <Line number="1255">#  define __MATH_EVAL_FMT2(x, y) ((x) + (y) + 0.0)</Line>
  <Line number="1256"># elif __FLT_EVAL_METHOD__ == 0 || __FLT_EVAL_METHOD__ == 32</Line>
  <Line number="1257">#  define __MATH_EVAL_FMT2(x, y) ((x) + (y) + 0.0f)</Line>
  <Line number="1258"># else</Line>
  <Line number="1259">#  define __MATH_EVAL_FMT2(x, y) ((x) + (y))</Line>
  <Line number="1260"># endif</Line>
  <Line number="1261"></Line>
  <Line number="1262">/* Return X == Y but raising &quot;invalid&quot; and setting errno if X or Y is</Line>
  <Line number="1263">   a NaN.  */</Line>
  <Line number="1264"># if !defined __cplusplus || (__cplusplus &lt; 201103L &amp;&amp; !defined __GNUC__)</Line>
  <Line number="1265">#  define iseqsig(x, y) \</Line>
  <Line number="1266">   __MATH_TG (__MATH_EVAL_FMT2 (x, y), __iseqsig, ((x), (y)))</Line>
  <Line number="1267"># else</Line>
  <Line number="1268">/* In C++ mode, __MATH_TG cannot be used, because it relies on</Line>
  <Line number="1269">   __builtin_types_compatible_p, which is a C-only builtin.  Moreover,</Line>
  <Line number="1270">   the comparison macros from ISO C take two floating-point arguments,</Line>
  <Line number="1271">   which need not have the same type.  Choosing what underlying function</Line>
  <Line number="1272">   to call requires evaluating the formats of the arguments, then</Line>
  <Line number="1273">   selecting which is wider.  The macro __MATH_EVAL_FMT2 provides this</Line>
  <Line number="1274">   information, however, only the type of the macro expansion is</Line>
  <Line number="1275">   relevant (actually evaluating the expression would be incorrect).</Line>
  <Line number="1276">   Thus, the type is used as a template parameter for __iseqsig_type,</Line>
  <Line number="1277">   which calls the appropriate underlying function.  */</Line>
  <Line number="1278">extern &quot;C++&quot; {</Line>
  <Line number="1279">template&lt;typename&gt; struct __iseqsig_type;</Line>
  <Line number="1280"></Line>
  <Line number="1281">template&lt;&gt; struct __iseqsig_type&lt;float&gt;</Line>
  <Line number="1282">{</Line>
  <Line number="1283">  static int __call (float __x, float __y) throw ()</Line>
  <Line number="1284">  {</Line>
  <Line number="1285">    return __iseqsigf (__x, __y);</Line>
  <Line number="1286">  }</Line>
  <Line number="1287">};</Line>
  <Line number="1288"></Line>
  <Line number="1289">template&lt;&gt; struct __iseqsig_type&lt;double&gt;</Line>
  <Line number="1290">{</Line>
  <Line number="1291">  static int __call (double __x, double __y) throw ()</Line>
  <Line number="1292">  {</Line>
  <Line number="1293">    return __iseqsig (__x, __y);</Line>
  <Line number="1294">  }</Line>
  <Line number="1295">};</Line>
  <Line number="1296"></Line>
  <Line number="1297">template&lt;&gt; struct __iseqsig_type&lt;long double&gt;</Line>
  <Line number="1298">{</Line>
  <Line number="1299">  static int __call (long double __x, long double __y) throw ()</Line>
  <Line number="1300">  {</Line>
  <Line number="1301">#  ifndef __NO_LONG_DOUBLE_MATH</Line>
  <Line number="1302">    return __iseqsigl (__x, __y);</Line>
  <Line number="1303">#  else</Line>
  <Line number="1304">    return __iseqsig (__x, __y);</Line>
  <Line number="1305">#  endif</Line>
  <Line number="1306">  }</Line>
  <Line number="1307">};</Line>
  <Line number="1308"></Line>
  <Line number="1309">#  if __HAVE_FLOAT128_UNLIKE_LDBL</Line>
  <Line number="1310">  /* When using an IEEE 128-bit long double, _Float128 is defined as long double</Line>
  <Line number="1311">     in C++.  */</Line>
  <Line number="1312">template&lt;&gt; struct __iseqsig_type&lt;_Float128&gt;</Line>
  <Line number="1313">{</Line>
  <Line number="1314">  static int __call (_Float128 __x, _Float128 __y) throw ()</Line>
  <Line number="1315">  {</Line>
  <Line number="1316">    return __iseqsigf128 (__x, __y);</Line>
  <Line number="1317">  }</Line>
  <Line number="1318">};</Line>
  <Line number="1319">#  endif</Line>
  <Line number="1320"></Line>
  <Line number="1321">template&lt;typename _T1, typename _T2&gt;</Line>
  <Line number="1322">inline int</Line>
  <Line number="1323">iseqsig (_T1 __x, _T2 __y) throw ()</Line>
  <Line number="1324">{</Line>
  <Line number="1325">#  if __cplusplus &gt;= 201103L</Line>
  <Line number="1326">  typedef decltype (__MATH_EVAL_FMT2 (__x, __y)) _T3;</Line>
  <Line number="1327">#  else</Line>
  <Line number="1328">  typedef __typeof (__MATH_EVAL_FMT2 (__x, __y)) _T3;</Line>
  <Line number="1329">#  endif</Line>
  <Line number="1330">  return __iseqsig_type&lt;_T3&gt;::__call (__x, __y);</Line>
  <Line number="1331">}</Line>
  <Line number="1332"></Line>
  <Line number="1333">} /* extern &quot;C++&quot; */</Line>
  <Line number="1334"># endif /* __cplusplus */</Line>
  <Line number="1335"></Line>
  <Line number="1336">#endif</Line>
  <Line number="1337"></Line>
  <Line number="1338">__END_DECLS</Line>
  <Line number="1339"></Line>
  <Line number="1340"></Line>
  <Line number="1341">#endif /* math.h  */</Line>
</SourceFile>
